<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c691701570000c157a2dee2073c4f6a585300c55ccf0d6f46928eecdc9724972b24db06d8e48150045c794c89f3d5923fd30d3b0c21115ae3a59b6bd16aed626a9478fe50526b747ee39fedb4de8307dc26ccc5293c2e6f3694c14da915d8807b50437f7437317cc05d710b12490f43a239bf22390454c435c6f9250edc86f3185ce0f6eef12273c67ff27ddd7d5fafb10cea0a2c855a462a9cb0b57c64098b417af94c71dde7b36d6990c48b73146e5312d6f55ec68ee5849cede6ca0fa38129a475ec2704b6c3d20ea562545fddbb2055224857164e084c74004e82f6d4de473151f48999a4f9d6de3cd5d5c6c758c41d41fa4704e5d6783013c3095d7c5ca3d577318a6d414131cb5f896078ac599b234a4e228c437374cc51de2c12c31939c6097ccc78298b130602bf01876de6f861a13de27598cfd9ae3e87d2d8de34096e41461ba3e20d83ef6b6a18b8ad837c66f10c908e0e703c1e24535f5b4dba113c02a86a4c6df845502b1757d12a11559c846ee59460e854c9f09f8879e735db739c56ad0328f0d3e9f52b441185c6dc96cfa0c5b00aa4c0c4c11b5ee1ef6497ccd8434b350b0e131ceb0f94877f7071aadbc976018d0c5b791698e36a161a3826053fb137f8633af830103f894da9218fc4413a1b6955c76b589af07a59350b5c3dda2337d53d60b4968480ebed8a8d0f2ae3a27ec9c5d713c6623e3c5a45e002d0d19b9f791a9cdd3fc3e2399768a71a7615ecbb59baa68e7ea2b5af9d0439de335146eba299fdf0aece79c4770bb63d1a12e71885f4164f1cb6ed9dfb2c7a2c059a8e3648938c88b6ffcb03558ebac2a4266568e7d517cc917d2f7d5e06eace296fd8163bfea70c0e63e8b9ba1955bb2a85d1106ce09e47d79d2aa99a02c4b82e7e46101059f801e94f7b2229940bd7b9943487ff6f321d1477bf8be227d6a7b83decbf96416c9656eaae88d598057d154dec100090275bc93cea245108a0d6b4937aefa5efeb05fd2cb898abe11e081d971b3f1b93d4a5c4c7d2d35c8937b546d48daca86676f4e6a27ba793bdf6e5709c3241852dd45bd82007c2cbb08d3431740ee198e488d9b8bad17663255e1cd91974b279013f9b1b8e72b9305193c92aaa824dee052636b6db9d2e770edc606aefe1c634bdee237259908bfe913f2c650584a0114d6b40ed7c76a81f74655675615861618ccc6dc7b22da373d8c05f92a19b288cc0fc414bb9d8aad3db518f3c69647425f51d58865cf8cedc802965c764359e3a357f089c78bf5d02fee8cf27e16cf739ba3ea3adde22890224bd9faec15de1bed1a05e7d8247dc41877361aa6fc9fde9c139187afba591662db3d60d7dc597fa9d0822e37245b9f71bc9b64b86178eadce8a1557490f72b4911910eeefa78e23295c8aa4ca62b8d70b8561199d699dda3c04715990347a68bc5e15d425bcc9c63c24cb5c830c84271547800d1c853cc715ed54def59723982f145e8ae878eaa2ca9c2c63119529d7944bcad7437103e4f524852472a7070779272bff2696780bcba90f3cc27f9ecf0c2199bf27ce73e6ca1d94d8b96d128a13ae7b189271ffe8cfa0cbc606cb07568f4b3f0fbd19094ebff528b6bcb4b4199a9f8b28bf80d1b31733a7d3c35cf1d3de8b7c2a87d9af9cc00eacc6f986745bd431ec9c28544c3cd1a1d08ec6a0b2206422bca9a146e61194700d0a239b1837a38c980b41300c136f06a1e8b1b140bdefd56d9254c0a679c88c139d74967b57571eb2c22b54821735e32e3c772c68a9fe747cd691c0ddbb3585826732e1838ffbc7ae4082fa2b78465b2853560d582f55b9caf6dc7fae08211aa0ec9105135e3bbee89a3659b6b4d03fef16a36a1eed36c9348d8f313873f5ee33cf54517a1f36c8e25d3458bf20b69037e57eb92599c88546a0e8342fff031d6d19dfccdc67369051636283e9847cb4dce9019bd773921ecf6756187800f83788ac227c3740d103361a471c0513efb14f7a411d5503866f933d0c27556b6e659a1cc2fc7a193e7aca674279607ba72861309d9fa6a3c10cc623cd222d2852e576bf44568ae6cc627ce27c288241e9caf94fcf60379584f2541713259085f168f2ea1c480190dcb4fb8c533d5d3e786080c987d3bcdf62e290af9035389c9ee92b0b03d5c292dbda77a2e6f6fd5e257b1e5af43b7cda8b6d7d536c34c88b5fef75325480058ad1b37c4037f873c022894f95e7b43f5a79bd36972a1ffb01bd6a4112fe70536884326eb3ca886010aa89eb837ff0f2a7172c09ee72f2b25e6da44ac2cca573cb94be481bbdf1e5001eb6c83aef98f0181ff54bd1038358e105a698154ac5995dcb5a4ccbff7773092b4a0a286a72d517ae2c1cc376daa883c66708ba0fb41566555bff1fa0a10a636a94d44c1a64b3c1905a66b41852cbafd62dc8156bf32b7a877a86843c2ebde8c7d30d6e6a7f0839031c656fce6530861371de93e6d1fa244612c45b427316c6e9ee60ff7fbe3ca17d766d4d5a934b923e143617d82f402937ddfa1356013d212c828d434e942d53273a09bb612c11363fed9fc9bf57c04e8a04a18bea7a2bc0ecc54e44614edba6f72074ab2f460c659c4a4452315c86079f48c70f62554db595c2ce80c51866306becde265c5a7808dc488801aabfd96f9e66a8a76ab537c76092ce0cacf93454d0333f189d8f9eee59c0d77923b61f50f082d8cac468833a37d7a5ea4c5053ed56554579f491891523e519f014fb72b1b398713a9581b460528811b9ee3317c74193e582541a51030d32617e4c62605c403625f9349570800be044ef640f61ee215f6e8ef1f8c70439857c3aa39346276496a4e12f16b07efdd40fe68794024dda45253fbc3a57c862cf7a9617791926dcb18e4cdcdceab3ae9270fea1d27306cb21e5755f8088f28c1206ca78c558b57ba395d07ff5fa689f283505ed646ec05144d8635abce4f0205b0a4d7a7222a517947830994ef5e51dc2fcd0b1d7af6fa8a4a7b09e7bc9b24859c2077ac8abc403defdcd0abe6296145f0240f2ea5c4c806e2a41262456510a6a093a306f438fa7cfe1c86a32353e050a47b03fce583b7fdb2983b2bfdfaabbc4d2d88597d6db770d235f042f590cb4cc72539fb289621d995605431c86c76ec3f2b8f1c278e8c4b9873468f2d3803bf52166b6ef8ec8571574e8400f18bc7ea5db15d65ec2e00a4ccf35dbc2f580230a9e448600637271e3a0257f91e2f8a9b578d8ee6d8ef6a4633388765047bf41c32c9d98e23bd9416455475e1bdfdbf6a6e2a78f3ae1e909419e864ffb4d0982e21d92924123a9affc09cf415f6f58dad6d1051b3452e4cdf26fddb251ec11a83c23bcb2246ab83a02f0586475c0412b14e980a2630690fc80fa0d67fbef1b0261830133e68002a49c253adcc9559f55968c0695c573863eacd7cf90e56f4abf11410eed7db65fb509b241beb837e4818e4bee066899681a3fe931f0db37a5b0eb83ed192107c8ba175035bcfcf1df8eca2d5909abbf41d84f58a1f3c51acbca8bdd86e67899fb802f43525cc8fbf49eeceb305b4aff485aafa2762c507c9b0abe7cd281f1182d120c900733b6a31f15ac98b9e072ed328e98a5310d87dadd5844900fe9c293ad57c6a40ae7791263bd85df4b23760a9253142d7631f7458d88eabb82b6b85ba6436f259b870fc4fc5d4a99fc9205c9975fd53c4546e69631934c43e32f55721d7cdf4d0b371fdca2cb2934a48c63730be903d1f8e51c4dedeb0071dcd37bd4a5189707c5349ab851583c1afee4e4081c09c129cfc524b321b5f6233086753f386c44c3e06cf4b923ca3dcc89ceb46ef38b4c3d9e67a7043742f15eb709449cc4d8fea2dc642c864e56a0faee0c1a4108510f27f439bed9c9488c6acc44e1c53de80928bda81f586f47341231bbbe581b355fe7ee8cfc0776ee2700352709c10dabb159200b58db4edbefdcec424cbd86ba99e1336d12111bc705f6498fc1b7e8929fb05a5ee8aa2a6d57b23a33c1cfdc8f28639e19bb326f61541e7221fb9da3566b110d6f07825ced744fdfb43147a4261a14b53f759b8615af571b4c7aa9b9518b97f3e2d4e48ab51bcd4127309e4c5984e08ba583c14c14dd9867a22d4c9be49c75d8a101d1b8b9af334ccbc4570efc7beb67839ebadd03babda1b32caa3465c9f65347e40c9915411f4395ed03bb103437a9004fcd1e4dc853036fe974cfec4129e44ea1aafec03499219177441b72bf0e7b3176c8172fe870ddb7d0fb68d1487b43e45b3bf6d0e1159afbf5d20011aded17fa89f23eb65be661df58ea2e2ce2deb714888401cdb8f7fa2e9fab6a95fa6f557aa1b906c2727fcfaff3d5e95978996aeb40070cfa3dbfa37177e076e329efc008aff320d49491f673ccbd4828649bacedaf1ac6df2e5f3c056fd08cd6cf4c8737c299eb24182aebe8553abd3c2952d41d823f39617cbfca740bba25ce5b91590d7a1d36f38c7cdd74f19820278227d9680b0f490473f99f282da561110f1b6b3f814c0d13c1c67893a739bb1000b5f1467f573d075a45143f8313c261864c5479573f42ca266d458b2801e54f08babe7ebe7f85d66a04ee408244c985693f7492834869891521690c6b9dfb3610d4310aa3f58537009d2f4cd600f581271094a81d65cee286fa9c7d43f9c7cb2106d5b80ddd122c42070f9a7e03e40e9fb1e75afaf60b27549f74da9b62d5d47f2db53b0ab9e0fe2401308401503109bc02345f0d6e1be145753fd5c95d73e9792f248d5b401c9b68339e78566140bb0e8280133873772e5d7cb1942a1f55a96e3b33613882e5fb2bfb5061482071960b687a3d8e8a49432540519f470433679c2b0cb6c371cb0f443895d0df4119776bb57739268ce175ef4dba4f9e2412b98f54c4b53eb1d9eb5d8a7276b0504f31b519c5a5dce80167fc01faea290dd97ca1d2c0f7e79acde4ff1eba40901be18a2ac8544a40aef40df5c15510d51d641db19a87e15250033d141713e335400dbd560f5f7ba189e7a27f983f37d9026a3e26c58e36038ad65d7426ca5a4370fc625c86a95ebac25bf3d5139770c2ab66a880ad414efebf1c7277ed82cc3ffde271021772ddd2196d0fe1a033c6b569b3bb9d3d9ed22912e336ee594b5d5a0ed60fe721e6d99f98526531d2cad51439c69d6b4fed84173f03ac3091f1f669277ad06cb727a14e0cab9aeda52a3306693362e0ebde7534bbe37514024e2d570e0e42abf3ea0b33919bab2fd2b86964d61709f8168c25bc1fd00ed97c1d5434262871420f7cedbd8aa7fc02c98f3d529221bd0f2d99acd020e0c5bd9eeb12c28fa8855b5bebd13a77da9c26917614b768afcb6ac40a2554a214a3a2ec070092a956a8abaddb280e7105dedea3ba55ade75a01ddea584fad34b44ce606f3242a3e7c6113f23edfcd1e22865e2ea843ecb582d781cabccc46670955a5b22adbd09a35d0af0b60c4b92028f944d83ed73f9c8cc03f8b0ac351c98d8325642dbd7ffa2d375cbe6466a60578c38a960d43f76a873935b2dfcd068ea4a5fe9edb3101facb5e8a53b65594593b8f6d26a021900d18ef1b585f29a7ee6437e2b57c2b156791cc8dfd62721238e535c0149ebfd5a4d4fa273995e528a9081b62beb0fa81c3b6d81713b09be22a92f4ad73d297d66c9c0c9fc0986abec1a21ef79b5c669d11b2db14369b271187d96019d69012b7196d6e6c8a12599c3af11e9fad140ce756f5ace23d5fb7260dcf12837ca5b6c5a320b3203e544d60231f7f2113ab7fb2c15b6c157ca3de27da5ae1df7db2c8bb1bde82809ba299c36b23423e6c46f5f16f1efb4442ac25ff94637b84d41bd6e2dbcf0c3b785506a4389b3941c8531fd4018b2be5bf11fd0f64f1f8be20260a908a3519e094fb50eab2c37d2c7ced297d6d1822e58da758536a9dcf4dca5bd12d64554afadd00e5cb9576cac384df230847d93a67bd0438f06a3d6ed360413bf707d42bc1071cecec509b25b98a8e0ebeb62afe5128d2a8e546a93fe3bd1c981f0c59363bfdb0baf80f231d3b51d4451518c3fac589ab6341f6a16f7cd1dde9ce3bd5cbc924a36a6101f79a54f5cbdde6606e4033a70c6a6416f29ee1a3a4d66a1cafb0e65e831faeb99dcfe7ca2338d364f76fd23431d8a0ae34a4970ddfe5f83cf2cd04df1c0760cdd71f51f9b0016cd1049a04ba04d3d51b39f889d550b37993294c1e9876716c208a25ff2c01a2dec5e2caccda442287f5849cb3d3fb6a8da44c51d6124ef221b6b2f4068f56fab69e91deaf1859d83c774625237a3efcf9f1afc1c5c1851a678382cc4c56cbbfaf79b99b80beb06c2a5227cec0308de15c2796c20474265a3b3755668491cfd778b202febcf1ff01ce9d17a1dbcd22fc8634b5ae8d260fe60801bf0f2412ab7cec73324957e8e427657f3650bf79015d268e35ccde709a3f503555d08e06747e4d699d43b277a2613059d93c71f019db973ee8c0e151374707dd250ab287b404caea82033c8f8bee816efa8e052dd7ce2f9e8578db342414d7b7883f0d470b0c1e0efa948165b0189474f4c6a0085217afc1d4e148a8daa48723322a18d457d8353ea9b290774137571ea69d88f0733c732a68ee825bf5317bb9cf7fcb5a0f838e7f938a1ec2946b7988166117dce6e9a534f4cd512461cb91306531f1210b15f16e8dd32dc271aefcfd668a937098723d45a14f7312d3a6555ad0e66a5947f8a3636d2c373d48c2e3974de54dbba121054751d7deb1f3e7c37362a41155c9625b82bf04be2b918e059d9b9dbc23207f1634f832e605519b63000dcdf0e6735bcb0258a5a8f4309a3a20f88994becb3a04ab72f6f3d6c21175f20940d43d0634fe44ef0768aac702dc500e0950678f14a4a3778e73f30140e755c0c59b4a2dd705850c37d52855064884111ed35bff4fa8b65294f779726a7be0f509efdc55ab0f93c6ec2b313227d7508c61b7777bbc155aaee9257fcc166b7e8e36b0216e523c3d7be2913d5e41eba96b93777dbf5212f647704a7575fd362c1cffa4c5d9ab6b0c48317e12ae1b39664c6da4e546619f2e18475d245a79cd6c28056035a43cd8612b5a257bea3313769f26691a552ca14f3f9f73871479cfc94c32c33f5516add5a919081944ebd64c7318823621e1b46568a76e6e7f7ca6b3e93841f2fe081458f4175c5e4549fcde9dc4bb515f3bba1f2df144006f3b6817d2fa7294d1f1b74bd90a2bf67e3c1d854d90b4723c8b6f6c6c983cc91014cdd7988ce2f13977da4c32ec0f4335ebdf37c25adf635d88bcfda23660ed2961d65e24118aebfab05e65d14f50c56d60e56db1d12e9749511dbc150c897abb793cbfce06d4fc65595df31dcec7737a72fa3930962508ed9b9fe3998d75ce706232e1024aabf0f7b5d0faa7a9b284be391a10fbcaf5521675f2bf9290e5dd16834b9b1a1d407f693c083ebdbcd99a908862b883f8881cc9ea5475507f57822ccdda2791f8161d2d6ac4a5ee1f80563f32491b1531a642643e3ad96d0037ffe0883a603f5acbef5020fd5ef9879c6cb41a93b3e4c3b2f6a5745e165e2e00fe76e6d416043c7191f5866d49c388d987ea518283d32444e919814b7010145a6da43ca7c860ed63dd9735b4a50eb8cc6f19b93de6ec1119fac6e9d1c159cc43ff61d647cb03d2574e88f74fb026108506f4bca3b6fa7f98b7b1a85879e7236af6886be7bb36556a2ef6eac5b1943eeec848fb5888a9d95d43069f969bfba631cde48f6e6717097bb7873aa96410b459c4887b86a0eaeb9779a26b793ac7674e53a1f6d5bbcd1ab1cb3961b738cbc1a63d348f4d8b6218dff4588ec8bb777afd604ccaf6ae0c5353692d15279a1fe8d7b42141559cb8f5aed6706a4d7cffc468612014ba50b753a5e95df87d79581d07f3966b6495f361b7128a1ab76368e0dcfb06bc0485b8788ffce8437f5799c8e7522ed3f2e497d7837693a364e380e1c2492b8dd87b9540599b124e9f4e22e40096a5e30bf7e232aa2ebf183e34375608d9f61a9840937d394a7c86bd0f41b6c88952eddd41e8532a01a419e5fbb34dfa3af8e2ca30104955c910c5b773870a6d901aceb303622134610f6102f507cbbe6313f0d92496c43a030a76d4eb4a3650c463bd93838f3d45d6bb47294cf4c9ede482e43c2eac87ea0dc0d91572fbec6b1ae86a89cf59b0e8cb88c784abf5d0640ea5abc885b17f6762c25733504617c2782386b377619c50ef9e8158a8213ffd20844d332afbfff1edbe3c398e999434f2608afa8444d7e5237ce1ec0a9d4ce4a242cd52b4ab59ff9f0f8c43e868b3804205e7dcf212e6891e5842067f7e69f87ec7d45bfcd463ea18b54e2e91bb53c512b9bab868af83f14cee91298d864d8934920b4f71fb6d262b5695aabca04607bfb7a28b5c6036173089657292662a4f4b65f2ec5a04c0fc072bcc0eebf61e180eb5e762b0a6b667096f5bf4223cbd6f613a7f472305fbd086bb077372e19abf64def7e9c31384b13fedb328ff4ea6147954c948da55856ec7143b706e6df80006945772f0f97579de9a2ffb86a31adf44737ebb5836f5122d3d17139e9724f24cfc1e6d382c90b5069d51679162b778cd6bcd53d142b9225da68b16c414f3030debaa0022d9d10c1389feb943f9d2131d12b7d08c79bc79ddbd695f2b0abaa3960f7612a4ead8cfa4153cb07eed7ca131f05f5bb5a2a34fadb65eed4d4fe52ed5e34f2b950855608f6f0090578beb90af8d4480a9e457ce46a7b8e36f68a72d7b6473f32ee10e58977ed892c2934815af734535b22775e017a0dce1250bc8f7fe226bb932de32da79319a06b11622ee09b08faddd17b04fbe74ba8ca31517d6d7c37e392af584c808d92fc85709d9ea176f8609e473328bd68905bcf5be52f29a74a0dd225a8c4c66ea71d381a137b194a50250374bfd957f810ba2a1281eda2826f7370dd6b0e9633520af9f08321e9f7315440e1fb73b1872593a35af3c9ca449c61920d0fb3ceb586653b059711cfcbf123a82cf66ec1e8cd16414f4ea974eb774deb486283e7bb7afe5d472c400b0b6b17ce6fcd1e974dfcf050b70e17c9322c5b09f559d94436d55e342a569f6789398a7ed431b4ea4016decc2aa6cfb52b7014a1fbe64d7b1bc3f3b134e8aefac65b2c0e97f34dcd9fc6dd1f89a9f79697dc98a65e9ae19e1f84cd562ae9d78e3e9e43443fd4627a3517b67d6fa40ccc84406248b7a0ef7641a16405805588cb3107b0273937f9b630dd1f98f16dff609ec34191cbb6fea199335109bd7c455308078e5f3d4e976381b63c930da7643e1c09886917cff621eac7959b652d5eb8de05978c765d3a31500b593b7c8cdedb682b01704ad70fd17961273a6de90caa3c84dc65539499813c9eb42fdecaa325e0a7f54602309a89c377ae57b99ac6ee22d40b6e33704c11787733bbc3f3e0624d6720290064b55aca80ea764f8e2eb9901e799ba98a18e90086ad7a8f592f0f55df3413489edc26f1124ad8d6c7d9839cfdc871c410f3b38a0c23b53f8583c27277f2dba66e31b1e28c78a7c8016e4672c47d6b75ae6f77c50ac838d28e2e74656b3d46d3698cc174e08506964c1a2706833b2b1f6fa14162f36bdda15b5fc5f107db2a0d9f12436e8c23fd82a66b1668adb9343830061bf9d442997221038d703f77d4a9abf3f4744066003d0b84ac12c2e2e3f48c567773cf3d8a649ae0f1ee73c0edb25a9b0473e5d310e3f12734c7371863af7b98ad21d868ed5c279b952d6fb8784c1dfb85203791199e94d535fb22eb8d0f08b3d99819eb92045a7353f2ce4901a30e51728ff2c3c7422a4e48a4bbef6e8adec2b9a111bfcbb9ce0272f656f99b9467866842c5d80d4120e49b0668fbb1bc67afc88c5b70b5af1fb1f0b384a52d8b50f35def79375a593aac7266bfd121ed05e48cb52527a45b580ee293ed4697270ab42dedd973709117d8247c5ab161850c1eb0bef7c0a54121c8347150851c8abf124f68596df3c59c31d6e4678fbc32f98383ae7d0bfb76a5a1aa35d803a7473a9ed05a473efe4b09d3034f560aca18844f3382a14765d320ec2b58fd0d625f277dfe6279fdc1b613960a2d2d54e1eed655659c92ff53842047707ceff73425caea2244f1e77c2386eac99cc17aa855966cb6cd76e9e88fa89718b8eea90f3a4fd5a3fb822a5087b43cf4416c28f12ca5889f93f1767312ae24530bd996a370eaad80be7f4a5ee8ee63d67179a6ba8bcd991802821c8a6a95b3fef191df848417da71c0a145259dcddfc0b1d3db5005978e3dc7441259f188b003ea9e5c44b98d7537601df4e50bf40a914c998ca4f729f4eb98a0db7bcca7c5686a87bb348a2e3d2a83c282fcf9dce663873d54df7acada3e2949090b6eeb97794697bbc35ad5df741104360a5f38b75b651df6cc3ecba2f4938f5e7153efd6e9f43ace910e9295c1206fb0edf027c9fa1281fa59a653e0e211accef49a4bb125c377423cd2fdc846a882eb79b95cab145b9ea0ccb3b1523799d9c6aab4103877db6015bb544a5e6e8bdceec0a3d61d1ccf2b17c5e0430b4262c4a970b8e85b8f789a91803f05f0ed379edac9722c4b3657e04aa32ba623ab2b9d88b5819df30774768e9bb440dca5ca3291c99a29d8152129978064329194d694ebdeb81e25df9e3a25db245c9eac00717cc9b093cfdf7a66c20e2f3441dc80f6dd8e47191fe7e9747ac77bf97945a32f00cda8ed8815837d9032796011a1d1a30f9853ff6e8c5377c810aa0f3a098f311440d9cf5fbd3d4749a3bd6fcc39cb6971deafe0e55d9295e28d4642880049c61f0ad5d8e8bf3f210ddd97e964262f67e838b6e2858b6932a07bee772cd21a33e7c1653df451e904c2e7ceb9e8e92b643530e6642af2be95f32aa11bd5bd56a7bbcc9515d67b6ff1ad7a0faab76cc2d3731f2f58452046c716a6fe6c72282a8ab7e2bd869ce314bc45b4d9f2f74f480c1275cee31366f20532417ae29d72bd704d5cb61c0ccb959947d1e399e07f1b87582eafee9b2565ddee73247debea9df7c6a622dfc07bd6872b2d070f4fe2eeb9babf3b81d2ebb17d643f72b0633068d1ba9b4d9a5ba631288a755bff17644f5444c7600c34c6f5b21cf051b337f6197b112187c66770b5c50304adc4f54efad8113fac458151e3a47900fc1d524be24b16fc9c7bded351ef1fb40442f6ae2e7904b08ce59cf2402ce62ff32e888b6657cfb00c38a2961751ac1800e109cc8a503eed88b80360d79e255e12b5f7a9af2d1310509d5664051c48dcb8041bb320d46d0fc58b2bf42bb319179cf061180cc4196698b641751ed9708f3d520bb41787945b6941b914ef1cbd88e51c03daa6f04e365f9e0a97c6f97e5fda3eeba139ea92d8e997d0d32d64336e61529e934e02125acf13f731215c4862a32a1d7abe8c7a354a1900f1b25fe8f802f60fe91388965f68caa7b8d5c92a29490aafd26ceb319b0f213e94b5c21dc6f42c7e7c29980fcb9b51a5053039b2f08b8bd7a8d1ad5112073bc83a10006e9f76de19dc23ccd5ccec842647d1ac5d636e700f912a0d14a65d605ae51ab86123bbf587dc180d9df6ad6542e8cc393227cf4e0207559b08c18e6d436fb78c84ca84f175bdde699201a7e688ce3226147d22e7997814606f7b4177b54da45abd8db4642d0854671a9c60b3c1bf736da0befe697ad6b780c9f07d78d42aa4fd1d8d9b4ec167cf0dce0f72a81805cf612e959a03f4ce1ae6b4fe6b6c85c671e3276e99d85c07ef6725fa78aee0ac55ad919d814e30b252a51e871ca645b304e27e807f56b15906af7060a2d000f1468be6b1869a54da25c8515dc819484c4197401567e8ee82ee599efabe75cfc4f3f147749534d23828ae2c081ef2911344e4d2ceca2734b20f8d7bf8d0c3c969951c410de845ada879a31c55dc04ba289707f1131e922fb5a880013654751dfba57119d5c4b9f506f11fa7cd7cb38f38005aca09bc7beece8f7892374fb2c752715dc88cf04c0c661c614be513541db7054a8058e9471a80ddd0a231f4ef808e158f72d8a6fdfba4114d55aa4cbc522fb40b31664fdb8a15d0b6f5f3898031a08cbfa40cbe4ec1457b0590c9cffbfe3e609fe81f44a4699125365a45cd821fd9a2885ba5097de196e3ec43ac005f920be98ad255ece216469a66aaa96a9eec8f1d0a567d847ea7a94a9b3f9cf1fc92dec8dd514d514e5d998eb16a1a838805f96732ca4cf7e6814a837cc848bb4b33ede6c120ee298f3cebcd92def95df5f756d9cb16024389d591a9856cad4a0377f72e38bab4b2d88af445193dbf0b90d124780e34bf196216c894dfea33f74eea3f7f0dd740af29f06ee89a04bb96b711deb85060c850297c921673ae5af1ea709b9f9daca7e0895971b84ed8db701c6fe583e53927a1f1d34ab60b62c7a673808b45e10f467689b1ab2798d09fdff9680386c51185000d779f4c7928207a501200883e4392bd2039b2056727dbe6e69558d2b8c289373f1dfba7a9d98c9dd9dabc91309391008f15dd30b964781c52e2a705a499fece2435493d6ee903f1c3a6984adc6a0e85841fd29ae607bd7089a57997a5f6494047be5c0e067bcf6c2451206b0721739e4d7a7c9e4cda0181b298833c67e52884e6cad009d1b0df87a8256aa044ec8fe9130ef2ff54a60b608404dcfe0011b3ec3c148259c143eaa95d85b3123084cd897f45be406464b48e5d7afc1a39339f3678412b785208c68dd447f2229f414ec8b12267d4b910694ae8316b23fa7f57c5b9370f89311f479a246eb5a36a2ac0b055a8150fdac0a3e7a826caf152b274c6db25e42aaac87c35e82bb0902cbc25cbd41c6080117735c18c5a121cfe122e7a4fdf0d3b8e7bb18abd229b224b658e4fc960ea4e98001c69da3c7d2ce2967f5e117d181106542a32baa98875a1b2583edd6e5d7bb4fb1c8c9efb7ce72933dc880775c482e87e438237fbafd9f526d94610bb7cd5a935192d6e6307c737ad44a45a99bceea626af46b9f837c93f5e68195e56fb92d7ee2da57fd71e8e186d94a21d3cbc151b247aabaf8d9456092b105cc3568944bc31301657ea528062c4b4223aa3c2659ffe6f63006169d61769e25cf24026a14586001530588cd2581fbf4123a325fa6b08694aadc2e5546164ee0d81b3ce35803dbecb2d4e7c868c04f323e884635be5fab6edc9c7a61dbee52a61a1f80caeeae92f67b8309eb11d0f72563bb1d764ed10de1a197474aceacef675ce53d22af224bd9c63b0c240a85de6c2fa4da74e69aa4cb1dd21bed127f0cac57582e93b45e2534c3039f1f14dd0b2af2e6aabdb8eda9387ea1793bab74ce0c0770b53ddb8c58b4921784a54fddecafce7bd98dc35ab7c62402e3e6d20633bc65c8cb5741d89098158a9c239ee65268d3ef14df4c93a215b23164c9b125da64d2bc2678d46d64d6a6e64f62c5f3162ec4024fdf04c7b0b7bdf63bc17f28759ca905107360f2699151b3da3a5513ebae3e40dd254a7951cdf86f2d8f475266750ef3f7ffe24b4e62b745edc77551024c992bcb0ac702a617d02948810e73eab2fda4c1ac88fc55bbd68d8af845cb083fa00c986d9ad71ef497dabd6b3a02da6c05a051fbb488d6fd3a4b423433ce2d5b6e186e47cb53962825881de718ce821204a0160d27f8e703b33be09af4ebafcf2423f8bae2b6a365cbde53cacb8d14ae153dae4f2da930f63a8be810954671fa4b393913f309dee66cd81c53f38bffd648315bc4cf413778924565bf70102317735fd4f32a2debe8f62cc845f29583f28b5476dbcfc08e5932459e68dd4a1bf105ad24521d8196b53bb899557c7ea93f1076b34959aef86ab4bd07153e7684eb2c437b7660f67f53232f2c43b8816e85215cb7129ef23e0f72a47f41aa9b20580a92d6c81913accb9e08413cdf5cd591e06cb14a398846b28f17a28e66e53033bc7fe120a0c3099b3033826c1c3fd183539cd1a81c16e59fced289b6737c8bfa346a116b6bfec21f253061149ce24297155c9db943cc51515ee1829e9c7ceed2236e63e7b23cf140bdc6a80238f46b669e5f7dcd604664a019efe1770c9dff303e551e3a80b7218151e96901fa16fa10798442d35ae29bc8845b44a88761e5c8d4708d78917a6bea3531fb97d9f71cbb781e87dcc34e742b6aa89930b9fb1d9f1fe2a2214cd3ccf67e9a9950b821c278a8a481360dadefb809653df140abfc32941346835fe61b6f1f951c1b36dd4e710aa02054aa1c4562f392a8c4fca962170e7dd9651ae92f56fd21396115acf76504e750d8e5efef4f78f79ba200948fe38807ae81eb90104593319e0891aa2c099fa6828e0938a9966c9793e2f6b6b2652a63b0190316c0b7ddd8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
