<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"915f7a20dd432aafcee7146bf5e64a65dbb1bb1fc4087d4de24e982af2c2c3f69ecb57d7513efc49c194a394081d839da7ea5d697d6d574a26380208b61523cf4795597bc34bb5663b9bc28d8d399f9c31c030bdf2fbbbc5115bc51c68b1341c4f157a0845946a99b29b3e68393c5e1ed7f3de607aac522825267d6a211ddbf2b6efa85843c9a8fc4a145b8e6a9ace6f49a6bf454a073b0aa2047dbfe702c8a2a3fb6643b9388b0eb99cb7f206439280595e14c67c625c9f883c70ee8f242f2787e0c1b45e96abd1f55e15050f5029cf750b9df2a4ccf4e55d99f1a289c01764d695f65517af3c42d3b118823277fddb92d97a3596052e1a0adde5c09357d621325e41ac02c536caa965c276fbac63997b2179422d28d5912c0434347de075602c3f64323dff733f7650bb342c75b512ccf216d7ca4858ee6c9bef1ccff7bb14c49903f3015d4a52949001b64f5fe9644e00479c84cf5c10d5dcafd2a614a4b17d9ea75eb1f24833b496d53c53e8d9f6cae75a21654e48c54635613d1c6a36cb8414891ada6960f2166469a4a2a2c9bf258def4e4a48efc2d6178b7359ab946b3ab56c9e660fedf1f5fe748f038c41e80898516b974e58113974e8c96e3d28accc2d7e723fc6ca10e3c6ddf284fb4129053f578e51d9b1221e21f2594e4a98fdf426c9841b5fea55f5c5b6631bed898c2da3c7c7389af9af16b46b0a2324245fc051bd0865837de116535daeba2f31d365203a8c79ba42668a9636d0d8221fe291c71310380c15dc6eb76ae66fbad54b008d821cc353d9b50ed7e180b9142614ccf91e0bcd60fa6c8645255a882959c344192b90c0264838a5ccb0dd4791054e1e16306c13d432dee0134de96c94afe6dbe4d58f6ae6b5edef28fe0dde947f9c61bd9f10fb86a13f3e8c1e60d427ebe97e49891305c4f29bb88db0cb57960748d0588cac9a249bbf1aa03dc67b7ee0b9e8d10ef5a9032b283b3b71815b9fdff58190649011c2f676f7a3df34fdb29576a3d48519a68756ce9300e17c4b19af75d7400bf80276b86327b39774c94420c87293a269419e3b29408bcdd9ac02e91045c2c1c4618437bdaced95df7a379b253afda569a1d6d1b7d46bf289339dc7c8a1e14d752c8ecc787ef048ef1e287e4770503a19f8d6673c6dfb51c1860fd0215a121c332804b1db2483d7cafdcdf9a67f7515dc5924ed0bbf73acb279ed62d10a9e0b06a21dd8b1406783a0a98b30aec44a0071638c65826a0ff0811dc363764ec396297c27ec589a1f7e5e935dbc2b3ae214ac7509cf5b16f7e71760525f1db175a37214a8c5ff8c335260c46ea077ec8e57e5377b1c741df1e2be99bf0870d4c51b9d7364d16669356ec2b2e4e9e307b521d3f2c3b213ee82f3fc4fa782674c7efd7480f47c6aabb7ff8b4bddee5d11cc35b23d5d65bbcb2cf60117a585a63bd3c13d4ed7f617ea04a675e7eb760bc7f48b662ea379e64608255d2f44e9823d489fcb450578704a8677a37121eb7e806798ea87c4a2435332018c40e14dded150712ac1d02943d99f920b32574d55d7092ae3e01d88a539dd7f9b1e28b2210dcf1305c64e57651a8efc63f17fd147dfe378adf5715bd40bb54569ec0bec6fe85c2cbc17cbfe6e31ed9fc83452d32ce20e3f805c823c7d49c36b0125f2868d09041608579b616db94988f8a44c0aa9befb11f839728ac2af48b2968ae8cdfef0f2f2e294b87597cd8b33067eaaebe1ce7ceffac09341001154ba49b8f7fefeed4d065e55c496734f73d4b10dca7578120179b417fa267ea68b41982b6330710b369f7098e8f6f9169bb807d5ae319c6b5f62fc18d352d2ad43cb2ccf0de6ad074dbb09bfb4be2ba0d1feb1430c27cb5fe88ef483cfdc8324b220124c16b36ebc3c69cb6253adcab4a400c07330334240a706cfeb3088877bfce9dea4c18efaf03993ba19baead182394b0ae4e433e7a33b58e3b58ec74c9e0112b1114c9045d35e19190aacd1da28ff06f62842591b5f83c9a2525384620a0af910abfe3b1febd2d74051b1659d285fd471702e49cefcd78ef012ce2069acdea21150a961504fbc1f20348ae5e04fc096eb0afdff63d9de6c911a36b4d4feabd666bb6c20033cb18c1d5f61ae3787891ecdbdaef138539ecea0bb7554b1c3ee699906c423afe906dc23cf696fa30a827bf4dfa66eb6d213b4a52b5d08438fe7979450d49ed9f14174b337707824b6b7c16dc58cba31d40fb6e3a03e17ac2f0594b1417a2174f6ed7105066f8d95680ece3808222de83553684e2090beaadf1760440ac646cde1c579a4bce5ea594adc2b400c6707fb0708cf06c05e74f3c3dada1240c7b266542af9f37597b2871d8f0f429c44bbb6d478f22cf3ff6cb7e5e368b71d1bfa2bf93b486eb09e8651bd909a683da397a0ef308837af0903b3490b0645794b07245211753697cedddbd661d969957b154c28b0d177a17997475b964069086c32f01cbf1eac51789451cb2797f2a0d3064556f40a57686e061b6ede5e4cad8500dd4beb0041b92db9bb65ef751b0f5707f57619bc448f3f039013984409b7f13afdd6956dcc257e20ba10b115473d533c1548fa20f298917ec62cdabd2a2d33d7747e953007765997bfb43e48bf8c19991bdd002b412191cb0f2a438bea59508585ac3f2a34606300006ad9135ea3ee90ea5a18e5b45cb24edf6f58799014b9e9104590e18be8b65d76d3010ba2ecba472d1adad48b51c14cddfc6e94f473bbb0770b1e5732c2b3cf8206c712fe2e43f6289f1e6fef55c07f85236934ff157691402646bbfc851c71687d36153a86cccee7575dd429837bf7b7c56227291c4b77a60157f12c8909ad50145a289eb006c6472b36d21114bf80e029640b68c0a5235cdedbb7c5040c5be61ce3eae91d20cd5a295f4efce566b7e8a61e624e86fcd292435291c26977193a6ccd465406d8200ac5e10de41bc1a80200faea4523f452418fb24a5706382619d8bbd9aafcbac54cf9461947d0ef6a2f46c22a5a013b7fa9433e07e5e20400b92374ba3c6b02d77f99d64a9b49937ae766c96a646c5ad8e0b4065df94c1b4f41abb5ebbf393669e0055cbf9619ff60ff30de37313404dd795c8cc361f351fee88881f2cb7d10fa1597c2df9452cc876cd4dda53b7352b85802cf5b7112c8cbff5fc2dcb23a795b3903a66ee257ef226ec5ae5ec0cc2722eadc3f9a1f2ba74309d0b6b9128ba7c7c7aa756b77f162b99e8a14c14da71b6d8d45b8aef5818395f3f30def9f3f5282313ab17460fc014734ec7b381700d7d139488ca29dbe6ef9f0e6f8c5874ac53f250b14b4dcbf8827c50262bd8d7e5d1c3ce3b038312f6313af5e8871d35d84588bf27bdee0767d9ce98e7cb81c6a5aa1aacbc4d3c2b17f84abacce4b830da6bb824e00b446b8a793a9070497bbc1675e827ce8a1d1a01dd59123423b67aee6244e002454eb4b2c089ee36a759f99e0df27c7c6be7155e626bbd83c8ef593841f781617c3fd426cd7cd23388bc083b33a6377acf9841d172c1a06179f982f621fabc6c419adf8129a01e434b1ceb930b5e282bb04ea00242e0dc69c96618a9bd4a0f719b50790c0749a6180e1b8abe7ab85e62111cce32a65e47660d1cc2fae35a0c5f11fbe8cf902ef3b69e81219fd15033c2c688dc374f62a7adda810ae2cf72c97f2146288f93219480f4b210bfce00f91312350af3c7de87147299033f2874acac2791142b6c347e8558cc04e605adb4e115415de8c2fd2630f42a074edbf2e99a687972e9fc455a760b58c9991cddf3b62e5f8c6e72fbe5a56749794e702eb6595c29d36fe523e731ef026092248bb8de3a1c87a11402a699ae5e833f3ea5ea7ea37d241e83380bb586a048cf9052e5f90415a9373ec064dea42a02794962ec6753313b568fc3357949a6b5f518924efb8f60ab6f1f1f212affb12ce273c11d38a8f24dd4339ecc9711457f3331b28ff2fa792b8c79f24e88fbaa4bd566d89dbb3dcd1c4789aa0b13caad4b522687fe84f3bf4215ad5058ec918164393c8c66efb822268d1e514fd3874fb0cc26dbadd6c1ee5000ea4137f12d49f11321f35e3410764c630d12117da24cc71db28f4b9c717e791b4cd975b4176402885c7b21d0ce11da2fd57ee99697ef5981cd9be0cd31bce16cc88baa58fbb3f739601e1e1d464646baeed40f906debfb501990e35801e24f14ab67bd1b7ebfbe0c6bdaecc902359a06f2e01048fdd7d38ddcec685725c46709e77d564cc33b3d052380c80fa9e17217623d672586c21f9189185671784ab4436c0006f5807047b52dcf2866851d0049e784f790875b9fd8cf5ff3d378c52edf96c03368e94f8c1df3d7728c69847b31e7870483f026c029e1e2331e616974f6c9b7e7b6b7e586a4372eec730b81b6afbc9e4dcb50c974d5d1ed67670933e96c4e9a4bad0ff06046ce5844e2723a3363e95f586ca94262d913a47915d56267576c9a9a4424bdf985bf1e12fc30c1e730129739240188f8f5d4dd39e2228839dc132f2de783c7cf079a2004fb41658952c1e422c30c8f9d57eccbf34c933ca1d6401735f7375d8eddf99bd36a015e07daa120639b9c2685c15505e36f893e08f5be7ab4e76ab8cd9dfe9a98631f9fb0f4ba73b4fbdf42304a7cefee3c8a255b5d39755de39ea5d8cf5a0bd131970209e540299728e35821b94e6b0541ea65f9ce37503f68d74083e22fc4bf424b143ad137e412b84d96af3dae0142a5b4f007025c727ecc59bfcd11209f7a9cb18345e35fd6b9a21dd6702ffea5dc1dca656e9c338b96fba1bf69a59360ad25d139ead48fb17dcec1690be536305fd4e64ab07eabd5b1bcd13e2ccf02d43144dc5d3ca62e4776ff5f79aec80f6f0e9e00fb7e0703f74d3088b034673212e871c5106178b3d1ce645dc1d153145ee1f35200f3423980f0c7e566014361e6a362a6293c369ac0bd5973a3b2a4d4df256c1c3c0871e8f95566b26e00320b914c9d4620dea17683ab29a9b6009217e2c1638acbb6a4368b22e45289786f8c4b381f55113e48e15b269ea2c52757f6fae3521c2a19df944705cd25fe60770a3717e5ec13927e816ccc9873f79f607c3d373b54a25827bf36bd464fa816a019b33cb149c73ddbeb34be4235f866f18f29776e2a4a91a5a6702b843965fc9ba5000028da4ed7a15bab9176f70027539a2961858b86969ad8c5c7a59c22010ca5755ca8221cc785b26ecc2ce3ebb93ea8e10d2ed34aa5fa82022921a6245998dc3adb2e2c8eae243ca6b1cf482c894718dfb399b4755c13e4d5f1aa13bcab390e225041a29bddb9db5c0fbce8d0deb79424d5b27f23109bf09b799831a063b3e45d8420f5821319cd4e46c618185b9998aa3f318f560123324a427d34684687c4fdd14db7a9307e17f614e303c73befbf093a2f81b524037d8d0c6498ede1b93a930c08dab804a8c0222567225fbf84d86a0a52c2b6949d430dcf58f5048c38a8c2665232094fb5baf2232a770d5d1c13d244881264527660dce1d3b2643e93d84622248ca6335727643a9e143831afae739fe9fa46903016facbab4fa67255527b49fe73ec127e24f933fc1a7befccba123589ffc32b573fd23f425dd1cfb7bd9cdc7d4f188edc0b022a977d8fb46228b3a8d9acd50b4f25e0c4baad3cabbf972f7ddfc0c3271ebeb607e7d39654ada05d110aaca303cd2fb97fd4f683a979ade439407bda38a87943527a88815a5a1a333d1010c99902119c4621c287dc687fab5088369b59752db9f44c04c2bd0b18b682c21a276d1bf7b4e1d7a3a11f55de009f7bde8a1a96fac2cd93f5fce60b67e78ab904d2a780385bc18f38ea9aae05530d3e5d368044f20b136955c4a1b23ca9671e6690a064f1d96e475f527551e660e100c9b27cccd4dd03504c316934b083b2a3a1602db2ef883d1cdc11b67932706f20d0dc4f9883ee225cbb9dfcbfa9dd7b7641918249e6030f4a80bc98e46d0ac452d47742188ae0b14c17543766cc1337ca58fc5442e52baf9efae5ded533080130a5b21cc6cbbb3f2c4c01cda0f236c8d995d09449e08aec6adc3d1e0472309af492f4afc1ad5b25a5cf21bff80830af8b3f1f746f6f1f966937e02c5578fa399ff9e464d32a004d0396e89aa67e2140426304e6850ba87856db3d778ecda686eeac8a9f1e19a6dcaf4286d286f8449081297fd68da7f15ed46e6976c1c3f05b8a2244895d23fe06bbca115afd97553fbde0d110e51fd9ae1b027eb7e702224dddb74bd3893f72ae8341db5a694eebe760a2af872f1c0721584fbeebf3d767512ff97591c3010ffbb02a1534525f3e124ddd04ad5afc9ac0c4fff950a968551823fc6d3629fd418f62de370600f51e8a093bc8caa05140b87292f795bbda8159c684d40303a5e9db2c17af0ca32dd3873af101febd8e8699bdd397007a1b7faf28352772ec00c681b47e2fe65125dae55319d0f9a8b2acc5117f4560b534d1852e4e019e019654d6b90fffc19a02440b1c2f33e245c74a666ecb992893c3811ad84408607ed42426da830df32d848ce366d1697b66396efb0865f5081cc0facb0da72d6406b3c9e108c02ce7a1d6113cb2d3c92c4e84246441930e4d9cd20cc39b7132ad4a74776ef03ec8a1d0e995a187d47e4848565b9cc37424e3f2642e0d49c07fa9f2b7272000f5cb26351c007773f6e477955327a93f29a1ae603e2f8bbf49237576756c2f50da2c6b5d359c5a1bda7a33d3fe05bb4f687c81e4a34310d35d82d31bbd070338fd77243763fcc0fc00404ad18a21b5663bb970c5842e94f20a8a15e7c33b46ee389292ff5ccad893c2f6a6cc3695317b6a5c5cf1544f63f5818730fc1c70fb6d1b1ce709ef2eaa03eb2c525f1d0dafe47fd0a003b10c8ee228283f6adaa3bdf39913fd7e62202ccdfc88f3450c67c56bac44e3b019af786ebe0b936e1d64f9ed1669635dfd3fdccfc6201d696ec0d8720127dd13d3b36b7e8ca3c10715edbc8c6c464cb200e2c6be21cd9e3cd850a30bacaefa42819b8ec043943098ddaeeebbb88150b10e54f1c88202d4b696b500a89c6cb7253f02036f22336da4a55d92ed7293ffe437464057f29b4984b4e20b7286a1e2e4b6d0b8ce28d8184aebe1de523cb4e1ad25f256c4c8ed19cce763a4206cd72a8b55fffa1252642ddf437484737bc359f44e1774ba49fee6676dd765fc5c1f4b0084b54072fc818fb8c989fae7a92c4463f0ee11f972059800b37dd641d0ec0949713b42da9e4308793f8931e9762e848636d28a5f1ade3e7106c3b2cdbac8e9480aeac934c8fa5dce366bbd31adbd160803b85aea556e3b0fbcb208fa6fb2a456f76986a0647ba48ea0b4efb65dd9f95e83fed7d4cff1d63cb0f99a829e8cd95719c5a84500df88b79c9a223cbf26f8876f5dc07310a18f9a0966d666cd2d61dce4eecdcb312e779966ab9f2f36332ce850d3b6f1eae7d8c0992dcc0db34f634b0f7fb91ca4857cc2f6d103e1b6a69f12ed38a333e9699b5fde5dc4eed103a21c751a18f2defcad6a99d7915656dcb2c2b1a56d67d377a19897c6b54c987a8e6518c405d46c46cff0578c554c34dccb1e6f34f0180c77fd3c5653749b48ff6e2201b55b3a8651a583b80b44b772dfea4aff1ec2a58fbc89fd527d61ef0264e8518867d289f2ece43a00038c6ad6a303aba6ca8d018f412d2e68a38cfedaf6b0ac57d576445746be7d218191e9f60373d74a01865faf39c340d9de1feacd924091e69a1a99df9031ff872754556585a9445a3b657c6d387ddaf82d92c80d42c2aebb70e3b0e7cf220b795bdd718e8a311c727bd5ed02f210d8aa147d1a36b90b75e1ee4527df83b7b53b945d9bad08ab15c8b22f52b42bebbf6a8bb9fe276f0e09e1b9207862282f48a5536e7df1bd0cbf8e2fe1be00f0d74e025a195db79d57d1cc15d944cef2b448d4dc46cab0b58cd7b6c7372819927b9cdbca5904e3a077f3289a22ad5450478de1aa1235d9c66f8a906842a4c1114af8c04b7458957231346043a9b10caf295cf3f8539b9d408f48c2419ee52907e4f850cd352db0d421a5f0044aabf99b196d0269bf7bd1bc65e34ac386d0743d6a5924801767a871922316b6689ba87fa24b09ce218863d6bb5a453031b0311c9b9f766f8201fa2466c3290f10fede07d9719400de6b0f055383d514170d7d706e4f66eb134a95287581d523b628c577cc6358a1f963bbc1e141262afb4cea65cdf02a95fe464461197bc0144524525c4ae1b4e23af87b8133a56ea725859c3856d22ee7ee23428b83e827cd927baff154499fb6cd49fedf24991152af3f2ebcf263680ff915585ff2a00f21fd5f7a977ae6c8770f2bc689593dcc22a1195e8faf39a86330fb756925441dcb2a4173cb2364b1ada1397a1a97c8b64027c19b235df38c6391bc2200b6f76e879a827df506ad5828ce1ce39b3ccbaa510fe626507568c2a9a837c0a5decd42bded8cf245de1172c43dc001e7ff507f8ed5285cf05d53978a60ffebb24f360352ac54f466056453563550244e2f84978c8971090e875729bca954fdc515a376e5236a4fb4ce3683a3c4f2dec997f530d1b762df6b99ec73038cf08c9732ca74b1dcca257fa509de98ed0fe46dfc7ac34f4891d443c2b7de0a3eea31965a9b84f78b98f6a7fd246783d6dd1e33438ac6d804d54fe54e16a7df2da9d15af81299cba62b25865df1cd35fdb9d6ac6e406e9241e95db54b89b8c1a1be354aa9a73251cfccba7a7ae65a3e223c62901330ff84d23015c52569a50bb7406443151d3c989117a915e18c48cafbf96007a046709d9e21ea5db65c378d33eb81b76f9b15067cd36a2dd0612b437e3cfa0f2970b353f83f77cfdac019103962ad0d91ea22a070a348d49415ad934c0612d64a404b6949a559eb326d81465c8e2e8b7ebc2587d1746a13b6a5e6d5cccec9a35864abaeb6f83e4eb473653c1f81fcac26f18a06bb9bced77b9afe376cb315c276d0cc7dfed20284f0e92c15f24a65ab418b3a9c5949cec167302e6fb270dc6dd0bca11f9f23ae977b96ef54b23c1c12c69a1233d511307ec9fcdec558d3f792840e707f10f4176a7c847eee33ad81d3e14e2775f9be7928ce1385bf5fd71d3f03548ffbec57ac3670960b196e556ff308d87066cbc01ba79311a628caa77c093cb46e0ba1cfae8eb28153c61ba9727d18491814da3d70732cc85bb82fb2484e13b69087de9fb506fbfffecad729fd18bcb17115eca86e029cca8e73396b4737552c05faaa0eb17899ea496b9be2547d75e96527f5c7588f16ba7a8b1314ae329bf888acf884d55bdb95c2e9b2d897010cb7e9ddfb54c629acd3053479fcd3315f5937901980eb41944f81b0c96e8d6ab203f3bf323415e34abef825e1c1031d0c5986cef2b8b9f381c7d89877a3f941607b35c893d6e65aafebbf5d6c89142cb336d919d4eb18939899bd0afa22f1ba84bdacf809abfa9cd15db61188343382e74d0162afae43b6eca07c3ecc722e0a72022a239beb692886fa30a94e8b302ee90b24b2435118d2140ba65f1604da45e3ad43b54f2a76b890d338120843893ec938ebb6e845f34d132700ad3c37f754cd6d2d0329485aae8ed0d72f5c6fe084d41e0da03df4ae225ce19d20a8bbb03b96268cfc2eb9174378ceef1514eb63c360ca61ee2477aa4307b53db33d1560093fdd5f8f2f1b1265c491feb4f5bd37d52842975615bc7f2d0708ab2f298b232d89f51ac6f8bb45cbd574df1744a27023faf34fd95e3fd7c72f03f07cec68d1060bfd7dd963ebe357b6fdec613ba24771586d2e94aa1d65ddb7a0ee12aa185e5292d2f37bb53d8bc71d8a08f53dd9395231143eca6e7bf9dc198204dc9d665856340d02cbb2e7f3439026b6fff8ff6ad34ec98eb92fe9ba3155b0ff841120f33a489748ee8d58799343738b3d17ba2a63bbbd42a13053212367fc3b571aa1d181c8fbc7c2f8b6f0442aea67f01c9028d69887e0b7bb68988d2b8e801ce89389b8062182d5a874cf47f4d7d4b0d95531fd8ed1a3a905964cc83547af0784c72784534d3319d4dfd65cae6490ad0b297dde31dab0013aa86ea339c0891632c4eb9360c0a90a59953c10b6dedc92f7a1858ba2a13d7c961046dc91aa116e16deaa1233e411aff82118c7b772a8a37cdc017fc160699f66c78cf076889aa796a99924eb31b9443cb19cd8f57250fd8652f9b0bbd9fee458c59a4e1cca49661985b50afcd0c6bc39df4fd269db7e84951b6e48fce0e11b1b267e6942690d2765e891f33c74b38a712006ce8260791f7bddbccabf9a10f8f4bda9f16d398984eebe7e8a28042d11ad1efb52f3851bc99190cfffb3eccb642c09201f6b0cf547fbc5b611cff6c51b189ff3202cea57c9f94ae5f2c4db97847f8ec93d02481a7a8cb02db90d80ce192390ec109af67526f7f39ad24dedcdd8b0eb758cc6c840e8e1c819885ecc5b53eafa81e98c104114d76ef0c2829338576d3bed4be510c1d0c67f05e9c90d675a12525c6b7436537f36937291a07028f415346aed7e45a0be0207008ac589a8d3ca80be6b38ad5505411812e964bb8d5720d1a3d98c739300dd9f2d445e673c199554b99580ef62b720642e1d7d9240bd63eec729a6d8b3eed1c5b47584fecd006df6c2f5b03c4fdcee57d2721858b0a5d84bc2183b39b8b839315c74e663031b2b38dd02923da690f5e8a82b1c0bd96131e3296539b31b642e2fce3e4444ccc46fa1305d6ad8f56dba7d1ed68feb1ac2d90246bdade696eeacaa1eb1210e161ef1b89eeeed9e3268c626e62f0b6bbb3a5145428fba71bb81116bfce860864ff3b69c19f2b4a9a04aa48b9e0b277519c63cbdc495ef60e91b9c31d4db9f462912612d1f562758c0c3ca87aa5914f28af6be61f0e8621526fec4b119423b9dff989e3769c4a737cada3ad35d345f3aa232828b8e6c1401f10b321bc85736ffdb5ded6605500455c457d94c31a3755923e89cefcbe50c18b4e02a0170f794742d0b5e0c1c6b0e10c6bdc41060e5eddefe1cedb2fd4411e8af1c07ac4a8c69f1ae904fecfc07a8ba1a052d53c3ce24796cec2da27ef3aae7a0357cfb578964f9404f7b519945e6f2610ac04e04c95940417c50abd16b8f5bee2abc1a3d9ea1a43c75b31e90760b1a20808936f18c2f570886854b58a8731185e913b8cf7c39c152661decf018bac0979cf8f08703548f5a073001ee536a736d45cc570e31ed936832903f91da1d8b3da60aa4f01fd1c2b7daf0188400abbb9806c727d4433fbe5a9b138821fcf5111d89894fa04677a6ef174a2d1c84fe1800d9eb4a5b6f9e4a37ea906de67ea8f2a88f47afc43869e1279794b20d05c4ee3aad01324903822c57c5adfcc937d87779bdebf24b65e35a1e7ae70ca836bc49cb27b0087e9d97d95d998a8dc00d49ea48196a65a1dea6c72750bc30e400c7518ac9dadb9f4e3e6a4d4121c72f63849aaf3a84451cd4005dedeb00e2abd8de234c0dff6ca047b10c320d49754f4657ee26391b28623387faf2ebf62b8c5b97d25e3942228ff1e2c699976f49794f871240327d9013111f5faa7419f7c57fd0bf473313e0a50ab918bd778e361d3221a84772262f95c44d9fee3e434edd12552da0c6e086dd5f84e42fc78edd851ecbb0c923a699347ca56178307219a8dbe5792018048964a011c7e83ac865e91a98f3ff9d80620fbfca916b96443aab6533101eb2c2ebc0a28fba1cf04d9d7baefbf722f1eb4a494c919596204913754d1888b4019fb208fa13878351c3bc471b013714583434f888ba41f34c58c0e20617404e828890211acc9e6a9a98acf805bbe0111fce96fa5d8d99da8ad10a7df2a5112d88cbbcb085f3a1cea79b2929d3948423c3c13b5de134fdaf69ac9e823ed290efe9aed317a7dd67bd575b476177fd63f2c5ca90707d993a503da72966f45c2e44218483a525d1e82f7db307ff3583947412dd77dabc2fda05454c8d8d7d618accff5ecdf708bae884e726dc658725b4132cf90ef418efd73e74ed667cbcfae48f2ba68a67a7eb640355c2c458af88e4742695387f93ba4b10f69891333c75cf451d257316e38b50617a6294e4145718e73078fc7057dfae9403ca1a881ecd0291866a55bbc87031ef756265217d15fb986f4203ebd55c9a9d05a604f35c7c9a068f168b27084d8ed65452672423f2a3666a86895639431aaea815290cf08f2a7334bfe6aa5a13101fd686a6f9b41aafa9a3c0426029d4c57e07b30c61b7f355ad434e05170f5f9be08f6c116926caadc1d0f945dc5183f3e9d6d22311d86c6c01cf1f8193897b6a6c428f0daf40370ea65d06ba7bc872f273d9c8f8da38cf97bdaa78077a2f1c3a130659621c5b24d1afdc29ca0cb90fb955e77c110ec49f8e6f04de5033066b945511b35de9bd60835b63a5d2b7f50f75d4fcbafd55057adc3e497ed1cdb609b47d006f6bdcd2c086818f03253b33c92d7afb70129e3878a9eae1fbe90e0d6175f43b061ff6b144c1060c93b4e5f0f6e4c4e3dfc205950bd3f279e8e2c6a43352c68ad6c409159b38c33725abdc1ec5c99b9258eba28a6c5cc86773d377fe64fa3d51daa95df99f9afbd48dcf205cdfce7b285efdea5cc43a352d38879c97e418b3845a4c072edd49de491578cb6c37b4bcdc0e45b6b2b9d555e23ee6040174147c8199d1a6fa7af91734086455b0ee0d8c344bf8f81bce267d6cf6f442da6f1762655be965602e0dd95a42822457e7e6b9e29ebf606003face8a379bd7c9ad28cc891bc2f24afe1793caa09a7e9cfc79abb0699afbf689266412751e677a5917606d2d943705c01b389705738c2688c6cef9b6a51d0598b22f5ae09bd65dd0cc2e07fb777ccfd1d20b79285c778ce9fb57c90488573c425c9f3ff71720e15972bb19f2cedeeb327feeb2969f0d85e98cd6b0c00c33e9ac2e302d33cf947225c0c59ab9b4f974486e994e1ede418159ecc10fc2418646831d1ccaa7d3af4f6c28d01ff09574a40cfa690aa2686d567ab6072d9b7ae988dc3c4c575160090716aa0c181f5ecd8e6a0f23bc05f7fddb861809b7f6b12dda1dd6fe85b1cfad39a0051cd35bd5eb0598af42bc72124a2562a8da2f0fda5c5ea8d81c5d68d5f547a1d6c3be104bc5aa124ac104b11f18c8584f9258cfe584e0b88cc1097f12da73d93e8898c8f133ce722c3c79e81185a6e82820c3d03d7c75c8aab3132d4a46158cbc479440bdf8dafdb7ed795c76d3c3a87015551487c2e69f00a4f7d0e7fcd6d391b3577d2e1d773a78f2e289230a1161e38a060c4799ee97321111b35b5a6fa05f52b19b9537a277ff2dbcc2294dbae620a47ced2a8d69dfd108ea08cea4bdc66e7da6953578c121e8e4ae2b28e46985a3f080d2b774131ff663a3a20aa2709b4f96ebc4f668918f8d379e068bd8d8033cd9b2c68a4dcc644db7bc6a84b02dbae59155f42b921b9f65a47ea2472e5c2f3e0d03371dc09dc6f1c36e26b2afe6cc9df53976215a6eb3205848ee98d9664cf4f8a9f2023dc4a9be9e92732e1e3371601bc637974eeb4158f637161dd6b17805b35d2f72ce42e001dfcbb3cebac205f418961d283494e0e656aacc4ed1bcc45f2fbcdafe667447429f9a3e4175822f187fd9a5965dd8f4db84b4ae1ef0683ee86ea3aed4f716bf66e861af0840890527f7464fccf901e83daeb82f92eecf5056f7ee45057eff2bc70002f85ae40328939dcb2fa3ff4f9b2bf889b038a3b80704af2c3336d3f35efdb2d1c10e8f7a504d6a53e26ba69a040e55787671d5b117fa30cb183992898b9dd8e5a9c8465126487d3ac78314463e694e4128f3687a92473e10072b270500464600ec8477bf163351008b767cf1c75d7fe597d83bff6fd451c645761e148844fb2f36a73577b485ceafd4d895ef2ce046ebc92a28d04230714e9b44f735b9d01da55bdaa69618a9de313a83d1663bcefdcaa35fa471c02ac0d2832191f7e2d475e6654d1805398211486bf969588a45dfa473b92dc4af3dac4a827aa6fe942fa95c3cfdb80874c34d03ac8489cec31df8b61780ef443e9aee9f5e4edac40add82ad396dd3268a3600124c91b2e76e645fa6e2941834303279c9a478b0d7a638233555a772675c732aeffabeb0451527225977f2b745c0c0bf2ac03e8f41a92ac84d887c2d941e6484e7be8cece0be61cee51c428275e7e437dbbd7c3ccf21df3bc6ec5cde7638b7d2f803e278cd72aa91b23b2f7e8a99f4664caf55753502345c0319a56e18d800f1e63","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
