<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"913903b867eae90573df5a53597a0667fab9d5911f57bd58f70440eb1b64ebf46a4346dfed7afcb9c9fdc293917cde90875e7f0a86b88be6e2628ac5a415243e69f2a087124f9614e6a2fcb3323f2f6349100db8702bd31545809b13772c1f34817ba84e4d1efb04afe71ff7b60433ea0bfa40577f16f2fe0ac472be4c81e9f0109cecab0699b345951bcfbcd5453a7eb6642104afc5079f96012500592313d63766b7d0080fbab97df0df2b967a24738e5c95711762f8a8de28e98aceaae65a1140303eb65206e84acc1062a97ba2dfaf4f8d1cf2f6b8c66cd73c1b4eb2e95541c2158c98f63e012bee2fdaf99d0d6e217c691e31706b5cffcf594eea81a24bf80b5ea6a1326f6ccb844621ef9276fd1d619eb52d7afd4ea882470985dad68c5f889ff2ba2e98b0fd30cbac81ba172b443c3423d6b070d208f6862f461746845b277d5cdce5c1ee701700871cbd2b125d6ff5072d8147fcd6b59861ef700896cdd71fa1b6049f3a0caf99e8d0510cbbde6ec699564572bc56778595a849c74c02d9cb1948bb2b9d1b3182e42a3a2f3b3256d563f757ddf278d866ed59ad7b2d55d8d3305a221b0bdcdcc3b3011463387caee542e2a1622407e5d73629a286cb3c844253db84875f82d95292cf375d1221897fd8d50864b96b28c564144acc33e6cca4e3d2638d9a4c7e15698687ee5e823be8ea7b1ac437f57901be3fa69cc267b25b95cfd69838b4d43647156ce54bcc09f6ca57a23187861f5c4806f77494635634d6be0e55851bca529b130fdd94a8c702a41290e83186b19d78fbb004993b91946385fe5836148b870a8c774005fa9cdb6823b8681b3f49c217e77a9de05ac2911fee27c2044e4cd4ddcef947e229702406f0c06ae08d6145795c21c4b661c451de0b6d9514b8c44ee37e79f88e0bbfa54e42254430b119a06342823b1d29af11f2a320a3279c90199549586627e7af77f3a32b43d3adc6bd431ec718b2aa16472de8a3c86a497cf84570155b351db29111152c88cafb9a0cb0480211e73dc1fb1e8c1d035dce08be158ec616938779560ac4cdbaccee6d80c8a1bdd305edc9f5fffecd0eadcb2a16ab1274747d917dcdf01704938d216d7e4c0136d5d61ca19b4e8cf5cf4e0300919fbf9d946d574b1e512c72070fb841bdec0c7bfac0a437db808a3bb32b9aaee5deab26c8409ccbc22b2be4dd8aa2a8ac8124296bea70c74261103085dc11ed1d74e24cc59ee21009358142a6e8d28b4ec67d4ae45950ce8bd43342feed7d4468421b3b78f37961f6d819d663dbcc121f29d930a4eaffef8a0e5693b7e08957326a1d63c15bb81d0e2d97b429d860ba5e7f79e8f53198480979bb2a2db547c8bb3ad70af3c92c64f5372479edcf3633ed5c3c24a12af1464d6a8917ee8722fb3e4e59965ed385be361efb8660b5e434ed71db3fcceb047ebd70e6db81896b969c02b1bb3bffeb2ee6804d715fcfd75f0ca402a7a20df5571ee180be4b8160366be7c070521649314fdb312ffd5ee2bdada67a0099bd679df807b8ea331a51671b7acf8448b1ff46677c0993ab3e7c53a262ff8b943036d3de61f077c12ee1da22a8a36851f9e924b856a29f69ca239310ab6a0577463d2a88dbf343c0bec59e8fd90b10c1f6fbc1c02a1f30ef4843f613ae9ce45b24d9a1313f471d70218e955edc062367cdfc42bcbdf9bb52c1fa5c97ed2587b63bd78f9c79498385d174055f37603e9df9f47349a6527c93a605d9b0aeeb9b0edd2dd16ceb9135536c1cecf17c858695337d1775b3445a95b350b4a28ba38629b3460e749ac0b6638eab36cc433151d071084c16c78e88d53d5b37852eaee77ab484ec3231208550b4db35bfa7a526ed5e09d3209fbfc5a3c68845dd4b39e172641e3d5c423bc357e5020b9ce06ec662f76fdd8fccddc21dfff9e215c10cae0b2b2e76cdf613220e8ae35effd188ebd0655d9641a9e800afb5734d12bf7119ce73e4e959124a8d8b4b43203d2e31568255086e58cb1d66ab0cbdc15e1af5f584e363cdfaba2ea6d330bc5350aa2236ac44c53560175c5632f86f1c447d59bf177624c458115a2687fc88ba9595ffcc4f492ae8305b9304fa75d4cad5bc74eb246eed805ab1342e27112ff51a56a6f2c9f84a648d9b133fe9bdc1a5d545aaec1e586d74d2dc11b82d0f8b8145e9d8ddbb03698a913b8835ff5fe7183c313eeacf5330bf3ca27d1bfed6b663e49eea491a07c45c1e006046ea3adc3e217fb782ae69003a52f1fd79a9a1fd6ce987f3b8f6a5ed7f94a37a7e7856a79ae9ae67d420e9b2458bdea5c82e3a61c9cc4927a3f544a8e5a6bf358d806cd9dfb039e2f5ef0914d117b577f980b46da39247826cc98925364932b08fa910d60f699a5efb99c97c61ccd0121af5c371bb3e5b008219df88236aa338911a9fabac84d14dc813874868b233f32a88d148895f79bb895dd40d29c9d19ec995e813296e872d17fe825cad01f3569952b3aaf9736c5459895b730c8b813a591a76db186b3c3d11dc7b9047dec49cac5123c92776d03035fad6b7944621773f785d1395e688364c86cbaa4c475fb66fe95c91f563533e4613406fe9d9d43ab6f8e585ccef889b7dcc23651d30d392e65a9df18b2e97e30553d5f4fd5278c0aa53610043bfef2425c425513105fab09d6d7e8ace2b471e4bb1997e28f4eb5a7f1cf29768b8e2065c08e0868279ac967815584f5dc70afa6c7a5aa3a9fc765e9fff0879edd5c72c776542a8794c4fcac732bbc208b94f008970f25f9ac5cb56eedec2d8c34555e1cb94230d02a53933d35ce89b20a78841a83b58a7ff68ac3f25ce866cbec88b16d22e5ea14044976629fe53fb5857c6b705a1f8932bd6861f1e0b029fd4c59d2ebd11131cf2c57e3b330e7a54ca3dd675f130cffef93147917df2519428b88581e58d7147856575fd531882e7edce2acf9fc8042879588699b7e31982da8c2548b125dbcfcda651fbba8254e5edebc0bad1b48a6de8d40810ea265eaca1df923640f7a7b29174e876a366107c30e936e3f41e681614ed7ce59afa14d2f9cd08935d0b231f1098831ae3700041bb346188bb57c6fa4f6f9b759869e7e12477d885fe939a6116e932679ef7c291493a2e8a4db7fa409d4040c19adcc0d0b74d73d4a3d02e1c7aaaf2df97d670a0740583d96a8dbb8a44d6e1897b0ba3022619d020d5a3974aa3fd676d0ce68f069752b0938fea1d14ecc1baf093a9257341634d553ae04a564480e4c0ff70c7a3f9545416dd19febce49db95c914ebe65016254dcf354d7bd80aaf50ac7dd92e1cdbd7ae1a094511d75598b05a28b08bdc39e8ec1b033593a7d184b7ab96515779a1596b64b80ffee5017ccc79d913a0b8b5099d5fc2fc784928527bd34bb48ebdb6ad75e34af0d44a357136f6c2045c57d6607f5570a6e7f38fb6f033d5285054d5050aeea5a6198b370db9927f6fd117f4867a3954d8f9e2bde8bd969eee80451d42989eef7a31e7d3cf900c36577104fdcd38100195812218e4872c1ae3c95a27d226c6b787be8e9395dad6a5a58761bcef7b14aa1bf3cfd3ce4e1c786836dbc3b84082a48f40dd1107c37b4b41d1636faa4b3b745b6a5a8d99ee63e06736ed2f4753f129cdd4bcd89a58d62e7fad5b1ac29c4c60191c7ad29bcbef2f6ec7bde279de20b768804b17025a17d1e6b8d5f018ca98de8428d9e91b255d75cce7d7b6078daf259e6f552babbcf9e6b49ce78c0517616433c47657ad29c718a8fbbf2d2698e79c212ccb99fd334f4dcfa42dd87fe36571944b615670233817e7b18637e64e24b6b85a8e8f13dd37226ab253957a49bd9659ce507fa1b563d368e0d63ce46fe90c58bc34522293987fdc70782e771d91699e8311ff7d0df15d6dcd7551e9ea95a2efa38d43506a51d0afd1994c83d308f7ad43971ba82147323e2d73aaf4b1401f2deeb69f0d911a6d0ca335a4b2b052a352321540934e78fd7dbdc5e19789f2884881bebf46fbff4e5f0e5bbd567058c4a3ec2c0f30a6f9c966ac253fcb088b5cd605f82cd58620539e8d029f1dd27ac1542f56fbf7990ccc9bde15982ca11dafdf64a4f3bceb93aa6fe6911fc016956761e390b5c5819d21c8803682a0a110e51732fafece1b0cc1c3502ed6516ab93e327f8058f08dcbe00f364d244501a55d3d1d582a3a41f8a83fb337ad22267503c4abb71e1f114638adf6fb64e522484ae04ecabffdc6a4c21560c0155d9afe3bdb60d1148a207a9fecd6a4f26c0bc192387a56c46eef361c05251ef31ac191aab4c69f1d395a2ee456887c06e4ad455c6490db795886b6acf8448d33a448891ed11cbb92f53739dcfec3022201a7343a16cad47bd369dbd3ac144c3ad02795107f1e94fa5d8d9d92620b606f02180e441878beb718c93174ee5bc7aba992b6d59108d1ea5a5aa03f2887916209252903182ce00aa571413aaf66dbd0858866bf1ce4732570adaf3882ef0648bd71e4095474597b20e3d0f9e87bb7b7c231a3d1d866abdc65a4dd33aa99534f661d1fa928efd3266a44a773fc7519c22cdaaa50cbb7b527041ac6d1c290c1d4997972182383ae9482d35a86351887806fddc81eeb600e16cdbffa8d201d93ae4b5f7d000dba1dae11982dac5cf3eea93ffc0e28b0d6928ab09ec3c48ad66e09d23d1232d886dc587e7bb40bb39929d5df66e49c423a048a96b17fa95b0e13e530408bd37ce487ab823e9e87860fb9a3015946983f44f3b544706a0db6bf867d788fb76e7fa9f09758d8eef8ca6e47f114cca27a4e303c826af248563606cf7a7ebffdded9fa3d8bf190f4347191ab17ff83cb6baa75d156c20859fac23215b86789f936d06b38a66e1b668fd8a7d9966106d2f0511d42152e21521d13f2b98a322bd7e17d0cf3df628ce48811d1166050593818675b9c3d2978ad6dfaa6d0bfeaab2b942dafd014ad6425145290a5c55a33155a5ae52dc07acf32b7606068ffe60add51a38dee97c50e62a483a1c8270bb87ccc5ccd16913206aabc012c2594152e1e1cc2f00443d382add91ca571417017fe6ac54f8b8e0d2415a203ae8ae1ca3d5e3cf72a33d46f64fffe93ceccba66d1a3fd434357f4a4dbebb65f61d11a997062fe8110232d83d733b8afbd056a84b35dbab6ca0121fcceda37713bb8693e661dfc1ccfc5b7a333354d172e2aedcea26572c687a5497f5029c92143624a6ac8a88d5978d8d8b885e7d80b503309109738367f520b9abf4ee3375389c2ff2c8c0cc33813e46bba3b78d06e4db970bc2a1485d4f043c1baf7661e3e355b6f69df2a89e95ccfc64b8014bf86b3f202f0917d7566ec7b64b52e32c0de754f5041859f60135e883ba1346a188590f49bf381b20a86c0de04c5b0eb607a14905df7983743f47ba2fa738e4a82fe69b34ab19ba5f8190abf6431dc28cfb67f59d9d895a81a99555e5bf23365045e39aaa4545d5515c19e76e27273b523718aa8be9b5f3fd375e971b9491070937ca9bd20b8569f7f4af0af55146f0b8ba7acf0dc0346e637c3ca01f157abf7587987b93961e941039ed519e5d39f9d9735bf0caeae19fe91455229fe58009cabd02aa62d4186916a644ebc0efee6a6682524f31188fdab847386dc4caf5080acfde95cc3042defaf9eee614382cbf40ed2a9dfe7379afea075b7682548c0e5b13aa5eaca58f1eec5fb7f44e315bdc70b53021a29ca9f66d507f5f63504f7bb6098cf00d646552ba354a7d47c80b927832ba50ed9452137a3883e37ebd6df58a72cfd05c444696457d5fefb7b3f38be494798250016df6f2e2add153160bf41be2be9be44f8f6711a53efa37d8f8d3e5bec3c80d731f699c8ad0e408a9b73a0986bd81ca4e9cb5847e38912a4a9e1fc4be011c0d5f07e3efc37835f9d2dd8d7a75a1cb9e563f5e7e5fb6b8337a6418c91e18e38bab8f88cb56350f4b23f3883a44d7f20001dcace7a420f9dc65c97595f607ca70312a9089a279adc90ffde04f16ae34e5e3c7aaa64dd92c3e9513212aa3e5a1d5bc8bcd6a079cdd10b2925d0e11ca74e7729d5d8fd2918e9105b7852386163bcc5dc0ef9f34030110957a53550d8ab3415cbd37012af391e75684a752f6bc5c2cdfac2d56230556a87d6ef01673a9848619a3939a43cede83e76148f900e90ad10c03aef1a88a8512bf490c9e9559b9b50da7b87048c9c2263e6a099b574f6eb49febd15de19df5831027159fb9089f570e5b97297ead9f1cca2f4ff9ad89bedef1ea6a86a9dd52ea8265e34f7cf6c82aa065a06191e623833a7fd0a377b521286321e2fa2f7d42d981a314903860cf0b87bf00fcc6ca75b026476578501656a4f2e530530c01bdc1bc726b4fb11faadb2c5bd98e8dbb701ae76a7668327ef6f1c5ed1036a8318aaf806543a316e5d6a67c9040173d07683acbeeb72021b8da8502c3ecbb62668be6bc410691007d66839ec8cf962dd321871b5d5b6abc1389b9bd17584461d7fd1e4851389c64b72063aa9524df4422645ee9a84dbd313ea6317544c44b25d298ad395f3fefaa098c3b72210daf1e30e064557462b6cf8ab716976fe4e5bc30f1f9237450a9657693e67d9323e5829f8359040056fa5718b326a6320ea345b76a1ff28418a4a32f32b2efa7cd80b3ce3cda77454f7aa8349463063625cb3ef0421cf469e87f0301750e5c06bfad0fea21e55910b384bdbc566e123baa43aa8729d3b86e51c9ec137bbdbc9ab13ee88c8fb4cc3111ba7abf9870601bdd0c0f33ab8c7a1b74caaa40886a57733e9e4307a4a828193278e89be6368b91b2cb863c72ef1c58d907f851495461b024e106d0c7490a234e11f2f9e77a271fdc309df04e6ebeaa332cf5f8a90aff459ff4faf4ae529af18ccb26930b60365e29109da5ccfde07d2441adf102bc64f26aad48be65150d11338eedc95dba728af6274d2af30dc7784e346595aa20186f259eed88707095ec0ff8ea55b0907020792003e58722b7f736ff8e3ad698da724b94a43546a8d3a7912d0fc5f2f7f1b4d1dfcfc3c0a29737bd1223130c4f55b06d73477e916f00592e1cc44b249e0ac37efa8ee7a6499d31eafdec8aceb9730e3a37dae6e31daa37fda872625ac1de74623805def8939e0a5238642c78a67f4e5d7f3eabe473bd9f2f32ea6161503d52ef7a15bdb5e180d84dabfa3202d3e5a6c16990424dc941eb0b76f09978aa0ec46a625b4da10e4b27a55d487bb2cd6b06a66e194558fad44174f5e0605dde5e6b61d7f4433ef4840d193e6a728f1cf7c7c4ea0a766e12768572191d3dfe7921809f4e4cb25e8236d11b4a7e894f8cbd8c9b066fa42b0d2d715739df6b043e2a65afe36817cfa6ea11fbe1e489a3600e584a9d26ca9e0c0f7439d41918807cb06f7c8a7dcafcc5bd8016d3e4dcd937bbf5e662982492b24764f64dda537bdbb58cf7d66b56637db523eec1e1686e61cc7ccd1acc03f2a96d72b4c901c45b55d2b7bf366d91dc230cc2d424f8683ec43f09c245998023ca18a2ed3fe852c4fb0351f921b6e90e232369959320c2cf94d01471fdd853aac514e36db6d701f784e69477cb211fe1741056fa45bf762d5015a3b64629a281d1777f869181102ef0cf6fe17a3e5f17227f4fd0372917f428e0482bcccbbabbeca7d552fb1db30199f7519b4d0b524cd4cde3b745269fd7c21ec3bc87baf7ac6fd4adadd7f815091fcbcc2e5da1bc4fd42abe161becc4896b3386c867dd6da909c965a4099a6583eb71c2587bc87d53e16c914b9f949dd5deb5d83e094c359e1b5daee5dcc1b131b75d425a9dd3dffc3a4397eaeb2ffb89d8463388b43a681131fb94e1e038a428e408672c410fb07c2a84861874679836f39e57ad584e4fe9d7ac693958416a93d1be9ceb2b1d52bfc538d95f40b1b3c4833bfddd9285d17d9ac953689515e68c1b4d8aabf1a1492701f9c388b51c4fe76bef2d31457b68a6631d09d2665cd927551b4ee436c336217bef2a7d1065bc4f19ca1b66bcc6174118fe9a2bc7f66f42ca1c95eb03cdae2ecaff6793f5e40a2b6246baee980ce234df465957ce47db631525323a271442967f8220a0445ce0d0636a5eb14a2345b0f096ce8dc296d107a57e5a9bab39e89a21b39091607d58758b9e07c72f62b1e8c63b79dfd84b2699d3356ea81b17300d411c043a36391e188507d3903ac4441455946f1f83c4f509f6d7bce0de8750a142c0e5ca763324693adc753ce68b5366b0ef8d233d2c10c98fc53f9d3c6b3883d8631e0b2ab1a6f47ec3cd036f6cd002dc47a6245cacf0fecc036ef1201bbfe22a71f555fb095f528ca5094129efc334151bcd25c88528fd9b022d4837097c1849fe3feece35a188faca5085eaf53c5a66944b969e4bd6e3642a280db287f7be38e6a0747a07b9f03f4f22ef83aab6fa58d8fd3d75140b383db2b91d8ae299872c6862b8128674735c506add325d169cd11c221b33ba1d584c7cc22289c59fcfb517f652f32a268bb91cf3724b1636c6584c43b05c4dba5e206720167d7d2b12e6809c904e1b73e87a17d0aeab33dd20d804bc913f27921aed5953172a88884224bce4f054c50ad4d9e8746bb8d0dcc5b00494019be7d32f0c236f75fa7a334f09d7346f6e6dec6b8da71cd96f297d8a8075cce7c1fcd2ddd7116289b7d91b2cc2f5dcaf95af22608a6b6d322cf77908afa9376802611bfdb2e1fd659dd74727f64a4d501db4e65336c927851fff39a13a93dcf78d3a76ec81d44c54f57e1ccb7de656be513ba8e77855b2cac6f8d9db3ecdb193d24384884adfff4bae1695c16ac87f8b88406e43c33c29525d111cac9dea0289f2e60d57dd3ed84b7fa7853fcf563b6fbf8b1c7b7dbfe6b8e12c6f40a8d86668ef6c8ecd27879ad7eb2b89fe114e1104f043ff80db8fd75badf9e3a6ade2f1f456daee978b6ee0ccbdfd9df8f82f5d4bbf72c6358f4ee92d830feb0a81be5cbb019a0aabcb4931e4db6dcbb524502002d3e4e8f13a40a80af8c20ef9fdd245bb610c18b477b4c8d4205146636919d78c1f07b0f6e16ceb24f399b952ade646a42926788525f3557c063c6db1e160dce992f5b9c12696475da7cd522fecd11e98fc4e42fe030477fe975234328606cd13e8256e82618be061af99c9b8971ef21f2b60b76f12515ad0659b90ae6d9c7f794b40bd441d0473abf9e413e992c843768b5565f5a8fdee11e42fafeb0a3fd2738bf9676272206e47bfb3848fa2dced85d5c7cfe6594bc5e0753f9c91ce94d638d3045b7cd6fb704345237a7f006d1c01eb9d7538a4d1f34aef071d6567999bdfb2401f775e1160541823da53ebbe85873a4e50356ee3172bf766c25423be9f28b79bae407720d41ad22b750b7e53f6a18b25d1942e3d64bc2745df297ae9d776c34b36b32ec79c422ed37c9ec371f439926cdb21f5d551bbee5f4182b8607122749c22f17dec13599cfee2a396a6e17e983e932660b4fa25ae55bf7f806ac924f5413a8487aebfe710523862ed852fd3babca902e0e6c82111d98f8b8b824738cb63712b4e9d67a7b9fc3049090e6e5586d4b114fea0a56e5ec926d70cdee1f3f67a31ab78c5eaf5f99de27ba21b86f348b5d3ff393aabcab728268b6b3761e1cf948d5de5dc0fee37e5ff21c080d116a002b27ab48510accc5f2de431c2999be13d4951ad456e7c7faa6c68c7e8ec8509935f32dd7dcc731f2045c522e3c70e9f56f9131383117b0a174ce52d67f9a33c5ccdf5f43b7769de3280d413b513ad1da15c64eb6e77533777d6d8d5b3e7ba0bbde24129faacb6bccb38681a100d88eb4cfb688d2b19099065e1b6650f907f91bbe796db5686887fed39ef27b00e449f5e4550451aacc479b13e7f3dcd36e8be0737064ae09486d6b533dae169827e491b172d417d51376fa666309dab28c4168793b22ae398acb8d8e07095b7b047bea656928717b5e75d983872ef7fa799da7f9b0fe3c3a1626b19a18054d4de7f7551252c83aa59a282f9b8d77f083c32aa9440be559c25931e0ec7fbc8f2dfab2cf565a1ed8f0b72aeacb90a27d22543b0a9ffb341b174848e4a8e0b73cc63a1fec9b50aa07bee2f38a14a93b17d50df22e660b573a9261cfaa271783c0dd413c68c080b9846bbb09fd89cd88c484de67657c45744c76ccbcc4f85869070be9db8fb3abd0799c0331d5dad4bdaf6abd0725282a3e03d8b85531640a1f6117dd4b4adbb939ec89239ff7ba3b5ae74f6e23d8b127dd16838b137db9e2f95a157409000a0104d260c57355d2d5959c9bf07825312fa487cc3568b08f0c0872b6c6285bda19767c7ed067979c9a2878e12ee607c89dac9571740efaa41b38f8c737b2725fcf9d43940f3c8dd766c2b5c3c31b3cd8387cb1c157ea11351aec82e16c9087e47ae75d066a8ce3c81081085416261f13d1e51f5770758d9164450e5acf28b6e38a5764e4fc777f8a970fb6cf9531d162fa46397813ae5108598992a96049498aaf06bf945710ad131bb9fd11fe8f33400af1b19acb0be6ea1cde8804076bb550b1d847a179c9485ebc99c9e63a5e2009479aac11f82bfe384e51151e42d043c5fd9378e56fe4ec440adf618d3e4f07f2feab4f762ea572cde91ed63cc25af5dcf266845a27cfef0fbba7b4d6a4423de5832bad5eb693478334ab2b7cff6cdad796a986335e5b479f4c7ab759603b47f67e1e67dd0a094431a85154bc02291007e109c04c921b7ca5d5929e46c2ef71ca8f5ce31cb89eb6e47613787dfc6c1d6c513fb2b6c3b1f7fbce0985b36a1022e072510b4a7c874b57eafce97c0216c75b420df9b51562b579d89a7846f44db22b04916ea5947b608a9e22a629cc32a40652567f6d1b9347577abfe87cb63fb46c58cfd958d113082ed87cce6c485f7a2d5e1c40968d47d1419d2dddc0051cd132382b48eb7f2911cf7a3d15bfccacae07bd307aa4a694295dda4211582e2e69298ed7a3561db8cc98ee8f5c297237ff2d4eaae4a5ee49c3135a5567888fd03ff001217f76f151134786df1cb3afcdab733c9cf7e447efb58ece3c37a79f8d2250de817c2956f97c391a29678ce4f01f99a887b0acbf69b05bc127f6686898191016177fd4e6cdb23e5ab08af062ad85d272d83ccb35b1bc47883411b96ccf2ee47e8fa187a3d452182616e4e407dcaf59eab3278a88e1704e9c80a7c77fe8086722bb5bf841e653b1c94735a975bfd3717c7395fe218fdc7de25f1cc025d65892aacd98ae1128a87fbd75c758d4e44f418990b72f47421f5f83656d059d271e78455aec6f2e042aaddf7c5320acc59e388c756aa7c7d6159bf4914366b174150f1e93c8791bf764a6a3ec927b6e3973b8494aba4422f119a7418cda718c9e8f34029a1d3a0bd3fc2ff5f26699dd15ddbc988266794e072770ba1c99026268fc111f3581e32482598e53134937ff6d9e612a001a4a97780dab05af2ad9100cfe0b1efebfc826af71b9a73929085bbdc1a7a4e661903b46606f305dfea025c3c93e418eb55150d6645007bd6bb7fa652c2ee3feb0acce63150700d365f342b87879e5a71557ade824f005e4593b71452f01cb68f7f60edac7cfd8343609d36368c85d8356b0ac2a5d5bb8143925f214ca7f0fd79a4fde86cceefb59a834b9b79ba65d582a7da4b9d644234d5d2be7215fd7bb8f6fe1b15584982c5cf89ee12ac6ed5074b72a370df5f57e5394e10296167c1d1cbd1e8afe09743b56de790f8607067631f3fddba890194c23c1cab57f33eaa073ea91f4db692dfe8b02b838252e13c10ff60b18db535f44cc373964ecf4ddad27c86ebfd9992b7e52c9675f96b32338992f8a61c7062b04af4cef8cc524ea96c0cd439ea336f35b07ae010cc3d88b9cc6cfd399845b14ba04ced0eb667c5d07684f923d9b9ce4a75ca3419992cee7cf583b1df89b2e8f534682622306c2eaff0231abe85f847be222c0ba48cd29ca42339ea7426bb77f015badcf19ebcb7fabb49e12ac133f7a8c35eec8dd4625c8a8b1601417b5f87c828feb5305323a26cb17888c0604a2e26bc22d04e8ac3c329c5007b4b978567dcee36b1d9b429e350dbe2e1a7faadd90b1721e0dbfc9d248f8ea0f474533c515df060f8022cf1b3cf662b7ac4d6e61bd08c465325750b0bcfc69c4630d86d2c9c4d5818219812158cd32f2cb427f62bb0059566ea878af42afbd55fdf54d584cab1eee395f16369980dc78a1f7ea6177c933e9c453d01e80cda013337f8c527609ae0e93a11d98f41515446ebbfe522fb43d62f64d04524cd4af95a833f673b5cecebed6d5270282db948e4e93a8e642f1bb6b57677ce0509da80c0ea093908bd436653f2d93b2cf1ffca0a477d32758a4a627d9f50a77fe711fb46e553f56854a0dd2381043dc7ecc739d9a78a430c030088e425a621b0e67cef478239d4f596cfc18dffd4373886e114ab95725932a88937b5649b0845928c4b5b458193b0ee69b73c23ed46c647798a97b18095522cc7e5a1908bd8d734a146c3b43fdc2e67f9a070030852853e682197256430384a1838fbd71fa7f9da707417b9a05dd0a6ef8200b9334a18761cbcfaa12f4d5c958a5d3b10164b8d74c870ae640922857438e13bd6acc9db1565f1238a1ec1fc4b0f02a126ddf1a60dfe8491aa7a10bf688a28dbab4a814c28d36f22ce27ae64d9623a522289efe184a13107f06a4a192a34139ed97570cad1cca3f3bea536e744c3ac96f7524b6e4150e80542732beebd4c7eb957d9b8b37ef11a716547fb215b9d6a9d870a645d9fc6bead9832d3edc94db19fb58acfa94abae4036d63ed6afcc47692a39263d9d3001b60bff09d9e8033c445efd37c2d61315b54dc0f01044b50f6d58a3aa1ab7b26f9661c974ff325ae5c2cb7d257cb1432cd6ac42a16d53fa82a8305b8e67fdf20267e61e546073a06744a9d8df0be8ef57a99af1ed9b97553bf925a51da8e943c5a91ee5b8f2b8e2f14b5c9dc12061fe9a103117dff29077ee6eda12946d76d7f17a2e7c50f2c40cbc7d06d3620c1b7075f39caea5d3067a937f795f6e23018a7954e36a481627fe6e99774f3bec848ae0889638b7daf7ba8a1cbede42ffeacad40c89ae25456a7458aa6a1a6f6bf50c8aa10ecb760e0719fc3379a837602c5d3fff7e110986775fbd735eb99fc8b20b2c516f79e64113ad8bf5de455445c3ca9bbf3784378b2e82dfaad7902829268d90ce3c25d3ba9ca6b267738491d1b1379a611833330a2c4063118b3be39261cb3f82fd15d2463769f2fc6ca182baf12ed80c0e351ef7b6e0896a8034063a09965e76e511fd89c91cf6241758b83dbb87db4e40cb7542f6652b7c5de62a80c16874e02ab5f01680adc98a7a97ec2e35ee125cb51ccd82cc94c4cce4e0af100940f494bc3e18f95eb6cb9e5326f7e9d734bfdb3c37eda1e6500a7fbbd0d570ada42eb8e767d9fa7239fa47644f8031b2f7c029e53c9f193101450fe2fd4cd99c3e5e19cdec1e622194f865fb8d906c5abbb6f86e259b02c34501150dde28e2b76bce19c331ce4dbe06a6dcfe4ca0c65137121f5b96c81e1704a3bbcbc653ace9261252df9fe6bdc76680dfb2b35b5cfbec9a37baca2aef61b50ef6786008350cb3755ff2cd98cdb0d4ec169c85389df7fa69fb5a2a2281f6ee1de2ee0ccbec9a9f6568a0d464aee20e93673f66fa8897a13a78720da2e396a1ef8c867e3e4643a326e6ba7ec83d1ec7867ab6e8873a497e2cd8a1fdb1042222d208338ad9683f28c7668502c64498748d1ffb588c1d66f20df8860bde1f88a5b2466bf3a14c8bf462d5efcc78d4a7bfbc2eca48d53f4af7bcab6e854ed2e32b25ee69a6d4a6980c067b9a3ae57a3892a9b1c42bc7171364fa1d5200d66a4e4e218221af553bc89299d8081d5e5a006aad1c1f41fcbe13b444d2a18c85ef39e0ac69144e228690e967430c813879b48a08794db84b51f22c75296615796d0246a23ae326cdeff49eac234693c3203417352a53d2ca681a615291692cf7fe6749bbc7d68e20abd22d497ddef7d5200140705bd19ca1655a970f0aee124966d65cc5adc5417915cfdeb9e77c68be774e0f71032af8700ab48133b0265c3880f29a34e6cbdae7713f208a23e7aab45135eb0d4c159488f7f5a7062c4849a93a9dfe24eb79286ef63269e50d411c30139cc054e19b1acbf428d6e7c5388bbf7be0acead23cbac248dd0ae3219519b8831f3248041bd4ca6a9fdacc68f05eb1d04e73687c68f926da6f8fabde19a44c4df70a4535d13cd181a656bc21ef0e85fda6edca10634ba9608ab4bff7edc87b4983b10295d73f3875cf433b6913ed9d9759abf57d80fe1f78f580e0c82e28e14f92820777ce0b347c16adbd9c4839d5de9619c0f2271aa9e0012b5876cc32b4148c93fbdedd86e78d95486e88c7788cad3c4fb8862dcf7267a357c9a45af054f401effed89bb6ac53cce37eecb1900c1e047bb6f16c7ae05972eba4f6f1ec4390a5935f5700c8d7fbf8528a6218dc5a682dcf08878ce91d606771d81640a7f0e02cb2335ae61da8ae86c51eecc677ef05d6b633d6f66b16a213cda9efbda3d9f2eaa1dfabcdcd2069127ebb2b570e1d293fcabcda6fe60736e0610e5fcd2efb35ac58aa94a071f1a58dd82d3497d6dd8ae3e92a8277ed7425f523cbab0e969294a52afa1f6eaa232ca8eecd6c83b779f474636b5943bdc2ab4ac17a8e962a1871e6e3917f5b60dd8971b5374ae7a574d5442","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
