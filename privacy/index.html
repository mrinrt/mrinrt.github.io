<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e9c63e59d51004e3046a957d8cdedf39b35faec2cca96891128258ba05ba3429e3b8a511a42bcf0c357a98426c7eaff0d5a81bbd338a8c35b82b917afca113fbe62566385e745d93bc0073a0fb9b3f38e390bd0a88372b14c81fb17c3d26f054f0c6fa02f846257a1a411c9e7c9b555a5f73d51f2e763251dd577a41d255526c41f952c64540543435166b530102d577bab03a708e79ea310c4014ea9d5372258b00c28b3ce47bf15ce0194ba832fc9873b06eda9e71fdf2399435e2dba93b881f684c7c83287be1a55ecc5191bac186186434991ed1c5869039055187fde617f15d0c3313a01f0030f0add496d6e9e704591e9c9e9062a95471d99369fc738c1ce3bd013c5a40ae69f7709fde64978e951a5502d7cced5c1c22efea082c1e904187a7123ce86bf4d2be1858d211c2e6317e328414ce19c05e65a1005542daf58d10ac01f713317db095827ce2657769cb4d9894fb0293b342c0adcdb1239f51bc6951f0261510ac5c358baffea14980d9fb5774bfdd9594201e746fe538020a6b6eff707f1fa9546a661c72948b66ad120931dbd5f8a24e8a8b442179cc58fcfd6b188aa90c6b6703a47a3ad1dbcdf9bfedc09eb798f88bc15093e9c70637ee6906334c14bff4e7d5417666bd0db1ca5ca19c9c7f22e026ffa96c1fbf60e17054561010bb01c48c1afe7339b1587eff19815876795a57b5b7263c451df0557d9aa36f6fc09815f25899418c41277feec1c36ecda82cc4bc28b6b0f3bfad44a918d516a46b9d50654c120f50aa3b068ca2cfe2e39d27a2ed79cf5a1fb9b8ec2ce4ac2635f4dd586ce3171ebee71a094804aa270e8180ab02d1ab7dca67e05acfb8c3513c9642624d9e4ba68f584204b54fa2f388924c64d47e4c8e3922c5be45dc5b3774f005e50663025704c3c051a7081ed2d78a0d43862732897a1b5fcfd9ef6bb3a32653cdd18f9ce39f27126337b5547178d55ada77f870fe696915c93cd184050743dc0c5ec8680788a5898a1f895407301904bc978f43cb479b7615db1fe686918769b0aac89b5aa8330518b0a026da16dc80cae550c8204d85981c29aa9d1c2018f7327cd400bfc4b6a559a0d5052f2cb81a04cac45ccffe59bf40667560d7b0f1eebf152a6b31bb27c251cb63aa6c3d8b7be2b2536e54d2e3616a697a557a3a7a1a9c1195c4d94a897d6c915436dde9b35eb15d62aeb35816bf9986079360d098027c28ba2b34cc3fd0b1a5f5e84cdd2cb351060a092b58039e6acf2d6b88c4b24a91f0b022803ea41bdfbc523bec8f95366048a2922da3fa4556ad1b349816f7f620380dcef43b1e6a9f1ff317122f63ff38cd4e1831f358c49414cb7c376cdbd125eddbd40e286c0adf60f25fe9601630b56b0a1737e169b912e4e527cfaac093919e3ff1f06fe11ccd43105db72af1caee672df6756d0fb642f1e80b3878e6ef060aa87933593341d0252c68b0d1787754cc69ba605f6d6cee2b9030cdfa01638e51537a265fc4f84d837d59a31c4a4a59a553dafafef3b10fdee4af17f91c2d559b78842eaa812ab7fa8d26072a0f8122b6a297f09a34f105cf366c031248a3354f0b1ea20a0e85741bf208c7b26f066c3ed2735c2dd52abeffe3a46b579d8906d5ade11331043de726dfe15d798e2dbde43c2e659caae8979dc0f73b57bacd6be6b7a3d524953042f01f7df6fcc9eb4676689e11a4362d5cf437423092705dd732f9edaef185531cf0f2e8e6019f8f970c4dd2317aee39dbf30289f6aa46a3160b52f3c7c2907840c84a3720a64913db9f62c13e068832235418d33d1b7350c11c9fbd1b566d8ccbd983a299fd81e961e58a9a4777315fea9dd1c6dcaddd50fc58018f7c4378d118cec7f81e4fd3349b80a108ad1aadf6158bf737796751cb8438e5164f5c6ea6d34d4dd8679b205cf9a1a29ba7c83fd79f3a114eff8cb688fdf8d8d157e7c07277f1e4d54bcafdc9dba2f4ac00c234376c59ac27cb70137cceec1a86f5bd7750f11f035b23de5a2322c047711746724ce1939d754421b91838ff3b1fdc6ffb4b953c423ac0052fea0f59e537ada080038526b6a721793633871f50040f124c1ba0436c583a219f10e4473f8aa9b0625cad9c19f8ab177ae02bf33cb79d78ad4127117fddb787b2753bc180474c014541411bd36166dea267a24062d3901f1c89f36a08d43ab78e237caf19514539f0ea0724c80c4b7a5dbb8f1487b1b6aeb800ae35cbacf5a9ba18abd5b912665d1385faa2928e43f32dbbeb9943db415cf02165439d9f277610bca085a08038ea7aed9c6fda6ee84d3772646a6bbe8e4afb7dbde67531fe82565a061350e9d7c9bc5b5a3cb3210e4775f9ab6ffd80d8c96cb55131788a52d5248cf4f26f7d2adbe9f89b66495722514197e9f882c574dc90c86cbcfefdefdad0171aaf2ea83065984297878a87a4b0298cb302b35b25ffc63790c2aa7ba533e3cdf4f83a8934a2ac9432ecc09d662d930b8bdae04e21644368a2bc477b63162d981e81a48883afb29175f6eba587a6f9e52a229eb2e10097363d2eeb35cf5a4bbee26ecef39a147bd105de60d3fa042bf3228eac076d4801d73b6ab2d46c518e5eabff2e25e0d49f39663905d7556261e3677f803687d35016e6df15521cd1f825ea9c5651a180f06b4d22a1ab5856e0c415779e504e6f7f9a57178ab49fe2c84222799f619d245a677832883aa7ff6e0b83a90969a80f51aaee08ffe2d49fe7ed8fb3e670cfc1eefc9f65feee148d7c4511a0a92595fbb5342c3b217f6f255cc6d822660bef5d78ee8dc2910b5eba9a3714249c3b091e10e9b29ba8c5bfb9c2ac60b7fd994bb7dc61dde83ddf96e89754dd1f4b73ce3256ff78f8e6838ec66d693370a4f8cc2763726f2866501b18f783902e02a3f36fb247a5fc0a747bfbabc2fc816c7bbd098b992448f95f9def9da16a7b755cf077db8d711f10e2e8c4ccf3e41ae1e9da627f40268761f4f6391a8c7e2a688aa6f58444c3e0b0f3266d73e28fb0118588398c39ebb5e44ad555b17f8af3104711a8718e414b113fe451d512a17b8b6fa1c5bde993d02ab89c7cb0872bbcf6b53bf1900dc4425e225fadb03bba6f8f40c85c7fd4675ce88fe644506f420f6f0fccb9443a09d7d6cc0feeaa91ff12e16edc5e0f966c575fe8d7dc68a11c533900e0be2e4b3cbc0576a2535493fcb9e655df190d24e3956445b79567947c708a7e7ff921b8708ce7bc5d5d5a1cc1c8599ad9a2449768ee6bd24d9e3713d17b408cf744c43de9d27b45a29e9b3a19270143a706cbe0d8a1a6fcfab71eaf06c2d50cfff86fe8a578eacb8fba5025cfc0167407a5e432750e50313bd38901ed9401eaf9766769c461ce2be9fa6ae956b69846258d1c6aa0daf0d619ca83c79dafb2bc37a114f29f3c77ca5f589fc053c3123fbf7a64dfc08ae3a6f707d374d2ec438b536de988af5f195c925984cd47925bef5e469bfe4620827e8f9ee41ee14b001996fc58d18301b95313bfb6f48d8d2f4b7fd98805a835141de9fad29081f3b61c28c30c6e7a2b2d25f8dbdbab6ada78fac36f9ff1275cdae44699fac02dece967ff9c4f5d218881dc0afcce273cbf73e0ea4bdff94d722f001df8e1a343e82ac795f2c896196f83fd0204481f4d6728de868860d64b4585f842a94323cb2ced2441c3d0523f6bc95e88a1ad23a2ebc9ddc8722d9b3bfda5c2b3d3ed3773ef276f72e400a9c2d826dbd7d3fe6947395739f0bd9037040ac34658890b4d034fb07c5c2c31b40c81f0a19608ff76f251a6c54c0bca57fe850cdcceb2c6fc926e8dfa769f8c7d8ecab11594e2267eefb84090e99d5b9a7f007da4893635946fd5ad2e656d2b9aa8f27dc43eb9ce5e7de3a7b8ecda26eb9d66663441ecd3f4f6aa42eb6ca912f4f85de370076264f197ac0bcbdb6e34364b35c385afb44da6f24b95e1892e2173c434caf3a372987fc0a2cb4074404e82570532428e41337ce42ebb319d13f0ead203fe5f13ffee4b59f803a3311c3661d3eed1edc8fcf0310a37ec97164825606eecb9d425554945015827235ed57abc4c3607452285d8497e7bc7b02ce4ae796d04ae8c9d9331d48b224d884de9b9e4faa0e7a95f91c432a73862485b39ffef105a76141fe5705c4ad0c6fb801faef8c06290659c920515393265bc7a65983fa2b238531c090527c5656a5e2bd4533b500a9895123e8e0aceb3d5f953cd91380de326d6df1cdac0aff7c8dc241e7233243f3e284a92acf860f385f18bcdb574b26833157418f74a7c49c808fb3a4436b5e9157cb563284ce9cc542e380d860e05ab2f6b05634d082f3b04ea324472faf5d87ebb4f25110400f68fa36481ce46dd437e25687f9d905891da2c24904b99564c4d2424047915dc75ced7b8ca1cc9a41eee92f8246aa65151ef93b0bfe18ca777984f58e15d2421b89ccad1c471ae7481907df51beb96cf909c940aa9ae3434e180eaaa8a5905ef937713b53fa36e534c633d935284504ebaeb89807dc3a6edfa1e87e705a79f3fb0dcf94785c190f128f2d948ac6152a6eb73856d93f42bfa76d50f95f6c23042b2482016605e66068fd15c7b0c30d675477fedb26551ef6b29d2fd3567cb54f1e2a22f661cd5728ef3718c35ccf85df0b0a6b0786c10382d21d88110c46893d107cc1efd4cd43215c1acee0af5450fe48bf6583fd1877d16d7f1715a81968e31d283e77838838c5a9de5b732e29f9afd11dc9941d91a147d9d40d67f3fd069f8d60841333cfec7d9457fdd5aa0fef36b759a20b32f4b7de9397f612da365d7984d703788c5f5d964cc3ddbd0b3fbea00c6ce57f16b4c19edfd10d7f0161d14c8fcfae707aa3871e45c2f676a97fd873e7b71c2f88849b9b03927cf9a2876592ea709b4ffef72ab17f8cbb53cc7b6b58e8a4e35abc03b694229dcaed3304c45dba71a3f2007d0f8ef1d9c14e8cdef954efeaf27941eee610de30f475f87cab6ceeb628bf7f84d8d74906f06265239765e41ed110b7c651ae61444fbdbef7c6d66cb07d82e310983f2507a6bf54e2629968f7570515ef5e7b5cc55b2743ce08ce9c072c8d1162c4d6705c47d046f46d1e6fdf1d37f4fff1159f467b6df134330854c8ca4a2148a220e9b50480b75c8290c8d0ed37a817bcd43bc26aaf32b80ef934e9226778724586e45c2a4c371fcd49c822c35d0b158b1730dda4a59d13b9692a34c9164fab7920ca6c5cf29643221bdfb078a6e9b3e9838dff22130d0fc3e46486dc5d8fa100e1ce6f56f5cef20646d3630a0f28348dd7065b90b63f4697b15f1c9617256fd2db36f701ed18d6830d480bceacba10ec1d6e4f5a940fd8341276a8bb15dec27e51789a9a2b335dd37891d0afe54b9c888025367bdf20f99393622f56b0cdbc0ca83c7be9f0f1bd1d12fcbe5c4be3862f35bfd2fb81360f7209718e35aed85188974340235962cca83152ae319d529c61258f5122b234692a3f3cd178a98dec59f9d9f94a4997a3d19461f850a3ecdcaa8f842c516159296fc7d7e5cd80d3755d5d46a1e37085fc068390f6a36b7c3b519a7c95d1c4e2289cc1f2622cc051314479354bd7b1841cda8336fd9c874873ed4139af2c9a5e475b7da6552e8094c9a626105cd0bf0c08ce9d7b9e0f3a61ecdef7f503204ba6354f02a2d7359a97ece2f9fae3d93bcc70e14a58e3c75d38a15fbee7026b30dc7dd45e38ac8c71f7d839f8f3b4ee3f1276bea994914c12c23c5158371f12f730d6d9eefefad5f7a19d62d8d14ac0d490fffd2f90652026b9fd5240a144ef3d50ef0511cbd3b2939c31bca09fe637070cd3719128a7a2d3de509476803c605dd19ba2b93683e7c72e9296b246b9f1fc3ed0daa10d1fbcc00ec67026e88404b0884f19fd193bddd238ad219c6688d920117321788d466b9579f053b11fa6b121d9c96f0839a647b8388773e8a101a42c60f3633475276b941e6d91bd38d5d90e8cedb6ad5f45ffb1bdcf6d3982f0768ca2c81aa9bc768729657554e20541825eaa73b916c8e7b14a3d00032447c3e917691e0536e53977761709793f39c4e43f1a2fe8b5bbe00c49d713056c947c673b80659cbc808c9ab0a62d666c599affd8f01a78e8ba08e91eedde932eb2b2ae34212636279c5c81bc99386c3b5ec7bbec9a77f5b6a00400ad28b1e19064883389b9bfcf1c1526c8ef1984f77d124168ae44a23fc7df59a2dbfb1da020e293c330fb10a86f1da0803ebcb86865cf5ca6091050bec533ad0992ddf521914fac8d296736edaf0c3f21a5c0f14dae2f859b5c26fb99aac7955d676bf9f0211a8d77ae22fb798026fac9c46f9c17ba6327885f0d5cb6e62e6bb76ed60b4edbbfdd93b5103b498b71023260cd313a41b46bac4e367d308c01a05e9971ed4fa42929cce377a29ae1b2c8f7177a62473fe9cf401cc6956a84f05497ef314fa0ce9e51207f8fd21cf1d65a4e7410a062477a47b545a647797554d9619bfed08ce964b45b1346a91529ab917bfc1460daa76b26686d867547a593c95875cb864f0679033d9de7cf4d403694ea45b2557e92393af9b918f2a80a08e5dcccf963b9da1bb5e0c90bd2f245d1f788f26681943f6221f0254a31423e65d3de25e7f61faf72a0592caa225943f9e00e340cb42ac758e6e9d993d8fc45e1c6bb15f4ba31af67984bbeab052725eaa15c77a38938ae6188cd9ef0dfe770b87c0641ed9923bf1a20e8e3d62f04e35749774ca1af2b55e3b383b4234a61c1a02c9bbc47b379b225a9053b82cfcf5fce129ffea7d700d58509cf8d62d0ad21cdcfcf95e2ec875f9a8b317e79b1bf6d32e4bc6410943a387a71f676104979e8ce41dc88ab28a29df4e5ab59e071e29fe20a99cec3767bda525ecbb45f4aecaab539ea22122e63cb718fcff2af4122f39bd3ffc96bc103e56420fb8967bd99aaa673d8f4e73a6d77f643ed6846480c4d76df300ec5e9d27f0ab542e5a66dce74a94872ebbb3a82e99c01439a97408dea1e2970fcb8c727814e9b0615fac5affe720b8c664cacbe97388cb5572dd6fbe97dbe0646b293bdc058a6c5a8f3aefada02f4ae66d66f59fa0164d7fb4e4da81c4458b919b1a480c5d055dc1e81ba3a01cc1c780455c5ae2ce7b2dad8fb4679b3383937d2d9897d8b48089b07c7fdd23b84c0397133eea30a6ce432d9f603f028819a9330f7acb107f537a135c2754f3aaf4eac4926be62402d8f58e7275e87743a03ea7a2b5eb3ec0407ca1e210e6665cae3912021490b2a2d9b9fc415c806128505a357667e9179f8b023587eab63d57f773d36d62d207a94a1963fc3ae867f40c4028c9e0c238b00a463163bd39eccfe8fb6d92c2c9fc328de320618724ed653052239345f06eb55920ee137deba0e0fe472dc841630633bc6260450b97122e33b6b7d3d2cd8a7bb39ea50436ee88afbbc4efe3a7c2b36466a8e4b1ffc6cf1be2d363de1471ae219ecceb7be88e8944a016a294163697fc0726c4bf79a4f77c61370098e14d9e1f409a6f3039283c22abe0ddca96b41e91fb547dabf0dca6b5beb3f325fcb8476e832bac236d0c38f0639341c7b6a1706bffc1a11f5a6686f303c2bf1a94e9abf815c5905ad85997e070661ba6cf5301b794116837c5dc21814cfb7f6fbd719d29cf5ca9c5b74975a5dacbee5753ee5443aa5865e4cc9164a1197700f7c5d186aebe51e7d65aaa1c77a9f52fc310ab2a8ad6ea73da316578a6f2281a5fea7223ee02ba246fb24ec8475cc91135fec387c773e4cd880d02552b46edc247ab2ac0ab43733d66eb7227640025afbdac8f411498256e184d95718cfd7977eff629c8604f5bb90d4e702b87a9ecd85777fa8b7e2e8532a2928bb936e337e0bfaa29ee11d4ba22e6dbb1801e26cea2a71a3548f35b60a5e75d707e6460cfd8e6229a118e2d90b0c4cd90f095ec6c041f25d9f34bfc757d9083a5a87ef9e0a4456b4b337d85003ca2a46d042c0610305b4474cf2470da7fa9092b013bb67a10cb4801621566cd611933d62aaa6585a5b626f34b7cdbec1485d7e0f11831928e1fcb8fdf28db71f677df6d17921e3ad862819c33ed29dfdb8b352d9573824ae106c7097a7fb6e20eda510d0216bdde6c925b898d5fcd15f758b1234fa1e17143c6c38f21c362a62d8e9e1e3ed24cae107e5fc0830c512f3e0986ba5c56a7542150b2fdd6cbf6d514aebd347becb3675b4ccb80fae8c0875aaab68afab49e90986bf8e17bfb0267f156aa056a0265edb34266c3fdba5c7dd829dad55b69340d486eeddf5c4d8d485843da7093e35fb9aa70e08ca75e01a271c3dc93ddd48224796f0f10252e64dd940f91118046ceafe9582721622ac3c77f402537fbf08a090c37e654fa3c0e84f4db326b698d5c3765e836251ee994d821efe0a639b535c65182d25b68394a184a274a5cf30c0c84cb909a68ae9f7f7e4e9c27094c90c168cdfa9ca624ad3f44523d124f76f21245de26cef2879522efd2537ed911b62e80caa82ffcba1c3ac7cd93b619a0d6d11f1032a4452b1a5406bc4790fd289f56f9ae09fdf883ffeddd7834ce456b60fd038f0b1e066b47b0476ffd03d6bbdfccf49b8e5d86d55a44c174aec446c966428563f34c478f9e06e384fa545c7356bd2427cdde48182baac8f626c9c42fb3e9ddec92d1c9e5ef6029348cbc595d93e70601448a86b7e2dbaf896234a9ec4b56ecb7697ec1880d3104e641288df1fae1648a7b6b756a2a2eef813c601c35c97465c3ac546fa81c59ed586ad54baec6d13cbf0258a1543861a9f12c18f4b330753cc03d3edea5462bdbd4308d40b55aa50844efba0608d2794f014fb1fbd9bb4a4651b1dbccc71f3d4b62398d2bbb20d29685fbe2af45bae4c4708bcc2e9752901c1ff68264fcf92481eb6f812f99bc1e60b5bd100fd5da99a21a31adeb67156186ae45a8598f5b8dcaeb1a0bd612a5a87e1a1b2009ec9ae4c8446b63dc4c2f80ea1ce3effcb0db54f38267b026a605fa6253728e0f48cb567612bf544d3fdf8f58d182cf0e3cd830baa6828824a8dd8be678f42864893e96419df97a1e2bfd7c8c3afb239859a657c22c946087cfc764b944a1b062a2f25583b3e8f6bf8d397c21d6714ff381904fb72077e81897f388058ac38825ac8b1cac1840fef18772ca4026ff7354044a4c5542d29a1b7aba258e1ec477574a01c32b3d5cb7e6fc4da9078bae0de52b0eba905e697fb2a2f74147ea73a5b94b73f2e0235cc777929a9f573b56d75b3249d136ce9995eb409324aae5a18bcc797e94221fdd4b38b6797e91c094aeeb2f8495b296d7502d4645602eac2c83240e11842394257135444f36ebbb4a6469d078f21256728eadbcbeb3220e473e6d14db3277d25e7a3673c0b78047d7dc2a2efa04f7a1a2f666c96bba7bd680ca96366676c51579ec570846a0f7b71b922419076b9c023c118748589cd868dbd2141d5d298eff191cc8d289fde6c35b3b33d7ff2922eaf753a3ef8ce1bc14d80d8add5569a456399ffb4843704aa0c950b1fd85bef2223ebbc503809e96e6fc0fbe71db205de7336f94e4833beccc5e8e605f19e1f5dd7d38638f2dd5e30cdd07c5da13c3dd71c23eac4449cc5191a97eae60f24de4c5afc8e53453e164d729da261785b48c2268d487c5df8e978da682326c26a530923f37e13fd2f4a54a7625b82bcdca6e049764c0cf7a2f0f641c5f2938d2a8f3324f656a106494dd64afd68c173b696288cc883732a1d740b9ce95700158b93964c05f9ad7f97066ca001f5eb02354f58788bb74b88352df1426cde3c7901f50fe2047076c9a1878a51d67583eb4b68b0816c87d86c53ca00322bb4d581d78223e2264a81ea9762929dff4b0643de10ba095d3749786e98e122d3ad5058153d964276c7838c4e7d6bd9003474ba207a53c23450e2760f57e9e237b0a5dcb55a56555bcca00f9c6d74650d243cb3197d53c44c36dbd83ba5edcddb47020975efa96bd0ca251ba7092d56b51bd3dd3321eed041a9b483813e1d80db48516992edbf87eedb6260b38c4c38980cabe71e244c3a3065561c7dcb8520b53f119ffa7bca521ba0d7894066a3b82fbd7237975763faaaf17c6098392587ba8f5469ad22414c6fe8da89423227ed3a393c4a2041820029e05d9c2ce5b84b36fada4261af7f18f1b7cac95410fb6f2ab205c4af55c86e23e8003fd7531d40175b99bab35909524594dae11c0eb2339d3011760a6cb8547247dc4daffa037891e94e8d8170bcd767c121bd68b7add8243edeafbe9849368a0ec23a5a38d21f49db282a9a9ef86b633e6bdb61b686698f49d1ff8b2d547ec59fefd9892515068c204a91748051b3e0dd32a01ef1ff4269a517b4440178248471766178c77cd6617760645cb74948be44d8c4cac1c4949247a29074ea8da7cefcad2371956143234ea169cb16906acdf784cd4a651ba5a764ab4bafb1cdfed54197be2fe38e63e019b4692191c59dd51ed6eb918ad4a55b4f491137060eb7eb2e2600d695f988d267bd495e4c29d79e0152bdc8fc475ab0dd70c0372d827bef500d99ef816304bad821af1da24124719f2b06ec9f1d4298b93b84e63f40fec1a4e42682d5baec63c4de1808a6c26b9976e995dfd1c52303ad351d5154b5adea434171b3f322ea79bcc79fb9ac85f3b5b1878e0e0f14debad8b0ce4c3bda2935a3d42c9a08631bfa75d02e2bd904084da26aadb660237bda072e9decc396b440a46c4320b342a9166d5a98124fa424a9bcb5da01b9af832a3343685fc1d1124eb9cb8e1c4d1e4b744249ade2f5c3b8cd98d908413707f621001b531fdc4f7f6532bb3f76c26f648ed96f7fc51b0d7bd1506a2fce3708f5cdb7846905c21b136ee1ce93058dc21202a5a6a4665465f7695ec91717b4659e7a74b070aa5706876a6a690cbe99b1c61ae358117d21a34c6e4a584aef37b2bcdd23ce8ec3c615619809eda30a1302de39a944c1027f1974540463d422e2916287d6b2dff8954294f97b467ffef8ae37df185afd9aebf351e5e713d9e525fcee25941f753f0d741def58518f908ccfb785f888272e84b423d6f8b5c843d2920422297896ab675d46f3a775eed7e21471fa154a3276cd58542df08415b81d60a8feb97ddcd53ab167ec15fb216a16d54c92e851fbaba8851a5a8166dc4fa81b0e1faec7a4b0746dceee13477dbe77703c990ce95645e3bef2dc89ca8bf21ea0586f70c6da4c180ae91f4b321057deecf1e08cc91b1f7c55f2f4feeea01baa468dd105bed84d6652416ae373f98a580ead5d23f2abe955a845ba68e4a3f22aaf7091e365edb327c90f6b7db4566884fc57fc6652f6134be0f2059229d2a5585c79a864525d44ae96fd5f7233318de8ff08a76b0f89f48819632618c50e0f93bc2e7d78cbb45fe79acdeb6cd154dab13775208529ff2511bdc34f64dac380cade74d7f58063a9cd72f5b6ec1d6ff3840fd3f0b1bd6927c8f834a0829407bf847dc8dad6031b1449bd5ff4f182cd253a46c8b6509243e7b0cbc51c4f6a1000a4b94f2c75571ada94edc8aba4485570c10b5b20c8621dbf9ef7de2fd8217776efe69a9834f5f093db762c1939437c2037716962cc52fcaaccc8ab81e1d2c535e76d171fae3b4526f2d5a6c3f1e37ecfdb2f5bd7931065eab714bc661ec25deb3bdfa415f90598dca5577e66cfceadf9eee72077a7ce4674c024510b7e435226f63c0795af686f270b83a6f5836518a1a5b18a6eadeffa57716350c2c451764fc18c5291c30e4161b683a9b57303a4021407e590806333098fa22e5bf5a7c7bf97868fabb734ed27f8e62c8aedcb2d52004957856e44496786dc780f49abdd7d77fea6729f08b1d7c522b3bcbc3beeca8413855820ef14bafe1edf7101c0019c55622f510966a8668a5fd0c52e3eb604687ca5e3628a4065ea313d7fdd8fd17784e3cd3b58dd2678c47e7d8e5364b5f66ce7485c73758e8d85c7e54bbcd80dd9bcfde484927c2598b9b09a6bb84d5bbc2e47999b71992c8dc11d88700820b2dd3a876f5c2c3093b543ca1106c668efc5d47102ef867a259a75433a58ee36d3d053395afd4430913e183c64227c2c1a3898288e88187361fd99eeaeea998be44783f5f85fd601a5c1958409c10c75ae2315b86e8e743ef7e73cb8f4123482734259502d1238824465cf1848f1cfa01ea763c8578175da44b6d69a58ec3ce91e2baced4d49a24d0cfe9f4a19e15d2e8d1b391022ca6bfb76e4e6501aacc359838be6afbfd3b1bf6bdeb4e8f99586918aee7dd9eda59d7b0e308ef3c960079c30fa54f1839d7c232a7ebfa2f640d5ddb4eb6c49e3f862356f1301d3bef94f3807d292a3b035973472b04e99a7e762d645e176f9549df92645c98fc1c3a2c9c2288003430865efcb54cb022c33ada075de2e490ffc8eee5f2617ca7be12064943756c00ffb0547f52ba7f68f272c78dbc93c3774625bfdd7eb6794e51c10357be5de3099a2ce9f170a7c2aab3715f083cfe55d629f23fb212987142071caccd0b840d2daf17dac9b1fa8ddcab7391752448d0a7d15e3994ba9cf4559d9c9ddd2c243dd3b275bfd5b13ea31b5e2093d52436785c4ee637408472a3c1df3175ab3dccc401c637ee9178df5708460163852ec88dfa0a603600dc784fa105a9b2b68dfd54e5fe005b2de4b612c020e74cddd1b14154a2fe9d623c75962c460766b5c5adb19d4666c75ccf3d9f14463a8c7e7ff87710a8a8002f0a17d6b5f6309be37227152fa9d7e07a7912deb477c6e88d53db504d84ce86cdd9c1c649c7bff9da8ac556028e1f17c486d9523ebe3d250549f2a90ca19de4a1a13a77b2dd59d5aa21907d5287e66b228d14217f277ba1272a4677da41eaa8bf0401601fa3f2cf0405bd52774418abeea82a718103f057dbec9b9cb1d332b6d275faf0cc78c6eb5e06036afcda837223afaa94f60b4ce50cb1be0a4664d1c3a98de9715455efe8f6096c3ccfa3229300259ea6ee20523456bf98f161aa3ac2d5e76165a5968e98054369615931b839f5c4ec4cff234c1dffa508396a992dc3e855f0f0d13a1b848822261a400c91036814e40a100796f987f803ff4f0d2171b4ec2ad8e37f64ef221b7e709e90c9ba5c9befe21b2a32c04c120153facaeace34febcc4005178f9bbd8d9eedb919c8bc22d530fd2e0000931fb33420213c8e7c2c6499b046841536e2ca8990f90c9767aad4f03bdf8cd2acbb25a8c372aedb6ac69f93c83e4a8c7fe25e4eb093d5432430c9d528b7babc60c44d9eb0604d4782a55b207448cb6044a8ce09a4bc2293cdebaadbf3e691e41d376597fd39b0df114c3c6c2d6decd2b2a4b8f3c06b71c958032090f6655139498f74c5c2d7c983b0cff6b660e46ec034ba9b6d7ba4b67d2185b337e14af1e8dd969631232695abe1b9afe91ba53058ac3c755f6f0d285c429e6bc22a3a1deabd106012e941b143e8cce14e3546fa4184966cb800a60be69b62501b2b7766f0d6c7d2a395c5b23ff33562eb93ed0e9a3e39f209317a3d1cd932ff97cbf66dcb7e4ede82987aaf8988bbee0d3cf5ac4c89303cf1ec2203679335a8ab8a8ecaf81b7b36a5650366ec74b6259ad9dd0e51124c1d32525da99d6d996e19f492e911ba3167fdc0c7c9bb565a1811a5e25df61abc416158c299d523902c8241e93f8da5d28b4a1105f7c2ac637d5b0eda131484da6fe2e0bc286921d28ed7629245cdc121a318c921f18bc7d9be091677dfb9af8d7d5422ef409a6f5e31fce9e52ce94f1fa5a5cc3e65565c13127aa784132003a7a69a2c90c4c33c7cf0cb9b1b59175ac02dd3dfb861b33752469f34e2509ff99e1d7534e5b4fba935f2b430862acc30821b2a04bb5cee474ebc6412ae90d34c46c2733c9a4076c34bd55a0fe3f5bca93544c7d0de01b1b66461a6166a69a99f00f730249e446ed0cfc97d9320600429cfb863031e8f95d087df0210e72913b2404347c6688cc6faf402beefe1a0aff6b8397fc2ddbee2a069a6052198426f2e3df90d59ccea2977c59d16089584740caaa47f9c1f5eb39405e79546a76b416f23c9023c33f9555997bc4da5bb9efa05834cd03ecb541795b3f1e24c07632bfbbf113cdf9a854aaa84a29061731df5f6a4eba9c985bd66b188458917033b05173ef44ec5094433a85efa06073af8e8816f966cf57dd707dd3c3461dccb5af315ef17eae0085e071bc1b713f8c78ea325d78ae05be370782a6c1ddda527ac3c75bc39117b23d0e01b3762fc44724faafcbf4a0e4d5e06953a1663edeae3116208ed91d4740cea0fef3f874b44bfa93e501f1e0a1e95b6c8e283963af00c5f3ed7c3d2daf75c7fda9c4c2b4a2c3e37cd5bc418aebe9389595268e566351ba91f48d2326ad44a17e55f45f4c1c4e36b846188db103722af8cf99995b976806cf7e2c21592b061e5e5baab22490d7c5a7ccbd8fb3b69d5b096f33cd284b93341d483f068ef243edf0ab5d725a6e10acbcfc894080384c1ce842e2bc97e4eaf344b57d930fa57454aea5df4a09f7a052c33d2d06430f865840f053b2449c843f2f05d7b4dab712c136df31c0d4ed9637971afab4caa3fcece924c1e99bbf1501269c945b787ae2aa120233014f3b60a4902daf9f4d19a0d3aea9add96c7d660d13d6a3dfea709b259ac06d724f5bee29331e40f7902eef5c82e57e463b18e15df0f064c8f972b1b1f72305435968a8738a5108ce1dc48cf20af2327dd5e19280b23f3b132afa1dcc537727da1ea92075749c4629c9131b157bd1c3669fbc5ed9509620f608127200c6d7a6b6226f4a3750272becaaa6c76ba77e5c5cda9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
