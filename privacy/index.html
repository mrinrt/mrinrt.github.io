<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"714b8043ce54f1b6967a36e5d97603e7f228528cf9d808785a1ef349a30f8a4d2e64f832cce37feb513bf948446830e46b36bcb1525b983c47b94d221b0e5381c84b110ac91b5ba4ea610b9b0fe518a2fe3ac5b38b7c37777009919124263d99ec29de6edd1f617b3917102a992aa5ab579a7f26f45f8d5a6621160c75ed5641fbadfce3a0c9d794a65093903dd21de572bb706fbf992582c7fcd21848996281a04a22da96f4c2bfd06470c2a514b3b048238ffc68f8740133a988f4b42c635d5c3ec5990d4392f40bbaf6d6d91b22b8c74991744250eff2476a2e22bf4d5daadc1a43aeb0bfdd66bc22f714790339bb3a7d31b64aa913b9a3ff24e99b40cda64426ca8c36b42f8f9b868653e021e94d86ba4d6e397edae36e612b125047d9dc63f314ef040e3b9135d38df8276c5bda35f8f7b316e385a8550b0e42a1f176dd5a4756e02aa8ee7920685624950c8c3a29510ae909a3297e5b6236c64c4d740a4522fcf58a6ac64d3dc8ca377ba287682c3b40ddfd9e68f06c194df846c80a96821be79d87a7c67eafc74d7a1aed54d20e4b4de60ca272f5d0b9f40839172749daee37feee36d8d1a889bf9b7a0a317c903f2c70a6fd258b79cf27a58d5524e0874c7693bef88071e04a65c815f0701c5b9fa2527ab61780e9a61e39e547da5f43fff3fc3dfdbf449121e10a9248a6549058c42b34105aaf0a6b1bf64bbb1f7e6601067680b92445b4d3673be6e013bba7f1a5b899acc6573f71e603b38faac154184f690a8a8b78ee2dc4a3222a77a0015ace5881641aee8ffb58fa8a0bb0a8228d6637ad7e171ea3d494450c64cca0e9c488a04d8db5e1decb3985b93f4026ed2255df5a05154e5f4dfe39049e0dd9be1f83864d5cdb1fd5f00c561f2ace5b8981afd90df25682e745034f1add804568f8615f57c66541ae98d99339e9288932076d6be6b93e6e78d73993493ee31c774389954df373f739a8a3e6794164e05e97f1c511729ada5b771cb3f3e991b00a4fdaaae955b328a65ecb4ceed7deb77e015de831be027d415ab8c2ec8acf27c32884f72cee319a0ff9106052c832a45681aece41418927430ccc2a7e9e867acf24ecf2961d19c8e8246514388f351cb10504445c2c2211577eaf59df10a821ee623eceedb20426f340e049d28477a369ee70bdec762c5d889e4a511460745bb4ca13a287b01388e2c4c54f6d9f37bd553b09bc90317a9a579709c00f9a9d76e757eb8cd4a331e0e31cc7e8c8d6d4d8db8e60828b95fbebb8e55630e00ea3b6c8eabc1ca9b53ed773d69ce72b3867d27e18d9fb4d419dc7507126f95b1acb705ebdfc181ab912c6be8066e26c1cd9542d94e530f0020c1b22f95a5942ebff0f0cd3688127323b26a564bf24190ae0bc6ef8cd49deafd3370072fb589b05a9528b829e36eed937967a6be0833a07af4b19467220550b71532f93ea55164527da523fbd41c03785dcbc961da9221cdf57099b907dc74864bfd18d608e9663e504aaad702ff572a94f56d5495af0aee4ddbc2411444fe8549828ab2455066fc6fad5328a65e80b593b1b49bccf64662e8355672b92469e10bb35d462933edcf215ee4c743b6df3ea7be89a68c698d4be737507e7170a52e2761e2c099c8985d6967f1f7c057f212f8095d653d7dbd9f1e11c4d7d67720b2ca51bbe960a53da02d663bb8dc908e00ef2bd3cbce762eae238a5d9833a741c0d6d6dccf9f09584b78c82d7ffe490c8c2cbd6d3af579ff5a73b761e22f46b4b70563feec09e80a9cf1f91189b83e6e5cb7d3bc95e471f5540a4d5b4e3fdc0620bf253febdaaf88a22221bfab028a26a09a395c67586005712bf6ca0e25f9e11e902c740379af983e34b245a95ea26fbf5866dd7404b9c07a6a9a017a16ea67c14eda989f2c5dfd6bbeae73825b8535c48571bc24a146a98696f5435077d901b9e12992d84b289a548849a62f972380926eb61cf028883be76261fc6855744e899c9cc07fdfde0a3145137d71f6c61b964f23fb1a5672def9af4052534d67b399425456cdafd10770712146a7180946c530ed4335fae6d54f2ae85ad98b2b7d5bd0afe9320e0a0f5929a97c121ef9c31d79dd73bcf979965e2a634b897976fecf721e85352ef9f187ae85b41b9bf0ed90a12884d32afad74cbba4e544abb9207a1bab68f8313ff314a9d6c1c0d0425fc06cddad20a156c9ab2834a6030f9a01cbcf4758b350ca797506325b5842b028fe602e6ae40fa072229ee3ea75aff685c4f72d4ee1eb6b6fb95aa73a2fde73a789d6c0692452b0e5fba9c7769b8a027172b2bdef078268a5014f8b57a8d29e39570be34bec822722de49ac6bd4b11ef1df4f54ff426239cc498606558ccbf8d6fa25ab04e58c07ce3cbe633b0f6cc156139ce126d915ff780bdfd8677057b8e0b5cdde44a17b67db93d0dbc69bd8dcb4c8c33e2b39e203e0793c48b41b0404551c7220a1ffb375812421d35f1503db21788f9dd4e3aec0727783a2e541b7aece122e14f8859373b384ad77a40d0a327835d66354eefadc0cfa31e392898dc95dc3331047bff9992ec16bd543eba90b85a1e5b8a38a681d56721c3ec0dbac1002bee3ba1d116991618c6a6bbf8931ac54e29ac684a36fdefa2b6d4e53ea486eff47628b529e1e7d3413ed889495939a624d7999799ae81f8614dbce69349cd722a6e901dd1a231db835920ca66311e1cd7aab5c163a661adda678f5eb0d67d57b4f425096b3b2ad38d0d781dc2f60e5e238dd86c56df02c5b308610958bf903456d904c97e44e9a908f2a55373b1cc9e321adbcfdd42d99ceb8ae9e3bde6ddf2f64b04c85154606784fcc6ce9073f8ceea9b00ec95b469e1feca6662ac65679c36624f47be4ed175c8b6d00c05688ae8d9a9ed86515f48f206ba4c54da8caac9f122231158280ffaaa89ffc60a5f2d52c50bda334e10d5849a50ddd99ad6fd785bb64bd669289b0eb620282b5986b95e06895099fe2537430b031da8e99af9c7855089335c451e0ea0e1f64b636103aabb0d3be5c932e291d5c813aecc631a67a26ba46aa5af0a79f840e1be54b6fc999aa946805794ad8441e8b5ec1312f773f1424ee35bab9baec3e9fa103ebc8ecc250eee6cfea28b3a49a51df641f7a03d97d0d80adace19d40e537962bb42e63967c6620d62e8eb595d133b7b1fc4cfd90a27cd8ef7edd8c025fe2c30566d0c4c866fdf7cdcb409989ddbe5d32d0fc37fd5d629ddbf0e47944dcbc0e353fd18cbe06dcbc51e7cf0220c380650150c95da3409a28bbdc2d71f5bb889dee741b6487e2a412f3f344cc4d40e12a59e74a0877dc82bf4e5a0fc854f4588a81b30def8a49ce9b2a745504c6a3ec4cb7a3f2e759d24397f2a85beca494dea579b73f9554387429f38caeb4fb14657a107f1ad0311990c62afc4795895d85bb43440d8b6837a558d01a0f71d7ef129d6fbe9ffe1f2b3caa98ee5e4087e67cead3de298abbed2762857f7e5474084016a549e005e603f2a97620f6c450700d9b3fc138204c54c758bf888094236977a823e0222aef7de07f8ab78dc41b345b9e966522b640b61387f157b1628accb6dce37cff0c0194e0a1b760a97853d28a5b1034fe4c160a992af2c3712a30482ca5f29e8c804eff53518381a958f2ee29d66e9511ab9ba317470e2da884ebb208db23517994e34ad951cb27b2cf2002a3910b23b38aedfa8e7ae9bde4deaa5997be340e08b598aca9ca0d62a0c2e79e01ff9a0aad890add951f022764a89e17057f37d8ed3d5f6cf029edda8fcb406137f415d8a8836a2d68f8abcfcbf153dc024bc45ee103afb2edb5e03313e76cd8fee401affee6289657215e499203ef21dea4ac9538277d74c2d11ef43dbd926a9ccbe9283f4f22688151bd52d158fbfec9f85c63d3af8c5377e9e40687547fae5e2203979b08bd43f2041e6139b1de69ce085a20ecf4b643cb6cff10bfbe6f021ce6ceb00ac3e95c055dc94cccbbaccc7a2c3734dee8e2a6a8c6647efc114defba77c160d7095e1c338293f9e6ccd4e3d40f6d7f30ca723a9073c91b6e907487d47f8b96accde1bcb32e3bf9e8dd961f57bfa4b593f45cdf90550ebed93bc0bc9ba4d42c759c1c904e5a71f5370bae39b963c6a9a746f5f7bf2a7ccd1b34e2d004f3fb8d5604d12fb51319686067a3ece95fe821b8dabc5b4d4554ed3fafda1f699cf23cdf8ef6e47106a78c2f9a4236dfd248006851313b5cbd6cf229f8e0ac85509c6168cf8997b0cb209e1168a609890fecdd86ff45793a3c2642331dee75d86a88e33ebef11b8d883ed9dd75be557c0b841cc6b118ec9e91beade8f21a35977b3bce30796c7e6e2a47f0f89663193fda5fd756db747f8ebd6bd81ddad0befb6791514ada0da33dd6e17a772dcd5e8c6c2c575983d93f836852cc03cc006be3bcc06c68f3cca519f664e67fddc062ab1e7106d97b9ce4e2c1d09f14a95336373bcf06776e2546ac5bf60ddbbbf5e19582d5224e429546f20c87cdd60bf6c22c6fee7e56e27583d4a4f23b5b53c8039fd6f3a24c8623c19a57884554db5580229f1b403f2054aaba95d24d3c97f8dc318aa2162958ecbcf1a35315b17a01482416dce533cf3c6f5ee0068a6e21c2f126f0a16009e5d2e49942cc18a04a229317927709e4abba7a171cafa451f8806f889ec120a5986d9f0b9d6ec22e290e12409ae3703b6b9852463843bf686d8ac3ba674aa4d5e9cb8772dd644f1cac6245ce992dc5f85b61a16baabc34605d43ea2140ff5f6a5dc162d7ad3df15fdde6c52d1510251e0f8390ce34f7f28b7839c89f1a29fdf834fd9cf8d3cdc56d963e167bcc3a1cac40f5ab730db90b840321f23a16bc13b187dae64697aa93267ae8148aeabe917ffee8a318be5264322e0e685ab3218e877ac412273bc042631d306eab0297ca37ef3ba2ddd041eac7cf175a5a5860fb875216a62b74d8f4fef6453868dd0b58b41984b2b174fda24114cbdce410ca7571d58c6082e3c0c10f0e0ea160f40f2e24322938936495f36cd3c429e836a9a0be066469c444013f237440c031cce317fad5925dace95b268e2fefd4c9eabecf3ce293ded07ea33aa5cff2297291ada333a1b6d89f4ffbeed2e0a46de934d70737d40dc6006fbfe97d8f4b5196e3f8666cbcbe305c4d05f5929148269958941364d4e223ba72509e14c53f76b89c524c2219de4169cb729cd6d0f7df9bd4d7562795174d52dab9e4ea4966d329e1fa7b5de49cc64a366675e067b3b3c824ea5eebd386ceff4d71e1370ac3cb21e8d1037fad90d5e7f5e4514dbb83c26c8fd56ea0ac2fbaaabf4fda4c0a5c5279bcf441b68da125fce73cdeac75d2422628924a923cf012a67f6460210f59261ffc53941e93dea8c176778395e5ac086773e3c8af92766729e43cd869086734bb187672440e0934e55c0d47ca6e3be7dbacf993c23dd43d48b350d36c0bd1c1a5e7b605ff10b80e203579de0b089ce9a198419cfd3cce64de366e6bf01cceb6037eeff1509ab1c66d6ed2a8927b56919f4e0663680eb098503d5d8b95b10c8677ca2eaf0fd96045c70fb11bff54fa2bb6f5f5715224b7ff968fa37e8df9449bb9305853246fe0f128ccfd8a30736d1c613fe27c1610c48299fce8d8f2415890258fe85acbb93fa298eb9a2953417d8d642612b95cc39311767e7b1e1b78989b13316ea9d083a44e0e04d2f0ce01398dcb875c004b457f1671b897397021bcfd2637b72063ebb8ca41d2bef97a0b02fb695dcc1cafe62e204e336ec3f1c0d4cae883ecbe4bbd071a408cbdc0c1425dd0349a687ba7d10bbc2ecc905f2dc06bbc897c2f16e7d160245217bb69edbdd0f309fafdcc665de868f000d9e2ae5ffa04dc4379b5654c4a1bb4e2225a6552a91a55d17f49a697ee75187e54d491f7596f97a24e802133fce04aabe92d6fffaf7fb7e35abb246b14c644f8d78c770150f2d41b4095182ec834994fa96f8f05a33b0ee4810b0414149789d42594b0fe432b7a150f171981d6a512acc189ca71761e287e3eaab8b73907cfb17da1e6ccc0d05c2c128893e89c326e45f7459a550d3e0a1b871711256fbd8ba4c48234cef02ae53e4ca473b60cc9c2f197611979541587d0ba5a0b10718696e0379d569b6dbf4aeed930556de5682c5198a8e21b90badd94d7c78273f38f37814efbdd26b6074373423e7cced151815c336b31b6687ae89142ba6746914a9632a4e8d3b84aa331e68637383ad98ac4e25c1d061fcde6427f91b5493b286e538b9da999d17f7c082acc6c813cfe3075f482bfc2548f8d379270c60c3c2118d7e019e78c5dcd648cc3353e7626a21cb06d41bbd0f540f7af9aa417d2e8db653ba08adf1eb935d166b206030b024f4ca589f93b10613c4759dcf460340dfa7835ea2120e000202a4db575f2ffc6a7471a7c2e7a2ad239cc9f3ebfcc932c3bfa399ec4f411b9b30bdbf9d9d55bbe0382b016a7f2a9b3b1c174c17d4bbbbe8ca9ae413816deafb2cd76396d9900a6d0eb79f4de4551097cca271cd0842bad365510bece93fe2c7034aa021b23aa38a7a7133ae85fdb6aa4a9e811a940c42a95e82274d51ff83a5564431c9141c8ec1188a01f2ba1a49c944a759d2c8f57f0abaf440e14967d7a49224ee3dcc57950ece1cbd5bbd7bb7a199a8517f5ccba5821faf553f1ac3b411306bf709cd5663f999929f1445af561fd439b2f068237392ad6d516c247048d26e690422aad382a0abaf89a26caaae9786642de61077633e4b653872df276b6f57f9e28b72c8fde5703ffcb626af7940f61fafa0d2eb9a97cbd3ffe76d8902de7307bf54e3405b11de94d435bc9c0266e871c945ae42ceccc17db2ba08b14a58f5e64485ef4b87df83363e9dc2bcb24c1ddc8e6fba0cacfdbd46d0b601fc02b3b75542812a84ec43903ec9e32479f0305f420f8ee81f829869f06f9b337cbec5c79b9190856eaacc82928376a918b4db85ddea9665cf22e816e1149817942ee0efd004b1b3f19d0b49adc9aafb44ae1137d1bc2e0e66e99bb52753162e62b655f3ace9c02ef37dd1213a76dcdfe59e8cfe626db5c341ab5a773a6d1b0c8d2c941116c355e1d21413de34eb84974ed0dc163331f1d0f5688555232e490a12c1e8eda135c2cfadc49e6dd40cafeac985a6077d835791e9277f4c37f39198501357c3eff3fb0c714ea0a1611fe5541ecdd3364c947e1ba7961c69638b815600af3c0aab2b16404b24e5b44435e85a70d47c12c2b242d2e15ecb63a333ec58a908daa469154a51d5112c454198fbf5e20d0ba3d790bc40e7a8eb25d99322be15e1ec456936c2d1fe506eff2786079de47723f717b6482c238d5844eb7c703d00fc3647052ec4a0b8b85c522086ac33536d698002dd569d69b44bd5c57ef136031472199f5a3e64ff256221a3caafd28946161578eeeca9db6af10d6df3de5b0c47e2a77031c83874402425c3c0d9fab33bedd172227dfc2594a2ce1e43dbc9d5c00cf2571b4165ba8326c464501f665c175d22d0243afb153e6fe50da0ce6040237a7a0e924d80321f0a928bed40b6335d23568f5ffee60110b8ac8e0b955974e637e83b0981c2d0200abd4a3697550169e1179e08d05b5b0e46280548c6eb7e0470cd214b362d7f7c02e4e3accddde4aaee58ecb68fae9a5e587bb0ebf6397c32f2d4e6f82a769e94bdbc53804561f66f2ef0a3eee20f4dc3ec777403955409523cefb874d3a8b1b9e216f819cfa12aa3ea7102d63550cd80bc8e0de8b93a070b6e923f04bfdd6b74106550cab1dac5c485ef60af4fe512c46d7e0280f322dc2c2132d6d464c9b1ab8c2716494e44cc6cb0ff33a984f0bbb35d2c19e48ba44df2ac51c4e51e8c259571d418c103fb495f82cbaae3b789f39cbf0832d6988557c7300bfcf0e5f014c47c010dff9aea78728d116bd69ff496431feb2bf03849041f21e504ed36415d6f63645f6f81c7058e5ba6816d7442a42ef6738e2a7abb7a13c4820b0364722bf29a6c316558e1e71f355a47ac89baf6c051aaab4c6d1dda5225538d8ad6ace7957eff8a347584a58fbd05e70f34b0015237e0bcde5821bbee9c51a993e53b0babd02eb81c4654892395d3750020899a45ab3fa7915f587d34212b6928921d31cf78cdbaea8cfee5782325680baf7aa9cd8c0cf5bf7479ec2625528c0b4593d703e5da45e4db14e7452c04373439ef0ee1cb10b5bf5ada1ca21d7f4533a8e82036f31c0a54c9589f90ff7a948110abb807955227c7c30aa992c64ed4715974116c33a10954044a84e3ce2b9d3afdefe09abd832c93ca3acd623fc184be51046aac7e4728f2c05e75d1d827723a552e98ff2e06cfc2b8c056dd44ae1d38f8026b4be0a7f0b7de114be4eba6e91097cd19b4dbc8636c49ef8188d12c53866b0ac41efc8e0a6db5f314f82e6b7fad44484f82722a3d94e514b78b61565f95465d7a539a5644e6049cd0a925ccd704d0d4f51a5cb41ceac45ac21132fde967428dd22f6b288f5067d7f7b2ec8f61880d55f678e45a8ee8cf71abe43eba26d3c4519b9f412d059ae835439908a6150523a5fdeb91b1a83f3654aacc4a6f9c03e24b4ae3ae2b0e74e49fc2154deff0aa9ae95e605739ce8c19232494e393a0d7701b89a4bcf8ddf8102a73561eeed39442f4bfb58d10e32bace5af53a882868f1542a83483e2220b0acb199b10d709d5ba3e2ca138241a76c797d0850e62f028b7d36622304f7eb4059b3ee67d8563e5281af8e6d4e225f192afed8091c1a7050d915c89143e6a62c8e28dbb23f24f017ec0cfe850f98eceeb93264f0a7f5752f680ad5c05c09c10547c8e706784a2d6e3251843604eaaf99657ac3a12b2961120d05747cc0709d18ea8df997167a5f0f013000a5aeae7b5fcc961d26ac41938bb30a0f7d99982db24ae313299ee6b4f47c9797cb22a6116e7d3310c4915eb96dd276e9b0649acc4c23b131594ddb54541c906c3f837118a149fbbe31f1d5cd4c240d176c989ae33d7db691a188e992f034b84505adcd4286487c6264aa6c34e9da429482d2950ef26de1dbab5b1e34ac47a026c657f19214474b297f611fcafaf378715364a0270aa23405fc29de63d95d8c51950da92e5e426abebe475766a7840852a89d08e5b34098b674370f860e2ca9984a5a81984501ddfa5d245ee3d712e312ad28ea5f1e760e5eabfd15295ced62bf36e1e3d65e1a2212e7e318e2560b730fef103946161c599fc5d860770d6554301e84f1095cab2b7c50d10cb10a3945c3c4af86c56cfe1af08a00f02cfff3bdbe3c89a424101f99c83f91b6950993602dbcd4e315e505212b372cc9f05243aa9f6e042c7c116de9479e03ea02a18824e4d605c9e0fb52213b11707f8ff41a1bb0890caca9a58ca61ce592e1705c2bcf223bda8f8d0367836212eace22b0b351a043e7e74748c4f20dc207b9250fb4ee46be0c180e46f597bda98e361a5950712dfc6710577d3d83525ba00afd3eb7cdd41ed3e25525c1921305b8ef397461bff29b8a768a9781ae28efd14ef148ad7ebdb9cb07a1d3156ba738efaa9628233dfa7d29e3ee9577cf8f4b4f2df0f346a5ba818b6708ed0709cff86abf01df4ba21cfa3d1ca46764ee213c483ca24e84bf914a32d5d2d946fb7a5ea49776b8f3643d834f1fa62c6c1d3e49dfa9d1ce2b8ab91641961d1de52e54e034fdf326a7eb3a980ed76c59593322d1b01361efb1d0132a59cf3853552ad7a5d48f1746a7068bd62fc8e21e42f8c2feb27b8ae16db44eddaa6a526f1457e65ca361b9e54f0c69b7e0f7472768ba0205fcf7c97e732c58c3063d2d16d3e7f2d4f45e578873eefd7c588efbebde5215112494d054234ff3ec5f7a0f4ba3dbea09a0fe7694a9a373ce528655251acfd4fe1dd875acfdcab3fc3c137fd233fa68e9325913b73e19b46285feccf01a2bb1a76f67129aca37762cd4fd23cb4c64ea442733ce0617953133f2d12a08efdf702b1788bf89ae43f95740921ec24e356125ab85508bcda351bfca7d202fe7b4415e8096f9e2c26a069731f26d2438de23b1ca2defb0ed27ec032a35f0cb5357570fb05e6c8894c1c936a04d4294faec8ef27fc89ebee60cafa1ae10c2ab20bc86ce4c8abccfc1f18cece1f7ecdf5bb758173973e487f8a4fb3bf1d8474038541e058c11882c6aab804b47e696ffebda9b994584f7fb8e2bea3d77c2a8bb5aae4cb5e3b2ebafae47ab39eea11288e0d80028c6d43df230d5ab6ad99e3ca8fc279b6668bbdbf8ad0b77e39212403fdda08b7f923bf07fe8c6d93f8c885d5004df28e9b98983ccdb5362631414af627ffff269c29c657c846177942c9a372a01576e358d7ea338ea88041b2b81100db9fe30ed22d576c3517378134503e188eabfe4336a97f5b6b6e127aec3c6c45e3e5537346204061c231216d85759b7c990b1e28b9e0960137b0ad405e1f4a0c2c16f623e26e55fd5b7c6a592581dd32b0f4e2f1c40f467b0f9ba17c22146db297314a3df82e67f9df9d362c04c2d1114f746e41e2749a28df6e6550f07aba8b1e1686e1d37106b2d42ccfc30531299f9fb031c299961d2b3d084683d0fc13d2a1ecacbfdf028cf1abab8f827be50aad65f9908dd2c6bead8a347a75fa044ddfbb8dbdec5ec454cd318968c8feee5b356a44d221d3024965f90f948e8c7bf092190bd2af4d06acd54dcb99973ad4fb8eaa7fafd8b78aa16bb9d331f7afdac4ed89e305c9402b9ed6cba5dd3758140bc8ac6a96f5f729c65093aa334cb6cb88ecf943a3aae5ba35d1ee727a2d4ba562b421ed2d2d5b0a926ee9980f6dc202e37c6e0bcff2fdc680c0d33da0a56f6b89484b7040bb1b630d6a64a42de01de08d5f55432e046408979f9edf7cdd60af858c93cf39d370289719f5e9b8953a3595e522068499dfcc1fe454f6202a9660cda43abd95b9e9c54232de27b5590800b88c70a4178965d0cae10d3970a0b138e710aab77eaf9c6477753e93b34dd5c034a9b32aa8a73af735e53c36850a74ac40682f37fa01b297c5a6244ee6bb4ac3865e3fdfbe305c737dc4fd52837dab7c6f040a4cc4bbc75dd5d89f1bcabf5e7dc648de5b7c03967dc62e65ac5901941978c4c8c9d166074e49d3dc10a0ef4604ed20dbb6d3ffada4c1f6279eff0c94168c65d7981452dc728a82b40ed4d1e50363ea508811ed5423670f65f83764dad66264763dcb2b25985b5d61736267afa6352b9bd23146b625cfce5bf6a6608092b6df935d41ddc4af9603ad3f40cd890997c347e6bea80d673357170da566477697b7201df5f503135e3f4448c56a68bb33f97be4dae6221e196702439bc1a83a84231c6ad10aef31e34ea12cce4a5527043ad9023a72d47d953df7161f74e1a752abeebba11b7bcee23dbcd9d22955ebd8f2a50fd676c2f45626b37006222f35f236af63388919016d0fb040ebee74f3ad102455ec07b96f7101497e9c0cd9b9e9882600f684ea99caaa3a4a99be941c6e1d3efc4bbea94c0d36cf9bef50d1011725faa463f0044f3f005271d5278a89a8418c66e5cc3badf8d6592e93ed0f4e93113f22b4b0f1ea2295e5feac626983944250153ad67e804f607ba5dd6c70be4a8e6e7f09424bb6d2c1ac94e8dc3896846670c44a0df8be19197119b20b4a06057d2e45d996b1212c928634f55ae543d964c79a9f603b2c9d404015c2c5ea14040062d04b33a0b922d172f2f1c3f603b291d36cccfbd602327edac85d8aa4e05cc6ce4ea6549321d7e330b6595c55d3ed80f5616c032f3536a02b5d74d456ae0ed86aba4a2953645da2884b7378e39459ba6f9ab62e05c2a133216b2bb7e5f7bcb40dd2118004609b51658718f5105dcfd407f887b1cd9e3f3a29735d154b099b9a3e4d38aa407307185e752bf6d59f11bf3baa2540c3def207f194b49a6b6fa98ad6d32f04ea8d33604dc9ee9b198732684c4e47006a8d07b4f2a5c10325daa3dffc9d60be5b1a12a394ca4aadbb94195a06bfc29691ed118bbd56ba73d3cf12a80fc960332fe1e19faccf2eef6f0eedeab87fc4a4a8fde9aed9f9df462707e01c6c6d5725b2a50a53bf71d498a40efc05541dcf6af851a9cd1dc5ff4958c5b6162cc9133a8e616c2b25205cf3f91ad5b46bd4f065e151930b0b98e8cbb5efecad7d4476b2da1e9bc773096c7c879b6e7851e3584b6496a994fc01dfb9a73c0246240824baaa389e19f079b6691949e02e53b046747aeb4fbca72a549cc3893d81e7d8e271fb7593405c9e84ac23ec6cda2da7052207cd1293aefa3262a673fd198dd65f4331c610ac5fad7977b05f9a42663e74944b3dc1b21c67f9d9a2af3591a5929f063b2c1b9e2cd140277f367d3d815f8444d408bea4dc0f1ccc0df08bbf46a534c46c026c2a43d343b835ed11815ee98a63dbb7898d3ac671a6222b10107490b62f9eb653d53a2065029f1e7e021de6348f7f05f6df111d2717497cf2683447c8d99a5d8d8df76642920bd06f9214710f8b32003fcd061dc8eafbb8dc1546674cd894df898fccf31be33dc60932dcdd8b1d3368b69edcbcbb54b08f99fcbf336f9acb55b2dc104c71ead532cbdcd88596155fe0818f33f513085e9fdb8dd3e38a7dc13935b24d159437a698fb228242dbaf857f8687fa2dad3456fd3a64f875049093ec3f1f0ee45ab48abc5133f678cde83753403786d4dcedb912b95261ee6bbb763317f7c33faf6070cf1068144b75ff438de26d7b450ed173dc2c278529470fc04f1403da571e1e72123db82c070f861984f316639c616c4e0e5facbdc1be0566da4809e1ecaaae41c56aee67c73cd4c122470f57ae0d9ed66fd8db579ff463fa28fafd01274118772da7ea826aed0bb6c13ca60f68be8dc87d32d8de436c0756c944ada9932584624dac890b1fbd34fe2f05f05016a555cb29268720ca43eae6b6e8973778e5ed90d7e19d30a04fcd6cc8a2c6de2055aaa9322935d9c3e4a565b886df7e128c4278e91d9ec7ee476163e1170bc629c96606cec55fefc975c3fc8df7984607197849c3c053c20353c644f95660f9539de299afe192518ca8006f078ffe618936b429281b3d4c05c00c4991db03ae0db1de560a89b8818372e118b23e2a38654848155e03a965e7cdd1f034a84c2a12990b49a3ef20562aee5a21ee26d5206708b2c4f415a59e6303bace0074cb82e039c14bfedfb8faa9807ac20c80d95923d41b528773c49edb61f08612da74441d855a307456b9cae3ca76fed172431bb6c789de1ae3707ce2fc03014cc37348587e30cc8cf4506fb8169cf21a29d9fcb1e7af69bdc19b3f78aaeef1111b8fa60ac11cf7d10dbc96fe30e505ff5fd19cbaa3d97d8cb1014720be8a030a41866028f0cd413c5a93e362a9f1b8ad488955fc30812d4f5a277cb8603cf60ad60b707c45699494e416e8949bdfa7741a2af0e005c5255bd9cb2d2475864179c2b99f2144e5e860bb20c9c6d20d75609c7fb23574df68453de477ee201a03c27241f91cb20ebb15c653709624018f5f1760522581bc2806bfbf25cfe7ebd8eeeaafeca7286bb2f79bd759946aebde4c14dbac2358a1ed857d9770c24d65178d122b56a3bc975eb34c4cc194227b8a4838a386f47848857ae5d8a898fdeb8084599f832e1388ac10998b9493dbd8a6e5d9181ece06788416615be8107520d3998d5227b23461a49c64c2f9d195abff30752a1824940144a7f86c21dd2a5fa443fbba5c569930fde3fb9faca58e710288206943de06b66e325766f73a1c725688ba834d74c2f8b0277b74b9b8ad1f2d3905ba966ff66c3d9841cf44bc28471fffb97ab886b37c93b4acd20954c7d15e045d22bd3fae292146d2f88fef0677f7f212953a298c600e35a0a5d4fa438b2279c997ccb2e0c5a5166b06a699a89bd88f1d9090cdd3a5bbb4bf005739308b9082967c62fe70dd25a8c3c0e3ba73cf4e3e956f948590b39116aa33845b67502d264386c1d6fcb1f8a8f20317bd81473caa425ca5ed5d32ee6424bad9d14a3c785c3a952a007e12398ab11bce9d678389557ba504d811cce36f1d1b5be8512da8b9edf6c922b85c0f0d103f940699c41bfe7bff35e522281f6ee4618588f8e03cb1f6606dde9f3ebacf49cd656b8f4b69e3356b17c39cffa6ac51c3a4047aafb2375a0648a11b0b56fdad0ec9a3f3cc3bcaf0a73e98f9bcb9c9187e084a93016a6bb8853c34ac3d7bc1aa085b5f54e006f30c096a4c2b43670e0e687c9c6f3327630a54166da49ee657c52eb82093494866d6fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
