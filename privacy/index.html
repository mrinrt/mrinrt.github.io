<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f01a70824afd873bb5008bb5810e4b054c4cc09837b6f55c7bda27c5eeeba1b571b845f096d6cb9f4c2f4d97e8c8c95b57aa011509b72192e449d938ef8d2031561b6cf1184fd3c245f10ead3b64e01d27cf1c5dc1e6e405c013e227d3edb0e02e740b206faeec14a79e86027b5e0a7e66c43d2e7af2efa5009a52d21bc15d2abc2740930117daf12c86ff8970c9d77e083be59f7038eb98f81847a84d25ebc6e316e7cfb2ebbe1b6d0e9cb0978f64f09dce7fcba82f815c5adcee3ab45c170f6677f8074f44d18a92992bfc1b66232911c135c075904c13df9018ffbcad344b06ec7e37e538787d72ec152049fcd4c30b45f36dfd75a4b22848d4a3719408ea4c8d1e5bbc8b0ce5f523a6d6dc3ce93e8aa4a1e4da96a8fc2c6787e90618df0e7c4b839b3db01a3d323e9f92ccf7a9addb6738ff929ae0f9e5bb70d159519f180c3a381cd4f883da07c8d94ecc5e90decd28fb714f3f16edbbcf7fc21ba1668caeb76c3b2be82d787a007f7eb0e272ed44c6df13fc7779946a6a3712568daf43929eb72e9d66fe3c0f4032fbbe2977802d9fe1cf7b4e68398402cbcdea7f445ccdf16479c10d41e9e0470649b979c59306ee2b5dd252550b4ee46c0c76be14ce0c5a14282afd82ce6ab37ad7791ee7b1207a0c431f490a1f6cbecc30cfbd3a27b26469c9fa14d81d7b0bebc95ea790f4fae30bdb61779cec92b4d532cbbb6ba562006f2afa67ce6645062456d14a2fd5a271e6960657f1637a4ca762b282b99f2c96fc4d3b4d3ca9b918a25100eb3d284e6b0bbd8001af56d2e3d7416b0228e37a58d582b49751b47a665933c225c3e9735f6f20423d9c3271c2dcc799d799547f9df424765d9eed88a5565239e16f4883a6e39a1f600ab9feda1c8fa6c3a0fe5e728254ee04a135a338c325a8a825f854a5f792a8d3a8293f861e21fc39f645e81324ab03b089871808e259d783d2008369ab1db2f4ea6192b293d448d2aaa4797f87ec614efe9786ffff3aac1961cd83561b1f97a42f3892538e371d9c6872d1a84043d3e46546dbe42a6d0446f5e15002b82f3a4f164e88835e31dd78910247aeaa9f02c1bd22fb5edcf90695413dffed502d4f97c04dd142516c057c150a10b9183849fda95991cb4fda433e292444c3c7e51e855029dba7fd2bb4d10ca6ff98d016cdb05a7405d42f577d8f7fdaa9187db2e498587405975f9bdb5d1937b6166d1b6e2bf3c5fdd983af45f83fa7b6228dab7137c7165728df1a302a358f4f3e57b7ca9fa15d94d17e38dce2bf385a9f7c9559e3f87253c2998350ca0494e6121858a1f45364d1a3c5540bfbbf2578ae683f489ce6dc6677fa57324e6aabb4cf8a25390759559606a57d010ea4ef2e482aedbe34cc376329691850ec85a57a6f22483679948b5118795eed1aab586883cc48fd91fb56694a6ece4a3b47ed442c4179e6abb1d17f410bd6fc01227b45d73ec2a7c96cba0c568f56544a1161502676f95a45ed3f86503636bf62c2fd61c22a829b2b2675f5f71496681c03e1cbf46ecdb6cf7b73b2004d95fc49cb0ee81363b4acb77134f739f92bb4dfa7e0cbf8de33972810e2711fc34337aa3e924fd4ac6a8e0b63d8f1b123ac0c6e7f9e8656cf335139fe324b67461b0d8984bb7d054a2f790601a2ceabb3ec1204eb151027cf188d7975d5cfad15eaa5f18f92c8d2889de379bbece34d57f50575629a7c2ae23258c5fa92d79c86ae8214858b784dc390c32e16936ccd6e2e4e83dad746afc3e29b5126dd0f2f4928b93aa70f10dae8b3bd7d22f30e7e2f57d4737c405bda2c74492d051fcadb949d68db1704304d8c5cec80be68aa25b6dea0967739fd79a53920fb7257114e2b5e4dbb92d6f96860ceb29c52e10328a9d12ec5b837e74976c1b3c6be661128242f75ed9430736bb113b491de5d733b7bf1980442e26be4a0289da034d8f0e075c7e9fb78a37cd1296aec81c421d6484e66d63ffad30b2b80e0a92706a390e5e76012b3581a70b614589811bfaa76a2ce33eaff3f31350637d1a3f0bc33e6ce6ca5bfad1ec15e04c9a17f7531cdb79838cef5030c5a5e9ab8e9a2ef50c65812cacb74cd7727d19b9f4aa013587d24c8b512a48e2903fab885d334db883ad6b474fb4420960b8057e634ab613aba7c593975dc60b126111d84ed5c9a8058bba7318abc97695813483a840b7fc13038cc88594b5bef2699e629905d29d660cd98c18b9401f6b9c376db08e90752a4f92ae1420cd75165955524a43d7eeffc4571f28c25e40ef53465b0cbaab7dc3490134bde116a9690cdec1d96129bdc8e541d53d5dabf24b6197202523acb8c33cadac1a9dee19ade7ca0953c89bf10cf82129932a1ed94c2960e4f12e0826aa0af023561bfcc47b9352b16d715f5a1efc3ba3cdc0f5980bde2abdc8a4f2c561f68f34c926889a0f000d72eb0ce04c4631059ab01d832cdaf8603a8594b7656ef27b705f56fe14eb098d689d4cdfd431ad43daecee70708e1df3aa2208217afc2f65bb8252bf41009b96e525fec1e2cca9d9c073d064b75da931b8d46b073f902a623efa7cbe00e70bcee875bd34164cf3d0ac23cf8c732496f0ff4ead76ff9a207a977473d9b9b8b1a1953a135a6e1252b65fabd5ed773054384fa9448c7621a9953887ac882a49e9b762d614eb1f61878c57f3cc10e2deced28ea254e83c1d7aed3af4f178cd3834ea07582b8f7e938aa50736d7f805b8f5f39e921cc0f67906efad0a87871e4ec5e7fe2f86634938fa4aff382f331693306dfa5d2f049a44d268f669131f9615a14cc7becb39c81c48e3dc0e2c9261280b034acb4d9c475ed4e0731a1dec03370853e9057b0a6f92079f4d3350c7d66f36be81a48030eb68205a00a75180577c7f5ff762ccdbae01924abad7ede878c3d8e97fcbc8a31020f55f38dae4a1b2ad588b4a4051468b06773c9002d14e24e8a217a48aafb4ffdf1af41b2dddf939f7dd1dbff41a5fde4ebd8197ea3ac55cc98b08d8854d4b2944842587857d9bd967c3206d3437833427dac5e7f41bf7d72e5bef4dcb24a1bc4ffb78dd3d280689dc7291027f08e0ab64acb22e6d428cf363a5aa29e4c6c3272ed224ed8704542a1b649f119c9a4a6da9e7e191800af1329638dad66310ab979338db4e15995b8d2a2ec2306ba85798deec7bc227cff6c0bcf72254e3508141190c4a408a89fdee1eb9da15ba32909544f52ffa2db92687fa408658e3cca22dee9ffe8690ea09086bebb3d2bbd0f511457b682201274abba45b56929e6e5bd40622c0a107551d85ce28308c0e7144006125385da2fda1b73c47058b2bc98e511afd7903ba7b048f83af1a2f61a9860c98280d9a9592a742bf5906616efcd1b9bef157978f6ef7d88f98930ae7346e3d7b87d0b3f91333ae11505f0249e55090de10456598a661ecb7f1a32141fdccdf831556622ddbc9ffd4df5e261ca5cb84f34bd3786d52b72d03bb673be642524ca2759b577aaa3efb541897e95579bd977429ad1c5e392dcd4800a66d10389d9ec7a9dfab6d8b9cb9bc345905b9df518c0aa565b0592ea9c404bba690a4688f2d4e01369fbaff9867bd6d878455dbdcc357af9b4470234b5457f1b51315284f08c58270cd08609eadb5a04572bdfc2d22efaf3204b99c466be515a9ade41eb379ada67b16fa4606bb7a18f2fc35e4b25ef6e74025e0cb20d810b13f81f288c0942abc50e87e1b5f741929b99a3493433794b0407a0d02f652fdd007402ff4c83be29565815044f42b58ed65ca0af255bf6c79c9472141968c506f7a9d9002a44cf0e70582edb9820a0da96a658a2ae21ef433cc244becf1dffb1ba85d25c1d38f951ad121004c53c782416039466710e2c1baee1c0ca0e394521d53cd16a68766719b6e0d3b3ec7de5aa481cce44f0d7c978510870e901d7c37a9f9e70e8686133b4f7da60c62fbfdc5f5047859fcd9d6ea792dbf236388dee30cf1420e3a6a1b8b461952bbc2745d81d0d356f75e49585aa9e33013415354f29662bea1144c36a683a8fc548296ee498ef3bffbcbe42730b3d5a0b9929c48e0e19b2f53dd77ae6826e362852be53edc37f98b66147302b2de293859c8d8077f13ece14fc4471d750e63118cfce9ab6dff388bede6bec2892e9b7d4399a3fa4e3c5a5e97da9f477b27157d5a906eba0976470ecfc3e1074935332af56b9d17358b0fa742d2f247067a15e60929b3d48f1c7cd2aeee56e35f215c4906aa25b97b292add1095e5613a5bcad84a79839d6cf58731ce81d89aff3e5062d56491279bddc85189d48c09a5802c523a84f73326756c0e1f36d703bf07dc611d834c0a898d7599291045c5115327912a959b083af51b6020a733d49a91014ece2cae87f4b3ae6d6f4c85e2efa626d8f34f8267fb650fb2a21cd13a4f2d21e666c4d95f3319b3295679e8877c4bd7e2c9b14b8c23d32077703269a0faeddcb600fa4b89e70e036287da6825c20a850f8485572d8d8930c1f534a77222743a4802d67ca4087dd336675d9916a4e82be4abd735fc7ca1b8c1585d5201dee3af45a083d6e2e92ea9d4d67365bdf2faa81ce7fd2f45b785091f1e10557abcbab6211cd89f0ea10307de38efc5bb2e5669d2d1a60502655998cf01ee29d95047f6ca6101ee0d9ec3b48e0638b37759b391affd5c6af78ace2c583c6b393750cd7a329d2ee0cd149955f60464277b64470d625a2c8896e14068f1881bc53a365024e75af8955e2eb45bd778e204cd52240becdf392e7bd0172743906afc52757c6a439d9e6587ab8f1028d2e18ffc1f659fce15b0af4e4641211f7caec15bb00be1e24f90e3fd1f598cb8ccc6b8965d95d58308b4c147ee3bdf2320431241feea88d6a2fff49b47ac51d05c723be8ac1d7b0bd825fc33619ba19a910337382aa40f0b5d713d7a6d83b32afc2292751b9f681d0acf7bd9e492d19efb05d39fc8021ca2478e3edfd91191e29700147b58116267320df9034c51be246dd0685c5a82b3cd9ba51673e8fb4598bf878800a64d4f77c8507233609fa049d2593ad3a2f90fd412a2b75ecf8e67d2976fa1dd7daeeeede10bd4a52169f60fb5dbe05b1af6d42c73691d5350abb8787a71530f61dbdf8f4402ffe5a1437b2a0409277c641fd378d961bdb0958b65c4fb204eb4e4ccf1f53cec4ec466ad8013620d9a238e3318fd12d4668fa9e1fd30c3fc206a456b9db9fc4ac10f198d04b50bf9f4128379ad09ad304f6b06dfdf4fa96cb6be0223e590dec0d43c53c702ccb16099c7fe843cf6885c8b6c2626f5f2a04236ae2753606a6ef42bc791c50981781f34f5fe7127b52099830393abe7cb8aafb6426a96c18eb7e5b50d1a7bf0ac739382e61b7b245213c1c2d27c3b12dc71c3a874a16732c8ccdc47080a18ceedc122976c244c850c9adf70a89f82e585203775051066265ca46f1778cb1a9abe01c7b63ae71bde1711b6d18407ab87503278d86ce82fd604d2ab159f1f0ebdaf56e88b3e4b959f80b0b703949344e4c2c3d5ad7d0814500dde422e4eb7ea392c85feeee882984a7b3805665966ba3340a8e31f24020ec88a2b556587db0204005e2e176ba927d0e4df271988118a5b5a87ca03a10f06fd0453245f17d85ce822fdd87c6dd3cbea8afd682b58bd14b84aaedd83cfe1e57f3883e965ed44466eeab05f8ac68d1bac70f754a67155cb387877a2bf2492230155068831bf5cba8f025b8012e85b144adb2cc7969a391e59eb289f723d1123fa9e7d25d61f934a7e6b51976462870a5f4d31067c3775b05a835dd50117f52e97f9839694cf0f46bdc35e94e6bbdc19db64a7536e807f32656681ac973e3576bb5d9093f60a0558b9833c1b6d3ce21da6166c2d823d647aa6bfac3e64cbfae9e9ad04464746c9ff4bb7333120923a42986676a73054d3a8f81cc944f6a00e04b867ff49e52d4ce6908e0b54485cb0f72abfa0cdfd9d1e728c888788d356b411e9c32b59b06e3cd50e4c5bcb910fca812a787913a7e3f149d84e3988cfe50c5a3a82b224feb421356a5033478d6ea01bb128dc853bd3743a8fd2a03a22119cb47ad8e2d5ffd978876dcdf43a344a08a68cc88711b61113f48a9a24d4cfa337b9e612eb777ebff2e9af5b613d10555a2335bb3b68fe173b956a1d6a35d4f9a0ca24246a9a702deb099cbfffbc1a8e5a4b78e372dd5b5ca8d23386599017f2eec2779112834e09365f8f9d4e27b092ee9382f476ba58a7c7e14f73d411fa35d0baad1d59a069a927db8b1c7dd022b8b1050ec85fadf2abd9a279906ab3970012ace2a6a69ca40231aa0e92a1f6c5d27413925e748c95ec2c088eef1a23ada6d329f630b045c6da8f6167b0e8bf93f2778572b87d824952f6a4367c1afc0b0c251e76c67b315bae9d864627e734bb7322055807da9d5456398b8e394a600237389a13e633c0e0ffbcc3242ae56f3862265ea85be9f7acb1b9147ad250c744ff2e9f2d83258b5b98d9021f757cff55010f02cbc4397b1adb381e85df7763a12f4bdd8c506c7893a23c7b514c70bcaf78fa19263b4a22fb945a2a217b66cc5027d0469906529cce33ce4e1a413beeefa943b0a5d85b7a4789feb101dbe315122b78460ce76294e8f05f8e3f55249a5a5b03069571e3396e9b833210a7f3ed50bd31b9b1a7027ea5f1124970c7df2b31f790364528bbf48cd29bd5eb114b52d891a3f9d0d4327c122628787c6161581373b11348194feecd42532b6c2d645dccc01b3003efc0a7c7c37ecbe822b5606a96776fdaef32b3d8430563300d7e6a8c77f4feb944460ec24653d9abef8347de5241372b97391abbd3e352f5e98d991a31520ec6aac4d3387d80b097afb9cc7215432827845c4ab68ef56b176772d3a32a978b4e1048366587570ae143ac2f4c3cad1eadd458db0357ac634460570b00c569e71fad597823cf7705ab8dc6055c92861d234a1eb51ec7ff35abd70dd2619e6aa89a61ce79b7d1f86608c6666c26b0f1af02d39d99e3bd05fb952845742847566ebb2723f9aa118f8b8b06123477cc425037d1e6d6fafa75e293dcfa732d6ff291434a9699372226b3700423c67a0c155a3518bf4e0dceff360d74e49991e25ef524d7b480bee87b958fdb7a7b7e17a748d307e68c7759f554f8a280ea47e3d02b2a61a02ac5515a9321f9b64e27ccc3022a42bfaf864293a5e7d248937bbd86cac4e6ee75e0b5b5016bee54526458f35ccca0b5974bab6cdc4963d2d2ce6e53122e8dbf2c94193faa8bbb5bf26d90e25b1183a9dcf9e82e0985f5239786f91752f98d9344f9b2de08a92a110e8fbbc03bc071ea326622ff33cf667cf23620a7d8e5b3a5c3abb7048df38fe15f6c28545d8809520c6868b966d9a4acedd1a8c38f2cd3de437a62ff44876dbc0364a0692906dd36c7b7e2b27d531baa3bcf3b28f48ac6b4ad7fb0f68e6b55a0c5fa34cb2bb2af2d611985af39acf5494c16904c8da22e88e44ecad349f99cacc6a16a85f6ab19348ef788268ea138c2dda6146f758e7f0045713e2a44584913dad42668a1ade6eab50111f926fe61cbe03baa7f7c88a5c77dd5164b07b8e352ce515173d1bdc19e3b28c3d08f853c6741b8ee52872eeb73a6ef28cad29af60ca4f295ae751e3cee2f4a680435c9dc51482fbb961a131f227d0dcb6bc9c617000cdb990edf3e3e7011b522b2ab9abdcd774a32ac37525e11cb62c0a7454c1cb077d04e404f013895d29586032cbcac7d4fa3d298adf09ea9b1c2ac457dfbdf0e1e7eb816581f87ea07ecd9a6d7ba6412c8108d2d28ca88137b9954a394d90225d8eab3b97fd930ce28fed6ff3e93a39e8d933c527b515a2dfcc88cd8a8e000d728a7920e64fcfe351fc4a968c7920fd1f87c542952e78506f1741bee84203bc277f39a705191455d09cd487a9c4139c83022007eeafed20d2afc19abc2fe172bb1e70a3dd824f83c52c72277ce422057deaf64d4922895f8fce19736a0dc41703be136bb9bd7eaa067feb619c3766622922bec8e3accc8c424c27c0bff9f4ca7d843979f52a53bdb4af054f99fa2debd8b397222013ad63363e867781c0022744be208fdc39da4122b0330ed4fc5eb287ea46aeca518a67039f01b8361b33c24586fd40cee03e312df55684c316906d635f2da9cd98634e0dd60ac16acfe1982e4c57a789e7bd7768f996811ebf63b091a25c85a1043c5ab76c76f051b4b36beca30e67d8923e30ce701334695c46a9a2261ed3dfd2420d5d692ae8ef4ab4bd0bf752015d695edfef088a11d3e2865f1c11e4e35acff63ad65fc81804121c6381856c370954be91c91b63abaa5ee364d4e363165cf2a127357f320192491a4ca2692b6e6abe428369f4ef478584d6b5b868d85c4bb32a90ff269cbfd6db96b79990d6757e77ad698bba6ae5c0c985d6c99626f3989958bde26a8ae468bb8f55f06f0dd13d5f2ece01a8e50ff850f3a261c4ec61aacd3183a1e8f593e5998a07c693e438e174c5f1406c6f5e085902c6c286fdfa0045ead0748d9eaa6cac2ba0f40e221e28f6f2730676947254aec99d943e648bef93f4adc5922affebb103fd992b331faa25a39e88bf353f7ec9558dd46d542d85ddea8c310394c3feaaf19c7ae79b275532ef3ccd8e8c98aa691f63dd7172c985a5e10cbb55774a5651caefffd85a1a0596ae8534e127847b066466b884ca01868867b37d3af08a47e6eb0ff564a445fb03b2a4bb1b6e617252986aac9200b60bfbcf47efff9a083ed92b3888685b4e8ccb7cd5a356c943d0b29df3bfcea132075f957043c2acd46333b0b13deee2d7a154b23061ad24b8b8aa2d6a02cf237947cdf8b98fd19df12b9942728444adf32ad0710c47677462954838195bab597a20d8212c2a54b2104c9fdb31db623f1755b8a092e9d7a325d4a212b49a69f85882345901df03796a5eed53c68ac312a3ebcbef4604db024b9637243ff8680d12f5518111e80391a4027df94964ddd97a7784628dd3bf91c29fdfe0bf9874fc7cb55d81a7e9e253f689bce627574d6d1f8561e2e25ff54676532ddd29abc5a27d6cb1321cfdacadacd8629ad0a733faeea049006a5e9c5007eec7ef6ce3617cd44e7cfa4bb0489d1660e56e077e4d411f8de10bea1a940596cdcf1968367f80e591566085e48997f7f8e360782297bb5ea4a9f264e639aef8dbf9553eb493360916080e4ec850f7e382a01e7470bb80a73e5b82277780b11ee0c4dd9d9245f18580a12ab20cdf01e4496ea1048991412f37a4c383bbd747f1f17c4893cc2165330120a4b981701ccb7f72d9c2e5ba4c03fdcd3ab7f98f0ff8ef4776461454a8fd2ff41da532e4e447e3593c62d7515c698a128b600cf6a17cfd5ba42b28c90cadb137135fe2098d5088198bda0670499df565af4e61dc2b8ff3ca8900649fce68ff3e975627a69c5b158c3b5865194a4c89380d2dc429148a8c4d1b629f9e71b708731d20c1132fc89bc0640f0543aafb91a49064fef0e7f069d196850c5624254bb5a083f7988ace53892af5cb901e51ea4d873e96bb1f3e89dd0ca16a6076058c40df384b9dcf87d358c97ffb975f78fd6d7018797607f09b71205676127e36e9fa2a6951d0882fadabcb5f7d6c3b42dccc993ef214c2bee92ee175138f72a1e36d29d77477c3ecd2cb3e990a88744bfc143d3378be02c74cd59a884770fef8019b2e2b0be25b18b1dd9715d47b274027467cd68f6fd30d016e5af5d217ff2d92f1c7da1ddccf52b1fe02cf18334224366c7e34ef072c46af581a5ef9b67f8e37cf1cbb91364b446eb0eb67aae80c7b3da1be9b7603997d7c5c9b968f3b4c5279639849daea9058eb275c3c9d06ac9447053e9b0c80bbc990e31e81d0a53ff017cbdd20e89cac353403ac46df6190528a899ae1a2859002eabf3360349cae45e674acc4956b6d46066ee4e39e4e2d6b8bd2cfe36be1edf24be1ae1f9b6c80dda240b0a2deb685d884a267da22c40aa9a5656592aaabf9ee7ef70e11c8543c1ce6a5bba2353fe52e76dfcf5d781a3bde7d657f759b338c121f1c92a617dd587e7f8d13a76b3f1b64c22005921b9b6c96f7de0f7bd6bc9b2a3e2752bfff8284ee1cb19cbce41e622f90bb92b55ce425d6b310cb451626fdfa1c7dedd2039bbaa99f019e3953c8434e2d061117163feb28e8bc2c579aa702ac9dc0a9b491ba3536bd8df57ad2b119b39657d03e219c9268ba95024f38a7c47505733a018ec1fbccdba5519a427aea72fb16f15fe23e9fd0be8fca86bde6476982de30308588df225c32d4e23e6ba2506e7860779f4056f0d9f8adbe76c133fa5db6aa54a55aa8b0af00131176054f1ba5ae7ecea7c5797bf3a8dd50378e71fd48a01a77e1a093b98cabfa2de37813ea516e7449236199928be34d64680f90b2f6f9b076edf9ac920ac7d49b023e37c59b69857cd7bf62b8f541049d7f27dda51b77c514a1510eee84f46f723ba46f54002a3d4f8bdb147de14272078ce9dd4170c79d3b141bfe7797581ef96b39f71fe65ec99910e1023df966d0f49b3a483cdbe2314f0aa9a9fd64cccc834045da34cde353931a9ba44e2578991befeabcf6ca0e957e3ec29ee90e592f8e12668d34e99c6eb5ef30ee4939bea08c38db7990c00a39a714d5dce2fef1a0f19e40343c3adbd327ecf44ac738a980dd5f0bb6e7ed034f97f703d04a5f1d2cdc6946ec34c6c5851f93d577675c047874fc8babfb151d79facffa964a273f392d138cf1dd10160b8e958075d7792040d428dd100fa46241a1f75a0ebf5cd1c43c1dd36b07db7afd3001b3e309729bd162b435a60cf3f38a2acdd140a16a95ad84b79523eaabdfdd01554c12ed291ae4d27272fc9f607fb9fbc3e4c85309847c9f046cefd4ee9045a40433f7f7f2f15d7e92189474201756169ee5859f9345fc11f388cfd515614d8f751b759bbfc54cb2d0a79f237cf22dd5b49b06623be796efcc4c121ce1eef0a2e77ee6a5ce9e221d311a48d032ecda40a082081b40e0420a0c44dbcd2b06b38b5489e53e6e14f238e383e1f60396ded82cc638009593c932af70408e51f9dda720814f707148955a53f174721b6319b0db310475fd4c853433648f92887f3212b54cae8b852857d413d04a0d586732eb59fd6df4d3c71aac863ac6c0ffa04cd8ea308984b9016a5d6d3bd7eb0c63aaf254e34bb8bcf7be205364b5000fe806293896b67cb2cd5538e7fcb88b1be52ec51e14233dca2037d3767f8d1c476bc4c6b71828a67aeda4dfb1d676d4cde30ead5d469e7403d83cf0405405c4bbc1c55f813603b916428f045e7c5d64b8465e98511adfc06d8a993a6c3aefcf798f705096b7a98ca5c88f7c25ea128f4ff51e35a3129d20c2865ed2462b13b5cfc9c4758646f5220b5e083d947c8f11ec0635e54adb3e3b3e32da95040488e982745a709ce56e390026cf9ac77f3c1e48d64a8dbf76d2dc4066909b09c9cddfad0fa8e1790d403c578b3ad5afb1593ebcf06f3a237c984a43186b3d911b06d04cf543b87cc92d5d0db597f58936a0bb0b02b5ae1d29acfa70dbdcf1fd21247c0a6266bb3b21fcbca554633ee6dfac6f887a8fedf53bc47b651e3c598b18c30a619c9657fb9d5669993288b0d0682010633b88901c03daf18eb834ca74438fe665430f5bb0d4f53bd5746cd41d9d7cfba01b766254e592551533043288580c91e62aa7bb6ef19c8a46e3705156e48a6d3f228c53f651bd7232421bd999b7c556a75a66ca569c1cda57951dc804b075ddbd4f2fb757a898760ea8a18833ae21807173b92c35999a71ba04635a9795c9e57a5fefa2a868a7417b77c8ff1c262b8086457694d29152120a233ccba27f0551ecc5dc14f3170dc71addb4254a35550db5a87bce9603378c0ce4b4b77656dcb4ea31adfbcf66a7531d959b7a3f5ba6fc154091c3078ee198a73962c12432db27d0047ec97673a4306af1ed208b2d756d7bc89894b2c9141eb07e1d4d95d0ffc5d96667f7d864528dcd496262a67e1603e7fc4faa062d5a2b16d7dd078996ddf2a0d941b8750d26f07bf92f05ea148941af9fb978167a545e8c8bc7e0cfef00aac2b1c321c08f15db49193e856903da4826cdb65e2b726e147573e1f625a989030b2e4a1712b42d6089712a9958e58354b11a8a430f7f8c3dda12b3ad5a286fc4972dc4d05f2deeafec8caa16798694b0cf75d56e06a40e59d6099968f4ced2477ac233d06cadfcf04292ca87d35a39548a832accf7f49bd74c58fb75af1da02fb924b7378c60c8db97f1ce526378a1fd4a499c17d624ad5352e62d48cd65fcbdaef11ebe8ecd66fe110c23e4b5703c35a7bbda975bca0e8ba407f299644f4788b8637f8e1b5ee911e27ae39a85db9abf7a93f0d01c5dc1cd42fd960afd3362e5dd6db749ae3378d82d843482f641e84b7ad0595c8091b77ef53528e0ab4cc5258250b40f95ccdaf433958b869695c6dc0af0ef42cbc2db031007502d81ddb5c7becd3586f9cb2f3706b5eb133a4cb1c3b23491d1b6ff8348180418b83984b86345d3524cff2ec9e1270223904aa1b7329ba0942dc9b033ed1ff4888d99a4a05480ae90f6a848329d6d99656d16700523a35c3541bda2116251a009d32a5b9dd9d0e73b4a7e98076ec84fa92b29e077ad27c05c11bf6a1cb7a05e8d9352d2fb71968a3cac77cbedc285b755535e75c3f5d6aece0bd091842b09392b4c6963e47924c89c9943b8381d79c2ada5be44d684e48605b72fc36cf0e2ccaabcafb7a30af761aaa42fe2c7c84538c781454d6853f53bf907aba844df4cc77b3c933f89db538d25dbca19213c832e3581ce79b1466271d37e76e7574df2984be3da9d2885c2e57edfd13a5b750a091299a2cf2990ad24731ec6b7ae022a8e8232ad640388acdaa32d0f27cf69cad0777096a820636626442ffbd033a23f65a2c1e9346be94576a01b2fa0f175690fe3bc8191e014f959b7ea950a52eb24e7e4af83fcfae2047beabcd6572643aa1616afaa42198297c6be1144022d9a9453abf7f5c257f8045a3e44fd9c034970cba94f59d3ca08e7d8b0932148b5532ab30e67162a31846dd4408864f74ce00ee89187ef34e036193a9dfa58cf571af6868ea4c79890c13c8ff29e04ee7192351a8bb008df68e62b2bade3d65fa76a49d50d4e2d958f2dae82863ed2826240d83ddd0bcca5f6c080ea2fe572343410ec3b6a2caf096dc04b42b7b59c783720b47b678a0576cf18bf5d81348d0ac539da1761889e2fa378315c6a608af20e573b75c9a8a8dedfedd592716deb12e1e4b4fd260e89203e1c1d7a7b47376f3d45d1e419636fb8a561467e786de733db82c77c01f6b8249b7e3a7a489344a3b663e0e611588627efa7020728ba02d2cebba11cdb350416d8eb2e0d05156ea4b3008c5caf93b7d932aee1ff8f3718c594cbd31dc0ea9f547174488a1a2b19945a581a09d73847d11546f2e5f6b8116677763654d01e9d2c7287d09fd60866ae1cc4168b7f8ac0e00198576f913e06fe16d971660f5d5cbb7b7798255288745f511deacb85344abdc3c9f659c167b7c46f058b0fecaa3b1d8fcfb5da9f741eab2eadf95f3cdf633afbc1ecd1d6c68a2378e9811db6a9a92f93cd0251944652a9e52bc25865e41a66a6929c30f00262d7ed38eb6d31ada1271367a0ff4e1da75a3bdb8f89576c7497e1c4cfac8ce1ade12fcc908c654c29578a6d145b055ad150b8d512ad8db12fc167b82e082d27f310c4dbb6a72014f4f38a8c5f51763e7ddc278da2e152368340a5aa8acf25c4acd8a022748d3d63396ba76602e966f52b468549e32f2ace41eac15ef1136b7f0efb52731963822a54b563211694ef752ac8ba1f839855c28867b0970ead2ad3bb2fdf55f301d7f66311d646a16e17e565819f6a092826d80c234becbec67d60442c2a5edb3a5a814b30784aea5549aaa8969df32af0b6557b06590e1bf94bce7f92e281cb531e3522222c98c7fd03a070bff7d2742085c35042db9416dd9d954fe56bd3955b3957a4b6e549c5de361862c9e11644ea17c50a87cb2bc5e9fc3e47f153f192e2f877dc2f84428072f156606167b297da2503fe070807da2527b4cdce62255a5d764167a3aaeedbdb5153bd13407fe31cb3314ab037864c3373dd3e0f63a0ebb3047e1972b42144424c53e0ea20184168317443d16cd423cd9f80f9fcaea89be8ad66a557c82baada6ac14a4aabd7b6ac454ce34bf5e7b8256d6a7d49c0ff7a06ad6f0514729afa1dba20f5fb8a29a3110949a7d2b51a95fa4f6853efa36d80e1b25cd84fb264a89ae1d7dc710621b6df46c0609c440f5715a0cb268b53712efce596397f4ea595da96e233d7156a7efdd1495ab92d93e99054ec064e4fe4ed764915a42d1979b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
