<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9553d41824246d0cc680d4bdcd664cae6bff91f65c2210fb3fc4f43699b896eda4dbd1a3400f18ba70da001a67574d004fb91b1fec4459ae7e048f051ac9b204d6cb9ee0717405e4a69df40d100671ad55d1f10c81ccb722e3a75e75ad0709c5e4b6e908503e16cbe632a910abd8f1955d0e3df478afe9508e614a4c79a6a009859770a26de9c5e3a90a0b5346db26fabd979674a9522af527c7cbd6615d53d8f68716c6c68dcf17ed2b2f4c091744a418bd64edfb9da79fd0a57fc9f267f2f34570b46873c3839d6d4d7ff1089684e6dfd0cfe04ae8fcf3c5ec02c50532216b1ddd3bcffadccb315b09721ab45a727466d05ea21fb6e6e6b174699153729231f861d4cde066168d0cd93ef3a4d6fe2b04c8eead9fd4df115606effb6071977c51e79306fbc53c4404743934a325b34491c38879433f57239607ccbb7b758653fe8bced301401f47ceac827e02fa36502c9b3f5b8b9f983f5bc7239cdb30774834674406500bc18b7ffd98aee2dd606f5c17456fe7bd7bf85080b04073957a0492e9cddba71ac78e1d9963a7fa08ebaf0db98ca70e85bdfcf817aa19f620db169b779fd5510b177625b798e4d43d9bfbaeb985f2231169cf03ff58914f19ef515207ab5cee74568f4bfe89fd69e7f5f60114d4276d221c8b148c47fada22ac9954532b07309b4a1f7253ef70de001af116addc92b09b37fa14df0a8a14cead1d7fab9594ed839359840a9e324395e8e7d6a549f39af6e714d8ec6dcabf5100aa8a5ea3fb81a74ab6e277327fc24f90deaeb340fa6b8dd2b4d3875f2235bf071301c01e691bce9043eda78ff262b7a7b90f0d7b1c0d5ec1992db465b1bfb3acbc9e8bda82c91346c275335a834f214b21286c3595574be94f4e4a7b9927e3ed30200afd32e40e9449d6c1a01ee4b451832711a11afa3844ac02926f71a42ad4c7801a0d8c0cca57a1a3099f5f2f6f51bbb0b5dc3a5cccbd88ccdda486b3379d3be9482eaf20b74d9500efbd3b66ae1e964416b72ee1c50fa9fb48790383cf4ef0d58712042f9e9a077b9ea80b893a10e1f8e49cc4d4b79a311bc82d9e711adb5959a716022b856ede722b4b93ea782e858232981cdce5f0fecd55dcdba83a7ca6d32c31d34b55753064ead6d11bd5ed3c2e25f5270c61105b355fe75c4c058a9dc6bec9516ae6705c57a034a8a1f1884a8dd09e6b7a3abea6b5663408f55cdd4d633b63b9984c98be5170c8bc71327d31161ff30eea57985055569ca737f0cf59bcf3a87a6a32d19498437eb6d8bd8937127d2b5abcb91763e186af7e35fe9e4a6c6b61a40db4791229ba57704d031c084d8059258e99fc6b3685f754721192aec4d14d89b5083aa092629a98bb5c8d51f30072dc7ecee8ff3dccb5f9bd78e92a0cd97b0f1a7f9c2e5b93f1e67d0c48a748e3a9359eab942de270a8cc24bd6161468c5bdf59cfeec99d77c3751f87a7d655ef8c9a1f277c524754c9f0d9d1fdc15e7d4fc43f18814698516d8d489b9b5f812ac4939ef5bde99ba6799ef36765c8aecadda4838a24f12f146a943dbe0e3667847c0fc14088e2d2c65d97e1f0d95767ed582da8a86e2b6838060f4101f45925879140bdaab414de196867668c4950aa5689f07b6ac5cf9f65e6512c0aae0467105d18b8d1f20b1be6ff879a5609fb2f22c09f68b2d5f7ed7b83af2852c5c26dd137d618d8c1df55ae6851c2e8580b4fb8911cd7a198ae3e2a0b148fb7dad3218eb3e17d9eeef064c00f92b7e1f64ef99ad1b308c7ee094682fb2a4cced6f10a41df28d378ac704cc11f363f1f352bb1ae7baf81312ba56d7181fd721e969fb5d1cfdbad6572b1a4ea04e72d7d5d768b4d4588edbf7781adfb0ee34856e5b292cd7924e6b239cef9def2610dd65188925d05fb2fd1dc3f796b30afc5e77f6d66fb2d62f531e5474d09c7b9c28b627d13063d33ca9075394df57c7d9d445e5b14993987728f8b62050ce136b58d21551f96aecf6caa0a096073aeca04d7870dcfc09e2ec427908253482c0a87f9e285f66cc1de63f30644427a3a107fe84cb44bb96f61844dfb1b64750f3e0c939baa51b114c375d3ebde93a7cea5e98e4e294bc67cdd043608a514ec0dee22ed096d4f0a37dc4a978ddb739e33a00afbfaf4517ff7778a13c2d3ee3ab2847bbabe00015745e9503855e6129d42db32de3e62aa00cd06b13cfd2855e1af1804a3ec7b9dfebbd140691d2ebebb92aa3dc8fb16b4c1cdd30bdfa95ff99fd1669106fc47347a67f8954b9cc7c7640e46e1b38404020cf7543339fa0db50b5a41970c14cfb0bd69b3094f6cf93b31ebdde4f374b0a76b478dd0e9bb62fff502b696a0e64d2937c7738f94ddae38dda3837a4209413b228177ba65edac701c2ae4d28d496176d53935bcccf9597b3a395b778fcbb37f356ce2037fc7d1184e35c37133a8780c07ee4d0a528e2d9aad2da606ca173fb1e04373eb2e03ce689ec5e6afa6bfd75d385115e1c7b9bee06008ee988fc13af85fecdcad9a61f9930f32cd7ebecf328fd2b3eac183ba18f81d5263459ba013b86c34ca3c022675a2c4d1bd84b3df7bba397008a94c04818156bb75af1dd820f72d145c05b37cc74acb5d94c4dc6ce67a9898685933ccf72b162bcfe009a5d57fc3a4d90d383f22d542a31686f2f6d69680e11773ca007ddbafb8ee540f10e18b7bad69e15254d7bcedf3b84b2635ce2eaac38d4396345fc22468a62629051d2941b3b2d6c2cfff2ea041487b87fbd5cd6d47815415708f78226614889bcb3d47540f4cdde4a05ddc3984f87398985eb08e6b25b03cb73e9e4836c4ce4f43143f592038a7d32015b4168f4701a8707ef93acf823e69a4672bc34306a4b0a0eb9b1068f41b3208a8c829d589cf98535c203525aab897777696dd670701ba586d264afffd3880e0e5f596985fda327d00479aaadf5b83cfbdb4aa7ceab3ecbdc1a7473d1f16e704c4742d39a4b08552cc175fc8e04c84c915093e8b252d124bd078348fd1f08b7095fc58e7cb5464fb963eee6e84e1a52bbb6134182e4637c3852f326555a37c1e0ae2efb18f2eb3af379ed819b16fc80b432dcca1dcec56e8df08ca37d572006600a2982364ec0f29f2e6ad6a8f12dfd521820b3671bc4dd8714077aa6cc63c72e13d86b364b74dd57085bb082e26a1bf31dfddd11e570f40de0e8e2884395642333a6dd98f2c6c16de88e5d37708b80af5f65f1f415708f8c19e7837bd08aeb7cc7e09541e5ace9c97be5830ea146d7ce0d5bd7a082a1de0bb021bb3fa65a3b4ecc99a53f0afda2459a0fdf45d515b575567be549f782bbe174c2905586fc2524a72d533fe396ac072f08ab73a2733cfd74c04745f163f7cffcad3b61823d2f7384a4730d7ebbe63a1730192e7599cdfeb00b3eb18c2a4519906d9e5d5ad4e08804e320c50beb2145ed305bc46327bad5d9f24c3ab38a4ec20489772552f17a1f2cbcb02633279433e80464d9af1d1c731c117a239bb37cadb9f50f4128bb32dad457d2f16070f9d36d5a6c3275992b6f846fb4565485f170995753f9f478ca542a395cc48f2bae929b052ca8f961acb8fc26662a61b50df24c153febf274deca7671545c67b7279f2e7360095ea94c955dbaea898222bdf6a55ac7c5436ff5c23ce2eb23b71c5adcbefb24642669921e39271400581c87a881dd98cb496d5d6773378d0fea0ad6493ccdd111040e36a50f8c2538e8e4f10e68c7191a663500750cdf2536ae7e3af3075963ec03ce786fa3df77f8994daff8ff4d8974bb8ecf0ae47ed91c535d66441f7986f33659b5cefc73ffea1389f6bdba5749d9987fcc5f28c50f4973782f90e53c1d324e07fba3d2825d2521117cf40eade3ef8690675fc3fc6c6466c61527cab64c18ab5310eee85babef59b7f809d7c1904e5c9686b6e54b54cbbe41b957c0062e1a0b39f11327073290191f02e3389cd266cf8b938b2fd8bf422af98f5d991f16c048d29c1dc769389d84ee70d26e98c80d77fb9220d86c93964e0e1c0d1d1732ae183d4c4b0655d861e1a3c8e26af8a0409dcda52aa619290ff651a0640e20970fdab94fb10d859dbfe1762c22b6588d5eeb569238c34e09d8be23c6c6ea7f34f169ad524929af5abebf12b24fc20a41f21db1a59f645d9305596c013e6381057dd19a7e6ad8d7f83bd1e90686f25123d1512686e6f29c80807d6d73b2a0db316e3e9c9a2fdf0f70297f7621e55183a76dd5673b1a5e917839db8c6ee33c1543cecd719cd04c888154d2b82c4cbbf4924f76515e69c56348cd31c75828a6ee244217ffe435a6ecf573f6785254689538a0e7d9d35a357db7aa54fb35fd1dc4fec6daac51b30dc7a1bc1914cfae939d1bd04552c543b20c4bc42f7ddd7f40d2ee3cf25d9879c0f26a35e2acfe1ef3bf20ea7b80dbd0162fcd52511c2824fc50fca96f747abd9a6f60be780b6d583c6e4bb084579c6bcf950221eef390d07ca08ffff3d8ac81ec124a091b8bc3b099bbe468da0c4a7f8022f1116232af8242af155fa77c52b7f3ccd0da4c3feae78fa8c9fa1e6af25e44d9bacdd6a26f1a4032363920f5308ebd6f8fe07ef2a9c642bf49cbdc19304c2b4554980da70dbab44597cfce0cf7274bb9a3df3b85dc279571913e6c8c681d6804bd2a2995281437a24f268969cc22ab9d93edbdaa6bc7bdf47649abfe0f5f58a58f7015655f8eb5e1f46a27dfacc58f4d3d0b4032a1e8c0195b4034f7d1086d89c0cb43fdefe5dcd935f787b8c420a6219ba1d476c352dd4ee5712d5cbe4e8c2500292c67db648aa8cc1b6789faf9cf72838c040895da016c723a2c5b866bec3a957298539e75c12b8ef9e982377eb7ef0b7ba4f4afb1f98d84fa166d073ba214a9e363e82adf6122bece330ea6fb3e6e2bce88712556e7cae80f93b38deaa24381d4f7e0828276b21a97634b1a0467b024e45972dfcb8edd33d969c6224e6e29dae9ddab6e32f5ffc56f912cd008ce43e207a3b8c839bef3b4e70e33976dfc4ac26b2bc6d185d39fd6da80cae2d49bf98b78e461b8241559100f90368bb6bc8e1d50b24d97d2926ee88f7d9e475c1fe537e5b054d01c8957cce34d5a0b3ed8de2d90f7b7407d906a11d34c591afc662ad62a52d59ba7ffaf9561030873fdbeebfeb48a68e6e0d784fd31d3ba4092acaa86325414aebc166be0c9b5f3b7416c71d4df6f3819ff6bdbfd0dada69a5d8d8d1e182a2a6d2e8fd30386a3b8d6678077e00aa1eff9f089f8ed4fb9210e4129a35a40034943ea4a73d141c36bb5eb80716451a5b84181de5032c861ab2036ca9e59b04206b214db99071318f06cf0a6ca45952289ade313f1a75fa972a23e1301dd4acbd5a0aa4b1359aa279df2bebd1d33c90dcd806456f4fcb1ee443f61c4d6c8650d34ae217d138c0171b66ced58151936027572a204620d82949b61b883ab8864858b84d3d3953b4f01b497cc2e80a6341c66f35c4d01d8e9bcf5ff502dfc7cb0a27534a13b1af9d958ffdb7b6763e31e8e7b65ba3c32655368dc50fc3266dadb274413fca8ffac77178efd488fef83481567bbb08b4d6bba29fdfdec96be64f336570a329c641483cc7c4f8ad52c0966ed3a21387fc6c93602586ed51f557fbe09fc3faf471b2e5d13f428708983c99f821bb67cd96757e0d1dae101d97b842ca4f9cf144f6f06c25768c4ef7d2fc14b785111bfd5f97ab07d5c73c7735e17598103377efd9b3a0e7d5b604d5a74bbcf9fd8e5509ffc22e11eb35abcd48f5e7c22d2e4edcbc43a1db4440c53585cc0c4f4f42db7885d5e160e1f3ef108108c1d9acea4b8e6a5ab836c65ba15022a39fd1cdacda176c7ce44dab6ed1e424ce79983ec5df037e31013f68d2c4ee52ee35248ab5f9b1a762f4f21b8ebc2208219162b0f8ac30dbd820933341c559e70c31504938b063b5d3b56f70a7097f268cc6658fa4c45fa0851fc824997e4afcfc4a2251c13c2a6559a712e839e0cc0d8b9873930aac25cc830fbf5f67f3aac068ed03f12a9f781225ac8cae1d491d93ef1e4d60a05e303553d14ad945dfd93b9edcbd9ac01095e22f4a6797d23040c0067b74c03cb0336ffc9c2b5492ab1f2481d61983327dd848096cb1109e86b7d9c5fea932a0eceae7a93e1959d7708d2fcba550bf128578d53ab6336990936174626be8f8d170ed3cf6a6f0dc26407c088b6149656e1e8222e0fe067e2f4c220b7bc4d31ba0ba06362d3d85de80b700a7826c76b4fafddb46715cd0217ca4b8d86e341eab90a612c4606ddb2e9af5b4d105604afdc20621e0a2799a03122b17984873a4e802cf5469bde2136aabfcc965cd389b9a714ee937c73ce4634e68e1c77b1dbe3dd688ed693b75b04cf15dc8bd505dc695fef9a09660731b9495eb25fd9040a423923dcb584cd60607e3817ed063c77524e7a4b9d5e2cad2b43a4d0d948fc2d831e92c73d7b0fc1dd094f8334c06e71591b9836165b42d9d124ed49344760250a6b04c48b9bb747bb0790b3e9af6ec55d5a0ca1bc0dc89261d4773eb702c28ad8a839365699d89038b35c683d9688b1cc209e3b2a37940df1556ad561b0119bfadc1097fb3a54bbe74b71ea3989893001c124ff50b7657feb34d0204912f3b7d365df08ef220433a92ce2c4b1a9199c17236be92cfe2c09c9c987e7497c78b1dc21256b9b18b67b881389b8c12bce0745460b17d37efdaf67a7d627ce08b31029b9d1a28a1de14c5c00f2dacf0d29213a3247ef11d89c508977ccf70355b5390c7b439c987232b988bbb0dd30166a694372fd656a0f0db26b55bd6eaf2edf3f6ea089e077c7d34e381ba8dce69bf928d063e4fd9479cae457d391189cb458c1240cb02a46ebf62abf6cda980af9cec9c27dd2c96d5b09a05d6f2d18ccc3855e66ba60ea6b7141f12632466fc6db651c5f389330412ac87b62c1c890867799a4b90e12e990bc2cfee69da8f360132fa9e1436d48c63cae6be74ce2eb0f279b8cc519c645bd40bf1e33a2cf478905dba6580adf8c7b44a6d603f54d83c9fc534062755097b22f74aa2a0d604279c85acc31e0e172de462cb609c1902af0a75fcdef12a9cbef2f1e0b61dafd87639c2fc72cce43404422af1175d13c05d453b811693f7e47a17043859648f76e8d1abb2d904261cbd60fd80c120e9988b4310247884ad80bc088b40abeb88a73383c3cce368d129c4f2b980fc0be9764e33c894aabf0e5348560c7840e01d4714daafdcf7b8fe009a86e65ddb1d570bd200e47f739b4674ea41581ef99de5f6ce7aff93ffc8cbc2175b25399bd45441d007e64547a7add2422049507e0de017ede80df6fc99eab8e50924f027c2d68d6657e3b39ce523cc409ff8e852d36d54005a234fa09ace34964b44f750f01c4e8f0164c9c12c9df7c049e1d6684b0ebeea37963ea3a32c4f53118694c05fdc5038bf753f8b55984bf20c8eca44ffad913468bb1ddffa2389c44967becd67fbcb3e990df3a70706041d7b31a168b05e84f4fc60c70aa1e29605e988af1861efb8d217c8d25eefe656a0a6d38a123e5e2feef67e1c38ebc994e06e748088887a0a711fa5769583e44476f6e20c9d3e16741b1ac703237a368e0c2460ede6c6a2c231647508cd7a285e67bd49459df3a9a9f627b09b5b3cc0a7b1d1ef7c5ed3b6d15c5f573a9feb4a231f73faf2eaeb83900e0d3cd74ea54e68392567641eb9202d418cd77dc409f49420621320e551632bf25d3d3b8f074b9ffe490de7bd47af09a4c5045ace47dff60c361c5bb743086c9fd79d767e6ef010ba934e319d081f4dcadbd35c96b165d198f86181f228f24371c5b857b4e524d5066166fc7556ceb8af0688e30ecdba06e18717fe04ddc18fe69f648d9a695283ba65be63386748913ad82cd566c1fb1c57cd7f534aaabbf2195e2eaf11c508970343c0f2049155924fedf8933439aaf81ebfd5f7d3fdb3c063d8d52f0e709fcd4daa497b0033ff3768d98f85b05826f5eac8b24bd552c227f9cdd3458de9740a22905f5f06dd3797d9b7f97a1cd7d4509bff0a497cd3c83f6a5c5c372f8fb9a741a4c1c01138036c185cf924eadc2fa71f3a33b428a1231004fa599a56cd64afa6e0c3f01eb8cb17d19835bf4ea1fc3888528e0427d175f77592a0bd3e5f932d698d5aa1d6142d3a2b6942bf8dc6ca6607d0b8224dfed83f6d69239a6e501fb26695b4fa11358dea4e1fe380ea249032ef4f2cc8f5e1e0016b691d5318db98a87794093c3d428b096218e9a6487e66a80e5b1734d2f27ec22bcd97175470f0875a41dd62396d0c66a14ac57fab86df0ff70537596a36575b459f7ed165653a05fd06127264318ea8b74b8b022819a151b7ec5d2f1409efbc4e8733bc61ffb46f7db1480213598028d06b7642f6db2394443eea80f70b5bb931d0411440b1e9c75d059dfe9fe15fa2a998aebc2a0a953a8c06b1ca114e6cfb22b813a4866b0f8baf2d5f35a12ab71188b18a368cb7c1e0c8fc7539f4d217886aa93024e915e759b7f37ac276154cb4752690f6ccb4089b2aee1e83be2e8466db158c58394d0c82395cc6f558eb6ac991f1444b7fd072ced4c6cd4707206dc99739907a51409a9645f4b58566e8ca8411938277c88eaca79e923b48f6941d1ecde80693fc6dce26bd9cd0e2e12ca4d60782bfacd61b3093f491d81204bb0f7e93cc648ddedc1b87c2c870d0615a6e28dd9c43e7f35c0fbc5eae0f214f8593a84cfbe315afe428dba1e8965a7500a4d63106789eeb9336bb78e027815022e08cf37db42457a90e7da6cc4733dd47bad6964d6febc9f0066a99dec3c33d3de4441b6fb16837018c78ea9f1905acdfb00f4becc28e6df2d84da143b7f3b4b4bce558cf26cb10e4be1a90670d938090ba535cd4096a502443d4753eeab155883adaf94a8662338f85f5be06b387fbf1c6559b44d48416b1779731e35fe43eb0908a92a9c5ab2734e4e814fe954ba090887056d04982c38248739b7e2c5646002c8519cbd2d022b2ed873248f7cccd32a871050e419fca8e93dd7b0c7036a838b0dab6fc44a2030e8d376f3765b130646969f4ec2dc03ab0c1fde24a2429accbf28d42d273ee754b2d028ed16a01107b78bb25e99de452b6e795d69c0d461d9f40ffff6ff960411de8b9cc176c9506e9c205ecd4c184169bf948dc10c123e315d028d0ffb3aad5421caabe6238461547dbb8fe73b04fa5392875199b16597f84a8c203f36cae1467bf96f217c4cdd5987cfa805b2a0dc0ff4725e81258c87ec5ed362d5b8c7043a2315465f5da299b423842745e1828db1ad1b1521617138954cbc8d7ae4fe549536a7fed1c6c98817c9e880eb94b2ba444473fb3bb56a9d17dc4085d5da8ed2599ea56e6a51483f4754f63913af7798b2eb78a32eb64fd194798f95d748a20766b5402f9d1e1a7651b50e3abb5abf9442931a3d1b63e65235782744d6e8fd400e222dca261a2656814c3066f15ba91f40b48efdce90c08b8846bfd7d8c8c0556cbf5fa27a87c5a8b0a76a361c3854b0172a18b6eefa823b9688218773ba0c1f2cb45469591547f71fa5c505a232cdae1c3c224a020b7f11b4fcb539f76ab17d7ff7e69788ca731a539540bcf13ca6f247af9d61f7b2cdce183c2202306735a3defa357054383f760b3b275b7494f059f040f88cb290f4f783c6bf3a3d5a1ac8370c2d7bdf5ddaf2be53e4de66035e3ce65590c5f4d878017458da4056c0d95cb9f5d26c59063283e21e21e2fc64c6085f928d248e6747a8c671d501d223050324ef68f32fcdf82b018da787eb984de480b4407048b3d39c262b9412da9492c16d18250159480b070afccc8caf6f81316aabb0522e4d94fc1405777973cb9d55e4f7c595fc57a9ee4eed2c3724213b3411539955daf43c9a7aac4c3828c894f6e6a794f526b9bd410bd45564a5eb4ee5e3d6c62e975b4aeca6a8c24092c17ef07a871bbc0da7f91ef674e4d2ae3e8318d2a4d9fe7350987b9ff70fb6add31f697858f4f62799ac1ffd3e68cb6538ea82c36964f3f68cb40dc5d0b87c9dcce0892adb4b478247daf030981502fc69616e16c31fb805b00761fafee9533a81e51a440ad3eb744a021ba6bcd3c4e7f911e567172319ee5179ab2a70c44328ea63ad0ee97da664353fffb96af41b2a82ae4a4c456757e1f5ea6ed3207175202c66a52d66dd29ca23fb7c337f72a2aa59647b3a9540b4e5ea1f9ba8bc91e680f39d35b669a25824eb7044000b4351230243a942cc67c4c68d132fa68872cb6b43ca77dc8524513c91a8c4042e8340757d92ce1ccd307bee0c01ad699370c0c0fbf5e14d13b0cbb166fab0f7768cfb76453425a8d2c462a6d4c4ab2b438c41b76d9ebf4b2469b154cb3aaa67498050f1002457db542094131bf0d1ca69840262a3b6d2aec11433040e4c20e45919fcf69da80e1b6c1f1bcc30fb2ba749b6986e5d590d86bc06bce484cfa1497559fdb06c81508f1d54f54c36ac837cb1cca4afdaf1cc1ffd71f281e205cae028be33f380abf846ce8eac8d65c3363146798bc287136762cfa45cafb015304630321c3a8195e24c2052a1c17113e9b2e62428ca5c80ab868b55d14e501f5fec76790d70de86c24f49f8514d1e92c7a7d33f6907035fcf2b1c78bbe133bbf14db2564cf8951641792b8f2a738f7ebbbd66593b21a7b4f85187dbf7c0d42873f57d8a1aed41317c945fff7155a5c82ec6e922d2686b3197e38e3d3f6efc66b288bf469e863c163023b8c387a82e4397bf15d1a4672408d540b20ff6fb70306bac64ef108c1e6785f13ea1fc40c93a0e614a29b47a7c8cdc30aff6432e116f61ad14d9423d85f41cf22a3dc757266229ce147c6ea470c2aa28712abf7f655513fbf0a04bbe34919e2aa67861851c6248307419cffab27865225d16d77f259931abbf82d4934e9bffda50e9b8eca246aaf6b56a92abbd9e7901dd9210cc962e476c6cac5b4cff351937e4f9d57c42d18ab2c9ca44a181b28a93f371d3b156a48d0e5256dae8b1d71ef9d07ae84327a894df3239f9b8a1bc083a5cfd8d3dce707070d6d5b67502201009d7a96494835c804d7191433f0c01c8f60cba2ea84a488628fcc3ab0573157779269b8e0d698c69122ad79f84f2a11dd7fb660d3acc112c67cd45c173e82da9a58a3f0481e35b4706bf82f1c365b6a1bfc92e5bfeb550b4af80f0ab73ba7d22026cd093cfae54aef89973e870e93e5922c6ebb39d0af1f3eb885d483a9ab1e4b47d936c499979d23e7b451a32a0d8e23a1945ddb914376bcf9a9c4d81cefe244dc26ec290273576bcf390e9737a1c7a8f02f8316ea2ba8ffbafac13d6e1703562d0ccafe2936a21f7f788ea495e2b92b4f15ac0374bfe9f9670a8c7f033c8efee0cb5b69f3922abd913465f515685862bab3aadb87135d89d45e6401787d8862215d3db44565e1a3a8da1edc47f69ec1783d76e79e169c698611fde2701ec8dd1d7050429fd1486fc69ef49b89332925f9ce23b37beecdb646a56f4a6739cebc3b0ddd5d72fe02dd6c0b507a684ade9dd48148c8365ee629ae3d8ece6481300a3840f377f3660665b8c5c1dfe7dd0f7c537c6d0217df8ea69035cd761ef392cc3e2ed2f1746f61353f98c4c947e9145bfe45d26fc6c4c8eedc20846fff9690fdaeec08b802e0ed3b922b9fff0d62b19861be69ab345578f364fb0a5a0d5540dfa160954e7882bb0a4585c5b0400fea616f826b587f44443198291aa9ea1c783ee837c9be1aff597f125dda8555acd918a3aec53f9ec27b6c7ef69eda74fe118cb1eaad58395e0a73dfd6082acf72049b72f945cc48236aa535080aa5683a6176f4db1f231f87218e7a70eb8adfba56ce16c00cde136b48a3f193a8414c0014a808f79352a0aa2b6d1c8f9c948abf3c9dbfb7a6a0ecee6b3764e97212268baaac5ba49068474653919bef982022c67dc0242eaaca35004e8429e56b5124511d3a7ad1108bc92cd9bff02b9928765191a839341e5817142f1e7797e94f2cfc9912d8e34fbae9d2c58042d371dc8340e204df0c9fe8efe99c3bc759f57b915f8407ab3999db5da60ee62b99c62e7b8ada2a5dcbd024362c874518cd9bfe68e93598ee11904abc4061b1f185b2113a63c76e43df6f4a296eaddb209d9a751c473bd2ab047ec7a3bb6701b5fe39aff87dc27a875de07323d538447bec1e0d192e45a50392eee29823f2d384c6ad9aae0b916781dc52ff898ae5c96bb531f2d26fc20e0edf3d2d26a4cb7cb84db776b549268975db27175c8c31877597d2e333beb6517ef96b065d56cae0cd230f8f845aea6c1b35f3de922f02cc676d8d600059620ee35ab96c8c95227ca5e238c143cb1d6051647f1a17a9679f35cfd50c617a8d9184fd50e22578d811506fc266eab4a79d9fb557773265a35d50f6a6ca1aa097f48c2adb90d31b77c30c50f5d6d6c01e8b93f907f104e84fe15e045ac321ae82d696c7faff2ca82ed8cc80f73fe13aa5158d33f5c39982ea6782390a33de5bb8b9706a158868b9ee27fe39774cbf02f13b0ad50bd57219d8e9123f0eeeb51047eb95357a6fc8f6c5e343155f2b9a0e159882c854245db77d5ca58ee62838a99c3744f46fc7a5ea6e2c8403f8c4233bec108ce37c294e73e68cc6a53360097812ae89dc92272456a5827655ce771f106694badb73ab952a6c2bc2b7a3a8b71106b92e563441f2ded043ed136a688e8a84083419c49115cd0a47158c6df4196b5936b4d087b69462efc06c6dd281fd10ce3a7c783a36274cc602ded1a70fa7a2c62556fa1ac7f66c59b33955582d3ac8220c894351ed8c50dcf2efc29af1d6ed19187abb4348aa24c4e5d3bd125fd72971d5536b60dd8a74f00149a011f58a1f24b26a48f6eeb47fb5e11fc2770259136083286e1170c6e2580bc076e35c6493769eb27a05c89105ef264696866823099a6fd52eedaf5b0b605b201a10b0a26b0ca51307c7eb41ae9939f0e0b9bda48d533677dd3709b201ea8e68e956c26828883f2dd2e6c65510b361df0ae4d432e5e1fc7f0bf29a808ee48531521eb6246bd20edf2697992350dd88d15130a1485e811150ec099da54e8a1d59ddd56348e851a98812f0b41aea2e4899e378596f2e76b7f8abdc68ce0503a1027f72c4a270e90abdf11857dbafcc6e6e7a29498b45d8869a3f09733784c6ac91585fb42b75a6050195ae4b4c46858887f8e201291d345432bb5bbadb126c2a22f2bc368ba8e89bb93da1edc4008b93197aa8e99180c0d60212791de2f776a81bb84ab159680d64a9e4febff3da1f996a415c57560d1d8537886e9ac3b632f8a1b4fff709999cf27f0e2ea4bf5e62262ec2efefb4ec590bc3be6af31f4d620754e2523d368a0e46ff2e7d47e73397a2332692c7c818cc0911f990a7df7c6cadb3dd1af19905d2d0697b26727c233cea1adc2d67faca9e626fd6408a895086817ad5db45beaa1034b8b1ef6aa0eda56291e0704f411d8dd56cfc58c95f691164a7f3ae044881d49ced8dd42e354a5ca6f0c937ba4a4ea298c44d2b0921a0e0c009cb4f91e021c29edc1ed6eb954fbb238048eb0fe5bca402f17626a0a69c8e3096a1f4bad028ecd5f0d5019130c5c19f7a8ba7e8e2e8d55c3a1d39ba27f06334636777038ca1dde9e52570e0bae763b017fbda16b6e058d64fc2e7527def1c96ce1836516bbd20d1b8ce745396f8cdd270b5687db8e160bc5e4c2f80c7607f20c88a2fa38cd3ff721d280b5b16adaf20292a29e1ea7d9e4b7aff2708fdc309b221d68e38ad580dd9e1e53a96bd0dd6bbf1fa3415e613dc700cadce2b46ac45d80e0a44013944cc993ec11a58ffc4a444590144690e562574112db482890549f554b7bd6df1b67342318195fca56dba1c13bbd10002851b28ee7206c08026e980fd8620c9a0691f03e611d0faf1e9e068f58804930513bfa79467e1025c922dceb7a1278db4a85b3ef00444df0b3f43bf84a221a5322e00824bb56d039319f441c57a440952c189b69d890bf6f425b2ce941d4f0d9f9c1b44f301d4f7e7ed5112a5b80980456a02c2338e026c6097325caddfeb5a9f45ae97377efbfb98ca0beecf1cc22e8fbba5fdfc83aa7a3294df00653b8bce1f26d2d978992237889a1ddbfd37fbcf414376485be6e30de436706a69b2e1b7816bba91e9cf5f33816db60ba55a577d27299e435be6da8a722f8eca06d7e9745c330ace299fac154a82588ebbf195a3d109636317b42a479232e3bf7d37dfed17b2929fd8814764132b8dc7cc913f000c87c822634ff5450b8b0ca63db379e94a7ea63ec9b2834d702b697e49a4652fede5628ab9b449ecabc23878764b11ab14074db3d04f749980205be7639822dcb58dae30f6004a4f22507907d791cfafda46cd15643beaf20bb5174aa3a1e484df959e79d6067680f1d061ddf3a56da8aeaef4b6b884045813e77c777e616600b9d003005159186df954fc740a2ade81b612ba05c31d5effc3996528c2824a1850fba44945f50d9536691b30ac447266438ca7276b53076314966801cbc0b608fcb846a79ba2ffcdd3775496de9e1352d10b1a3710978f0f2a5677167bb63171bc379a6d3fb9fa20534ed1ce033faba8c10edc36421575cb67e64144ca6b902292fbf9035e4e521d9fe4e5c17b9b1ca72244a25ae19d1d129357bbf9e2b9f9f67c5678f092ed43bc52f31e9b3c4a8a38852a127df9b9529a28edc0d114c714e41e04055fbdfc6045","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
