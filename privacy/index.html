<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"453febe2ba85cda0f788025edcb40415f3b0200a884a5a4df1dece638cd788df21f9ba4c060d697b3fb526e43e028a28860eb6ccaf8f306c5046325f8f40d271d05d2b28d35efe3984194102b6283c3f4b3bae096ff3842432e7dba95fe02b8156932496c56b83b9d5eda4b646fcb5b5da33b72f8cdc9b4bfd4b4d501ca7700a7acd4adef8e44be7a6393249c31961175539ecb4ee1ac34e47dde846f4889e49012263199409c5a0289a03e2acb6d3f5a71bd2beb1365dc0933801892a6c02d912c42d23e309a7bf798ee13ae904bc6f774856ce51119751c7606135df8341006d7c27311608ebd555fabbfe1e9999a5a823b6ba979b2d0216dbd863bc178b1a1d7ae9f447f4bb60865b0e45ae4495724367e0c730fcc879db562627a922b893e1789cf37dbd755df13dce4900a667823ad5d4dcbdf3c95ce679cb302b8cba6e6d80b710e265457499254822265a0f708e15330a131872b602d3be534ce38c2bd81ff3fc51edd4f65a82dd158230cf0d2a41c18593fa7db54a0d7927984b799543cd1b9bb68d505c0e21df0ed43bc5f99acfa3d2dff7f25c598a960a14548d57790b86a543341b17559426dc242c8b4aa30cd8966df1c6f021254c2274625613bfcd5eb0527af633957f3bb810748ac54595707ff99d186fe71559ae8784019fc22cf87b9257c8b38d52678792198ac29e220e34f99366aeaa6769df2ca21c1bcdd3935892840342a82c922a950ec165c1de641f13c48ef82d57bbaae0fdad55764f3604438deef43a2a8e4e90245bd19a12d621c6e9967953172ebec2e89db10a9ab49092ebb81e8ce911869ec446ee18ef923fd93c86716bf9d160f46c1065a05c55f3a7afbe5d5cc94fffb5f762a5d219daa92c53681285c49f8f8c09dc44b241ec7912e95e9afa7fa40be83d844a7eb098023134f731c21627a70ea89ede61c671a3a02df600c87d5cb8f42f4cfc6a26ee7371e17f357634a7b675c3454c0eac1c9e25b86bb5706d953cc2bbc1cda091779a853e47676e7a9df473cc9c4e58980e0db862914fb14c29ea35c83aa59d414d8c208b88a6ae302b9a959ebfccc77ebbc113666815d5705ed8e4fd245ec7e9fd327b49bd3c2402c4462602cd698899d215d241983bc6f7240f1d7c5dc014739668faf69510a60b752d1fd79c49b54603f2962dce8f81a38ff514152a6f00de9c462b87d57509d6ee2ea820472d4dbba0c4b59f81b40325e7921174bcda20d222391e959b1c1c83a6359e9fb412aaf005c03a5e4ccb971084f96c5b844eda2e060a584106fe5e4d4a21d3d97a91f82b971c00e548024a6382bab0a38f612d016712f998266b33146d8e67d859b582793a16c1aef412c9d5eb2f09d2f3d489219553b432a02bc7ca5deb64d1e9a063193c17426bcaaa38072a4e16982960bf1c630a5ee88fd50544ed49b30a9d6f7f9fc50947206825eaf123325296a4a56b1d6c3ca52850784c349e7044f29a522fcac84be46d06816f99c8dc6c59d30d0e19426c64192ce9c3d39e33169defe8e7b030e2c1a856740f0ee5ee651d7821f394422e061781f9cc1f35f56cf1089babfabc727eed039bda31e4788b6961195a43bdbd88a00396790c32920ceca983ee16950dcff5382ea151002b23f718d85f1b6d6466b24cf52fe6dfb2f7f3ffcee43eca51a00b0a1132c30c033730132414f204dc128cde03612c5ef35fdf5c84adc4883e7846b12493357c3a67747b55e84a8937d93fd01fd537756078394f724a815ae1ae81bd25800a5b9cdf2981e0913b7260dbb954650b4423b59aacd9dbf76badfbb53dd172183599d1f6b36ebccddb79db51ed017041ecfab9713654577d3f0cd5792016edddcf74ac9e62e8609c2ec78a01d36b5d88f2a2b89153bea675caf1c531f447dde83c8f3e1b77ad3082cf99cec557e0cc210b190a93fa39db2494a41c2205021e0e110816326bd75f02db07e6007e9251e7812b28769ff1b65dc9e6b9fe4d3d3585a44949b3b5d388deff81f376c8cb70d014474f6d0e31a89f7a346d7cc9bde71f86b793ad0f4f0fea64fc10494c21d3fa15456c9925d23be3884ef9441b989b30749c9e223705b47d38e9db588a2f9372102f4abc13cb87f052c0bf2ee2d1ec9aaada1890abd9161b0aad42b326f6694b9383b4b6122a271cf6ea40f596a1c5783e23b983f1b7fdfc70eecd63d39c5f2135c89e83cc4e4b21895506dc3580dd124397cad3b461df2765d60490a6e2f3966a94d417d6ceec598f6508114aa5711c317ad4a1923b79189b4593ff238a6db72169a200505d3ba5665e582591d36a35d85fcb72fe05ef1d5440d0e796a20dab37e755edf9c6706e97f4827f5d1a2f34d601267d4ec076613e477dab942e954ea993990cb7f4fcfd7e02f79054e27808e67dd84dc896e983b0ba61f215a6e65c4c009480e80501c78d9f4d0e313717fbf89698df3c9858742d094d2e79be7c4319d0dcb868cff1a81c544e7b4e28736ab7a93c6febf364b5d678b2bd38ca4e96bb7ff96a4c8e9395e05e476e307aecf90f7e7f7afd27b7466d89872715f024154f3e681d9bacab77a964d7cca6072f9c66b1854112139a6c35c7ee0ce35f885e66607bafb0f8867e56ee343028e35df75de89b5ae796addb3695126d0e836800bdecff2fe1117f52ed43547c8c19afea1bcb02d7423f10da125d2a84984d88292cabab9fbe7a6cb0b972c136912576928522f362e4b40ba945043deb504d93ce627972df43aeac77fc6b48d3b66fd794018074a75469aa1af635510df8b40b47578c7ae61c07c6c6b1ef446fa46cc5c18c1fbead36034071f1a2b545f582daba4514d92eecdb36055526da7d449241e12963da21f03faa3a7655a49b4ae9304b3cb0ee60fa086a9129e6f209e2959eabdb669423bd96dc1d5143bfa2682dac07826c1cf2d964f691e4f7e4ae8938dca9048e38fc33bc4b1769b2752630eccbb44f25944a93f652cede9b400919b1fa2dbfb603e2c7b78e5f80dbb59bff09f5e6f309ece9055338735c39439bf7eb60c0d27454ef182552aad4fcdda8aa07af4fbf582fac797d60518631cead0679a08ca560b749c67112e65846edf9683e2a668373c24e8b150533f27e52620dbc1c5fd0d2bb82da6f1d79fc65d02f153ff123bbd1d9e7e716df180860d8b8e0f7b1dc4f1256960f629ee7be32f19e709aeb6efd97c557bd71d50a392af3f6a94637f1b437ffbfeb69799b1ad6163fdbfab5a30480fd9d908d1ad22dd3a21ecfa07214b6924d344871fc9611b83652feef1fc1ce4b8491b18ca5bd624d6a5f205e506a10a185e257f7038103b5147f273741afcae9457f5f024e7e595252a00dcbdf13cfa41953813b46d7a94c88b32e35561aa2acd95068eb104444581a5e2665de6d1072544e3b9ad6e44dcdcd6f026c170d58c065b0294b2b1cf753a47d176c85c8d3f2335f97c4e2b4330a0425ca6c102fed59cb96ec2987133185dc6a67750327d2e6062692ad49625c263d649a486bd2e139d6aa17fff9e3111065258267e289faeb0cad4decfb8dd18a3f7e15b51dedbf6a9c4177626d865c214c992678d7fe603d17a358cb336cf79476fe8e804914b849c0d09949a9c26477cfa9dbc4bb567e8e4e12cc67654df2f071c88a0dc9894e43e96e3811848a864e0a862d7d30fcd168c1002f44ca0627460ddad91a53503bb2ee2f50301f5aea28c4e54da65e4eccedfa8110a4cbf04880e22291f8aea519e7995428a228de6cedd10e9675472e37078b80bcff2c31e0ba9e6ee4e8670d25c020cc7b9d172d7683003f3d772650e07c3ff76e1d0b5f46a98655b04bc6a4976197f62fc200e3d6dc84ead7de88f9109b2a9e8c8897d6a0b0f50bcd541dd47468055fc9bf94c3dc31d1028c6d25c3fb33c142a31e8067aa64db51bdd5dcaf830dd2f81de546d705343abc35def1876dcffd6966c836580ea364036dd9af046e434e6099afb5744d28b1a7819acf514e9fca786024a3b9fa896cc8367b509f280845827bc5322f6188bd8ca415a5f7432ec6c63176010d1fadd6a4c25c98432ca659e27ab66f5ad44e7a559779e7f011d62446699e714d9c4eab5e4bf08fb1367016d0f6b453f7eda172fb7cac4a609d6a074c4362acde4ad8859be77e8acd74124e77075620fbd4dcb28e4da7f6610a2a07efc999aac21cf96a96d0bd6d774a74945bed8cc89f8221ef5c446b9c1362b11b8a4aaef6404ca58a233e95e1288e4c718241fa2cdbc29a4552a61a78a371d9b582292568a67e31e992c6dd61e06c87dbf199497df85f71adbbb76ee80ec3fbac776ae1375b191cdea80be72ec4e3112760892ab3719093d3c91644ecad7efecd372fb90079d029ecbec66853b7a985354b37f146591b1560ebf484e39294473acf7abda4390ec60d690a76021dba8bb5eee4360294a5af898fccc0b7be917c01ada38bdd48da426fa204d83906a3abff5c33da6bcd5323b28c853852b2e12bb55a16606b8d281147dae1bd482dd415d7f57bcbdab45ebbcc63ea9387b0abc5a99d2eb70b7abfad7a46bb581cd02e9edf04bbd8aed1aef21a0d49247b1ad14fd7e817e992b68a30c3fc9683f42c705660beb7fad691c85cc220f8d705c3fc72fd6584de46bcb807201ee9d180ee8aa555469baa21e673bc2be066a0d40375c9cd0f0818fd611c03e13ffe6a5640757bbe761b5d745d6402e30287f1f7fc83bec952c3728dab03ae155acd57a0c72258bd0e9f10ce8b9f13b35fc5e46d2cba3a6d81e809e48fe3931a47a1b9f3e09c4aa3373eea886de48cd4b767c9d9c05a9a423286de1eda0d97f3c9e3a40ac652c2370ab88594bd1aa5f5db8deaecdde2d97981e69bbcf5e18be92903bcefd636102d0e17dfbb12a083d692aeca294399a4c268414dfcb47281507118d563c8366f4d257f17508a56f756f9aeeb2111e931207a7ae70677e49ac01ae3cf1ebe505235db50aea191ce7464138a9d2f8b822d35b62128d8692796688c15b45c3d2b2686012e4c9146b845b48f47692782c01ce67d947406f2d16b50f7426e48f26cb9a60f0d25674a7c4e977245e498d699d6e892106985960aadc853dc6cba62d600a2a5d97b94e8731da9f6b34342921ebc0121ec50af5e6de56325c92dd1a9d5a7885d9e8a6c0a41821234a5fa1e9f4b899c490c4b03ad70fd06882b655972a9faf5e5a2e5c58fb57b410a3eb77c6dada5b31b3a1ea75085255dc5f3f9297a91b22e5365dc1d8689bc30c95b74eeee1c3b739df24780b99f18a030b8a4020c626d26dfdee025deedac30e9ef197b87a078fb730c43cfb84e7ee36695136cbf32eab1ff592bfa34548db05ed53323fefbea2c4ad4e2abc197eb7f2ee7daefe7e658c0172867caaeda51b69a0820ca9dd5e72eb40481e1a6f237f5cec5477bcbde48fe5d025d5bbc63512cf21789191290ce9dcb5107af90700455a61cd83608da0463b3c1400ddb84849ec46afc19c7a1785be7d56c3725f8592023729aaacb4d9bda06bc28ae4aea426f0669d80eb94e21b41ddb7f2e1af139b645225dd22f7d0c0a60f7f7e05e4522cb425f12fa93d6279f6d412b63d113290cc37577dc90f19802bdfcafb943e63d252bbc75d3ad4d14a2044da60ace4636bb62a07913484e73ac3bcd8c8de92fcf44a95d5b56cb2b72091121b531b3a005f5bfc920bb141bf33312b56c55a748368bf7ce791a4aea96cd4945c35a7f9f1b9b86fbf6dafd3f65f7818895fff23cf29b1e67f2cb9bb938b835071b48638c73972dd7bde0e414deb0562af8428cbad6af1e73aaeddfa8fbaf8f7241aba661c78ca4ce7aecbe87fba4e33be571d708637265c11c1cc0e649a8858b7974530b771fa94f7788d69579cf3e2ce86745ba6880cc635b8ffea22c53f21b28f126f31c2bdae639c6e5b2ff8532ee65eaa3ee4a75243895eeac02e90d9804c5348548ff7c11f1e72b03ec408b121ad218b334a8def3283d9b6150c176c2b730767b8e8cc3eac89d3f2cfbff639811ba87f8800a05fe6b975303990463c5ad349408a7b8d4e0b5211dbdb1dacaf47d3a77b60a0af4cf987f34648170adacbcaab373bc8e7b10a25c0f64bafe132e08bbcde3161f88f0404060c43d45cf4feeff7a6e867dd0779a88ebf694d3863be81e0bac168aeaba9dc33f1e8306bc563352a2ca6696683c4c6955ecd11d7fe6fa19bfac59a7a55a532c5aea6ecc9248f10d50ae55722757ff5a24e0d0f1547c4fe293215dd1915954207f4c5ef8ecbf297073d17d312794a497642c0163c07a8bf323b8ad23d54612d8bf73919586ac5a2218637e31444c6a394e5be3baeef2143ee4c9446a22a5845b368a72aadfac4a3edd14ae9d01f906b7e4bc311671bdbc8a2adce4cfff892f9954271821419b38428d0017134969558c3b3c320d1f18d0d408b595a11102021b68603eede4ebf864817a6d0f7e869318f00d713316068db4c09eb7a35ed2750d5f192b5a4571c211f0e8a26622eb3aa505437f5f4c50ade4aa8bff20f75f83110241c27d257d0ef25e2abbe6e79f596d84f07604d2a82c8b9e8b6b066e0978b8f15dfd737055ba5aa62c62ee5f3b075578ac9ee242c0f537ace1440893b880f86f6ca73dcfa5ca14eac8b001d0339b024b8e310e685430a410a1853fd5baae5630d0342e6ea457314ba22a0d3885ac119e05bc4a9b48d14dfe79302330d409762e9f3fca374207395d3a09f1817dbe4ae1b50f217cbe93acd67c2cfaf6d302f7a770cd4ad7d936451b6bba7ce55a2443cfe974eeb318c9b40893c86096f89d96cc8cb1c42aa021c591e7f844a35b0302a32d2b297aa622f167d159b1189773249b790448e92a26665885a95ddccc46a0c2788843730021ec47efae5d06a0a3dc98f2386fe1033aea6c59724c620436840c8835ccd27d6bc0c8af8b2419dd0f97d0cc0b4ce35527a53fe90fbcb6ab33fda6447aaf7bf050d3d4805530f21fd88982a6089914720f2f2cff48b983020408aa489a36fbcb9ab18aba6024e9465dab76ae2d3ed7bb04378ba7f9eda02580f8858eef6f96b3ed9854259469bc3b7bd74bd66d6e573f19c428d90c5200757e06a40f875bbd12b7fc88c5cd1cd64554407c86cd2af78d87868117d561af32fe1e2d3dc4f9b22bd29aa83b58f820659ad147de4099664a94d5b6e125c5cd014bc336848744f390d889ceebcd65044c50dcdbcd6f2b200074737051df08bc23530f24191ee49de8a213d27b9d65157c7dbcc248f4a4fb606a9a0c79107ef84c759e1886422b81092338490585ffabf2b788f599d985c6ea28f772e8fa3e7aa9f4dcd85790fc8690781d81eb20e0803ebdeea380c6c1325cd3e7f037331cbe8524dc469353164cf2d70e92190bef4a965ae37dbba10407213a6db295e821a2233836bb77f3ce998c62eef68fdb8050549c39af255a0bcdf110ce5ad9dc424a664cb131ab8cc5e8f81824f24dc890e905cb5d6be9e1a35a6fa4ca9f93efceac0c7fa1dc76f067637b365fd03970826eb0b806bd0e3064dc3906fc230f5778ee2ea7fd9f7b15c70d9c0ee72400ff37417282d7648fac9a5d829326ba79e215f1a8c0ae74e2fbd71edabc6288ad6416de57233de79fcbf45b1499abb622c947db9c31d8f858ac48b68943a550f795cfc37fbb37f6de8b4aa09ffff0902920651e0ab1a78302741d0dc5639ea69d904d09dc01243729b673b1a9601f3cad8e50e4e5ac4c4591e6c9367ef00aebe5507262af16e14b3c43f7f78b285714e240732efc28c741478bb1739b4034bc32bff2b433a02b51441e96cdf64be26e3d87641dc9333ee35a6f1a0d7c5e42381f3abb6cd06da059af2a047715fa4eacc71f4b58236285169334a21deb1ee4c921344e580de1189e1911696b18958c3554cdae7ed39e63d7688209dedf38208c364b5fa29ec0b85e60c32008384bbe6a380bfb5996ed5c4dbf76615b2052acc044efc710c68f9ecbac0ab31bbc19f4886d11e4950305f1f5b592edc006e3f5ca208d9dfc99332f71ad1651d62127e3c1ab8b97175e3ea01766dbeb15687b819482915d3f182b1f0e40cfbbe4944e367318964aeabe1884c3325d5168532255e1d5de759bd7ddce6bd0fccc0a6ba8caabe44bc1fa6dc9266d6fa538a07fe10da73b438281a449ab4ea5a85af731315d7db1d01fa5d4053ad0d6d60d0c083ec75e05dc09501b47f382fd8551724d7bd9e307ff56c13c9686aae64d8d3b7671c1517a7ec832f88ce1a16868dc6d326c51241fce33d8eaba69789f40aa3f3403e4b11d1170001614744b51703e70a5337ca92958f64ec41da842399f26a669073bf0136d3114796b91ac5667d753d7dfdf03db81ff26b64f67ec22e4ea2bfab4904cf4f95a094aa7715a39e4e3d416a0eefe4d2d04b27281d83bbaa544c66583846ca5a66905cc45ee94165251354a9ba619246dd664b88955cf337ed3ddae84c1b87da48a6e8463d79095f30ba41814b3dbb5af755afe58055b5d0b256738b3ba9c94f2b6b28e82838d2fa15cf4be90e2ddd6a5d59e8193dc63d924e9f20406bed854bbc353b03fd6d9a7f517f4b024a70d32bd8167d1ea180697f7e17efd3c28e2d6c6672618f152c354ace096c51e790700d24a12485f5106283295164b6a9127c2f815fc5cd0774ce4cfc7b69e196d0b940b60f58a64930cbca85975f0a417dd596fcc8aeda18e58cd5738245a14dff64fb1fcc106276f682021e6915f77e581416d1e2de8027bb71de6591fc0c014d127c8927292ddb667a59b518cbcfa27b2bf35163720e0a152c488f23e9f9a9aaf72e30317901c611f78adf5c566e6f6aa7e4af9e141357fbfd99a3011ce22521dcfd0ea7df88ca8e373a77d0d8abdf1412d07457faa9ffea6b6095cf8748ae354682541b0e9e253df570d7e436e33d70ec58dfbf04efb2137e155c8eb0dbc04e879aac8cd4d4181627e0a39d176e7a51a52b6dced32d7daf9857c54cc8a82a6fd2918c25f4b34b598d37f907fe11a065a09e77e1b3ed8baba53d65919eeed3972ae628843acf2f17a5c2ae3bc1679d1f714169d5323c863a5c9b20280be19421ae3d0293ff8e33a8c38106ff74b84b5a1157e4e30fa8b4d15aa397bc43d59365d1481f70314c22fedda36885a316150267d02b94abd7b383a818fa86426b2f56e5b3d5419c44d5797eaca4b1649c5db36801ac258e5ba29fb600f2cfc6e6dc9915c77213e86bc7173f3350b92648c6efb8f03765316d2f82a51a814b96db6bcedf07dd18e20d00cf4da6d5c5b24c0d2c676637ac3c66b52f32a7175b21cb48d0c59dd5de43f5df2d4be55bda422d6f1a1ec347435e633541edf56d1128f7cfcd9ec1bd1ffefcd3d5ea7e20b9a22249aceba186ce3bcd95c1f225fbc1160d00995f4d11a58a9b0b2c3bde86f20d5da24d1280fda7afb7f42f070ef8b37ec9d4f2b7af7daa62454eb30a33628bc8594a497449610ef26f008081c36f4f640e5c71e2993fff0068b9247877156c8b4633d262c05e3b8156036d600ba2a51f766adfe61587cbff37f5836b3222358f5091063298db6d3a60fefdbe53ea5a4d09af0b0759d981616c191c4fcc273fecd1d71036eee8919eaf94be9bfee6f1a0aa0b46cdae852d09e2379ec3657e08acf304f0d802b764f3fa8275fa5f69beb7e3f6ea511bcdcd3b1f7fec666ab1fb230b3c0b526f12f3ed204484861ce7d7dc2f63705f80fcfdc32b50fb7d3004530254e733ae024740c1940ee8c17079de2e2f9e63d346c3e94e2b94d6651460634130abbbf3dc67c870f931e66f7b8f418d9265b0dbe8681bc1b9b70bc20bd9a314a66dba5eff35e3108c12245f3d584ebf9b2320d72ace1c93fd2c2bf4d89500a7682443346c6ce9bccb9a2764cc686847ac27744419e402a3ce6277c598afce2cf473469c60c6dc3daf82e1ebe27ac44ab1556dc1028071d90672a77604b0d23801dfa7b82c7b2145d68b150e8581af6bc30b6d004b5fd21399216043ce4b6182c2807aa7afe42f588c4eaecde81a173a6cc3ed1dcdbd6fb5f8fb905d2068c1e26722d27204545fd70b0c9c9de584368b58e78cad7ff4df1661fc82e6fa53efb25250fbb1a34e28cdc396ead14251ad3c2f93ed35c4cffd0cf31b2cc8f0a84c1c1cf7a36624507b72005fd9cc579c8e806bac2253fc420dfceb3b748dfadaf8c5b5849621cf1be0b83a0d74a74589dce2163131e39239191f24f9484d9b6453ecd3db758ef69d5b564ade2b1b8992e793cb85df2cb3c7151fed41be47009bbca07776b9cf05b919d0c8df44ca7f9e86cd1ffc0b4da98e8f7bc2a52e7d5f399acfcee836c4460797b870e04eaa6ca5e52204e7eaf3aa60ab14555baaf56f1407fb470a869dbc970d362d4706c8999f2420f116acc1b2b49433f8b7de9732ac0c9ed5e3fa830e6fb3a241484d3c09e69d9bd06b0ff7beb5908b22bcc2beaa2604f907d9b3ecf4f161a322e6b9bf2abffa2b16e2622e10ba08bc89a8e767508c1b331b885ce88d3239bd27ef140d7040c406b4d44fee79d6394ca908d5d00c5f91cb47f5f51f7a193b2dfe532ccf7a9605e3e3a266ba8ba1d4ab9d6074715bb248cf8f308da7c3084efc2eaf8616f58abe9c04cab37503020dd9d03cbdea457b7ad50eb2c3d7d3d472f03fc33671bf59b19a5e556a5c3ba4b22252a81df48c6451da313efb70277d001b5713eb628905c94fb50b652e48423f33102ef19d053e564793f26d6a35ca4fa8c0e794710b8b121b102e79aabbf0314e9a772b2cb9c6cb904b2d90cfeba486263f8177cdbf4dc92f009ee35d69509bf60c1fd9e63fefd345f0417cdebbb7512ae379f80033528b7925955a668001db070c2b29447d3e14406e56e3366c03bb3adebdc61c4587ab7974f4f98fe4699d64eb17ca8f6c6c52935d1ab23c96da6f46d880630dfedd9b14488c5e0573bbd6012ae9dc00eaa6616126c95dc0749bfe253b5575c496fdda5499fc2097d3d8f4c8223c6930dcdf40dd717e3b156557735d078eb0486e18c40dbda78a1d2e74ed82bce3a3e75268f98470eabdd85706ae94ec546d6b93af1e55efbb65d2686059251f299a84f41e7d55dcfa44d8e1024b26e9f7fa9f65cf5acc9e3171195128a63ceef18633c2bb48c32ba474600fedfbd574f9e6a4c026342e7a68bf25bc2e2260a771597077a638ea9b67ead3343dfdf960eb01c99a6c1360690fc1d242f2e12be2b1fff14c69c692488ac42c97b2a2660dd7030a9a6bbf9548c3d1009ec405f89ad11f1042b9b9ed7f21552beb291ee34ec042016c1d8458561b1dce7e35cbac76153f31b10e85699ce9e66620c68dd2591f6786cf6ecd40c648d2e1d5cce1bc863ed47346db5aa9032db5d7a315ba6434491a1854dca7931f3d8d395e77927382dccd14c796354919e7e80c93314dfe490abf85fbb4c17dee0aed2d8f7e6b19d69e222b7b984b2af800711ebb36b246e4b003beb8624357d019435629723ddc52d6a106bde3ee2085020e753588f3c1e5d8c46b561140e91346efae668064597f4deebad1170858be00575a6f51fa2b68980dc2522b19a508a5429f195f4485c6af88d7ae51b400f9898f65575a56968a4f2ea49d67cfd890a5c693cf2c3da90d8db061e77023171922941aadc3cdab79bee8fafa763795032ba47a5735c550408392af24667467996b8585240c8daf1c1d312a2b8c40183825547e5f6b5b1f46b8575c765d5cffcdee1f9cfc9e0097479e524f37d619e68148c96333d4d0a189d33f07021f479f3e9dd2b1a18f7bfe32f905c0f07e5ff94232931393c40701351efa56616693ad3d5311fb6f5ca3e3d4e101617fd730b524d3d7caf97c5bebff9e7720b3f498ac682f4ef39d5dd02b6fa6e6222bc57eea06cb039e6453c076493a4d2701bab1b101150c3a86234c8e2ea108111b3834c442b878595d2c7a286cb92a71ef8c2188e10c864cea2910a27ff4bc8680ab0b04c83353b666194dec2ecdf7b17f16f25006350ad713a289a533fb39cb740551abb0e3e67977bfc59bf8b3a1d5d3a2ffd756dbafbf213f7e8f039514b2b49c73732032eb38607006a037a9112e03ac87315c62447a1e2f5028891d1a488dfcb34b675521e51fce49a69f3a049c452477ae541d69dbc1a2f069f135eb5b53d38473a1b765682d7a1deda503117dcb8656c407e64e48117df0913564c02323ee16beafff2826ec4d6bbabeb48f1f9bce65f747c9eaea7731bce131687ac025681cefa27b07a169a769811a8156bc92bd4a7521ef2fd44605658166deba20c9c36e13573823c37b99c2fdd643463d11ce153accee8d7190a6b4f424159542dcc0d442bc93c9514367a1e8716f0abfb4ab0d948d0067521f2dae67742703d8dd7b166e6eab99d385d4696eb76dcdaeeb1283362476b7eb2b20ad834df6ff7662a5f9a33c62d1b267f15e79a7641a17abe930699672630e93650daed714c855c57535aede793677d62f0c49eb154ed89daf6c5c606ad43345eee91f4de20a2f3126bd222ff661a709dbce2840fed1bdaa8288f22c1a443dad3538033f16533e428346101b48fa26307bb0c52b97ee2734461035b3ccbbe75e9bbeef53a4a1b4b9f593adda79392717c4f8be3d1cdfd750e17cdab65dbb18dd5e9e81a0d78d6aee83e8dbb1ababa17ee3db454e289b8fcc3e3aae10a6e114490a1ea1f1330ec07fa577634e42da0678381e72c981ce70712c835410c84d39bfcc17fc4e54aeff31cbba2afd4d71aef8e54c323a0ef8a74a4866d95b097eab58828719d1acdffb3d6c6b39c994286704ae1acd3f1740a09d9a18435a9306bf242440e5804b61bc56822adba5ba5ee531e950a54c2ee2fa4b18339cad8da7a56900cf0c820b329c9849f99441b3df07da21813c1c22cd7883e43ad43937f4ea22489c9ff45e33742f6058f1dc1a9a15f1b2d2fa81a6faf589c19d85c3b7851bf4297886e19c5ed6e96ded17973a17154174ad32bd54fbd1a2db085edccfea67c658044873af4a7d00d1f7873e391bf6ef0b175aa28778f67f2e16c16d07db69c80249509aab81e1a9d4a6f51ead5e13b7d6b1ec868dac973db23cbd800be695f58872a62818afa56187c7ef6cc6ec655982f5a309caa4e2d6778c37ee980d89195162579b36613fb957fb64bdd2d94cd1cea7616d72a085802548cb5f3f09332652147a4a5d49daf04f658f488b6b4ac129947ad9be01cec75cedd883550d10f1bd3059417550a858bdebcca1e3f7a63ef3aca94b6b5795ffb8e85ee250b99313bce008118504609507882056af4f121d24653e80d5870f3434a2d542649c5a0151c355b3e40cb3032a5d41a56bcc13cef656af6410a9740a2cdeb5b0df6fa5c5f43c8529f9ae008e545c7ac04397b489fa4f703841942f7c85f9df15bc8bee5becebb5811f06bbbed31c2956edf6366c221a800a269349c17a94ce81a23f8ba5597f71fd174ea039c7eb87d54688db4bd149d8d5e0c7448614a8099a7c4c0c804b9f85c5e0dd883da7ee14815633a3d4912a9019038f1eacef5342fcc6f36c6e703e5a98fa926aaa9844a747b2424fab0804e41bf5d8e49eaaff60056a606391437d056a86762130a054e47aaed59eab92530839da7823d52b1bae2e248c10ab2e3532d927e073668884f1c69cd0d71c7048ee8753fa47310fe0d2dcbebea21b4168f421f41fe89ebfa93ab935256e8408ddabd7816dff5fe1d5e1a8cf78d0902a608faf58df3d417370bde60bcfbcf02a0df769ea323958d641db73dcc15546a6de4d29bc7c76a81b70a00714f4641ba966c8a2516be2dbd076ec8eeb0d376799c95152e2b19921c046db08f0894ba67a9709cedb4c243ae50497f3111097dcceb9aec8d5f866a5ae6fa9db7193e7277af2e79b40a238ab78b22d7fdb45f94f70767180164fad7dcd2825f6732d2eae8bf1f84f66c38cc98af27203a554636c4d3fa8c6215a48532ed472a8db7078d865e0558d50a6533e322fbd2ceb4a69060600518116483fce8c7fa6bab63381a518506a4725bd899eaac3c3e61936c46c9f5d55f4da7f5ec572bea0fcd28a8dbff5412e755d26b80d925a879ba83b84d1404180a24ca79532aaed94614f0da9d7e1f950a2a8532f7161e00fb7f6467bf27ed8a5ec6b4c4d211ee7e9d9c7b7457d0bee777f7bfbd9d2c5f5d89adf07c8e49c6843c6f0d89a884c97d201527db67d09e1681e29d16ed526ac0482c21fe34156d2dcd38cc9fa4ecab5398812100dee4d1a4034cbfbe730c05160aeae074ffbdd5fe5537ecb15f4f914203bb5a500ab8b21bc007bd74eec3f49f8bb49112","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
