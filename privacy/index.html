<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"592aa3b0252a23dce9c698177fe2fe2c0516f876efb45835f53e1301bbed89de4c6820368e781f07f2a816b30c059cc594eaa9c7367eea0ed88c0ad4229669c42fe31cdea88342ab1a5aa17f353d3ca3084b9bc6e123fedc3542363a686baf1b5d5386b0f79a1d9f107b522a64bb9eaf9084557ca75a3114eb21f06db85b8e18872b0ce3996b28168acd9239e7bebb9129a204d8825a4348a15ea8b353479dbdc8b9dc5dfe23626dd2ac4ba4593836db28634623557c19f6963d1136868b4d4ac8323dfcdac6b472c96f2b3a2833b9f5aad59e4541f3bc7b39778067941c8924c1fcfa5e3014856c77fc1acf2fa534d20424968120e2daa653473dc521b1584d59081d66391f8150c4aef05ed5044392fc0bae9cd2b81c18f47cd3b69fe24caf888497fb851f853d837aa005a2bd4e3d88cad63adeca143409091f535e5ebfadbab5b35779fb00350fc42bbeab66fa5d1ec59c70c176f8b7ef2b38d59fe9f5dc3012344fc0cb4e484eff81bc52df980ba20af225c0781f1cb5170ed01a4b792768d1e7530dd867f17bccc4a1eac9e822a8876f92a99be7d998cf907a8eaae2f39bfbd23b402e6426791aa9a4f13c9878be0f8d61741dd76748edfc98e1dbfbb24e02500b1d25eb4f721829bf553832d3d809aaff5357c49b2d1ec0097b2ef76b864fdc0f6cbe8702f75b56fa976ffdb3d257564e1d86dbe10e115a20a8361c45ff9ff478b73ffe6a0fb2f5e433bf9cac501af7967544f651d60917ebf335b1297c05720963b2cc19311f02c6bd9684d9819450dec5128b253b8e94c9b3b76e93a198966c8e18b4e3e60f656cc89e494a357b7fc665aa0c5c53a92b24107a222c382c32e13ceb974252c29ce472b58bae3593dd2609ae6e652e86ce29eef8810c157a8f670ecf62657c38f455d3c5e0e5fd2f80b07d9793cd8a6dbb87198155129c16abe969ad9beb36651c3aad31f504397f09439f984f1d5b34b9c67a2d2cf3154c5046389969a8cbb2895cbdbc878b6b62e69dd1c01e53ac429ae917370461f910bcdb1cbe36f4c865e7c366f842a4faa2f9d61ecdd483cc244b7ef235f72c07d210c49817faf214a22a84b55e8f9a63d77752522c5864e8440b5986e972e4eb586f50e6a477b899a1f87a354d4d2ff905bbc7afa3ecb5b570497c1a54912c946af8a88c50eecafcdebb0f7ae8c2b30350a10492f110b675c0b0cc97917778d6fd8ea080774844e7b44527efef34278cd4e98e70ab307926e2e05af23ab835d21e20ba01ea5c30586d50150048785468d54e2edeecfa3cba75f529f0ca8785a01b22fece82349c2e4a347067293f8e7e4d6b579e2c2400b12414af2fce5b89de96a03882ce19d7687e9f2a24f12d5736f7c28f0da4ca126a8a6cb9a28f0c7d6f1276087a89a15f2f0e20ebe61545f9a7a379dae24f449bced33ca64c91b8a78d6d56e90fbcb8c3e02223a1063d96b860810b37c07726e4e3479fdfbd88c7fe9bd99ac766dbc8d271f4b8d2ea4b23e143c53eb70b52e7a6827d8221809538caece790d0c7a3b37ed9bf466c40b5ebe5986e987bbf30b8430e8269806054226f857b75e2fab87753c57ed3a5798547cffdc2b5d52c48d70a543dcbf69f5defff0626d410bc20a0c5e3a1e40c29d57ce53e4b971fb9aa62a98a072a3eb79f65f646cb34ba4aed9f3fb7b701cf1e17ef257ea7376fd5f2e827e004633afe6359b6e6da8d66286ea2de16ca5fe9e3c970aee08e331d97ee4b638f5622ec3f6ef0860dc68909b2f707a61b5a4a110c586db9f68c3cf0ac8bc870dfad1d99bc5730910d122a7b9bde304803dd45c0a24036039ed0e53c3e6f48f5f2b7583aa1201a6f6be7916d6fb8f42b962bf4a9e8ae8f750386624f92f46fac17482fd37593560505b2e722a97268dbb7fda6a6a99c3887345a39d804bae1c1e65ed33c67e8b720901919861a3fe1a4abea45afc85c44c1297386867acb253fa2a6cc530fc090b8447b35adc9cb78cabaf49c871ee035c0c3f0ccdff9a83d4d8d6463457ae63f516209f7c3b1af5ad15e9e4ee897441751c6b7c7000d58dd317c86b7f39bc1d988b3fabcbb4ac7c1fcebb184c05349d0472f68c571323694b8a3a2e44e316ba53cde727aa455e8b6663b7d55011ae5caecca6aba4070625c0de930d9f22c8027d1564b7e4147f5191fae7356d99fff1261cbaaddb4b088ea7493ec89c986e122d9b7bbc2a09408319c85a94f855f9df3a3eb4f5b52d0055db5a71508305fd0080bbc943ae5cf2c8537e53f2425fb1237d4abdfb73df8d62b292aa806d9dbb4befcfd054e2d65995fa847399e97832391db9aa258376745dfc14e3b9e29f7c00af54de3ff8a2b6b0d34eaab26fc6e6fc275adf8a74276a65fe8440f0c8ba71288d449f864152bbd9387f41c5b8334f717d6f0fe6a2a1c71291e7a6938940a40c2f80ebd49fda431948901c508782b0caaaab5d0fe47759c96f0b30e08fa90fae3f4641f53a50fefe313a34d585f9b0ac368d4c96ac85633ea2281ad25182b9418a31a67cf105ceeffad3fb3d43d8c8c459929267b5edc8662c975cf074312ee023be3f3ad4e8d35a9b526612f3d419f667117fe948e2abfba797b72502737da83e4799e54a50259c3e78c1b2a470926189f2a41b6658a623fecc23f5e123b60e8bf43a343ef1cc29c9cd2ae471a0f0e3ee2d1d1b8f0565d57a7eafac0e405ad66ed6b3fdac5d49d3e4c2cb828c4ee5692811d91b1404cb59f12bfb066596de7f6732b735427d58782a45de2f7bc43d7e3da48cc5a47607d28c1ed4c9bdb9c213ac219e4106a7df274739f694c61826690ac17b20f06cfcedf36afab5800ba0c6b55f072d124fb2371907579a1e102c6623b247dfcd700531ced37435bd5373ba9247f2ad54341d8d974731fa852d97eb3566b5c70fddcf42d17370e929400da50fffaf1076154b0ecc65424c77d58ced19bc4962362b38d3085642f814eb2d6499bb4810712c0fd622215293edac1716d856e3ff00ae7ff34cd8abfceff294da0db7ba3261ed41a97bfe5eb453cd852c81888dd1912da398d2e0515b86c0b3f607f7e0738a728ecb1cd69664ca740718a9e342c68ec81d4064cd01e30b7540f1ff850d1d8717e4b2514e1d714a768e04e735ce0c3930d133512519749769df6c6a704853a39b9038e67965a21c514c55c2676709ec67f84fe6d173c46fa6143f24bdb78eaeb31763e4d1dc15934c91ddb07953f6ef79d6342b2b78011a7f6893bd3dde196364362f72884a73ab1841c241e2935d5397d17db04cd82cf72da6b7ed2aab8be91681984dafe04f4b420ca22ba231c4ac34a9198df196f37008997e82f79ba73ae7edadf5b88edccb8918c41852ba9b83606a33dfe5a41a347673bfb21b9c1173f9ffee716547d2cf23b3dba2c4c18066a324718d28b80753ee10d0103acc81aacef2eb96cf5790a57babeafb17017ae0ff0c8a49079e441c17fcc91b876cec096d873638ca0cc600a575dfc2acf822cac50c2c83d30ce1ac245c9b9fa50ee9bbc775846aeab160a352f0d1757d4f617053cca0113ae52914f69a684127b93b503ab78a224715a439d923fb6c17bcf7f3bea1e8f012e096d81209166857d4c615abe33014ad3246f35e7c34d4d6d74c57f7b9d95e36f1cc3f4ea5698605328d862f1e51899af35d37f7ae63be649a353f3ac545ae9cd78181de23903f5aa5c51a36ef7dedd39b1973f7cf6d390976fde1690f567711964a87100069b3b846a5e3433396d1d823aa66261f77a603400f295e8145da4653bebe63386ffac0e3d4b573c0cf28934ab5c0e93f7ced47941f4e176ba0232707861b383bb0c8b0359e338af38ad7b84e4dc0792861ac79d4c06ae781d5777f835944b515d91ba570a7837fb22511b50fb814c60995daf78ed863e5077cbdd1e38f7050e9af0db71916a04b21d3e36d9f2068244899325aaba49152b11605c5294e9d169a7e125580d1ebbd217f046cc39765eeee75f1c2bf9bd3ecb6594f69f3a90f4464886f3e9c01923c9617855c50a30cb33d6b8dc39977f76b5b2137a6e50fbb1a882b2b10d9fe719c55f9a5dd119baa2d60eb4f1138796f08ad5c48b33235177553a05d25253084eeefd3047933ef476ac876b6b23a9d3bfc589ab25f2bc17f12846d9eb4dcc3b9b414224981295ad68eb7557b72c5cb12196a5b1a8cd28f205ad5d8b7035fa31fd42394dccfd7ec63cf0bf1325b60380b8e9f5c4c83ec5eb8cc5aabea49e5bc4c9f7962dea66013d00ecf8761be023436fb84f8217cd9b7065f2ea68a5c311876155d29e982544b021b94c8e8756c5e7a2cf691bfd314221953a0fd62786a0f86f583fe07b3162225736fefc29458c3b56d85761249b8159450194584c0bc8dbb94a8deb00eb151aa77c2f9a044955737d624d5834cce74c2df21b92765ad16b06c25d2d527a25590b438ea5c468b699efd8041c701c2f7e026a709bf85b038ae0ad50d94d276a01313027b3959561cdf781aba97b382c03ab8f3810a12f442895708317df761abefb1611c57bc55f24e78fac6e8dbd52064f445d4a43d46c8ecddece22fe112c2eb6881ae914c65ec451ab173373a095580fc8454809d78724877109d2b37376a02d1e5167b7d23709eec0289201ecf2243f4d761d01eafc1531122f307bdbd65a600e7103c166c0022b168559d1be730fd572a6f91bd1c4ee33601dc3a0f5510de956f1fb4b9c14b45cf49ed80a139b530ba9ace20b599a0e3d7279d2208a53f287693a1a093bf941845e1c96167ed0046773c7d37e471eb90b73d7be01fa581d628c7680ce50700ab3ba225e2e88c7cdf95251a612b000cda8b2a7c0d95e1a5e7aaa24fdae8a38089f106ede471b8b2a94b0cfac32e24b4623cbaed2affa4a0c7765e914d82ef3dcea491ac6c4b586b1d420ff038f2025f8db088a12ced1f75cce076bbe901ed572f04887bec0c0adab152d5417be0f9786757c8295d3286708c45a36c102bd14abf3539b55322a9f3e452b00769c9dfd9b9827e65a522e0d929f1e9f011609e80cd159e7b6ed03d090604e4d2171f85693c1592d6a318eaef2b7b294b683431dbe8d1cc68286ee0e588f5caac32e7602b120e041c9981f03ce4c0e79cd1b272910e8c582327ad340f721cd3a0314213a1fd96f7d93f5d49be36c70037065afcd0ed3bdebf948e97371b782c7dc52b50b85d51371fb4d44389aa10b7328d3f337f012ddc70ffc287983f75d25aa1e6bd645ae8f0dbf102dabba82b4626fda348fdf91cc1f7e00e79d42629d5869818ff61737874d2032d51751a9b4cd6c293215f789b60ad15c6e0b91093ef86dc77eca6c252506c5aa7473826720345c32665102b09f38226ab7fc8c85a5e3e895322697a20317a565d10163d983c29687dea7b5bfa559970ec94e67050543361161d7d21bc24b1b17cad7ad74b5b842e03103e298f1503daeeab557eb1a4f07feea43b95642c64953b416fca12f9d9756bf62313ac60d4f82e61a11c8f4dfa2771d44281e905b9e9120dbf65b3a9740ee7236ea2dc9a606531af4a186dd1fbc0904545f6f35062891d27ed11636cb17357f113e34890b1b25086994bea9f4b4825cb971c9c228d6a343c5b251d7e75fdcc977d6d3f4cc44e65a47d2d6dc442e133146b957adb27916c2656c7a81325096cd46f7f732046d3f05d77c205a65c3404997ca71f06a0464fe96361b1c489da8a627bb3e992511ff6fca215e79b38c8bbe08e4227111aef369970f12c18204aa6adfde4d013a005efe4a352ec43a838462605d08836555c0f67b1ffa4736f97ee66fcb6ec9d685b4229287d561a22d67dfb5f782e8d2656c822c423753a5117428989b02a0d682f019d529074de85e403fe0b33617d3265d0a42be38747320b9379ee756760888406ecd32ea0eda3f0b0e72cbeb2054858fef6e7e0dbf47dc5bdb029dbb14786fd7653b48c85fb853a3fe61bc17fe2f05b7b46f564dbbf6412192ac118198bc5e73a962131644eedec632a8e1d4379119fb350c5f6c75572d29d3d84c94e2060f1350d58588e5b32ebeba0b5b15a2fc634c6aee33cf7bc6f02086d39162c006d17b3131c8fdab2d7b797a4157594c43da973b97f7d8ad03989643a18639e1947f4f4198ed5373b8d76bb32b3092f5a76cfddebfabf8babd9626c0cd386ca875477503cd5e0bb3be3ed6975f39d29c6f2544dc49db9a9055b8cc49a3a1ab5f167973b9d1ec512dfe9eb8d7649b22f7d35488811061b0daec16a683c6923f70b169497d37d887f32835c34276f312ed50b2ae7bcbff523764200af55727b5e8295d451d71ac760660aee8cb427292e1f71a738c661dc3923e10b778438f223ad30254ba0d61f30b7e0f44b2bf2cb14b969f8203fb70705a78ea2085712b87bef96ea4c073d6357c8e9565f974cbefff13c05a187d1e46644815b20228fb0befaf636d2c65669d3f108330bcef4248029fdad5b5dfb284996eec6d278f479f817888bd701ce22259f890f8aa59663b5ac62818b114a39d2724ef3b28a4e05cda0ef2dc530d14bd28afb4ea8ec2bbb26989ea960c9f8ea93e527a9624dec2a293d691dc83622d07ff49e4a8f2c4601086915ee0f02cc997094da2b7a612c8f755befa204be73865386d4617a5e92f09107a2fb54daa8ab9d6d4d76441b5fcbcf63ddd486ea758ba17dbcf0af23e9e4024d9d805d38446b51befc4f09e129c4107f2d4746024fe32e22b10bf3df06c84d957f88e3c501f79e816dce69ab92988cea40230caf43fa606e140295c24d96cf54e693edb6eb4c618787e07fdcfa16911e11e6445ff53970a6f04229ef5e045d68b6cd37daf9555e9bbead4b8b04eddeebfa30c42ab459153cf3174a0614f42d3fa24b0b1265888a160756c605bc0d8ff375d1351b96e92b3d4d12aa9fc2c3190c2763eed41849b15f75414f99d58f3fc145aecde68d72ee34b7feecc52b7bc150cdcdccf9b41a0bc1d80d154049a472ac0ea70c5bfc8be9c21afe1001ab441173392a7311cee62b6f64cdb8931142a4a4b35fe6180e2085f612f681146dccba8005656108b659a3f32f3e652266fef480e7fd1b059570a9f06879b974c07df397c2171ea63173e4a4653f8913c9c105c5411b7e17ad193a4daadc2d4ad9dd9a74cb53766aaa12357a29e9e4a12edebc22c699209ee251e5e23dd871570228a9eaa3f1bb84d660e4f5b2387cfab59c41033c198ace6efdc7dd52a91a94a1f5c29575892010c2a6817a477e2e55e68ed5c4cc10fd520856b57f911ccbdfd034cbd15867c1d1584b80df2321fe82256eae14b91d3ddf6ec0a7213a22ffba96fb3f2201ba036e0ca06c99f46dbac57f917dc9692a791075462e336a7431c662b54d85d0678a3c8e4d87a3a2ba170fac3f0318bb80a86d1cd3dba7cbea5f68b4a347184ef20b5ac496423223a4880c44ed603c71657532121236ffc32850f3e0a2472c8167138c3b07cc1c4a6e5a04c38cad52c81cbd35ba6e7c07b795d4e2b183c34f4829235dbaf94c5b19825750bdb9d9064b05022e24e382746ea02de2591baf94f7e1884dc836e534595c7da13099ea896d8b15472babc7568a056adedbf162a35b8945f9c5701364bc9dc3c33df88facc4db4ddc4699576e699c4598de84671efa84c4c22139044f3a2b7a3ab5500a84041eb481e3a78a0ae66c9f249f37f723218fb787f23ab8a0a099e354c4d0af7986690633c106470917cdd0ec6ab0f21ebd0d44bfeeb974d81df1a32e2848d4b51cc2d2704db249b411a238e8e922ecbcd4f46a6af7b773e27a48b0a3f39ac01640b4a0a0b041e1c0c07934023ddb11649b5bb2afba94ac847b262ad7bfb798284dc1728191b4d89136443ddb1d6924e5f5adfcca28ab14e034b192b67732d225f6c79b79d0143633adb91818c3c56c0879a0167ba843323b3a609c950ea6ff039206ac370fe7b19a4903fe19c8a37b00d6487740ad9f32ab6003421ab8170fbf88979bce690234e4bb2865c42f7f6c53d3e147e6537edd6080c9fc8cc4112ee7f48f9f770736d5a609ab4dfe4ee1ce99ef09e6bb7ba4deb83548f1afa9175e28313179703978fc8f6b07c581817d71acf0fcfb55a1fdfe33519d37746e68d6e7dc489434718a18522ca7893b6f4f711164b0464dfae6ed3d1c5dd4ec08a2fde4ade5b7f3845fe654a0a031c8445984944b9a1f92ddbe3705c7a02038312d2dda1289d670c27fc6da14c6ff11e47e96eed4e97449a2e93fffc5c835af3c51dcbac4944f6e05afc7d0c991d40c5c42ae6abacfac08f0e4ddcaa3e3814c565b24b1530a745849e07d23b5d08bec304e745cf6fc855fc0eb97fc01f0e39184692e43309e445663d41b1751a6fdd45c1692f76662f16f9ac51331ed33f03313ea7a7967cdb1ccee212203a35c870a1337eef74a1c3f0105b33e86b5de2a919e7e79ad8b8495e292069e7f77176b3aa15798adb002daf7088091637aa487824a73809e3e0b228d4a36dd27e659bf076a02791c5f397744042227a4423e117092ecd86e3d075a007b175b03e23c5ad35d2b7792a8cb4c37565d8dc370a6642808225c4caccdaa97b3a786a41e2034c0bebd8c393cf451bd315f7497ccb17cee205e79b7e1f5799f92ab957bb61ab636a3e71e2115195156fac5de8c5954852e4f5347b8117eac942858e67ccc3cb894f4d09bd39426eedf1b7bcde1bfd28f6b1c2bd0380aeed0557bab4709ab4a8a084bc224911e3fcec36496a34495245c0d8e065a85ee37ba9b7f34fbc11f40f6bfc35356afe08178270bbb02849b4fe8e426196934793052f1bbb1e60765bab4cd64a3fe4b1d45818ff09711a764b8bd36620cb22924097de42b26794641d594285e25b3219fa2cdf162de38e7682cdc933990bdfc7df1af977be6acc85ff23548761990812e43b236ee0aa6bcf99005599ea23a04c2c1702e610f0957a80505766ab0da4eb8bee1e4f05e1246b4a5dd8e7e2b310dfa8070f9d363a2f89faac74f0ca8a321ba33cd9ad8ff06a1ef32cec084fa636a51afdd4295cb5adc33f59186b040fe5f156dd49a7f8dae05c90fd8e8c8aa3f523fa7dfa83a825fff56cd6e590704052063e66b89e7a9f22377a328274b3d4fa81af03f43e50520cfd59c14a6aaec4540cc1b7a40452d222e21d61de4617a6e6ac752d8b82bca20b0dd547a9d3ff4ac51706e7dbdec022f502afc22b6f88bf788c4ebbda8af7890b315be10873aeeda45dcbb68bc500e1bfb286ffc89ef2ff627681427554ebf133c3e1e3e2dfb97a79ba6771583351fc5ed5188ae2216e595fe4891d4a40ff22acc569a6c11eb9d7553298640bdb985c1b92f9c778269e4c18ab9addd62a6d62ba9a6501bd5e2f98e53d4c3c605572f3c5576ddaf61a6eb031b5cc600a160b91be5dc09def410b5303a322512c79fac6325b0cdee340c9f9886e7ef1cf505bfcc4142578264384fc37015118b612f4a5e09cde6e8696fc7384bf7ce07ac80e6c86b41608769f5d16dbb0ae76a85a9a2e47306dcaac820616ffea381898f0977f8a99a9738b7dcd7215f8ac5be913f65b7df9a98c165b84cf65910f7047dcbbd15fd13b5a5c5fd8356fdcaddcdb05ed402cb0965b1e4ff9785c436e2a5e3c85ca9b08fd232989714ea4aea616a9003438e222202b95eab62b7bc578e1289f097ec09bf587cf1b4a21c81d34ce0cf04ef9a56bc3e0c37e86ffb94fb37719f7f819c34b638612b69aec08f8eb8e1d35a18cb2067c7351aa57643bc367431c7877c03b3f78d3913b3a0f894c6b63eac8727ded5e9aa2b929fb193f3860e0fbeacbe6984194ab3d4113462a293d107c539d9969397fc2f929e5988d06c177cdaa1fcd94539fb12af52e3c2cd49dc717e8eec23354d9ed3d21720da885e916688b956b0a4f33b91d67d62da03962cd0cc44436cb23883915a5b862b07d5c50a91596a07c053fc538b157e5b9c7827dda49001d701a693e8be6a51077a80ecd84c024d3a30e44ddb9ad7118d648d8876a21e79a7d490a093883763c5ca056dbfc0718c13e55e1a4db6a829ab7d53fc7ba9640d3b92fad834715c75243a4b561750bf7850db78d25706df1566b3224e475046e3758d7a4794886d6b39947ee7372eaeb7fa4ee2ee577fb94f97845d31f27ca38163011ffebc223106c13c45687b6b5f1e304f6ceb2360b12a0459107ed565604efd7ce5ed62212e0aa75a2846a7ab31a798cb043dd6a3f0094bc064ddf5169084cc1717306bf6f73f5c4d8db7721176fbe78086aed4ad4ea4577b7a4980311906f4afab5919681d572d00bd99ac334d3b71b0bc2cc2e4d3e6c3aa6770bc00d376d0bbbe1ce72244f6d0d8e2c920f1056e5a9629d080ed8253b1277937f61b95ef397951237ce8e54c19b36de4a43929a939e60b38e8ce37188c9d3f0fe2a5c216a5fa61bec2b8dedd33b2d5c449d1486d94e4cc7aff1570450f65466e6c38303b5be24eb696f883274d3fc54a69514c28fa42879b38d256ba3ed754f4b64cdc0bbe25877efd3edd6b172ae600c482838b96c0443135030c6242cc3b7fa9bc9011a82d0101df652fc19c83cbdaf71a205f8866797f2c5e4707c1d5d71eb6d9fcb1a8be984bea557896e06542395f72d93d7b34418d21678d78752c5dc94f33bc2bfe27e2f48ad3b9775070ab6b7820bbb2ab8dbe46bd24294dccb8fea3a6039b43d81d8d87bf33a5dfd667dff91ca034b1bbc3ea8e033806d1c3784b2af658ee0031eeebc2a8707ed51c5699059daf758073bc3496ec1d659069e50571ece62059c1f76c53993d42d5174796de216e7f1671ef7b5c83832d051fce6f7f92a30481fb81d6b7c35fe0f0b52eb33dfe2a45c2d5d3d40425d20825fc5561357e4d49562063bc37de25fec49f77a129ad6ded00cb2bd9a09817986b52cfde01fe598dcccb5ea6a606d9ae100fa1dc3437128d74bb54c9853896ae3d544bf56f1f34188b4b3f2ffc330fc52e68d12426807a1afa28c42574eb0995d84e455be65e3b72c5f706e3ce0e6d4c468e135a819d30537de2dfdd2bf08d67e1ec05871378ce83c7ff36c7c0443a86550bd49eee80d8ee3111874f966abb56aa01487c04253f995085cab3462b469d3037e1b09972c0137184150ba4bd91edccbf82c079d51b3142ebee5e302895cef02d836b12b1473038a95c35e176a33401a81fa44a934bc52bc58023823edf58402e55faab5b51e766d377e1c77edd990514addd4289f97291d0b4fe298644e13516ccba9371ec3e7bd877b8c9bd2b1ee18cef4a782c050c25c6e3230941c1f6a39294ba5caf4c788c18e7d2a22d12d19e5033addadb800cc58ddd7d4928e7ae58bf52d7d51f2f0808994741e823d6467397269add7f1ff7cd0fffe8585f7cb0b7257b91c9ccbe78bcc6c12a366d7cb27544f3d06c74607888ddd70e2a306be26e9be1df7e98ba6a53e0e28e7bf003f9e976e37d36afe9d19b798ad5cf1240824e6872922a4baeb1d634178f846f8e784894bc32ade43b8f53ffe45030927f48a10f70f3f6b06c9e3088e40585cd946d70c0808a7cf170ad725a7c0b5b0860365892222ce573da053d10b59c673e849973716144f4998be2ba42fc12de799d8bb16bae7aca5cde340ff7fdc74661afb8ef045a4ba61f3aed5531f8e5eb053b070d9f764d61c7bf3c50231e94c194f527e19ebad9d9a4d6bb8ad9e76e92d9f3cc0ff70446139a6b48073f40ec217a39dd5c1e4332f841abf24fe20556814a02df41834143f9466d75471602cc51f6c8d8e2ce4659ad33be950d734ca30b9ca8050e923656f58ff315eb778cc34ad870ca07ed23cf5cb78f221792d4d38c097b830dc3b2c12c3c73afbac3661d3e4d9f0e8f8a51425c319a289f5313a075907324f5945d4fc831db2891564b6d89209538198665cb9e5e88cb8776251d3480a9cdb66b6d971f4b309d1f3ef218b35d15d306840438bf1251f8915394cc1d86dcdd6b0614147bf5afcb06e8804f9927a4534c276d897b16af834c1bc3d478b226962bd13f71935d5e73285a8e5a851511dfa90cb63346b6704c86ef10ae00d75f1116d83c77d8e8a477da27ea89bff4dabb0627de31c6c86d21f4e068b40d6cb1822c4a395ffdd337f0517afd7cb5418985673bc9296494dae2073fdbda10709fe915d087045a38842b5cbf338825da4a47d644dcd80c38bc84a2a638d3486102a35d9a4e384cef38d473b39ae3526a864350dc9c0445ef8ee0c521e3cb5e2ce833fe4ed866d830608c42f5bf200d4fd7e64f7ef64e0066215cf100c9c38fb19331bda5860bf1e49e9bf75439be107327c07a70bd935b36a616706c2d7f0d29aa71e60954ba22abfb54993c48e5df67328381546e320645c43e40231b0a01800596ec0aa66e532b30e03f761bb5333a739c982bf8c91ef3e7714354011d5645e1d6524690be976774b79dd86f0ebfcd85160c727898bd284f966dcf8ed803946dce5760d4e159902961fe958ea2f5202f11f81700e6b11a74ff477efc62a4b2c68de19677192cd36dcbec32ebca1dae0e6d1006c30f987f08e2793e43e4190d462c840c124387b8615d83ef185f925b11b9baf73a2d1064633308cfa1faf411593047a4fbe8ab36954133f413277d1cd68d6a7a007eb52d73562e1999b1181275fa1023a958648c59583572f9b4a72262459460775e08d426671fafd372f518c8d2fe1b4aba7825bcc8f8e8e2dbb226b8154ddbd72284da137132c75927989c37ddf2aea6ad7b9bc99948996edb32a18ab2d891f3879efda452e2efd18a6925c406f3adc9bd6f6c3b0aeb78ca7cf810cd1386ebb571c2b2630fa9d3ebef319166475a7e3a97a8e9cd561ae353e4534543bf7f7fd2f75e48118e2a79b03d63026e2c62f1e9254f1d5e4c0917f7290eabd951c7770c4f71a14f885a74d84a2ca089feb0d9310e93b4ae2df1ed5f762d05f9a472ec3e8c52c30fb0d273fc52c9617e0526028f3a94021d44723b0b238189c750be412d8a54a0b3b5ce5b9d0e9d7340c15c118e52ae45448c7e84011b0bee7187db0967a0563adcc32e67f9acc6ccb34075f298e7e794f0f491626e7cbca8545fe6ab32d1aa55cd348a84f1d8e5a18801b9b222a7f064aa74e66a32eb8ed567a659d6eeeae8bdc8ef8869337e4d52799beb6c7c08d9ceecfb00bf28f57d646599a36e837d5bdfbe53d621498e5d0c18c97fd9c2b674ce5f5d71c47813cd3a4ff0ca47639dbac7d27600d27ebccae5e340d5fe196ad6d5f51f883214b3228e8c630e0c18124846fec3dcb0e9107a28a9acb27f637b8ab1fc53cb63d1815175b16d06608594daffa7716bd04938b0c1517914c5d1f601d3fab0db25c9bd6a833ed5d3125fffced2d46e782d780700c7dae521f6bafcd97f48a620fd893b1738cf982a1f4eea8b619262b5b2ddff48f032549667bcd7ddf550ae3022ffd331929020289afabbc1f1983ad606773e9f206bd6f60193f3c3a0c3995c57937cc3d6103776ae1ca7398e4b8d42df663094ab10f884fcf2b9a6841461f79e895b33b6a22d6299db8dbd1f4c60d758c0088028e57090e3fc314c5823e8fb8133ac15ae0ec760d13a3e0944830cb86c60d10bab6a9d05b77e346d6588a6a0900f13645fa4a6494070f74cbc368dc9fc8f76e684f29111350ff7e30f68d289fe1bbc4c3b8e0945347f8ba49349412e7f3ef6fb26b774b40c1e925d016d3647a187b6bfa23b83df07c82423e510d2cf2d026da4374a8160baf51d3758c77a33fdb7a3b1f4aa197640db3db1d17a6dc713be37852ff386d44ebcad3847520d6463faee8d8fe04bbf1d62f751dbeb868776271ec1185305f77e2b3f242c740454ff27e334d01047f7e8662da5361a8c51f312465dd10ec0418d68e6333e06d816d149778b26303d0dc8e9f4cf979ffdb2ef686ef82dfd880d65b715df119499cd2d36a50be93bdb45e04bab3cd3533ca26f714cd19029a3e22fffa05dfb54c6d09b18e53f2ef4c7d9532abe73d393c288a3e5326f09220e7dc1250831dfa36db1495627dfa6dfa9f3d1b13c0f13f7cdb3f4b21c87d2fc1376e193b2b7ad57cf6a22a3a24a07070a6058acdd06a2ba3f313292cbd863008b7dd97933ec27796aa717c6ded6fbf217c8030307ac2dcbff8fc5a20a97d3fe66c4fae5e43dbbcae3866fd8cb401535386e4683564422a32c9d99d3473854dc2d933bbac51bdd6ac9fe95c3fec037aaf336dc3cff782f440669095dc4614fae13105054bb8b6a449a2078f9236a6f155400290a924cdb03cf3e73035fec7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
