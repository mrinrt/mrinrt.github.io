<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa4952709a4b9f285afb0f7c0ed1e58ff1546c6543a538b2780753f8ffb242d369d34984bf08a43ff3f46789452a49878f5d5564ac9f063f514b8904816e6599718ae02608dcdb06bcfb50b0562113cfd696aa670f5ad78467171e63eb6fe62ae539f8543270d5a9a679b7d1101f2caf09057c2f9e6401ec7760f1bb550784c4765167885dbdde6635b040501330e103d54be72eb8f458d720fe4d9c609b62b0992ac79851a6c796b0ad6ecba2cfba4eb9631aceb3ec8c9e60221d24da75c316382f323e21077da74f0c0af70b443cdc4eaa19975d75bbb846897eb69e76812b1bc2d1140976b1cd9e0f1936a73d050c8040f540206ebfb4d9379eb54b8e55c62e06b29bc752bbe8b1225a2bd2d0d4220af2481b9c4d06de04ce267298c7da09ec58df154decc9d65f9deb52c58cb52bdab5e7c7308127985203815060e718dc00376f79eb2f7ab6d681c5c4d08a2e412d9ee377fe7852b586de0a0b772630182ea3028d7eae98017c05e07acc272ac4dcd40adc6b23a9c064b200b6efd89d3f9ec07c18db8fd43609003648889aed38c1481e662945bbcd61780b78ad9b0cc5d316482d17da35fe591b0d68747e59925ccc951cf95ff9252fd198bdb7780fdd89e4f6389146062b2dcc001c3b33afba29120f38fb27d5de43a49051e5ad6670f78793ccb6a1f163c10c2b4d79315c5a9660fc284ca9e85ba9c843c684563a8b26f052d5b9e43e6e5c2aadcd4428e89ac47e1945dfcb7a0d6ac6fbf0ba69ee1c941b412c2adfc772f75e32a34b7ff0fd1782f4b7408fd57b067f57a5629d7d638337b91d91c6c6211a7369adfe5ac7c62f2bbca4a1a576912ce17b1ce839c5d177bb8d977ad49af97c3067edf01de4e111d8589f2d3cc85cb46ac62c5056ddc27780115ceed4fb1bb808220dcef679536cf3e292e75a90695c2d9a785dc4f1705778ca59167762e302687dc40c44ba086f9243c37b9b23bf801652edd5d11d80c0f1af8c10b7e17a2432730781aee5d10895ab567c5b13af8e11c66a01c504ebab6dbdb0dce838061cf7bdae9f891d7e75d55784dfa77c1b2e12dcd71e9d2d6c9225fe2265b98cecacb01c8fd80d87e0b0f2df49273d23481197fb7cb4d5bafc400ad01f90ddc6f9f534d19ceab9a94f9b3dfbfc9b69c134c90b2201d61c759f311b09c21a151a865f63bf86ab85bb373805e04c979edcdefadee41139f4abfdcac14a08af569b3cf5fe0fe04dc32f88ee7fc315fe6b7651f2a91109f590b175a0e8d6fec8df5bd071097e553a4723978c3e7ca1566fa56266abd9130d4b35630b93f6ef6fbb95b1ba6789414556ecea63a13574de510ec9c6adad900c792eb0adcb34fcfd42b3dd6d452b87d7e005ea24f8a6542000225931c292e4540824c3b5f8e9ba83cc033d6f8d1926c8961a28fdde0282bcbcd327d1f7594e06517c89584f71abf35757f33da3fcba6f3742799f590d2f26d38603671c7dd55915bd7af4d14fd19a139ece7e9454e0eb216c3c073d0a38c7bf24909662f0333b28e5dce28eeef72b61f2da8934f4d94f40b30c7f8b36dd353b428ded6c0b0ce95919c75ccc51997085fc77a0612ad3f521c8ee314a149817679a554ec17c765429eb759e5b505912247f6ec2db6e41750e953870e4415a941356fd04d44f3975e91cc0ffee841506a9cf43e6fd43aa1fa666885491bb3fc13d65a40d03823e4a5650bd225eda5542986e9b67bacb9621c3ebe12b894805eab73feebfcb4c07226a08f1dcdadfe5025efd342332924327548c54b862af51e8a4fe49b80c51f045dabc7c2df0c54fa7f2ff343a160eabdd14470acf400f76d21b034f152633e1c1d448834393c9cfd5f55633db63fda00a9825a64cd414433b47de3c7ab83511b655e009a61d4ea12ca9af86a4acceacfdbcc55b3146bde206308585f9eebb92f7547788e5a425c03b8e2b0e97f5c834a247ee4e5657e2d6e11d6502bde3005ace4b9b40126491956d2918705424c0e3b360472cc335e67dc51b60d9aebafae10f65553a7d48f170c1627c3e52ecfabcf1eb2f138f310c72cb7145c7de99b82a39dd98aca16dbb7e378519668050ddacfd9cdb871a4a39920544de72d1da0aa230c0620de36f9656b0680a0e4b71660d648d877a9b3e016b0870cc2d8f284092343506e0a99adf6763e9e2307f178795659872e7483436a2428d4f10de6074ebbf0ffbcd2fb83496741282eff5c7260c203041057b6d77695c2a0b043a21d170bae55c3429b29bb3bcfeeda675d297c103021bbaf0698dbea1cae4420eec45a7b1d7afa72a8650e956ae3db01dfd8771e6ef0ca92c8bd724f4df994e4f99169a54946f06cf4f9f27590e31e7e71a0d2860c524f2ffafe7d7c09ed57a63c165caf0f7a1974b1874575f655d8bb990a82a2cd5f23f0199c24e76fd66b31dbe16a6f5989058a3bc49f6f493ae5d582293fd44e69308399ee6dfe1570adbe12b679b1233c0517012eec8c5b96367bcc81598375a1889ed10ecd9a2c95f1da1f02bc5cbb8b825d886fb7cf725ba1717c0cd6b2329bfd0249e1dcc7fbab7e4473f98f37698fe3a4ca7ac31babd7632d4f01087bd1998d05d2b9e1027b3807ea112dd02194341b7644dc6dc8a9405bd591565a84344cc7c2e4cedd83b0032a2893467290e22b08b30e321a9a9202e1d7ff5870d0e7eb455548b3ca5dfddd264230b5652f3f642672ca2b03f72fd572259a99b48571b28b0714211b4f541c2d7ff8396cd5645eba963fcc08bd93dedd50bfa70d9348df2ea12246bc8e31592044aa21c1991ee11e3d7d4d567ff239268cc4b37f718667efe6535ee30f8845fb4f173a3c7006b913219a7cc96070427422ac21450b297bf5851655c8bbc5d0023f606111db62ffcc9228a02e0ac84cda183e6ab436ec15cf73230e281f6fab44a6c82126fb8bf59becf595af49f9d7704d15b03b235f097a53fef0f450d9c77fd33bc9a1018c7386f7ed80726afaa9c825b3ab7f4bc87db0d54009776a7d62c5a3e8585b90f42417e286b7a2b03591e04cd20be7806e0ede66f836be98fa54d364be6afc5c51141ea27d54e9994c8c2992f838aebb3dfd067831ec1be55c8d0ab9bde12c0d828880cd27071bb049d5817139f7a9f2887725d6f896b76ff50104cd5a1947483224433f91baeee34fa9f5324c2f91c706462dc65670418b444cb923dcf1e3a605b8bf1b556df8b9716c2aa09688b38342f7d9b2b07da2c9f1396dfbafa43f8f1aa8ee218b9d8fb12af73940ab788d7d10cd2ba48f3db9984271e1032f837463ff591c76f2121d113c7d870938535bcb643fcc8f1066c01a074a1a18690eedc3d36f92ec743500cbb34a29bb0de08f166d8a4929974f65cdeaae46b7256772e26f7e192ffc1ca070d1e6b31947abcffb6e1dd01c203d1d18830b3eecf5c062d89dd3ee8aaea74f1fe3e37d5a4da413f99f38d164572fb22f85855c9cb0cf81c98a819f60b96b32e8e4c7c030c40394040af5e9b1e530fa5f729ecef379c7f97b695c9378237c31b1044fd0b4edd7b503783ba16e23e0c9c95815f6f17425073e01b2b00e1f460dedea37f84cb8d6f0f5c78ed8885ab8f03d22604d6015f218c9b619d41369a73e22f6f487a9130a9e6f8bdda1cfa5c1c24c5dc875d91de3dc150b744e144fa3ae6e794b76c0d8bf8dd806cf7dc125fa01453b7ef803b0b76e1d85b4969c57f66a911016c76b8d8afdb953dd9e87c8cb279dd29af5441a6fb1563bc4e936a5af9ec93cf88eb716f308932ef66daa8460fef36c27ad66cb72de464354f335199291c316a008daeaf154a70516b32fb9174a7c730e792119a124cfcfd0618e4e4466d948b81a403a486e9419c09215011a79838f90505e622a429e7f8b170ef4488d240cc9b8a3a8379ad293b0c28331f34271f63b2303fee69cd779ecc68c82290c792e6de65db53b0c4402c58f117256fcfb92b0f6b3c6bde77564806e50cf5e86a282e0e8dd5561a1167ca0883d2140cce64b8b954df750cf2cf70a8dbc2a487edafbe7cd5db08f3df5d79b0b818beb720aa36669c69ccb36e904e78aa37d2140cc5154d30344c617c62d03f79b93d39c607d6e006be9bcafdd3c5845ea53f81ba4b6a0bef55d1bf21fb65f89a59b093c6952bdcf5e42cfd9f9c3e997e150f893bbc92079468f470150b98910865992a5885b176ba835d8d681cbcf0332458a09b78448867d7a53a6b6793c22ab5250915687b2b1126eb9e4fb94687fa2e125ca4c57c61ea75fb15cffc88507884553aca5e3f3d44fb48aa682073ffe8d578650b3ffa456cd604c4b9753c09def70f4b919984f9fd5cf52a15480691fffa3c40af90688a0928ac4874632e9425437f4d5119e620e5a58300c6a138da0344942a6b0400619f9c1dcc85af0e5d328b39d0c10776e09f9e48a643203cd87a27f08b4ee67213a2ba9a08fb106b4c733a2faaf53a5872a70ff6fa8396faedd146b97356f6ea46136031b7db8baae215d1378a8b8ed5044e180dbf89c94e990b91541b8ae9588877db73bd46a1192b665a8f591e369bf020c98b774dc6c209e73ab033fb1db03c470c558ed46ac1ac60c2c56c8d22f481d422be31fbe188a5faecbf7b96c96ab7842aeb7db6332c8731e2742bc25d558657f321982d48f4bb807d3bf65ff500f95972d747dd817d67e3a8d9432fc48408914a3e6e776ab0f09653a6f72aef3978812cbbe0bee61041fddb90d1b5d73972b50e55dd20fa6a9f546bdc7fafc99fbc6a6f4e6d5956b741911246f52aa5741062ba9d2fa6edb9d87f8a57660cc5b756ed5f61d377d35a800eafc108a9e890075946a194603238529be6c18bb76abcdc4515b650b949da1cb77dc03d0452c4794402b74fe35af204439a5df6d52024121467b3f595f2f86a486960d6225b62c8045fbdad1a1175994bc1d8ff22713df81bbdd39543c5609bc604597a1f8c15865593d17659da04f6a2e6e5960420afeb6f0fec828b9325b4a32a739e680cdce445beaee77e090531d9372a2870b3e16c83a6569a5f6d5f3b25f95845bca238a0d4fb1df692cd9baa10c719331e877437bff41c6ea1b2f9e316f2140f286247a85beb4839b81b6e80003c12b8388105dcd8bb47a3a7906aa1226652e977efa0d9cf9994f02573d1581fa6583063c4cabeaee518de831c4c5778886b11839ede261de0d70c415611fb4ae70c3418bff6817bcae4181270830cecbac22f3d5962573cc6080952f85cae44485c3cc4e2b7c157285c02fd031a1ba409e6284fe805ec67b17e5de4b319578ea2ab20228e23e881ca9aa1e4f3b4a5281bb161961e628957155891aba5428342b13b39203d00c1feaedb631c5db6700c7ea54e1360808ee2d752fd4e4b55337b1fa7a65e8fcc5c548be3d1fbf28b9825297bef00805b8c85127bd1e5bfc7416bae7bf4c3c9075510cddeab230c2a2ded1b3ec635687ea115dcd8a7f53c6555e39a18cf3009276ac3429a367eb23347960a090a289ccde5a0b4e0cc50031bcf71875d22f90bbf6e451ffd207269369c125b75580301b6889bab0b0fa9a79f56c84c3ed6064944758b9abae77b084158829b3403848a3d6a65d6aeedda5c495e9dd54a589133dc77e542be6ddc1f16f34ad42865a0cd3fecf2baf20548f73074bef707bba52563b7e14b167d54afa265b3d6c110bf587cb5d11f434640e027592da319bca90e57f4bd2ec1f6416dc853f8042c039838114c3105e6af9e4faf2a1814ec4425c946497a99728ced5f319056442e6f55d99cd410ee47f4e7ada549e060aa041f4498f525ba666376a68480e28a3f02c2fb8efbbc061781b6ff3d91798520e0bea290970fbe3dd63d22be6a421bbfa27953bb41d98afdd1a46137d549b168ddb5e9fe54f49676f6bf6be4e6b285aedd34bef6ea0cbb2c2340d3d5fb225c77af5938a64fb4b271eb30c4368b98da6e3baf742e1d45d56ae0ea3fd9eef2a9c1af8189a01ab8a849105af4b8e581ae928eb341e7221937aa6cc5a381daf10f7e5055fcd2464eeeaa7e2276b095060d8b18ad7c619f7c4582ba0894111fb0a7517da8de5642c4cf71c23bfaba96c13af25dd979399429c548b56e803589d71ae285d17cfb7f8acaf154fd9224657b8dcd5a185d499290b5e884f15b8507fb716da305152747bf588752baedc9626ebfc04475fa23a7cab6ab0288a5605991eb6d7204f0a0e1db832c847da1c20c09fb5ed8b910fe110a872c6e52e0df0d52dc25a460c69a3000f7bb784afd9acfd3538c0e649bf526de9cb15b1e3adff5163cee8bd4559c974007da9f0e5b2704d07fbee86ad9c880bbbe1bcf7e9dccd3939742624a19621dc61d135bb7d0078ccefe1f30ca6db67dad71d0708ec65b1fd5418cd4adea02b67a4397812aac06ea0244cd7e40f81c23a8d014c8370337db0d44adacf01ca6e8b921c16821ce64264d1284ab827ed8c72c3bf4c402ab632a46e5da8786b4fb0ce932ed231f9c5d47522bc8315695357972fc85ae3eac0b85eed30371e9e4fdbff655be517ee8cd315ee6ec159cfee62b7b9f1549d62d5f7d89a749a23fdcfcce407b25cd1cde8bb136c096b57a03fe838179124415afdc89e5fe43bd290eb1903277d2f1156f15cc9b45abd7af48d0b57130d11b1b0799f50d51759c1ae67dcfedcbf46340e72460ee56e3f153d89fa1e2f01f38df31d6872d9566c7e5e4e3ff88bd929efa939a19990db962d6346a309bcbe66afd5eaec639279fb409e583c46a9cd21696dc52a34aac82125e1b88662dd6a9059b4ff37b16a9cc566e26273faa5a0669428d49d49e6be31fdabd91e722bf9df731f3788d49d72b7eb30508f589ea13cdc26c64c763237ac8cf70505b39798fcb8d5ab059f87e40f311fcdf32dae232a751e0d2a2e042853d6b832bd39339dac65df01fefd760c83af2ae61b6c882321a888adf86fd66d734817c645ed3aa54636c0b2b93668e329fae098f1334dd0282fda79ef95017e90f667c04278e530693e331e48e82c52a66a7e1f8ddc9e8dbfea3bf45dffbc686ae9fd6ddabd6d8d300e3e0c53bd6996c859652ac00a7da40e9cdb637371964e043497448241c2e23429a5b75efd369a384129526e2f93fb8b692a901b0c60a566ed1bc69079a67b21cb336befc5e738f97ab52f87779c96e52e72dcdd2dbd67f03265ab3b11aff3444a20c164c5bed55807c6a29b5ae2ad5b7e8142376d789f06f85fc10b605173010088787711b2f0786d1e0776ea784bf8edeef05f79ab1416cfaf45f0292d7d15f820ace5e29b80cbb4afa78357fefb0f65ac06943fdd22ab534ce7488e4969fe07123da3fedb71b378821be8a8d81cb879284006833fa31fb54b0bc26269caaf8504177d66bd7edfa36865144c4b898d6db1a33153cd48892fd7911d4c6da0d5fc594a223cce27234d7a46f87191c907afad31c874cf305697e74484922d4623f348b8d8a51e6121407b210cb0497142450531a9f4fe116e67ee81264e06ba893dd4bd574b8fca27f75ce669606315db1750faf59d7befe18a4b71e16bd5c443e9e08b3b73ea004ca8316163c7baec65127fe4637ec0e4032c03b9293e11f55b8fe01fd13e41720fa21ed57ddb8953008b6cc261838d472761f4f4142ae3e1ac9af3595d96e44e068c73a841e496a756cd73c9ca2957ba5ad07c235dd3ca98c46a4b1cda96accb7ee9ea10ceb1681701838ca1a67e3cf1c7c8bee52404d74facad51a8262f4ed2c23f67e2dc64c63ce958f5945ba12bc1de2e122f84a3b1d02e12b413eef2d2bb615b7904c3b99bdcdec969e03298dc8c13aef364d4fb8ec7a447fe5aaebd8a4f2ce38dd54f541ee7f9fe53188490850ef201f293d67864d5b0590be68af3f4aeb9d79b6fd2e3c573d46ecc6061792d6d7578150f54d3d4baaf65c7d13b66237fc4de3fb39e1fbe376eec2eddafb5ed9abd0fe23f38c0bc2e7b5440a5d61f67d94ad1fdf51f7a204c1d420c9ff35bbf52a2025ae47784a21ef488bf3f2a4376ed82e6cc93ecc19628d6f19eb4fca394e55fdcc166587ea208bc5dc4f93302d505d09874f7feff87cdc344798409c76672d794628dbf34b7bff32baf639227cf48ea89abc2345a988f9e06a4de657ddaeeadab5224d5cbe51858953811e683497acd02c5fe7d0c659bc07a20629ad3220fc8896e1802f324c4d9d30731cb3a1b439c05a5c58919402e8cca5bea291e46762f8b07a4efd68c8718b9bf181f55cded3ed4bce147c222cd0310f157b425059e552d634560ca9e45530ff3933a2105703b2406fd595ae16554bf9186cdba3edb9859ef677c7b8c8e1cc4dd097d5b6d3b66f2d16e2b721a785919a7f1165349f0b9d4fe6c74c5bc4bd761189657368bea6f1939886c374df81aa84522ccde585cb8fed4327872cb850998bb4d2013abc2c2fcf253be96158c41f764e5123780d67cc3dac6f725a49d9a0dbb0122107d5cdeea54395361f116c9fe69d5282ecf6483172fac3c99765107987a8ee2381df5ecdd5f074da48740a54ef6ca64ee947180636aa6136795d1c63bfc31fcc9c4b4ec1fc3ae17bf0feec973f87525b72efa254ffbed20e0585e94b0869e6f24c5a10e2cd88d4f26acedecb04fe0e44216397ef05b45f15764c1cbff3d16d5564f8b02fdb327b3129058959f0badf53bf2e73729501270947d5940f28c1ad615a6ed78fce2236a0c9c31a93449a0fdacecad93ecc673ec3329b18c7041efe84de559e42fc36b5e00ed3aa6919f9551b85a9a9fe938cf3b4db5999c7546fa4b2022cfe84253e03c98e9fe96ce89373eb6dd94cba27e2dabae47fe0883159429f2a73706ee68dd70357108dcee61313cb700317fda224873fc86fe4ca9f0b31a963427f0943d267596251f5f43c60ee245d5cc2682116ef598f9311a55067a3d50dc5bf75685aa7a5ad41a2de16eea9210918e9d7881c4b005aa5732ada8d6397ff514c750ace568cc64605ae1daafba2b973d0aeb3a9a9bef7983e40ba0a452cab56d5c13a09ab3bcb54a6747155e58800c4b6bac8655c4d757a7fec4d2c42094190717da09738cc3089eb762da88ea4508c03fa32bb5d3bcd32d83e47c1453cfbb39789ab41bb3a50fc42d1300563c7afb15913cecb0473c0baef33c7df5756f11acec99193ddff69decf415f54531c0b1ce7e42e6ff4f355bcf3c921481fc23a3f8e50458c7d26d8f9e20e7c1bc0496f4d80371e43ee34110f3f6533171199dbcb15c030290d213c92e44acdbce46faf6b25c6147d8d3495f03233aa7adffaed088071d9e5b559b3c78ddbb756f95249f6695e39ebc97d05931b5c16fc1097484d0e86b2a255e98f9807d3f6a5293ffb28c7e25eebbb46f2d3a24e48257e919ed7c803e68cc75e07c3fa2b4a95aad30bf44714c398e1941b4abd2757db9b13cdfbade13ad94f88b8049a8d4c6b369ec3fdc00a4ebd6ce0e32f7a284e91941e3e8556f99527fb271ca01e472594a4ce338a7fd0d45cf0068e6c52bd36644a10646c14f6a9cdf3b0c4ddc61000b4b6976de18e1e0f88af0599c01b9335f47a6a396a489b20f0efa473f4efbe99154f72fdef81bcf0056c0cd5ddfefbe86c3a60c843a460550a77bfd86b973c8804a2327f5fdb1e1ddee1c3168ab2e7fe194960425a2045aa9acb761b9b2d8f45665eb6e4373fcad04ae85e50241f6f03e039e72e764e8085cf7d1e118f87457a1ac56c699d670a1547bf8e6641c9369a2b493d79d7e5020336d7010e3997397a4d47ea8268056ec961d24851a53f2fe4f068518e037ea31df7f36c1073c88051f07ba40bc3a66578c8b07140c04c7c2cbe1018ecccd0d7aadd256d3a376b28166f10b094e332aec995ce2a69dceea6f7549e38c56ef8e564085cf9d94bad5186f0975d913fe692a96c1e436c5d0f16e915e8880ec47c369df8acfb566ced806b6812c349bc7aa065e49d782f35fb744fc5a33944694fbeecf1c124a82dedad8e95e3ff6d1c09a5f214800cb34de1044cf45a04f653fc42e505f232244f5c922c21f10ab3c867fea12c1adf8d3241c0a122c70a222457de6754695598a9954d8417a37d217e8226b549187b3c99c4426943ead0cc0daee6d79f85337300997a9ffb74d9049ff73d2911c2df571e5b13cbecedee5e27de4421fb0088d3de390d246a550328b98a16816087651b5170c00426b47f615d0a6241dad7f25e276776087a7ff4a3117312dc5bc17d56a2ab9dceadc278d36064dbb1cc76be807a4d8023a5e449846f11c7caf14aec868eaa8ae512a595d3b1791dccf0105e1d1d74855c2dda768fb03bb6890d32e06f47cc296e98f488f14eb781aa896a96ec7c2b836dd596c4b383ee5ac723d9aad957ae032b66b50dd1b67ed2c408ff4a0f631b8470ce6a03694d45420a2bdaabd0237a05c7865d536c9cf67a2ded65b574974fd8b0d8485b4a19a8a71ea49c4c3fa9807a11a0ba31c734078623b36107879a9b30526e6bbf534290307fb268efae90d320fdf887b34b15fb99b4a588bbb82dd97693e2387f2fc593aae09096f0c8d1a03f4756e8b0d3203c2b9def96f6f3c685fc684dd5dbd27e184252137350012b3bc49d8a014fda63a0c8d36ed43acc6d5a1683afaef0580fbc2f135b84647a4f3ba4b533a7cec99fe8affadc84a12deba5bebe8deeb5df19c1682ff9756e9228c4ad0ba710afb4bb2e5c91cc3d09a359d6f124575c00885ee4d1a7202fc53c3cb96de095d748fa09e84e25548851b4d04efe2b45c7713179004ea16ec7e3608ee8a4711bc94cb89af062519f9eda567c12895e1310ceb867afd11eef844d3bc396955990633724850abd284fb690034aa403bdbdbd92872b1822ff8db7c5f559034d3d2bc57a07709ec5d0d0ddb650f2663b07fb041b025de0eccd8d2c716199c386ba0f02fd255eeecc303516ea5bc82ef7fdcbad3fa1c18c55624eb3a46830e321d6e434d71ca5a413d045b4e1418657f9163a6e0159f5af3097be64273b5949f2d434204f50e83df3bcc6298c2c6eee9f08d919f14be22799f7d3a7b8e10fc2dfbaffb86e0c221b236aaf2e926d2378392d52450fb0021e4a07c9dd6a609540e94720213d72103d2e11589b4e349a75e553882686cc8ab85984ee3b31cb6bffb80742030dcae5a6dbbf05978758f100591326447bae5e6fb26aef8d6be89bd2d16a91cf4d135af6f7c7d769617546e325f464eb7e201c956edb17a3b22e2bc4b223e93f7b4e04efa1057f2eea8a82f090ccd8cfce699b32917be8345f0bd3bf67461652f67d1d0b7901846923b3a9be142262ebd76d503059bea9d0c46a08b071e7c8d6a4d9d2dd520864a21720af52c806c7e87e262427fba4e0c796ef5c2fd71581bbb2b0acfb2a8e8d1d844563deca51391093d7acd490925a5fb5800eb8867e372b6653e54e2f985d16eca885454a31d7a94ad6c4c67a698dbb66b5d606668cb12300c916017d95c2f56a80a7c0d1c126c50d724c67df181c0815c0f235ddede2957a1e8ad28ce7191a92d608d56315bca975f61f90e8a3b7c523d68ebdc9d8f9db4f254f67e2a796da58e44c51d34c3c478199e097a08d247a9c08ca1364c4a4927613c271f3b3824d0f079db6783a7208cd4533d81bf692fb1d013d578627fdf42aa64fff17491890ec09d9fc6ac716fd84e25f64519627d0344a5b132e05c98affccb00c770774fd8aba3888524deb26224ef73f53882f8147caf2ca44679c8152c5745e34fd2f0fae2a551df8c03a285b9abf2f87d93169471cfd3a9c91b62017c46cb10e79a5efd7fcf98474f8df58a116fd2e46dc8404ac0ffdfb4b608652c138ce0b97a381e5a2b402760e4664904c555e618be65b338208d15719a59bb94ef19c6ab7e75708fd59fb3c2e450fe1aec4b8c97542fde8e179979884e8e11b83b7527cc8441c5d76d0ace42cdeb6e04d8b46c59f73e80c2d30d914f313464ef5a43497830705071cf923099b4ababfdfbc1a57f8b21e1a8790f3528626d64f09f46bd081d62b6f9a64f4f8b1a756e0b34246f8173217b7251fb846b6100c241aa507978f421760e72666da6e22b6f933b2aabce931a0aa81dc3f0f8364ca4b6bfb523044f981d9915a4d07637a78a3472bc9e4d2fac800b92642e388ce229cfd10463436e08e99f4102c79b961c23e2eae93d98422f970287cdbc29876a2b51f1a45e417a49680ba111e9a593fec9b1ffd7e4775ac5c570a83a2e2cf0d82659cb55c6dab47e43ea2134fa30268e1717a4d2f2ded225b18285030fad1ce274764c04ee31f79432b109ec5202b69719a6d450a07b390cebd876c9988b538dafe66b50e0ecdf3d59da3dab090da42209b3faacdd5ac3c16f4078e5001e0d821a3bec6e308d9d04ccfda5f9d236c3db805555444b73b500345b41df45776a42272d5e4832c95e216d4707480ba81f67cb875d06e6d72299372517a8e5d055f7137d0cce591c9df0e6c878eea4139a21223e4e985413754017b8235d95e31276f0e27399ad99ae547a3683e2f6022b0506f8e5a8fd91079cb3047984bce5f9eeb8f8e8c11ac60fc3b80a69d69bec88c6af0fe8c3bb529c1d9ce6417299013624ee806cbbdb29d5f1947662ddeaed0db188d4517ac0052422f47f770548108fe030a9afa4cd11855d7d0640475fc65261bb1e0aefd17f1601c0d41a66586522f7a477c6c530c1393834b93601de3eeb0f036ac7521425fd828e84744e215137257ce82c181f4c66cb973e35ab0ebe83cb6dc23082eae4674b2386b7ef282a6137a3d6966738e4f7124832773b9f646e4a1e483522bea24853146799384e7c3a4834b26218b4df6b509d47eb0361baad7b89ec417179de45fdee56d098ccd4f53cd3a68a2093b6187e55fee72568b4313a7f90918d528532bc46ace17b4169e778d54b5399e2d7334474099d1e23f7b514c533b5589954490ab0729e62f61a38dd4e36f967c57bcf03a5b14d42bb71534c3b3e5e2e6394bac69f036502dfa1e97c46dfc5b7d167ca8400a36b1461f302038aa31f72d2cf5b1dc1a6e2f810ce59f1b8a8c3b052fc2c77c46205339a70773631bd10b980f8ad0daf10d071ef098d2ff883b9e30cd966a49e27ffbe02c9632a6931a8a3238eac69ca2a515701c32b170c62cec463bcf0324c66ca4ab62cac3991317f63d111416432b58aca8f2d6106c0dfedf2320dda88f2fe820b28b49250d18bd0987cb120a79b9252c054f4afc7032cf4dc7ef0ce7976ff837b7c8bff23a3903f36e3e1493bf9ce97d3ce2590de503af2ac964e74f39d3d7854f6c9ecb5b05ac19b5e8120fd5bcb14778cb73de2f548422b836311bb9ffe0432bb870672a42d7ff5206a3a85a12aa7f2516a20952dc45eb39c198e0f547ce4b1e8c547d40156e965428cace91dbcc939ea8e64fd57ec7e394503feddb9acbff3cf314ee82df33a0321573d2a6246b35b2a8a2ba0ec5555ca943d8df2794e33b7e506996472c1f897f09a830fb2376641d16ff8d0248505e45e2eb23e94f8c19f49ccefeee3a212ea52b69a870c039c4c493f3413c68ae3b9ab157a2146bebf8b88a628f6a7857246b260e7b45f0ba629b1af40cc4e9bba87e249424af370665c0d9b385c66d09e30b8d83bdd696e725bc7bd05abbbb97452b3fee97680e76e0e372f467b3cef92c278ae9682668b84b715eee9392f331169cf74a6142a5ef5b1edac2026bf84aef641a49bf8e16ff136c830e1ec5c914d3a69c668525584bd2c49ce6dfdbe9fa8c6c564614e25ea71a65f8c6a5b254bab59cee93fe3b2e067cb37a700cfdfb687f8c147a3e6e5fd920b845ba55e4ea75fef412b6fd829558b7dea6f115999950d4587a139676452a016495748aab0497340ab067e04e33eaed01db3504fed285b7b25aacb5481ce9483d59af8936f720553099d728d4c0f3f8772c2a31e7a412522b35c38bdcfb7dcc87c0d59a38a9b3f90bb08870943d817c94120434b9e3d81b933e802dd2b1d06611a84969e697987c23197949dd61d294b4fc81eb487121eecce404ab4a1bd7cf9a13fc1d373d239c68afd57ee9b0005b7a6b9762ce2b642491f2f82d312063c246dfeb07a26f346276828bf6a8f8ba6dfc96fbee771bfd4130796def15b363df11246ebd1ca83eede8a06346799ca17e1e91938fb39a4095d829cac06146971847d33d27ecb4fee552ba0ee8f13530110c2675f753e9925f0f44c4018dd83d3d4c31540216de7a4ed4cd4545f69f88f4148f7a29cc44f6a7ca215a64cc00f78c75054c6a4f53dfcce3ecd29687e4a2ecf806b3cd0b61dc5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
