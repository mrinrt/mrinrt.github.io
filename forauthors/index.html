<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46fbce217d32d59401a3d5df5512b57ba9b7ef13cf1bee39c3b456645f906aecef2f55402aea7bd9c6d17359c48984d29aab426190cd9f46dd873ff35553c46742de2bf3fff8fe1ab5baf58ff0876393efdb27c7e67059310052db7115ea53f55aaf8931d9b3f9c1b1e119313a2b14282a9170d7d97b8911e3d51ae899d8a9fae99236948984ca6130f15e049cba1752ec712b6fb3e01d692fe03eaf7a195686f68f67be1771279e8b97fab19052ceb1dd7d93f60be0ea44deb4cf2b93d3409836d85d5887afdc1c687873459b213880ac28dc70d9f246a38f178dd0a92aee48e8b70bd9a360d6b34ac2cb2a98a1b28d4b2dbdf5d3dd42463249d97656600f49b1ad13bb77284307f1a1651d1df57c51d4cf59fc695583789f169ea35aa05618413950df1bb945b43622259aed34ce2293337730d1b12ffa2d8bd1716bd938ade386d1c22478272bb7d9f7e4dd305aa65f2fe97a618260ade712ff154832fec495b1a8314c1b9683223ec6474c8c86ccfdb268f1ed1bf839dff9108c48a7bad062643dd3f2c53e45cc6a6912e19ac15706bae5df92e9cd7e11648ad339ac6e61b7f3a372cd38eb718b9890dd512fe457d04efe98f8a9a6df887951a7337c1bb04ae46b142728bef0d7ba4554aed2cc1500d2fc002e43e3449f3bf7d6959406e44dbeb98c70b54237e04c40490b5d841563dc97381ad513325f0874c236a010acbce7aae9c85586698aa202c9c23ad805a37e00fa6b2270973b356df8c484ec233c4f402acc09daccc588f271480c02b534c82e45c288f0bf589051a8b1db8c5e65f0b2e8fde2097872eacbf52576b3d1091c9a8550af9b8a5ef174cb69aa19455ca3897bba140a5c55733c58f2988e48bf2b1e102fc3b2dc2393dd1c05002ebd2c895c4c3c3e0cfa8c5386d86ccbdacdd6e8f89e4de55e2980b3a66224ddca20cff2a0b83994f7d15e62644b8d5ad39466201353841f05fde7938fa873e5a407e7889e5193f05b1e1367325c6dae64a074a631fc0c8ddc8354d50c7950d94c81e347987c6f69a380d7497e14ec47e95b3a40853ed39df765452db8177c08a30e6c188be39dcdd083bf555f559960998a8995a605dd27483120f015efd8dbedd591a3eb8542bf82671096ad737a04faa77169862fa77139663224ca982968245b726328e6bbd21d59dbd30d20b4bf81353573620c4e4b2c063458496ac75e0c6f5f07d7990cbc12c9e1ceb07f58281110af4e64de146d5b84e4a0069d3f00838396c4068a23cd8d031a49a52a44c34d27d78c809cae879e1a3addaeac01006f1cb8e0ba314ff96ec0342e8e58a7ed0c69d377dd63431d82853a33099fb109d7bb22acccf4928e34dfec996f8b156cb08152b001980b208e0a2a345c0723741030be3fdd20b20c6c15e263afcfd1c150bdaa92de008c56fcf297a459a2f3844ed8551f61f6f57bbffea12ef87a51a7f7929abec4f280d8ccf00a417911fec1ed8f8827424ac73f1e159a1f54da098b30354f42be1e40c905978f25d67ff23fbd4c4275eb8ae8113ee2524114303339a5f2a6a1c8eee7993b7e6ba5aca126efd498e17ffd35e6e2ec35aad1eef166fa14470fd8ddf8e5163406bf5a842eb5edf0ea1b7497df3f34cd95d75c10aa0b612e4945b6e66f0cbd8dc48c1fe0b92a420cbadfeb2672459a4ce345d4b5e330f09f5c50bcd99960887da35dc23ba766d0001c514349b8667d8b9642d487ed7357b7bbd05671d3ac4bc135425442b53969ba7d98e995448210c120008f6e11ca36602540ecd607c40d9df0b2bd487166b86550eb13dce87e384d47a96078d6740fd5ec148f0d491623f97db86850fd57182e9052c8533670d8e8a45a9f0ae42c8b25e53aa52764646c648b6936f6f8dc1803783bbbbd1372147e0ed3bd37bd7eb5a3ef83f405dea3d3e095ba6a14e18b81cd71d3b50cdc6eea4546f1ad422dfdf2ca3a453432707f3baa31301a2c1110cb007d1e02fef87023debaef1d529a9f3e51aee80c0aaa4faacc2f2e5985e6db6f4b39ee100fe9d6a531f80bb9100fa93ead8b32562483c69ff9c045533826585ac2c9507c48cf037b137092548861b8e514f0c7c1fe82fc93b57d0f89cc429a50078620444e21aa28780dd3f9292af0ee2b4f212a2934c3a853832ed23c86176b7787781ba86c6ce6b3733c1d05799bf92c738a2f6110e9461ed43250d28776521dbaa108ae43425e3c6b43cf29b2324acf887b32aef43298f0cc079ef2f6800eb8dd40513d18c80aa202322171df62caa79cba56a2cc4bbd5231e4b761c75b7d980e2e4812bd207e1b216ed77b071cb6cebfaaf3b1b4498bdcc967eca84149c9d5a26c125593b689f2135987f0af01367b35906976b455720daa2eb3a20ba4fbc5713d4b9f3971b9b8a2746d99ec07668008bd998daa3a8b21877fc78625a8f7438cfb77c3c1cfad6770abb082b881c3ba7b8f4abf6385f2419364cb912dbf76ffa2b614e540c1ee8e575a88c7eb427b2a75af1ae33f38446dd7d29689e24003f5c85d7de26d007c5f5845653c2203e365135d1f6628d96ef1d3b71e905db98843e233b2cc8f1a765b6b0f3146bbbcae9a438648a8c5318b0eaeafffced846889812709bcda55a63a285cb82ae2b508559db5a815064a83e2bf2f8ab2526ad548ecfb68fedb5a9d6d4e9695679187b7001649f7b0c3338cb8a6e671bc064ec69374bb6a6c4a4e0bccb265da8c287a5af82b57b1e24fe505df41887a343f93e50db443f76601a8ed7c4ae8337c0af8f2764cffbdeb531d106951ef5e19283b04e08abc02634d2ed2706d26068632780ea4cb9d5785ddffa466bc176eaafe41df51640b9119da0ca610c3f01d2067b4a118c9ca1c2d798ee5626f00beb1dd94a3dd7a2158437552d19c62a585ffd13e7549a4f4fcb304f9ee606b2b44f29a7dee87ac870ed855bd2e4a956f91f188e15a25f58817fc01732379345ab8200cbdd8e6875dcf68dd7141d5ef03e3f9a92c900fb6569328a4d6817fc6197fee0d60520b03282ebb366f0babb6fc9a7967fc5f6b5b8e9490510e1b6a838157bbdee95caf6f8c10e819ec130d48c9925fe7fd362c37504a81a6b2ea4b231c5ecd60174573acb9b5f546572baa07f198bf673de1194c9b353c5e637a4567ab3604cd95b9fb1c2e986b846b138f27fc0fdcc42edd1855a75105f2e6e6f139edbd0454b00b2f8879180072397ae3a4e5a7d3589aae752f93b8262baf9a321e87d27f6edd814d06228cd779185c5510e6de84e8b4a10d0de1706552e0ace7cec60ba1bff026aa262950a6268808e48fc916119f07b66872f30e44c323571a5d3d129927cee5ec863c37b2349b5af2824635bd68a4d8d76b34e67369b54cd1339a0d042cf47166c22e298d7357df9210a59a6e96816dc0e25854030c46f0410161fd3f8941fa229ee8b059abcd0c09418dd4ae3b553bf9f949402089cd68c86a962413c53533f12ec17c1dcae41d911bb6561e842ba046f67e9e88bc705d6c1478d32793b6e0a2edb1e839a859cba52a718f307f3aca06241e0eec1721e0ed0e361ae756fdbef2f2a0f9861795ec186558da6d98dea5f2d9d5c50f3cd7b7a38995e31f46c88ccecbfc471818ca50d79743280270ffebc8a81ddacc62ef1b87652c45adbcd101cdaa21116abc5daec3a456d2a0a4fd80ef2f486b34c3494a52ec06a42afd6d3459f569dca20e236361fe48408dbc9d4ced20bbed25fe7058444078c7af32f449066a978365a30de6d20dfef2c1a7de271f038044787d38a1533ff38fd359c55de3c7a54466638cc5ad8b1b635f7cb2024cbd62fcca2e683cb09dcbcc58f3152d0d5f56d2905fa62aec904460ce3aa079860efe9bd381962c7cf15012c13fc690656ae98555e1e68f373fcea025759ed4eca5338b8c2eb08b680f8caf45ce188b4f401cbb98e90f80d35a214828f12c43d2bd8f655b55f5e10c68d9ab1f954ede9bde8e7cfd7e8ecb5658f6ed120513b00b818b63a72c38c5c487898679c2983130b0ed30d8a2cd15e7a5e67cc1a5867feb3dcad43f729fec1b6555545621847fff6f5a0b3eb3d6e6bf6fc6a4972e6c6706d143e9a163659672dc64fc02ca08f03f307eca1941cbf4ed3ee725c9c6ed29cf277314f78c9eeec727ef37fcbeb8c2506a5476145496acdfcaf6dc7f840d945ed1d0619ebefa68a9a171d0ee94af525a0d63f50d6baeb3f7989c49d1a924fc6759587de45d7116514f27ceca8c4e3cab6233b8c949586e3c433819b5e7bf1eb33b8dbe033c4beed7f19a306d6fb668fd8b61c83f9d13447b7e31853a09000649f80e80d85203b57616d30c7d225f2e1448c63b4583df0623f5cbe622eb5963fe3dca98469373258acb774e0f31c026fbebde659906b332194b14e63a64990c7701a5f47830d8c1a1c83c8b3a95b60b3488fc07ba200652f046c3a7d41f98cc86e13c9ae6e869da018a60e7fc264e74b4bfc940eab0441628816ef199b31424b592dece94d606e067b10a61a9a25a20e0ffa9c2647d53fd7a0a1640b76aeb216c086fac6a59ab2fa79103f34a38164d4654199ce38b500b463745706ea59e90d4bfb3ba889d924967d06541969c0afa4c9e523f77d6756bd42631a8f5c53470f9f183c9bf50592b59f479ca94303e03515b44007bea596a4659da9fed440701caa0e8ca825dd8ed20610966b2e0db1be8ae1955a177b745210659921418e9d998f648f1b0dc3b8d14d0b62ad485c6c6166531c030ffe7362378f05d86753c0b3ff897d84b8637ae5fe942012b9b43d633c81ddc90369e95595fbb7c4198022993fe03cc6ce3933a2fad7449804ef16de4e0e96090db2b9a81e1c077c7482c57675ed4a48fc2f6f3778796b8aa2b3bf237a52872fd2053f40d8609c58f83c0912379890620d6069a299ae195136ed97b3235c9d555fc5f8ed0344ab2cb6b87b2fe2b51cc3b91a1c44f3e8dc1e44c72442c69203e1152f10b61c30dbe1c1b44954564385bff167490b9300115e0de6f45b905f9879145e9eca98a6fe884d437d4b50d743c9d277d1eee4118a9c300032edf68786b905af4c5f58a5b0d8684a385b575047cf2314145b3c476b5373f953842afa14f5cdfb71035e8606affa7b4e76572d44f11cef7b74f70d9791349b7b3cc92d329e33c53c09aaf3dbfee9a703933a68ec7cb3c5bb8f3dca1e675eaf114daf8ac534b0b075987f5269b0360736edaa7bed078c40cad11a734278045842b0d7b2348121a141658464dff8ccfa3237c1cbd7e781dfa3a76612a839f55a25707333b81af6a4b92a1e38b4f096fe0e0da454772f48d8a496c2f32fa5545c7cefdc567fb66eda398b78ee4cd6bd5788e4c8e3462b7ace45422c1158a4045916f319f0c06d12c6952713eac877ad93293ee6508a4fc9ea30520e0ceb1ad67fcbc60f0160ec7c5f6ac07ce408c56a7af7f932eeaa29d87632f89297a5b28235c44f450c7eff81edf5db4a69f769d333506eaddfe8d15650c5f8df1a6c906f9a4150b530bf4e4b21c4d033af63af9e0f52757613fcdb0c2534248e57e7e00c4ff3703d0ec41919f30fa25b5636ca338d59308ed4e20df7650c6c9619823e75ed9e536128cb93a9439f3b45903f8152747096e50c130dbc33d47e856e7e818b8dc457abb72dcc7575cf3d5fd323711684b0cc0f7f4f1130c974e002cbc340d698036698ae96ee512c049c8ead06fa8af8d4ef5aee869afc318109b2580fb02506f1cf22c640668473f704bce7a949e1083d31abe3f85db56dd9869ff3defea8b88ccbc5649e89084418057c0eb343ca3e2469366913726ffe4a353a92ac9e2610325f434b2f07fef077721611e46dbb3ff37e24441387e88a3dd8a5d41b4da63d78da87486488cb2fb38eb2da345c3780e3cff3d7f854258268b9acd0713a23009f312f209a456eb0d52c582fdd6af74a566cced44026411175bbe17e40fb725c6546068b8ec2c5607c60067081f52550618be3fecfd35fb360fe8db6c52e504964a197489367bde62530125d89d57d15e3f363c170f086ab3c5e23994ee2e7bf6149c56bd03c9ecf244bb159e5e68e49719facf2f4b05ba57b68761e38184bd3042a516a763dd1767b1e1d22708a2213b92cefd4c8ccb02ebe566ad3994d93b5a65743d7ca4dd53b009959b9b9bd6083eae40997a820278fa25a5564ee5486d48312ca3b784f6daf392876abb44d26d3409b413f57920bf53ffa15da3e603fbf9321182ff17dff03ae76e1ae7abaf35627e87a4992f49afe9f66f1ec4b7e4cf35938de8ccc81452a09658a4c7facb461a7fe943023f3477e134512f21bc8685c587e4ca1b9e61be96ed569fa2a46c510e94d9b59cebc34010980d7518779819f2fa22e5f94d13f6b4cc95dd0878e4c90659a3c25e73c93301a3a855e90150425a5fae0cf01ef28d9177fea19e09503731a5bd18bf921b13a4e95d756fc8b7a7b2bf98c4daaf1d70961d9a4a777f1f34d0ac89d330f7c658d46f401504a94d863fc34eb4c9f23d55f7e3af8f381efef93455c06d4d9b8385c718bd76d12551a676c93dcfeffb1e2e0c39ff3d87464c8e1d31745f3adc792a1d6c21e9bd74bf71bd44fe597dade2b7c69472b289572075e36dabe671570f8b9f040e7d6cf7036bc1b5e8ff3d82c48b8bf82ce6cd58dda5c884c715b81f60d1357cd44d98992029030cb2c07428101476ec6714727c98be26c65bce53b6209b527a39622526b57c90add4886c579642a0cbe5b6af0453e27177db9fd7232006a656c2b9fe798fbb81509dfcd08c5f0bcb4f0020970cdf701055fba74e93470e1d889b0bb57cfb629a71fcac6f8ca01e38039e5ac52e4905c0eeb35aebc62e5f2f26fd366e4932445c70edb58c37a99a929892da8d01d7f0f76e6292832bcaa6de0f3adb572345feac23df0b7c4677a79f69e8dbd9899618a84b56af586299367e486651817bf93994d7d9ea6b470e6cd02d7cf129323e1b02883d98b40c46c287a9a49ba6bfbbbde57f3c99e314b05c55572ad3f1e985ed008032f3c5d3edf90a5d28a882131c33f9ff1c6614fb6994667aadc7880a022c67080063d44decfc9dda01f82f53d19f9b2dbf5ecd9409fb48a1602c85d6357b2f222ad29a1bdec6276114c9f3c138f81fa938bbcdc2cb896b872bac5c5062cea0bde35c219ebc84bf55aa5eecf14e14398f3d21f2b2854c8e0b80a111408a578d863b6f6a2c442e414ab02132175470bc82a66f5cea38f14f97c7a446bec6cfd842393178f36ec09c580d29b9a7dca74449744082f639f7f3b4e692c97f759a6aada65d33da3e48c28fc60f86877d6f90d5b8ad75b6cb03406bd9e8f4efd146e6ea86f3b598be39e1c3fea480dd14a9e9c8151a3fca68687a2fddb1953579d17642993312656b6102f2292f72d3dc5cb1a885510f1f813bd0a074cf304630a8b70b030dc94a5cc8fecedd70a9f009f4ea880ce50d2d891df405a06702760477e43701080d913ac2449d17bdc378cfa5bcc891cdcbba4e17fe396d72e47e84f1f519260dcb7f8c9321297ab38a42cb6650731b8f5bf886e009e0688f8616956bf96124d1bfb915063de382504a554985958e30ad3de73a942a7dcfaa3202abbc839a695773c0fc06905f77c076d74737edc67c414ba7e68f4ffd6923c0e29882635cacb669d851abb7bf4951ea745d0ef0617e502753e27009572854c3bda8f66d733292e4c7802a1e60b8712b5012053504dd560f2610f40bf7eeebc0a107925cf85393ecfd416835cff2ff9e0ad168be8cc546b1533aea8bbf3da7f812bf34965f2846237a03ef2a345b99052ee919ccdfa1919015792245ffd1ebe66f12a305c4801a66500558e4b3e83308524fc8ba4179c06ee55cdbfa2d0bbca93e75ad7df0e057e629faf10c223e03fbeba83c87f0b2749520c82e1c7fa5f3fb73e32e816155f18b5264d02925beb661e757407bca668886101a8e7da01fba2abc87ffd2e550651bdada2e645e587ea105cccc5f2d78dd51df9080127d7af2bd67f5bb41be78c5a4845b51b2712d2317b1eec9db863534c15c5d2201e1a2d1837c8c77449be2449b2d32096401bd52813aa1c84b59b15e472392f01c6ef8e50871dce2ac0dd030ae7021e33bdfeb54ba0d18368591e00ec55ec6aa0bff32995b785587803b74a98296bc65b4705e6418b4a508ce6e6622d03183a14ae67dd6292bacdd6f12c762cca98641f2b4c4c40a25d1cfa9b760cc5c6bc44f45df1a7ff80c4df61cca9b510ce053c991bbe291f9c47f887e6aeb7f503f837f618e680b98da408a7d77a6909e49dcf78842cd5b6e52d2c20a1f096628aa76c1ce8ace1d885a55baed5b792a2b6dadb79be9383248a32bdf27649e491d8065dc416e54d24a942c6c15a5ea9bd3f49fde6886a2324b022f516d854d14333c18e6fd51f705ea7acb2e3a8c5d06f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
