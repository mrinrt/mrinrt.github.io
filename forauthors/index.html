<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"311c7493a9904c69b90167b73aa461e4e829204457701a53cd4e7b9723317d829c1dcf7b5c1a63455b3660d55fd11b7272fbe4963c225f68ad7ef4fbdcd64416a8c06878e9c54f9d9a11841b87c3c6963f58e148253b1465fb8a205e9742c4121f5c854bcbc0207807bdb4331924f1b2ad87173992f24e31e282b8d6f7c53b56aa015c7a8804247c1c354d0f75c280ad3197ff5ed537e9505a63fc377945441be951bf7624e5c28329b5857cfb3357fe2c2e86b23aa0151ad5c41ccc2a5532c0abdda2551fa7763b906f664b1fb8bcb581bf1bafd23efa26277767e6fade7e84e2276ac591e9a23593ae65bd9c2f8d42bfe857022ad87eb986fda0cf26e47e6b8e8c19208d11173fe8380faa62e887d9000c36d934f0686e638a9d37d40805c6c9a58f1ab1fb018552adcd1473837828b8553fe107d28bbe9afef1c2740c84bad8f17c0aee5d339b7ed52bd594e440d29f5ea6678f6d9c0eb82bb343d55ad98c3e109c02dc63b5e0e301c9eff91922312438c449a90a7d2f085a1fbd88c100072ecaf8e802e9d7fc22b508ef14decc6f6e4c5ba825f9b06d10ea6bd0740d10373bc4938215ff0d94dbb113dfe4157baffd99cc0bae46e52ef752377493d80bec50c6cdd0524df26620f0103a980438facce5bb1ea9b32d62acb8c6d0465199f6d37aaaccca89e86f79cc77c25650bb7d5580ba0d261cc59c70386e3b9910b73ed58b7258f9dfe3ef04635b492e46d410a3101af599107a7bccf86e6e0d944f86d2f3f65dc52228907833038b10a0b71995ed015b340d9ef521500d0fc43c916c634a06721c8b1ad0711a672eb9e1cdd27f90acd7fba24587d897cacba286d576c7dac3ad9982430f4c4e8e0c2c4c4ec5ea5889c92f9221a4a9c351753a9ab84186351d41b94b5f6afeb4a94f50ebd9d1be901ddff6d22fe9d37e3c5cfe6a1f7aa56ba3d835a8c35894cd37ceeae54dd00dab4aab34b5a4bd48f0df4cc266061abf2d27d0d16acc6495a02ddf4b0dd40f7cd17e55ba7f370f06487672143b0ad7363635e944f744f439ade018c485fc1caed95e945dc96e5c855ef666c75cd49df35dc10a253a69e36e07da5d962584f3c301d2aafdc988da86ea6d6bfd5f66309257ece9f639f1926f9ec55f7dee641b7c25b30bbf07ae821eac67594502d1e3f7fbaf2aaf96339088d3e0f9ca9f1f2c73f204e2089f67be308ccb14a405668ef027d777229dc04c0c003cba66b5af5328f9302bf5f96aad600dd0f527d7756a3ffa1a498efe72db34c31ba9443709ea8cb82d6bdf7fa43b0e43fd568f8f743add39b20afc96a59d5d5af6787b51ebb8c5073e673956749f3a7087d908bc4372d168065948c5b9c82d3166e1bdda80fbee82488008e343a7e1c13727411afd7dd25cc3791b2d94c3b35b0295b42e0bea7e4518a2440eb4ede981d9e12aa70e0a99d993397c9dcd08e0066d61cf57b188b9b16ffb88c71285808fb5edadc027085be9cf0a61f8f9d7da36c12d7579d6b933a405188d886f360a21d7670e9ed234dde5b3ff51ca7607091755cb21a60b924d2cc1b1f6784fdc900773a2f5d82ad0c05b3646268d83331b6df38ea1498b41d0e70c083fe7e410736187a2d7b90836fd2db906fc71876b799065c11c0a05b66a4d16fd024a46a4e5161c4ca0164e40ff6e17080e10373882c22fe71f3b99cf75dfdc50d0a46c5cc8dc39dfffd140fbb18ed1be0faba951c624a067c1a88b05373c7b3465788d567b134b7b960ba156a6418ea18f8fc4a4d18ddbae5716f0e7a3b50789d442bc0c0d8bdb03b8f13987472e5291e060341c76319bb7c70c32844d2b161fa9af626bc623f45cd58e8c30661ba532f128cf04091f0fd43e1845edbcf8b425d2bbed56e6512c7dd240cb054387fa9217f7e9b9afc082314ea37fe468f559beb1c9badbf29c3806e711c1087620bfb2d985d74470b486a369c8ac81b532e2e878bce3630249949a2c992cba8264bbdf8da4b98762e591fe7d6abb2d7843072db6616959326690dd7dfdfe8aac6e7c7a54da51e482a8097b346dbe719d7f010d52b48cdb397d29d0597be8c581b13c009673f7255c82e583cb1faf4fc684a69904be5c1d56828a5c78ec44c3641a64a40c0c30b258f90f05e510ab7f321218abe406a6d7c7a950037d2e8dca032dc367acbea9a1568596e68181fe003c0e0a3e4e36a93643176075def31b014107109da475d2a2ced028693aac825f2eb525c41ee7a7b8cc69ac4fcb39b5ea716e5c9e0c5c98b95f8c9dc1b1cd3b1918eca4fd0708a417df2e196287e38914afc1a82f1853eefce4554ff15f818659422e0d06d13e24f3b7c02406b9536b31678ff24c9ecc2ac826fe8e50fb399e8403b7e1cd88705c795863a57aa3aef9ebaeb11bb9e6ebeb99994f57d91071c7ae22d8183e6a174f09d29a76ab6764bd59f1f0cd80f76e26ee613f45ed587668ecdb6254430d65bebc18b0094616a040bb07f2ecf1b8e54150ce573d4c359811bde04e4c9d18578f496a3b10b5f6b962d8dbb3726cd30b05a5c2179219521a45edd0a864abe8e98335e1822266aa56b1cf02fc3b63d73e3b5589a5bef961a56f6896b0aa4f921e16d74ef79b62feeaa95bc3d2627d3f4e3392f9b280fb2363e623624dbe6e0ce94ec6db667e5387eb7900261958e067430cf09939495580f9f80eaba98c09705c2fc93fd5ff5e89b7eb352a7d23de03641718785437c9a79a1567e9e9b97f3e23dd429a4f5befee8a5aa93b043327848b18663b62765bd93631455e7f7ce2146db534e3d5ea990f7b6690f1c61ab06072089e1145f14b630e909f79b72b408e723f718b48698c574974bdaf0e282aa46af3dc8504b4509b87db32b0ab067632882e441a45347a199d4217ae808b5c1c6bb50124a3416d4c584a0faa04f321032a6a0712182f7ef6a98470826075b232a299e5001bd18d4ffb68b68575c8eff77fcb101ab61d06facb0f100c636e6739515baa5f11c08c03fc3724e210898cbe77a6118097707e17bea95b5854310322bf8e1383c03709907119ddd0f3748fec5e7f5ebfde05da43d8d53273fd14ad20066ee226382c50dbed2315e0993614adabd23a5aae8c4484b7ffd1138abd19185b24fc565734f2ccaff935ded8f9526b8e7ee166ad2b561b29ad29cf24ed8ab42ac0a93d2159c08d300e8377b122ec4c1530f78b857dad4ef6e9db15feafe68c7cbaf305834cf97d79e7f36207a52ebb64110b31742c2d5defefb81b06a8a7348f3a8f18cdd73706b33d3e0d342519792ef7767dc3ca46c886fb0e5ed93cf7a0a0fce57265fdfff804fafb8825c00668227550f122c36af14fdea947d6d3d1dc29bbb8ac0b677d947d9dd678a419c602691caedf7247411e51f89389475d74502339b3b3ea9354823ef3225ce9dc28b5827c84347acb8cbaf0296112e3e89f4d9f9bea227bae5d9e358097e6aed256fd4c080d40500c54599a8ca30ba3321fe85c05f06b98cb98706b7836e945c3e7467790ba109a01b84097c331ae01ee353210bc2ae12fadf91d13cd14d6904f7c7cbb66ed0f21039bb72d371d12216ede6dc6383659efe11206a603b95f5ea62673332a47e430f9ccd0ea74aeca882f08f1ac518ac737d5c6de7d388af67abb3b12a44234b4d7378acf8ebfaf9e8a6ffd1bc45bf4abe573233a3eadc28ba9d0ec9e1490a50c6675987a4fcb6a1ba6aef15ece1dbb20f3d696e018051589526cb012a1e4f604aba8d602bfe1c658ae631f371de56752f5d6e5c6c6eb39863e03eb447bc70847916e2e07c470ced48abc1318b7a123f2a3fd8bc2fd280e8792a1ca3172a7fd3d3756cb1ecbbd0f444db6cc30dfe3650c26476069f6052af81f152a45ccace8c819a16e10e4a6e47347515cbb140b7239d29b21889dd29c2c7754e437086d1c29e387fab695530a49cd546247f8d46009411976fbdd56842148ad3c6a982a9ff229758642dfa6466632def0f10dc15d9dc74aa8fe3f9ef2569c176153373c3e7a5b0ee9cc8a652391c7ed51334b2822e465f2a672076867518856dec803acb80ffda34a702da3e7bbb53da0927c162f4ed82d9fb839ead46f96dea124ae50e67bca7bc54c568e794147e5dde708a7ab915ce54cd10ad0bfdcef277bfbbe0ab88fb8ace46b3c326ecd6b44465ec7a118a9c8b17ba3e9d73aa7710c1c30a0871a0ad9db7dd01dfcc1d077d37596bc9f452962f1bdf1ebf647c2a549d846e191ef925d21b5a4e0a7698e11956e0cca62b2574a94d3b7d1571f03e301e19b72709247df5d3f0591e9f46115a66da4dcaba481d400cd5dc10e53fe92821476a4bbb1bc0e8a5d346ebb2848461fb5aa4aed4799a3bc0efd54af56ecb867a40e837b1ddb388595e291a4d2782841b199e2e2655cfc61bfe2f60b6cd890ffedf86ecdc36515aa909d737a857718c97ba54f8f8fede26e611542ff4134dadf3c11f7bfed3a29a04ccc1a7fc3c359eed92a453da7c010b518c7c74ce8707a14130fe8ac274458e8bedcbab722c3b9279cfb9c3a95c30dc15cbd0a51d34f8e9a0159e04ac6dd44cc658b20f246d9e74015a5a7071e63c651be94718072eee6a2dce4a17a81433dd33e80453798f9006bb201baf83eed5047761df50492bc08d7dbf31c41f8a832c380233756e7cd9b3b627313dae692f12ba57fd73fc20b09366d2513319db227680bf7c9ff5928675f887001e319177d32fb82883210b6492e1a75d4016d98dc12f9dfe4f1f71d3684090f35a85a91144e6d2f72bab44c5b3257f807af265b8a4fa4901b648c44ffc4cdcd099fc129f6fb7b6595978f4cea415933f8109f6c2e3c86f686e19800b050778357ef4efdb9a4fa365d2cf65e766fead9da1e62b4a77f355df57abbf1d857bc1b633f1b2aa501706effe1963f1c3a8e441b3ac4b99728dedd6dd409e98f8ce4d7d176deeb8d5d7c1281629f09a46bbe405bd68611c66d6f8db35320c299c28bb5fa5cbd7253eb87d94a2d3111e08a43076eaab01b5df8ed2d47bc1341f41e1f9952711083ba99cfc3d27dc9a5dd567aef6f2473528cfea7bcd39871b4709348a680b4f1bd61f5fe3abc453539b1bd292ffc5ade8e2e9dd233663c31b6a0ccb6af9bb6372ae9d5350838d35aef698322d0e2c9c75d2f0f48d845e7d3e5e42ef65bdf250ca58200676504206f5c5a8159ad860a24508e229a28379616e260c9a0b2aa88d920027f4efea83a6c04d7d32c47e3084c72b1d2fd104fe056031193ccc89f9ddf73cf95cfd26dcf84d0fa02ef4215a3ab7c6d987821fd795f5bb7e61b2111e2aea4e9a2c049825f9dd15ff1f6229aa52e33de67645292b1208d39da1181fabb8a0e9c57eda78acd23d1d3c6c104f020c7a6b42aac1909ad0ee768430bf65ca742423789fea14617299299a63d5dcf4e7f96dc470466a0ec247e92becff8659f3edfd0d52a9bff2a3920de48255586fdd672b76268b1e629854a48834b7059d2397328767451bec6b1830f953862537208734e2de29b3295870506e62a5e22b094cc623456b8dc1d27a159756ed6587e94231de29ac55ca71f05d9ea6aa8e39b34f40b3d2945e6f28cf217613cefb18051a7891c589eb0becda974366cb042681cd8cfcd226297bf4be2bb11c56d90cd243dd3a4dd5edf03cdca48d82c1ea3b8c5e70306bc0ea1e2bf0435bf14c1da3e968e6e4ad5070a3df483124005c6ad04a68d48b13ee69c611b81c46e3561149929535b47d0b027b9201436324d5819f42cd104b8735bebcc3d1a18089d4d5d0b77f692c7b371f5640402275362cc2ffe7095ab7691df49f75c21f7f59066a9e8fd6a270e45c333f0eacdde05c029aa83c1ece23bddf7fd65f374cce3d69e102c3995285e3707272c435ab55dd32e00ea56700a10cfdf44c3310b42503367b8df304c7774543c72b99f4014774d47536034d2593a6d3bf4a0a3c137bb098c28714192f31a72b3b3301741ee8898e942da1f5f284f74848f1827b2ac9014cf06accdee0361843f2d3495f030e343b5545c05481d6d396d30aeb5fbe472156ee7acc5c199e98aac26b72afbe45a68ad83f8713af867a682f6e708325fbd4a9d2542eff2ea707b081eb907232541159b8160b098551d30d50a310249a256123f1e041f14e85fa0b20a135515b7841edd9a1c9e01010c8436b4d63784fe6d3af7f0c06266cdb0b330953ba37c16e61514fcf81c8a88fb9e2a10ebab75e60136c644f88d4a99918d4956a4a5c1eb60970d6ac0e70977fbf51dde2dd30dc4fc75fd6d4bbca5c431f742ebeb4213e3ebd963f578733477035a1bda7a6a2a4ac7ea7ee98c8665234668a0da3d3d34d3b7ddc10fa78f54b9cf466ce71a2945d11dc1593d80321e7a6c2802edc99910245e07b118e0fb78c576e62f0c9ca8f199596c6f5d2a6e9c4610910d2aff2699ca84d5b1f16884fa0d5960fa72025dbc7b89c5ef5f4608f27c2b504dc3edb29b95e52792f08105d6addb5e66f958ac11c9cf15c79f80df7811c4a36b7f7f85f197998c7414bd9b1a5dfad7f712b5b5b1f7fe931b99e48f403a46b16e4c1e2b6bc589cc27e1d195893cd0e1cb5d02a5f799297a7c0657f68a84bd7b5e7a032bad21e271afbbc3e4d0411acf75b9b2cadf97fb59123818e06675c8925fb0d616c17b56c671c7e9440e8a97429b98fe7917072b8fe34e3a42ed60fd7dbfd5321d451ebeeb2d51813b51cd84661461f44cbfca89370fe7ce914283df63ee0ba89b240bc1edbcc5bc68d4fc3119ebaaffd6fa52e16d959557bec2b125b0450c4c5c293db86d2618c40097f84b91e001b6b75bb372658f9327c74a139143037e794ffa6dbe14beaf21d07228fb4b3a41c1bc0763b501009956591382e94622818e8ed479c8d0bcdbbecbd194ea130856c1e9d9108af472fdd4c21a11be59b6edb642b73f6f7e6a32fe1d525981cdc94e4881b3bedd6c933af1bb2100d42eca33d8acbea49bb8e08cb27c0623660d949353b6d0e0d82c66093dcd8aa9aefe4cde3876e1e25efe366529d264e91fb211e6c2a1049bd8323fe3f036003017e0ed1b717889c5a0fb78a477c92368663411a0105a69ac49d5052440fb9a11aee62f6c4720d43b0bdc312cabc71374d070e314458fe9ced5c87c57a17ab8423d9ac78c7af3be0766bc5563e65ccfaa000114faa13031bcd31a685c1d36b9efd21a09eba9af0fcf5dbc89bff8f0636c3bcd25d85d13e3a03ce2462200b4b5c9eeaf48be56dd670891215b754ba48161344fe06126c7b96bd49e8ee20be1c2cb120de652235b56692d77298df682b8cfb7e14748d35242e4ccf14c1be246dac50b4f3359cce1526ffa60d0db1dc8bff9704f6786953e39642ae8ca05d4ee12dee989110c43fca0ded694490ffda4dbcc3a26308f1f41867bb0c697b7b751f5e6eb061af7a0235f62bea25fa5be6f1f87c074a2b67910be801be4f1e85a8d0725df30a327d17616af2120032eebb501715aca24cfc50bf572b4aa605e9ebf7f5a120cf5e5e1d13fda4bc86f56b8453b39073fbebff79cbbf3de7fdf3ca41b8deaf98387a1a5279404cb07f77c9f274220e0b7d185740b556707f22843ee3dc21d605a532893ad55717f2a0b45d732e15ed199cf35b5555dc989c232851179f5e2ea9b0045a8e70c6dfaf755c06a3c1f0c603a5d9f4909c3916db54aaa6b61bcc5f79fad272b945fd29d30f419964534da001dec08427cbf7b5bb2ae35f09776478b140138547449fa97ed1a10c461f3d103a11c7c8a9071869eee3f8df97a5ebcec836cc91679f6b5a56399c687814ae23fea8ef282016fc4a8c63c35db9df058dfaab0b3a06fa4c89556b0a0a02161434a9b9b020ce8c6a5dbf19365a5330b07863abbf3c8076a3dca70935e09153bd0a0296d8d72878505691ca8349e1308dbb2eb6eefdbab3d79e09c7619dc1d6ba7fcaec3c8071d426926f81908e0aa4cde513117aa6d0665880ad4651ec870af9274011be1f86c8f0a9526db51633423efb7337dcf7312ab72239db9fe11f9040e784c8769b482cde131938eff725a17a33d5cfec017906af2a5a1a1f0b07f66e9f0920f7c42c0a74e5876e6b36763338e7a5a8a0dfb9f559631bce43a16fb721caad1c84cd73a8be7dcfccad4ec80d790194d8ba72528d2c02de19560e8347d100d5f3ee8de77018f9838a1c33851108bb9c23a6ddd99cd506d2da244965411f144ec576ca9b8d0a5fc80ed4fd23eb81410e42309c3b89ee5ff03206234bf517a9e4499bd70660c09c8862b0457e4d72217a56722033b0c9a1ff2f61eed2fc39859644ddbc91a14ed665c244b458b7db1ff6d1bac5dee5d6a402e1793ee5a3fec06063b5fd1228b4df4c1f377bc29162c3170dafa9e9202c08843201f694f6cd8bf3be1632253c467f954fabbd4624bcd257f0026cb6d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
