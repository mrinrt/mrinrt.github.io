<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"677158c10d213bc43e2e89d9a04055fc2bd82c968d56b346d0974c120c1c816ba94fdffb2b42e36acc34320e5c001e43c199b73a43c09e3f42a36f2b28db36b1fb09e473a95896fc6b7eae27bf08ed2d194e18381a3a90e202c931dbd5a2715dc0c3a067f34dc99aa2e1d3c9b362814759f8b6cd468eafc455666ea4b7f633a3e347c0e04bee124c61a8afe98e5a2ca0fe5f9de6309bc4d6bb4fdef67d7ccfe8a3134d631aafe0f4771f038b812da3530c5e81153dea4bf562933a3f6df745444ec64293e0d0e2644b436c70f0d6d9dcc7f45d43b295bccde18f8fb2daddf0e7be74ba1822fd0032c753bc5aeb145f38266ab28e0fb4855ab2ee086967ba2fc964a2f64040d0401618078affcecb520c75572aba39963da8d120795c09702b29796326986649895fa097a14484306d962c6e736c4ceab1d225bd0c2db291ef3cbb2b837c70c39d55560ff3583002da8748abfbdaa7712fe461d08ab9096ba4522e17e732d17f530424d2384722ae4ef8fcbc0654af05f0cc52e4186dd28d6b490e2c0f8e6835697ddf3adb2fef17ffbdd4c1bcb804dd0a3845376d602315aa124118b5eb4dc68bc0ab25e605e7f56e7c9b4a27d0065828b487dec41cdf1d24bd1d467c2c2b2d161eaf6eb2751e35fd3a11b96637f9373e573da966655a2b484d2435879e5d3daa7d139e50c5d12377bec84f08632db23a34e5207cca001e8c1c33f7605a1a17b8b27e7d84aad41b7093e80b82f307557a3a6f6e4dffeb54b5f9561048a521746a64587854f3cdcc5b779ea2df6677330a32014ab29992f7cbc91da0b30ddaaadc2449a936d262a7ce555d65239237ba963d732d0377632d8cc24f03d72a77dca82b350783f578cfe6d027acfb3edf784ca84068de21bbba5ad1903cc974fd066f8e16248eeefd3a11ec73cd4d7e406e38451400dce4c9ea0d416a01d2638a479cc319e2d53dd5043a6f98cf12b566e677a3cc5ee5c4738aa7f2c06913d3deb823f811b65457a9f294e4fbb0c5dfa2632a2d050962272e958dd875024c98be360b09429f579830c84d5fcaf2611d840687e52f0c2387e5588f91ee66ba5b659a65751a72926efbd1f31d26e76b88d3c2eeb61fbd79efd70b40a15de091e8339f2bc2d8971cc171cc341cea3c0b36d4980c537da061a8416f6a8f8da188ed2a22f85f148f99881a29bf06ce852af16692a97fc0145fa9e4ebcd70d1f9f7cada1fe5e52d3ced84a85d7bbb96c359976843bbe0bc591c4f32e6c36bedc90d5897d8f8743af03ab9ae35f6d4319ec1dc124048d555f8ff51682664a1a50e76e36b2013526606bcf44852d1b854f79e5d2a80498e3f99eb43cabf8b74f384d770086a9474445b10089a5ed05f99774eb0cc6716d42f0281cb16f1b03fbb242ce85f08e2ec910a1fd627f21634bbe989e153c2198595b2f5ecaf7c36839db9f3d31173bf401d79d3132915c7c386191130808cdb8c480345d8ee8c01ac4274fad90ca18dcd48fa74fb40386e7dcfd620a4add3b37abfdd4b8c4f089ae85abedf1117e6f62d528485d84580aeffdbf541c4ef8c0d6376cab58452f7cc171880aa25a608511bdb5c129cd16fe725b6248fd422ec287d8a16f4c98c142f6ca01836047b996c3323db2764eca186d76e46084400078017af6426619a4847aef21465547c85bcfeb918ccbbae7596f37e927f601e9d230682c67cbe5d99ba6f9cd40b4d8cdf1684851efbdfed52aa35dc14008770b2b1af3381031bcb896d864e651a88a52b26ee9c2754847b3349f48768963f76385fe235bf6efc59660960cf24a7525491cd8656ba45b82d75fd23b0117d3b7e21dec7091a5a6ce319027d37a86b64b8d43f9809d347bd3a784ec530e85616f65b39ea083980f20ff5bea09735af142c4f2b7b4f5092829223808a6ce9e9a9da8236d00f4169500886dd6d0e3169070800c54a205167527567f694205a51fb881f263e8cff63ec5504830bad0d7bc4dddd160ec65605576c134cf679bb2eca9ff511d5317b4ccbafd8c71571bd0e2a534ff5ac364f56700be92d3c88059ddc97781d747762b3d5d7e8b40dcdf1377af6e0451211dcf36534a4c2b3434cdb4a8ead9739cd990efc2e64601b487bb3bb8503aed117693d3d027053559bbf44c108cddaae2acfc4abdb2f23bc2dc07684da5f58843d1c0490b4cb3275772562a43dc27b9c5632378fd44d48d921919f98ad42435f43768a21a997d572b30c7ab71a469fc2f1f292eb0b1af24d8c3fdb2e5aac865d73b1e04185e6aa0b58d46a6e9e747877b76cccac4653ae867abd6ca2571dd1958c5a729fdc925a16646521fc39fc44ffb86c2aaadf122451b738bf0ce0dcc3a41a5611a3c7d63193fd6f9e9bbf771ba6849a1e6a98392ac8ab377c6f1a7975cf13d510d8d511652d5d24a6f710f3b30d94336b035880c078c92060fb64c92172a6f56ec8b914cb96710dfa4be5c4daf303d50098476d204dce13a313dbaaf801c1203e5346fb88ef482dbefe0d4cfc77f561d7666ac57efa738af00de2d27c6c1bceb8fe7cebf23dd337686115e20ac34c8ea00fdfcd7b76c16e7c3f17525caa97d82342149e67e52a2aac1c1cfe4173fc5ab0884fa97445c5ae656303d8e45bcac38b810cc3b1f9d6d9b7be0bbbaec4a42304f8761f2ffe0519caad520ec8a70aaae5bdaa0a1e812777a5e91f44a26e9c31ccc9f0e46b00b57df6cff2b865cce2edd34fbd1b69846f5444a9e5e60b5bc28296945551bc84ed46a0f60385e11c84c5d275d5dd5dcd0dc014da3a126622dc30e331a4cd38456330846fa7abd8440afc572de976814e16dfa2b43c0cf400dc43f50084a105d85fe9265fb6519ce3ad5d182b6f3e5e7d92125be1e2d173b0e8612466a5f57390002b14d7f584dbd849fd118ee18ef188f4baa01bc535e6649013c27f7d3feff85d4cec7fde5e4181f6f321420286e7ff58aaedf5bf62aae4a3472b619fb06840669d6accc1e4cb6c3cdbce063870c47ef5da14f9076992784bd8e843ea2da3af0118dc509d37f3e30b9a340634d56887dc27d577960a60bc5d7e685af68e383957ab78feebf099bba7d6b1d93e27d1acb11f5d25f0981f687c1f4351709e0bb8c9aa77f62ed86d4304713879272ea75a98e9d426c78e288cbf6d5f04e3721f5f19affdc0d9a9af6ce8085cabad28431e2ea534732c23727e701a9279cd813b16b63931d89eac92b0e3b449851421ec2e0a95d9c707157b7733dbac3ea77b0dd2a64b89436db77613a38ab9805cd03b2f797f4666777ded8aaabb908ca092b159813789dfb822a7ae7e17c25f0bae19197922c38feef55e93ae6951c14f49fd0b0c21780901e52e9abcbd82556028b70a2bb22f0aa33474e299c8169207847ad0a0c80648442c4c5fc23b9660fc3af5ad40b4fe520e751b225dde7ef0dc3d2af969d0cc4c2db74da1366ea9e7f38f40dbccd4b3ae87befbabc1e4ce87cb727fdc64f55fcf4b082af3842693432b36333bb6bb200e3e41cdc3fd3c23e7c5037607b309e7cbd3af8b01473e90d82f5d42158268472e29e7f42d94e9e468dcb318ab9fec3cf87fca3e65f59af749cbfd865bcb31745fcb9be686fe2298900ea1ef47ffcf668e48b99388a28f44913a6639d27e5d1c8f588b4fa0a3e38ea61df5b63a1c685881e96ffff7536d7f15e9a4aa4013fd94338e4d4fea9b0deb794d6694bd6579861f7557338b99dd276c02125500116eb578874982a5b45b94669ccf761c9fea54d4d382c05b84675418580946180a6b1566d88dff15b0d54ceb26f2dd5acf38df98faeedb74ae32c663c7f36476e1fd3c4c41f53a1660397f7aed9879069f6af1abbe637d811fec4fb27d16df614725a6f7848b0d249d1890c300dd0dbe5d30dd9d5b339a49459a6f25429e086bd0da7aa3eb2d3979602157d07a1648aa220dd405b7cd9a9ffd684edd1c2b113d258244016384298271fd1e94ccd13b4ff84cc360a2a6396a727210de27eeaff57786ae70e426b67784bc4719065fa977674fd559d1845a718c60716190a432eddba0a05a297d2778fd47c899a08dd8a52932c6e0b55f975409dca6b023e5567a5c88a11d9e75858cc1dc786f0d7fec70220634133d48fec4434f0b9c4536067d44d0304bb73614ab675fe3cc32d1a49b9ab6a626afd081899b061e468e344bcf2ab6abebf70834422ee72861c7626b4ba30910d10e24ae116d2e04f4d4c30826a568f16339718bb253763d83c22975abac87e1bca68e8c01bfcc187dbbf82a1edb902c240b4c8f7d026b543a84817d873dcab1da5a083347268ae3789bd0e8e51902b50cf213d2cf3d3be1d6b00e6b20a9870edbbcaf6933da212d567433ce8ba0e5aca5a701d662f7b7ec1d013b2db4a5ee9694e24601fb41e5737f41150de4710a24d8d16b4a5725c6d271f8aefc09ee64f8059b8521eb89222024894ad543cba1ac1de3002724232bfd8e7cb2dd874b30ce9c72dd5918bf92cff730df0980472a201265c2a86278beb85144f5f10aa76b1bdc2bd50d637da3e57626c467041f5fbd59474dbec72f5710c0f9518e4a5768418df1de4264ac35c43418fdcae9cdd895ddb4be7dcb55a56f1e223c57d2d66964c220f7ebaaeb9705a9b7adc7b2b4b8c51bf0e9d9fb2d06b8f5428201638cf94c055f4d6d12aecadf47c3cf6174a73dee1955c11335f7a7a8783c9cda86de39d16cb25a732b0aab0e613a870653a0c6e85b6c850e5348fe7d4cf45d53abd28ef1ad7006f35f7daf2e876b2b3100dfb7c46bd5917a8f102c5d8ca669d6807e8e1808ebe671ae3887450102e1d4276e5a3d843425d6ec85539fec9f131eb34b8e4d2efd1967a649ec113cdbc30c32898c40d59fc39de08338bfe2cac3457de6413f8367effe8a2888e90ae081a41e42602ce26cb998ddc98c37dc33ba4a5a34e49f86e1ed9c75a855394f50d76b932a1cefb839b598df28d9a095da1fcfe772d93bde7f0e5f42a0aeca72af258f916624e6a214706baeb309f5dcac522a9586c848f286374ab03a37af0d95a63d035bc942857efd0f9c3f2122f1b6e996a9ffab277b900cc3f2a5aafdf07e5896fb7011fbd30eec69245fc660ddbd242ce20a627fbe79051933ff3b276bcf5dd9a6705aebfda1d104237c54d61899c671e609c634c181381a2b4934ae2422288d6d4edff49654608b1f90366b44b371df1edc31642c7293adefd07d9acef0974d8f8f24b2ef02057c4066b80edba548c69c9657ffbfde71049b76ca971d2bcb187622871f712f17df3779ba8d8675de632dc1117faae7533b7eb3040a4db373e23f03ff2451573d134ae7517feae1e69dd0cfaeedcc28ee2969f58a456a1c652f22245d221c5a40c1a0bd8e565e98838b578a31979fc10c22316a9ca24cc58b76de39d12318a3f6926fb47b612c9d721eed9d2ddabf38c2d9b12ab3ee19b9385d57e9dbde4eea4d680d422fbd58b1f5e116979aa070e2a17a896dd4a17473d26e4fd3d70570b3a4e89885a2523f9c3867abc5c0849418e1983d808283a08ffa56b8ab3f96b339d939a34cf58a7f166cce3ae3b9693f350d67671a990033f2fadb7f1cafc07053b5fa5025f24f4338df98a248d8c89905828792eb3060634795f166cec1b1535d51c6ce374a1a32ecb72d34952de280738e5cf230aa612f8e4f973b84590968de03e71d8cdb8a7205c9cbc5fa798068b49614952bc811f9671c823e69479cddb595d064dd944a29b9279a6ec5fc63ee218dad1a56eac1ae441421ff6e3389f2cc38614f604ced8a55a64bd2b11b365f15b17a847dc33f01a5c133b3cf24b6150efcbaf20e240130fd43a5d0dd06ffe2ca6e18e5387dd9ebff9117fa82fe4f320eaeeba0c284c03eb6ce8d0ecbd5990bb344bd6cc6b13b95ec833ddc4690e8daa04516c7bb30779d54ec6281b6be9767b3fedf949826b27516fd2b3f836f1e6ba97c706046e954f2cc851366f32a45e8da0473d1f2fcc425f8b3afc2fe7f7f59d56a2245715136003d3f65cfc5dc666a4ce5abe5a30a73bc3dc7261a6cae1c0094400db8127806ad30ba17cce9cfdf053981bca3be166db33d8cd9d5bd3c1be3e157d8d9d7a65a4df2079e471ae41e0f38ed4745e8733427423fc687d751412c37b5ff663b74768065da4debff4185da44abff34585f99a82d5c1aa9205697b1a115c8580b8ec6c9e390f5b5a4ee2875fbc05308a578d896acf3f68f7856d4e8f89adfa7d69f8b6ff927182bf51874d714f4e8d857778527acf9a92c88eb5e001668d89d901b253f5f414a383073ab169b9943763d2d1442cd940195287a0ac2183c4cf99e46af84f7b19cfb8feb88bda5699df5e547c36b07fe35202503d7fc3a69fe4c32179b54218e0343fdebcba1157ddc967eaf6104b0fd9588670d3fb19fac44781f5591bcf41a85b5d9645dfd3ca87a8702c9dad6296d52e73b2bde6a6b26038b210422d27cef65ea60dc7ed51626a5203b37984235f9c891e49b28c5cff58c33a11fc316222cdd02e5134213d71fbe12dce19597302f61f83140613fbb8ec8640a8b4117478438a2a0a7c4a6ba2031a754506e7894c735694e4a6863e56eb9bb5b5b62df7bb3475e9d0f881bdb528e4764ab66c0f081bb0339427bc15ef6819e8e702e7e99b96f86e0d5bdbd2c52327344a660ca37895d32d280b297b1bae13bd097a21da7e3e6526433d4454446fe4c192b5330196b4d8add3627e4b26fd501284b79597d8b3bf01ca5bbce78ece7de9ddc63899c2ad2b9202e2fae34c71190a7155e534a3f2a34bce0646ed7360f18c0850614aa7e29ad6e25f6fd2f313ba1e852fcffe3a0b3e8fde428ee585e2c738e0203151906eda7d5cf4aa050afa05e40f7986222f6336b64b82a761cc3462da2665b22c5a83c9782afb5c66307992673a99420cb708edc26becaf9501ad06953925d29217d1a9a5f204249b2cd34fc85485f7d0603ae24bd61b97c4dc08f3e7422e0ebf5c6629bcf376bbd09c151654b96ef78e744d87378076df9262fdfe5c17959eb48cad1fdfa7111a38a8338876a8430e2ed390e4a15d2da7da4950a5e3ae937e37af18bc3b878d74dab781ca4da8d31c7f47c09e7032f1cce46209831b33b012f4947834b44d9964caff176140ea278ba35e02a2059e2a5356e418fe4a1dd3c619152ff7bf5f38351af50d56d5a5e8d2d6a10d550d56903cec213c52f32cf79248c40c291f302cbddfa5c0fd9b839595133d541ab77243570e554eddf196f4c035abedd2654d2fa5de54b0986503c3ae9de7ab7696826923f61d6aa25fe7ce2aa33728a449e832bb6fb33ab5b6976eb4a93edf08b17b58ac0bfc45bc44983a5fd4a3c4ebf0a1c0efd3eef26246360cf34bb396e9c6a5080967e4bf27eb16813a0b895a0c70ab27f6d67387b7177ce3d6b1c3a8bec42d630a4ba77d89021d8fb29fcd4fcc513d78c59c48839a14760138428d71a40594caaada4df2ae7a8a0f9735993ab39f133d252ceafbd3bc85f5979023ad8117e2b15801d654ef33e7b8afb5942632932138b612b5ca757b9e644d4c38b0126da703af9b92ea5dcc44ee9145d17585f5131b9b1ff01f44deb4f6805e014bf4e6d2a19fafd5debcfc8f5bb2e721a61e02207f9d85c462bcdd8615eeeea43ea5c82bbfe12b2f8ed401af1e675da8b59aeb853e895c2289f06ef85c6f7171e09fd768a6e597be157bd3bb85bdc7b52c0a43327dfa9f7a48b546b084a28b2376ded991d824c310a1ec025069ff1398cb5641780730c4beb184b6ec717f30d9fade14a43cf4f0bf3e8f273f5bbc2556b00e05a1a08d3f2010de1e7671c69e408138efb91a6e7cee4b09b2ffd67d8d8db64d65a77357e162ed1a8c0b1c37d4b041a3ed75d2741ebd030792576b59da3870c595ad2f2dbcdcab6f687adfe33fbd0e47a13011aa863b3a9b7445631d8ddbe5b76e43d25bdd3b97715f3c7bc7f9dcfab46021a94a94a1cb074c66b086586c2a4fa59997658b13b8b735ecdb1b707d38339f05e207728791bc3d942c6dcf30111e0705296ba0e1e6987429f0830e605354003fe1a926fa18931b2b384762d5656c50f0824f7cb9a792e3fd22846dc43f0e9510e4b11dafc3171a158669f650328afb3aeef4e9a85da32672cb36c589aace88785db799255f2c70c642d26438902807ab998a8223764c2fccfca32c50f87e564fd0c8e04c10a26edc0149fb36d7ef41f38ea0d199226b586c4c326169f9d3cd767ca510bf7fb4d7dc17b54833a214f5f317e82292eefda68977fb92e2feb39a754aa7b6445b78ec97c8acf1bfcc26b3f48f230febc4e13e76877c01b00976956876c49c261498eade7936f94f87cc783ed918ea6b0d673d8e4138f7fbc3c97f94a39ec5c226097ef5d44b315fcb74eedeaf395dfd7ffd1464ad0943c7129616eb2863ca0180452d30613fd4541ab97","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
