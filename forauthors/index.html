<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1420dc0b8d5c65227b33c64748997cf884812b73bcde80807ff9cf1f0e2328da6283afb1ef39c26ac48758b04c33034e8d6a6234a78d715099f5cd4687b4e0e0514a3472dc1f2649e0e14a63e8e90e05b0b20054c07a0523dfb46400d364cfe9058f1afbffd48f75313e3c455a9cf3c412431eb4dc136109ca4e17ec25d9d4b7814d6fd2d27545895652de7be4d248e50ece311417bb7875681b46218ad91a85ad9829baced74ba9d16496774139862156eeccc23df809238545ce5a215c1892446398a97c87d99b8a78ddaebc3e1e8977cd3d8877c3a624a88e4ed18320205467c59f43c6237c6fe4e2008f63f82a4451804b5032dd0eb48f82e07ca5a197360ded85fb267f1d6910574a3baa82bf70494dbf722b4636a79b8e90cef0cd246723a0ded518e3cd50d26893754f573bdf073b0fe3aec421686df822c51f2c1a21f695e1ba857f420008430a835e938bbd4f0c3b67df8f38beb3fab96e8b4478055244e2436ee1bc8bbffcaeee311eb921daa0e0878c9f78b53086a7ff5ffcefc33331acc8ccad90b93ecf5c1f9b414ccda2fe75effdd6529117dface0e04d437b7e3bc6a7b1251cd2cf16ebbb6c39c3c95f428907f8c1d5dbecc7e125c8be2b2af506e3c1f38705d07a69c0d018279cba022357b913993a1a96f0b7656c977dd097fabd5f3124e8aed4029b45a0ee6137ad3c23a3c03017e4380121789107de6aa603e0234018fdfee78ac8770ef6c742acc0e64c466d9c55ca45cfe172623221226939dc37433a18d62bf0835d3d4030806f10b5e3190f35464acad3ad03b4aeeef73c46f6987ef1ddc6c71a4e86d9334a0aa4ede964046f7271d6f236b04c4ed0df3278024e4a76927c0d0a15fb4468898d0a7eb75d9383cc5c486ac123891e46adbd1fc05cde8b4a7c1f6efb3fe652ffaf68cbfebf6db9683748c27ddc1f7f9415ee828bd2b7e08b47666ebcad5df0879d65dd5efa1b9e410d74ac9b688e9eb2aaf36bd627d245876a72f6fea215b93c7ce5c57d6b6bbe9db2d4cb22947e828893f644fe1d545bbee57ec9ea14eb0b6cb807c60c51ed8de8e6970154cd3d4caa787289ac336f880b36bc28073dda0f2e553ad3dc0586bc805c742b57b555a4a516d56c0ae5349a500a44bf48e46305082a984212ad5de66fa0779ba56ef76b11ee194781fed6ecc6d6d204a468d986793b78c29fe65b79ac20cf9665f7f446748a1767c42b5660b91d05c331c6188e017657c219dbdae6a54e932b4391789c82cf76c7a56c8d9fd91456ee44602da6d72493bb252cdcfc74c2231d81eae247da090b87bbb1368796b7d405927f4395a2bfb54949ab0e9a106ff2af51ff6a5fc1a9eca88d25e6dac953ed7d78483e258baa07b874f0e5e66ccc925e5857ff9dd1ec87cfe88cdf192a4ef6158d2fea4c7cb5943cae6852d0ddd7a84f88accc5f88ad5696c4af374e2d36fb57fb9770a7588a8ff6a951c163ebba4b17b28526341cbf6ea5c84c6549993ef5494ce3bac60449d141059011b900398ae84417b0a2097240ad1a9ab3a39cd21644817f242e124701d77b1b85df21a37c8b9b7d13ef12db5c356322b820844942e65e2cc77997a79fd3c1111ecaf206b5133374e6e29b510c273476a572ed674b5a7de9183889e3450fad08ae85edb96a21c835d459a625047459e700edfee2792b91b35bb4278c5142bc1a0be871519e287937bc873cf9a663ea733b91d050e71f7849fa78e27bb502f593c1708d65ef6b799cf007723b00bcdc2da28eb2bac521cf0e540d3fbd5fe5bc99caaab16ebf149a99fa09fc980cff97afa399e48b2baf806fe7e7535c6c81aca9af7601ea346564f7ed4095994954f8a8461fb9d9077671d40ff8bb7fdef5764ef63864516a1649a04c25002696909fc690f3ee61a4c76e9af7cd70cd1520b6f8d5ce411628c7a55212b0bf87f3276b6e4c04971d9b895351b9f5591aed779ec4b4660a51a8ba52a84e3aefdc62b823b6b05de1bb4aeae381eab8a2a10797685998ee6aa2e8d459b19479089ae408994ee0dc653ab9536c9e06cc33ecde55f023c47ffb33e761276f195c0c8e42668e4509b5104dbe5180024ae109d214a4df8815d4beda895463cef6336b407bf2a2b8a7eeb72084b0e07a3f6a9207c460871b2caff0fd9196c4d70bac6a011c750f615ef8923bff58c4f97c1dd623b3bfec20269e1604eaf6a4e490db1deb135417c192ffdf322c871f32b79ace24d2cad04db3f89c1001398337e40d6328011d05496c278089914e57eeaa5d7df0ac715a6ce727b99fc2deeab2b722c125cc775882d558e01f25e477d078cc80f33f02214d48dd1a71213370b2cd5230ae37a5ab5c2b19d305ce7aa8c173bf591abe0ea8f4de25920d48304f3c2ed5e36cd96cd8cfb56ff88890f62b33c7a81dd6b921ad9a53087b4a76a08723de3d42621cf6a12e6431af912f2e7210a4b37bde6daa4b83e6cba076164f2642938be647d71afce765c0835d612996bc562ed7b8da627c2bbf21b2b0b3bf70be9bd65d13785ca20f31057c432bf675f1767d5b390caa7d2cdb33ee44ab50fe762e5d8b5fb2ee3efe6100713937f2e11209998c68884f4bf7769949c11eeda4bc6f80eb6aef583484f0e0d4246d43fbc75c01c5f8255e691bb74245f0c70e6d2ce3d93d4890b5aa44dbd5f9276e9d90f2ddf6a985bf3c8eac922f453498b52f794823e021a0f706f762a6f46edb7d401d37544e9ecfb488626e28fb79f523b5524df589b3c872d1324ea3af85c4a698bc1256222b7206ce40e92c516f2f6694672af0dadfd9250f217c4ce8980072247f1abafaef1a3d5fc18eff2fff9acca5f9287e0fbe04cefece1b78ae3855b1358cf1026faa4f2a402ff9ea2051c06f593a6e14aae8dcbb0375938a92006462a04653bf5d4212a4eb9a608c389bf9045995704334d5995d76488e99df2b0377e5619c94232ee6c64b995a58890ce409836df1c93a99c2f0acaf0e99cb32b7bbca8fc65cc9958615b1f4a2f3c044d479d40b8961ba7618b9a2874e1e5180f00aa1449f402f7b124a1decb3e609e3d010af21e9edc64a9c120d2ae38e0415fa0ed9901149c8c153d0e5d368d1e65cb8d8a6b0228a779951cf20fe72f3eb822f31d2f46da101c339dababb109146294424b11152e442531a6bf0e9716f7b546a4aca49fee77a487eadd02c7cd491bcade1e4179343bfdbb4ea9145e047e529bc668dcb7dad8908d9ebcdc2af732752c73191259245845e72ea5ecfccbc2270e8fdca780bb707e3d72cb2b5e190d9906867ffc04cb735aea1e102b1bb429714fd25c685eacd5a0290afc452820066fe908570a3672af69eb66fe64c2b62841fcf8713d43f028623f7a23e0f825609abab3b24ed819e432615cbaeb63bf3aea20f911e3cd8ae544c9eb92a44b11a6c2f6cf50fe3c753aca56008a8d2a299593807456c9056d77c860a19a3a2a37a5105441c4f9898a33fb215d2bc52f6eb54a1129e6510cbc684b4e2fc80cc1ca298c1199b238ba5eddcea3a48dd682e34e017c1e79ec06ce37a80eea8fdae939028d620500e2bc736d5d4c5bae460e0465964a5efef733e6102119c13c86c2a43f18d4fbbb211812fc60e67034d38710474663ad8e2de97754db5506450c3a355d682b3c04c8cfcf3c2529ed1a1223425824a6b8e69b778e2a7c5e71fb2dd89db7e9fc5b90a9bee567549eb763ea4d8680e45dfcefbcf6c1ac0f6afc0d40cf642880a6b9c1e42502139fd322b69ee2d0f745a791fbb3a2802dfc8682df3f4c582eea7942d064f5a6834d4f42f484f9071860f875a42bb71f9f51a9d998cf078041e3a424e3753c40a6c91a82ef17d52cb4332e46901eca6ab78a66dacc19ac7896946faac1331e82e04438b986292e34512b52b614a7f1b1e8ead52ae2d5f1d8c08e1f80e2317341e99a8eaeda487c33fa47f885c1410fad8eb2a81051f05089e00129eefd81d29d49ed85b4a60239e98acd9209a13cea365006956a09f550b73d6824c225740dece0f61c330a10c05c3d0edff88893e41c67e48de894408a851d266a66fed60b4639362f6949ff66f41cdfa084864fd724e448368f544078235f10cc7aaefd34464aefb79db8d5042bc6753287fe83ee5efe701dc334cfe0233ca93ef67379e30389325950fdd6f186d2742da86be6f2552423261550fe9b37f603eb829453d93b8c582d867565b32adc0b690240923aa668b3a9c85c15db1f61700a15f7386fe8382db3fbba8cbc3adff21bde0dc1e111977d7739b28952fff1db1691061003b8754eb255eb5673fbd1d16b38c5e610a6e9c81e526a42f82a1267940f3b46c98081eb79209c4fdab9533d2d87029dc7764adc232bf4f35a9ace5024df430d11503c00fb8626babf14c29f56a886c09e40d7c8308507c63289b994c5dc4d6ea9e04ba88203d422e354f8a6cbd5d4506ee15f8c261dc8bf18d90f2bd8e5b711ff302db6c912ed2189cb94c9b91ec4418236eed251f1dc7a80de60131d51ad6ec2ab15c6510f90ee7719f34828f5e0709d01cba45e4525a1311c455a4e0da21d8bdfad8ace5494b5bd8ca337f086acdc30c52d46db129549a8751aacddf944f01e5cb5677eac5abe64ca3709c42f92fe7662b9c1a008cbed0e8e8c5a7ce7bd022cb8e2f47876aa8ecb123a8de63b71bbe452e578dd139740ba38c8f5dc0b381c8d4dd9ae7330698489d4e9e96a540fc0b94a91525f7bc143955604b9dbd3584521054404d31d3d47a7686c585f8e86031f6f8cf95e3581ab2791284b06588006ea4ad4e659d46a7c0cdd2403135dc5e504e57865b8cf30e33871052ceaeeb9c6397161a12cc259812e0c19b2d4538d32f5f7dbbcc8ab81a14cf214bc4f835b7278753ab2e240ae455d7cbdb8fa5f3c23bfc9503db194bac0b25b350d4690bd1d67c1729004cd76cb2aa37b3db8da87adf0779243473d250cce8a8d14a65e9fcd1bbb9f7db8d60b3cb819e30bf723ac363f2fc72a5016921c4f731a447e8a4b6fe1bed671c74510bb678318e6a4b28c05604d324d2bd5115d53d0dbc0e6cd6ed5d53b0f3a0855829c49b034cc20a7f63720cb2a3015e2ee6afee05f6ed9ca17b69da141c69db91fb27b5c6c3701dda4f3a005b042709180d0b29c80076c46330dde9eca5aed94d6085eaad0ff3c087434acce55fa1efb6929979e7f246810d0aa66df6a65fffdfa4bee992f46783ed09428eae4c10edaa3ace8fddf5fc2ed1789cb7f883d007ce561d3b38cc362e1f37835f6e93d62d12f107ebd846d2fc060680f85379fcf257e5de14ffd9951897df75fcccb67b5341d45b1a617ed999ef5f21ea3b769d61495b33c592e4a28892311863d246671c50cda3bac33df40407775ca282c16966cda56181c1cbd86067c125f987191c7b37c71c906a98ce06f6074cc7ec31bcab6f747c50ba4094ccf2bade59898f4ac2e8d3c003ea09adfe6bc39c39008d961f948d95a9f28f47102b3feb2d90abce960eed611a480211daa3590608d21e0629fd441350ca4afdc8981211172a0eb920292814b4ae77b1a4b9bab12f685e3433228357e7e4501b49ef6906e3777b83bc87562a2faa91a9ab6b824b91167f5590c3f9c5adcb6f483a906c901c5e265e599801668339c2acfd4a321e8a231012301eaea2e6d507fae4a40604de4ea5020fdda1f1b1d264f15ae721715c92e53866897343c18937e6f52bcc7441fdec6fee5737d8cd5a6f404310a2582035119e2f0b7e21a289b51aee52f4b34199ae03c07c0fb2c613c2b202a27d87df3655b7f1e0109ea26f7739ae2922d2add05f83eb3cdcbd4a29980c5732b95b01aa99cbb761d901b4d607af52969c2158847a673a63afa21981e5943e86d216fd90c4fadea258fa181b89d28854663d13f64b60c22077cfc08a12f43a53706e418e098b5520f1f0240a6da096412d5af3327340a165ab0d251904632e281b589cb79540a6fd6b0ff2b9016073a3f4b0fa902eb87ba4b3aebf44e040f970c173bac459d6dbaf90236e712b8b529452140a356b6e5bdacd4bcf22341382c8f4d9a0bfdf1743f93e6285d2125f7f2a4b7d0d2f8f8f408b97454c9cd079441ff62055be09c76634a2a3f018143c7fdb3ab9637ed78f6e03434d228f84013dd0e287ca5c8b1022f315556778bd2922863e0919696565adce8187a7cb81b7901c80e565936d9ad2856af871a6c42b092028f3102c3fd3a632113d0a1fb93a541b63cb29434e9177c3dd62c2a47b54e853de0f7aef878bb0cb376767fe1ea4a2cb92e28705344e0f88d4c51f7f8f08055bd08cbf29d96e0123a72d8f78c45171f780e3372502eb94d35bb3b212679cb0063729486217a3ec627d4bd9eab68b17f1b9274ed3dddae7738f22f73b215ce64862f18b9efa68e89b58d9188ae89d0257b5e24d85f7298a9b217e530c42f4729f0d2911a1913c2e499184ab8ac006efb6d6009e232ea50541e0665a78563aed3eece4c484fdb1b3aab099f85f92582f909737877bf4f6419eb018989d4be005f7f474ee95db49d3f99717d95ad2a6cb6f835b0c76873b855067ee4d08d19c19cffdbb2b5a6f6d6a18b8cc274f55e1e0e7b0f9ad2f3a86a29aa45089193c2264829a12ce34556ab5d16294657c23414c85642ac03bda1e86d6b7d279758aed15b172993ec293a8692b9c9c5d9d69de8956a9794950f4697347c6ff912fd9f0ca39df1191481f682ab3a20ee8244aaee129921b1d2ec05328d3d5c2478cfb6caff1f9842cd8eff92c3179bcd559c50ee2e7b3df9184f0323c75bc71931f53e4adff7b6271633a50528e32191513dd0839d77bf7f9ad66be82923c8ebcb5de591afdd6eb244679d0b7423992ed3928aa895c8f7ab6120d7b07fedc5f64807653ffb75b0728a398f0dab4061d50d24404183497cb1f9a542a874b160be0025d0f75e95c24fcf8dfc78277d3113509be204e9f3226d2dbb8b00849e8c1033f4fde33306fda3cdd89601ef03c87275090ef31fd69cb8e38ceb952735b17ec41c343c4a2aae56cb32ce8024a7a2c4fd29854a3cf9c17d95e2178b01704ef1d7f01bd50344fe70d73fca41abb59fc5491adab82b3eea7eae5fb61c03a3ba9b49377bb2b6670796105773b17e24175dc40f8232a9951eca7b9ac22feb9b3e75960c41b51339235d754f86149d564cbb651d0627082954dc7ce0d097f15203afad9a8ef769589488607264243eb63fb19399200115a447b7b6934695d6ab1872cb95b2c3dd462a05a122c5a747f11d242277d6bdae227a6fe8c345521fe9b7f0d3981db6db492580c36001b1f56f99666938511f569fcd49724e40b5c99b96e3d1b3be2f1e189eafb28367b46797268b9e2005e20b17ac5892d3015aad42c111e4354f48c2fe96e5819f090e0028cfe9f4c35331399bade46939386548a16576eb42a250fcc0424aa66c4bf3b87f5b15aed8d343c01dfadf28c294e5483703784d5b238433b8fd06e0f2422f47fdca7db468bd9d06cca6339781a13665fd24898d65951bfb11c81bc99a35cf2cdb3b464274ebbfa8e61a79934c38128ea8a89905531c441689e08a6b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
