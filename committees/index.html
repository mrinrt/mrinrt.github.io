<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9dc9f96556c3ea99a8128bcbb4fadac678299f041f5abdf55649a8ac5d6f5eacc859788295b8bc8acf0b4feb3f8dcff6cc225ec3fdf240b416f4accdd142b5adb8190ee2a256f6abba63f7071774cfbf1bc4dc0faf3ce9ea2e303eb799e0ce6699759e06c3315ad1d59b0a33c89ac182ddda4b85945484cf17930a615267187d5f4a4340518632446ce9229d863e72af8d6cc427c4023706a018b876c423b54059751cb87be8e87eb02687481d2dc151d32db89a917259bf1477f27b9a8ae23e7ec6764ec538ecf5c7b419fdf5eae24eb5c5407064fe1c79436bf4f70e29cb485d3484d6c95ab869d71c43ed734a8a05cb1d6165c34cd4b2ce2f6d6795af58776a5a90d15b9bfef67b2c9cf7c5011a11c1e0e81576ad620d9357f8ced64acc443bde2c56e9cfb00e194ec1a1aff9f3489f50812a84d22ec0ab83a616c365f8b91ed7a3af6d34402374e176bd00ef8d511803c0edf8d8c9e089ee7eb9de575861a698413647391304d81c8c0fd2103d72ad0d9f5c830b628621e606e0694eaff5bba3a5298582f18e24b08a9a0296e266753b444a454da0d9ee100371bcce6510aadfc2fa964c6e7e4ff9b1eded1c7a66f5cd4ccccaa32fc61d57f24590eb94fd98bda8295685ffe6c3055efa60fb1907f2c53bed6e3efa8bc947053ab96743054b703a480aab2d7ae3552c064354648809bdb262517e5732155ec19fd3a7d56e9445252bda53f4ccbe745bbdb9458ee9a3ed34cbd6656785d2f268d9a1cb23055bcea43c01aa417cd87e6e3be78025f6e04f745d2300ef03bc1223a438630af36807e02afd98ad7f21f3e3e82913cb00b169077a8d6a9aa5ff70b012b77633d30225e2f6a33397efabfbe7b234ba94354e6e02f70f2744be75a7eb7082d2b547c4a273ad840d4e033e826b3615c33113ab202f0c4e34ec20a4efe97412c8eef923762adc79eb5ce6d0b0f11c878d79b0fde9afa80c78f11cc6449c6f87db2eec4bba71b10859baa219de8e0c158a90179f9171dbc8b55c664af725e6671e3eeaf2dd0f6f42ddbda73adedf06946b73dea309fe24c2878f38a77e734b15865b30b0cd50b78b1264d88c1f7b0d3ceeb75f40df1ac5c8be8a382e9c185856b5983962502e2c2216b01721cbb45648da93031980d1dce193fabc8f8aea862135dda270418bb4e20a338018cd92459197471e2e184be575a08f81bac4e39b39740a159ad53fb01cc82adb3246488f0e78ed9c4ca5203939a9bb65db32f230c0fa67c631468e9977cc60ad3629576d07175c6be65b1aa45aba3c650e5b60c5dfb30d315012b7b1cc2d2ef6b87f43d1086dd1b9b3d9bec11f5d21ff57549df4f8236eefc60bb32e40d3bca00f4b37dde887c214d8158a927fbe5362bf1bed9ef3aec0f14f34a89d4882a8f728dc4e1ef035f61d899511f78d6d92d2f677215a75f1495b323c8f0bcbd685e64ba6dc4d76f3e9d0d491be2904e7db54608c82fbde1d6f75ebcba1e2ced08cd433146edb24a5db8dbf1a21f1af06ff0bd07eb7b4ba54659cc654d8b2cf5fd41ab996956e542e77aaf327da67de23f0e59c3575a65532d6d697dfb187b598a2f0cdcdc29f2d27474e1ca7d9fd79074b1e6a5d87b76d72d66f155f2cf852ad5a802b2f21605f5321dfc2702d1c3f07768cd13ba0dfd71a0465270965f334feb7820b91023cd6cb4b94dbcbd775cf649a9c5d58c4a10c17e4d3e56c20bdb7091c53a25bec8b518fc74a4356a857ac3fcde6b5891f0ab506edd56563194e521e92a4cbe55a808fa6f28c3e5890b90586400ce5d25ad8233dadd18c035e889a67e32b712d0967f527078fc620fcce7e3bf738dc18b9c727af63d25cae4cc39caa3fc13661a697b984f1d7d8d440cdcda82312ab32d120ede8daa07ec994d678d4099a6144d51d87142e141401cdaea1964ca6857256a04edcf6b75241702957ea7676bf36ace3758078043286e1a057b7104acfb402d4e9aae2159f322eb9aa642d9c4dc4277ca943bea0ae6e552af48bc6fe2989a71df4a7509f5be7e75354bc04d80b4c8be36b0d7b1cc596021294cad6d416ade0df81471976fcd8ab576e4a3f49338a1d861a31dbc1f822a5233af4ba4ae42f6f720eacf24ad8dd5d9d44779ec642ea3c670f327d10a9c727938611a944e687cbb2f14e38cbab9521698634dab6aa092b8f2688a90aac7c6e6d106ea2cd148e8dfa2afb4a93d8ac7c9600b7ab051e6a3dbdafdd3f1dd1b90eeb95c655942922a08d6b930be0cdccb64a213a6ec7ad0e993cc4bc0019955f5220ce0017f142c390c3538ccd3eb822ea5817c345e56c1934c95aa7523800c5224aab00f8583e4891387c2cc3941044beda6a4512722dd5fe983f9bbce70a85cb0a546beb95e39dc2cbbebe1a94c8edbbf11b532bb515fb1d6ca9ff89c0eae990e5ffc6da871a21da38078f02639252f7fc2f79c08edcc78d55e751340fc916d642cb7ca862afd2ec68426f03797eed0c2b87194a3cfee34952884a7c88cd5593e60799066f296d2283e823a22bad06af3b48df0a1c0d66555b56c59d1591eba2aff103ea8902643619f12feeb79abf53e8062e1e6b0d1bb92a679e7cc8a62a2b60cc19286dbc58dbb4a72b0c29acce8acf1317c97ce2fbe147e92dee63c02af2c378662df25c87addb673ee7c5bac4890417c3fdbd7ff52e78e713ce4fcc77918d3455cff5909159b3de40ebb38773067bffe361ccc895dc0cfb61d6f6f37d5ae26c1c2c0ffcf5b909cbf0bdf46e7ba0182f7878fa5177d1a0202f39776a8da5b5c1420531e0bfa4c34e75667a2a4e05031cbe4c87f33299d56edee01f9dbb5648ac5c8b555b4f723809e18b615cf2267ba4c9a55033d404f877cb4f5dd7546d9733478bc5af6a3fa6ea1a1b8650f07e87d7d65fa46f12a1374b2e093d07fb39d90b7bd51ef236e62618a89e601a7554e1de1318b6e13471849f08c17e4ac6387772df879f9864e3b6e5ecc26dfb793f991e510ff8f6018acf0d76a447c7b684b2116013ba7d642917d0b011fc4a25321391853161ab62ba4e06a553a8e024ef9a5375f735c71f6221930546b84d0777f1e75019704a301432002915bffc1cf28a96fe922da61ac7038f00876b194f93d41f3308a66a8842a18a86fb09940ff3bbd9f884347b8486c11ebf0c0db5681a7444e9eff739fcc96d6fe66f80f966c4ab03e97c0f6462941d098c72c5af0c89f32cbe08633a4e4380c3e32127b6c13540dfcf41291f0427261033e8eeef228be512affa5076473b1d87f3da5111ce76199ba540f9260cadbb4fff372aa5c1c0c8bd4dc9df3bcaa62a202cbda084632c8113f2bc4b52a0edaaebbd7b1a4da0efb0621f98b91cf79de452948012e31249bbbb794407935b26a5c9153643439fe9bd04026459df6d185eb44ea97f88b2abb802e2578f7a6e4b01cb6e59bf632d5e3964d20713bc531c9aafd5366767c9a802ef1e4b2e7c00c5f9472535d1657c1c124a67f746a17dd8e3209dedbd796111ecc9adfca35e4df33bbb8113c0e8ad5f7b2e10e936033e120b517180a3da2c55204b90c39951a12ba0a7116b0ec341b15ca7adadf224a2730fa061413122669822ab63ce79ae9696c0b50fc38216da1a7f0b1a6e872035e2e15efc6936a4455f54e7fa01292ee2a9a923d7031728e79471be717fc1534198d1bd2f09c94633a8abc9a508f51dac0c9e352d5e3931a3fe80b357d60a321a74452cb37adc1c2adddbd4e7f224dbc4a58f3682b7016c6e111bcc4109baa4fc084e4432e35d7632939fb93af8f13c37a5f1844d6942e9990730b77be32edaadb7ac15968817d3b1bdc163ea1dc4c46b7cdaa4b6dfdd1a5a35541cf48e932be34167e80f78be01185f810ca0420c339189288d4daff0adf023a41b5bab1daba3ca0242e881dbb95425d4aec57e8a28661f3e74384c899a6c6cac62aba26fea670afce5867bbf46921f6c917341e6980d678e18c1a409961f34676a0465dd9e4935d25ab3d87d4b601a4a925c13374f415c63b5ed4f11c0a9754be2b1a155b6a198bca75a6dd97e256a2dedda96d9bcea02d2997c25b0bbc564e44546b5d601bdc1a39cadef8f2a2c6f5c466ea048c551f4deb585dda4ec8695be7610aa6a5bc3f5167b8d28d260e99afdff22cd9f394ba0a8cb2f1650c71435b1b50313e3cb1a0abc65aeb671bdba929e4c9f119583825cd04343236ad88c911e60d3c7393c77a211ce26935c76baba2ec02a04bb91a14f2e532896775989b9d8a34a57a3d6eba4c4339163b4fc7d4ed6284675332f2a9179d4e5aa24b969b1ff1c14d890d487c6f3ada00df6508bf50ac4710a2e6389f969bd2b3ffba63cc403987cc5d5d6da39c17aa91a195c210d7a63f51a2f168d3339b3c7f8e0f804995c22b303bc03dd126c300f5131e47f0e21c3797dc5fa2794c488712cc9d36eb248f51a4b6fca09955af5e89185b2bfc8ce048db727e057e1759b90fec1b43410c84e86dc1c1a3d5b7913b83acd0a3cc62c326d3da936375082bfc909f525fbe8b2e03a6a8f9c6aaa4e5f9c238c2088355251169c7fdd68363dceea0a3a96c196cad1af0119fdd98d7852b166ba7236f78b62117f2dc5217e4429f36fc58296510125e29b1476c1f3a4058a54042dd3aa0462cdce6b55a479cd5a44e55c2cbd787d59be49dd3683ca7a0d7dbca468a488b833bc51a4f35e453c681d3a9d870008873ff6647939e90d7bfdee58036e01e5da6beab1caf3921294e15842a3f4476ace874e886252b6c3a37b0069af403a84362c9bba6caa604cf2ee848dcde5fd322564e12bb70c2d5bd1664cf654788673b5baa8a29301438637b4164334f198879aaf9f2b2f4ffb709b6beffb8f1ebeb88cb4613d3848eff437421e21b20ee61b4322051875efaa3234798cdca8b1c0926da6ef456c376c5d8e7d3d1d7b292df19f2b8d61833e5e2d2cc873198771258533d05a94c9a1f1da374947adea7be4fac5d1d344d4890706311c92c6e63ac1bef628563477172be32baea182a35a764d039441fd29e037f5d25d5753f7f08ca5eccde26d8f37e78e0f4f1322dd804cf15841692286d94544de72f0dc6b6ca64fe547356b6bac2bdd7ccb923974d74286d009745b888cae505d270a1a89bc2d15b655f0657061bb48050a97ce224cb276c43c390d4670b67e159aaa8ca69263660370fb8b0932e1a48a6ba4c09b1caa215cbf9b95cd332405cea8831c4b8467664b1c780db94067b09743ecbb393125b56c811d4bb0ec753a18992f421e8f8aaafbfc9aff488fc4b86dca234aa31a1bd5f4aa2f980c35fda4f1decda89e5c1d8ecf70b046c5df1fbe183ccac901d52b6d4b93221992d7fb0e06b9325a708d138da5dea73115d39e1c493a1d09e85a07566fb3887bff7374ee8941fc7d5c2509c1c06fda3cee8be163aa7f35667eda68f5f311d03a83b2116952d36c63c83726c4f12a15bd9127f38e076c383b59d9407fc0d3c08bede63a24c64323b86f9c2497da2ffdd94495e99ccdd2ddba5b0d079df4f2d716d06821580d74f38b2f25001d1fdbdde66fded0539a9216961d67b7ad643f16ac9f2cd492a3b06897b87159e454171402893af0cf1b523d3ab3c7f0479f30015ff37d1c775f1b42614d7d50690e406970569d6ac44023701106e5b191e57118460ed9dda5a8bd2380c65693bced031510664fd53c12008962e0433829aef3b271cb281ea8b42c84d8bbdf7634eae25128b3f6dfc4b1f9453fc2cce696548d156675b69969d0eb0eb10af158ec3bb825fa3f6aaebb77a11b3f21bd6e2043395f8e1474f57ff4c884d232bbb847f60e83ecfe344a94526cd7b0ae4c71a59bc5973d880db1ea27e553c3f107ce89a82e42ca146ac2bf7e9a584a061f96d6f944daf90059f29476270379ea2ede45e4799dd5255d65ed50357a098eabe6350a3c85e12d2bb16c6522cdacc7a7e83eab205ec9e5f812c5e6a2af8b404490ab6689741255eaabf1b33464cab11c269614831a3afd4e7609a1efcf8c1939eca457be5cb9dbe317094e61d1c19860403855cc03ab2b4a22669f1f21c5f8df2b4bff331fe0a7bb1dfcb758aeb104fab7f8a168b9abfdead15a25b86500d0977fc437e617b32b006bfa80a0aefd0154150ed86033b3fc9f0ada1a43f0b1bd96f2926c0d7f6a7840f3c7dea257fc75396fe625706832a68e32cf0c7c05096fd6c4f17fd6f23cdbff9e895300b460a9e21e21547838fc944507f0769160f3bf73637bd3b35781857178c19d35ac9acd5cb060cfb2eb5106a5e7bf60790a7e36e1fb77f8d0322590454fdfdbea6796ed4c0483e7c49eeb0b39828494200da19511afb29f7c88ae55419569c630cc8fa7c105ad822bfb4dc07f188e6fe8bc56fa085f1b9588e965d986ccd4f9cc2f21094758a899dd33e7999c5425c53ed849f8963dd76ba5286c2f75dd95316899742228b8a0f08fc21a37abf4e9d8458c78bfcc18c353dd9b499763fcf38bfc200d6aa111707b6511d4c0550f63091eb3c46033f848ce0854e224d15a2c4985f261e2ccb518048b56b19c9396a5f9b6d8e0f802be0bcbca115c8b8e15af55276dff8677a4af97be0c8218eb5d0c003c0be20373801fd12fadc734f88020d3ca11d504ee6b2a5598cfe87b9402f4f09cd60e224eaf8379235783c2ee0fc8f0e1b4531c344b660b548addf0780f27e213086428a01d1ee79cea69bbe6e63306043f6db448ba061f23cf88db110073568d69eff5cef3d8c1ee985621183ff23b4271788912c39c3c8ae8436636f6bf79497e4604972a4500ffd15f57ac35b1cd7778d529d41f7ea741cc64d625c9f4cb42319c70963fa85e398f795f90c6a90c8403e30e63fd2d9556d418f24573095dec0fafc6792f6cadc7c4bff285a140d54157c7ccf58f886e702fb89cb30121a70ef56af22e7a29e775d0130a7951744d852e9c510f4a4f62d63894c8309f4e82006cc6a3f5edf43890fa4622031d0a24dbbe071b35220e0aaac0be7b0bf98dcea85609850b1979f8d9df17f0be259ce7b3bf7401d48ca182f75cbd413af5075535083d4db9d33111300bc561ecf209ccc8c9e64d55204b34aca9dbf54144cef2603aabece66c6952bf1d6fe463441c6e5c1b810b7831876c580ef2667ac92e21db87e476c71b2eedf3c21c64c5fa0e32f8984e23425a18a044d8ba27d063f981e6f36db30ee9ba022d803263382e015058923482af820d258d31e854be8b53ebcc104bd55371a661681336baf52ef81427d579cc6cf1f45783001e632122501613a0d978c840ea5a575ad9373a002b976a3bf6b51567fc1321c2a467b1f2e5eb5b675c203bc5f8a7eadcc5ac9d4ff43b9f44033a284574d0770fefdd7440738ffe42427902301312710ad44cb181c19fb4fb14f466386b79be76ffd636f8d3b4afc450f564d3b9afeaaa411965af8869c1e47adf71fdcd92bdd28a30dfb572bfab3e7280c34b8ccb1aaebfe8100b9a425258af5b07b65da713e08a847473d70068367534df78f6733dd227afa4cf30567a04ba930678300d640c3fb4c65c9518f1f8542c96f5528b83f2873687e7f73abb86c58f063f760f0e12312ccbe6840c25a58eb47f4d585d7ac8a934bbac645bbf31bdc4033606df6bf47c4ca37effcaf1a7d0f47012d21cbfe750a50c1ada1b1bdb18bafc5958f9c475a276a0fbf339d44265b8fe4acbcbfc6b7e2f5a7da78b45e5c24c2b8c073c426ee8d783dcfd9bb132030bfa01c323b2c0f2ee845721a41c99d3150652c2e3cefdd4a4d22a51714758f0bbfad0527d6ed0a34e9686e5e72519ba21480161e65aa2e2329d8e9b1a9ea7d9c330a74182b232b28181f7b33b0192c2b1c0534e3a48cc24be9adaf905317f2852c5578333a6df947435bc4051c8553255bcd4b03d45e9e930f43dc92c90404168be33fb9bd907347a29af3ee4db7dd7b1b3a73f2fd118df04a27796927e65211f9542c4d39131c4c11b0e0e4730df23f71601fb19768cd048ef2334c03006357e747e0c1c7927785081c4f6545d71e64cecb6d8ceb63d0f9488f11d4f8585218f649d7594b642336d705b0ee3f523d85c086bbd5a230819cde151b70211ad25978670c371ac568214e4da60d580c4bb74b62c7a8069c674937be2e58b09012ac0f14a782a6cfcce7dfd752dc5c0a16052","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
