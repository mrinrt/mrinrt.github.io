<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a73995a7501ff5b97e94a1713a2e216aac6d05730584fd0d85c32bae4b383f6809c8044956de1a4841ba81d4e63a80022c0a35aff155ddb1e23ce75ddc04bdd8a922e44c1bd03f41989cb53499e065585d2d0816c35e2480a3dcc3fe5a28b26d6075b8930980db49a0ccdde30c9c57ecae4e65bebdd523ca9a30ca344bf73634718ca65de6f0e27924872265be7de76454deb6aaafed1c46d0eae2d4d3c6eaaa14432ef209e7cc510e4215a8715986f27f9c70c803c84e3b6affe35f1113c547411d2fdd835a1d9c14027d417619fcf51296f08b3dd240646720081fc74c188073e138cd3a8919435911042fb4a0ef4efd792d7aef318641a053f9207f31244a34e06db0d684532edf6c840e1ddbeeaf8fd2b07dd3c7c95940626531ae5309b0c9e6f6a27a0cdb52b5724dfafc58d5bd64205b0bfd00beb1ebdcede096ee1a268152d3fdcebfccb3066b3a01124d7a533abf07f337053336df51267cd370e43cd4e7d5861495da16b5cf0ce13f0a7a336d1d336a9069f3194e0cd182533172a8ed6850785ad1e15824723b23aa0351aeea8ffca2fa6f857276b1c9a155c5c5333fcbf395ead6a2fab7f179d95c42d1988bbc37ca816212284f846c3cfcc9f88e53589aff4c19a4e0b7f435a609e066c255597a3e02e69cf35680febc804467bfd91345be6d3388c46a3c3bf8f048b9b8908934850bc854e43aaca6d9e512a594d205475c5f278c3d0abf2a3d63d7704eac4a5b77b83ab920e7e557d4a9cf4ec978e687b73dd50a943f25930cbd1e7a556e746139005bde646ede846c6be96cc670c890ffcfce9b0dcaa273f277721c0234835c49b9f4ff0b3dec4351a8a4ace0e5663849785bd26d2503b297ec78bde6a95852178cced5036f27b25f3506d72b7de1fc1ec692ecc647aabe77b7c2055e4a9cd57f5795535469d1fd8ab81069bfa438a95b251b1758fdfe1cb04c192304291c005a2e38cd9721476c1a4eb99d610f8bf5fa9ca6ee2f5664f8a97c404914cb4401d9179e40d6df525f3e3615062cf538eb298f4bfd9298b5e7d8450a759a6f4f23bb245f689abe661377d63fbb55e61138aa09d7a5a7c7a80ec6cdd1895cf1d1fc3a39ca9d6d6b9d961bed228a126351cf37f8764e1269beec5a0db4c5b88b8f479dce63da79b0f7220891114d7a64151ebbbe0ee46a8de817c5cb0105d8e0d34a571a678ffd0e44bcccfda67f14fdf81b4a4683e5f02baa8e4448a0a86073fb3f519f1752f8f1eaf31f76d3dc1beed1e126e006dff2309a52039c727150cf672f4ea6cd1d3ff98087556d2f2526148be3daab722d92f93f9165190df055d853ed388bb336f0a6c6b485b54802dc348c5713ad3d0d3d57d068d902081e11f176addddce86e13933244992dfae4fd596e0cd880d17f5f493372573d732df6abe9557cd7e7af48835f4cd3126ebfbc78be18a44404b985ebce00155c62b97f154cc1a2de905ea83f2f2caa0f180900d4baf1144186322b1a9b1bc8996c8c85945e4fb93a2d12d913a098a078616145a805fffda6593fb347f23e9e7e673cb846376fde251e6352aa3ee9116bef661332ed5e47bf5e7a919a3400d506dc40f92820ed633abb40c3fc19e4e552481216e9fb6276c0d3d94ba637d48ce618736568a1fabc74450c564166dd3674d316e6cf73efb02d51a0d736f0a1158e602f5a681f4ba2d4eebb373fa8de906c7abb9eef83c1367996e602f872f25d3454e666c21ce0eb07b45814c0fa3d12b017b000a372ae4ee1f5c6a6ef7d44304927a9c4e65536864cabbd4f077d31607229322e1b6ebb5ca0629da0d8ff78c048122acecc961337f7a71d7e8c4145dae5b04585ff0a61aaa3e6218f0dbefd73ed7c98170390afb14a4214af73a3fd49ed737ed9382f5c5e4c2d0306006c006bf2af3651f2ed54a20c3e7616e94e624ac03e1b2e439a1d2e8e5ffb7aa633d42736621db174a88000269640f08d27d04f83595623759dea98e8e8b1f0088211f8a9990ebc9e36a27a0531eb171337162d65275100dd00e7a5c5e2bc5d76c01cb1b7fd7198cefa32faef363537e7857587d22b091ad423018c2353baaad7fb2b4db2c2ab8f42747de315e9b44700c0725cd022b8ae1103fcbdecfe089c5fccac67c83b0ef48f92b2690b3448360a1527e49ef2f2d01d4ee12e186ffa1dac9196b31fb2693015bab87c2baeefbf1e0b538e29046184d41505cb58fcf1e5173af80a5863043683c1d2b002a65491044409d7c5b45ca3bc86b6f96f7ab639c89d9ffabb142a7192a5a32a0ad75ef2cda6b88a8def40c59aeacb04330f7ef811090ba3915de8d66ba77862c28fa87bdfded5d830e57db6ec6d3e2dbaabcac33210d6da273b0c79e903745e7f6551be57c2bdb46af9ac2a1cf97be65759be9a8e44d3c131d542a356365c724fa116a0e0da721aa5a7f699a55a1fe22e92d942eeffae3bd6967181ee9d744c0fe72403710d71cf8f983a1d71f0b4c5118e017438924a571294b9e8908bffbc7a50bed5d74ffd5ed3e0734c45a0d8a609581164b9ec6ec3e72e867d6a2219f914624bbb676d1d14885cfa2e30e75b625f98b93f4c8e56db9d445069afc6138af7c4ba3e65ab5cb18fe5bddb11d20155d090c16ae865a58b7aefbe89045c7eb908b6ce527b03c045f641413b8dbbeb519794b00e800969f92a5d9e846e2f643f0edc7254195539e0792f0363f57d71bc3490b4205082c4ce919d895d21733326236b84863eb6d2f19e9da586939fe182d9f5125fba4c37203075fe62aac613c959b70ed580ec0b52d41d225c11b69e81ba794a680b039c49cea8bf3d158ef883976498abec3596f43d9c5df9a9b4c8efda78e34c1501cb9b522749b3c9f3e975d055f1add66293173efdc0cf74b152655507f15a1f6233a4d2ebe2582755483d8bb172d81f4d93a8fdc75c8215a351fa46e5facfa46b368d52bcdabe69c741ea3f4d81b19617d3fb86f4e8de61838fdcd100202a22b9dbb9b80bb2f08e7c69d4a95adf962fdc0f8048ec953d299fd28cc6a041c213b0071d00b40c5d1f6c4ddd2e438c3008a79dd14c92ed22dea2f849b262e6b4d3907d66524936ad907372d0b5d5d701e0af8229c3cadd1b074eb85c2d17dba82882e197c345dca23bb51b223879fc35a6272fb726899ee881dcecbe8c7efc8870e7c138a3f1f80374790d247c76bd21f35fee3e68bfeefed46b6dcbe5f4a270dcf6534a6424d974dcc544d29463522a4272de74a677e7d4b5a6aa48dfadbceecc9cd6c8904949f94377991e90352a684b6011aafdff4a0875dfbb944d902297c3c11adc591b8d5db14f130884d1e2a4c96209a7733ed083a82dc3fd6d01b7099dad658e56ad4188aa4cf3e52b9be2e1c55f7e40e893286bfc734cac9a4d2da826f195afc05a540c287ac81c5e8e6e9e280a2e66371a7506e6c733a6cad15ef5733382207244dc0eaece9e4cae1335dbf73a28091cd1af0fa07c30c51f01ba61f05622c9282144250059296ac42d3e3c2b5519c2093857ed51f95b4443298185eb18e709eeee5403b6eab22fe7e1481e8c2e711da3fefb6b76d6f4ad71eb1f0d9096c3b56678f533b29dbc6910d00f2e5846aa1829f5b0f07dbb8c6c7bb2d817e755ebf372e59f80a2c04546014f6798576d1c506fb6209a4feed18dc93280e5d83426be336ec1fe7532813dd8ee706e28b0d286db3ecc6b2d24405c61ce84e68252be811954cabce74f18210ce9faa5a7f48872e3851ad82e26a176d1b66cc4d0a87774a5dcfc682caf81c5ea557c8dce5152378e1dcde0010356f72558906e25f09d64392502d49d60224a8b950f7aade4fe7c5734b6aa815366fd6f270fe85b83fd71494f216bdea42f5585a60718e7f13bfa51079415dba269fd9709934a3ce91723819a8d6c70c7e9be98c2dfd7b5a4934fa605d0ad27dad79b5337f6f274bc41fb4602f295b263ced1e8b0f872f2e89ad2e353a99ed5f30de67e9d18adb0af8bc79b04504ab781297f8a5e7f8ff94b4302dcf1849f19e209630124fd0490ba57f47e6b42a4ba4212d515cba16c2661e4bb57000f21072cebd8b9527c8c46864443cc3185e2236e3cc63f7a68ce83d2c63c1c03bf5b2a510c260775d8add104b6995d31cf477175c97c8ccceb8c8830fc2a4e7ae02bf2262cbf3f30cdab3741f7b1d0e35fc9373bd9f55a1fe372761b93dbac494467d900367a92950cf8cc4c025821f2089d99c6b8024f8eee04b119dcc63945e86a7968ba4b3c19652bbdc39d40cd4ec7915b1fa2eed0007644d8112bd6c0f5df5d8c5b2967c93997dd6ee88ba011b36c97fc7b0f9c492ea712f415c63ee80130b8a6c850551ecb46f90c83ae5830bbc1952bbafc870d999fe1cfcbcdf7885bfb7088329f9b1f83de5dec7b377804b9d5c95e2d980f5c14f98cf5e6f574df7dafb6e32d4681bd03f33bf1c299c8cebbe4d9ffdb0dccff1bf497dbc3e1c7a8f4613c6009a234f5e0d7fe7110be937e0f0f1e8b732b1a2e4cd61af72ba563f5a57fcb7076b0add168d59dc3cccc7a8b4ae05cbb5815416277118ba49806a7a5c1094667c75aec72707b84203f761ac3042c9a5b1d2727dd895cd094f1b8695b208dc1a47828455033756aa743e28a34a8e83f2444537070c1a1d514dbb42399876fea80012ee8645ba63e64e3c46ea7f165b5af2b06fea84c1b2623c65026d8d9bcd04231d26a8a07ef92374be509e0438c68b96d71dec89eef89a1b0846bb531e4b11c7740e3cfe9ab3d1e2a31691d4aa1f120d1b3ba1e370077fe5595e736cf19112ec74db45d9912f8af3c5da09107db4e5165547b91809493da3df2bc7fa87a2f0a878cef089a42cbda39c0f888454ac31ddb24138c164ef9f7476cdcbdd0ecef6dfc785a9333802c6da4a46e241b4bc42689da044b96c9a370f17e27a5b024606746545c5e16a1afceb6ea9ddb6130d04193d932938832000aa8ea247b889832da52d3ba6c3f1a8b09a5f1ca1b151f88bdf727b3fc2151042acbe7b9407a6d5893742edd4fdcc403100fdb81390d4f38fd995f4da723fd370efb437e584592418380e07cdc709aaf9c1bbe8dbb5f789cea6706a8b49b0d1de6470e864093601d4096fb020de46c00638ef7a70de53da599577b15a6870da71a8e0f58632c84e87f391af5204fcd128823e2fbfa6b1eeb877fc852516783ea8178597b0f30cebf320db0de3b97f76f6510d3882cc0fcd45ad6cd1fb53d098d23b266ae55e3dc7ea06df1d2b1d2525d1496bc501fba75908199431dd89134e650d80f26289ae88dc9265cbb32b5600872105e0869d44a708c21b5ba35a57eb20caeedfc88dc9eeafd0f4b3e884d7b4c18ad985a7c887d8dc07637ebc1d97324481ea4f45c9da8499ae12b260834b7b1cd08c08873520dfafa0a6c31648dce62444f14425d62e30a3261e32188a02dbec011e7d8d1537801fa2df5143f999be6cf61aa29305de711698fc4752ac23d25d81331a402b1d6f4032cbf54de78f0330dfc303f598a68882507ff3a1b2295e25e1fd2f6c8cb42cadbacb2e9f47cf40bdb6c16e0389589980a6ca58eea5297c97230e89070d4e89bab472c7862e63c3d3a76f4c1c9db60fb9c4070619709ae442cf201996fa6aabba1a9a5d06edadcc126a0d076c859c1c842f25c8593961e53580a998e7bd8d5ed7ea2acd5afd75af28843d2a0ac6f045554e840a5c488d2e961649f79768dcc2e0b218a63b2150194f8d9c3ba7fe44be6bf10822caa3714dea0e837419fe1fe2d002186a4d5c9bb161df52998d867736b8d0dc4630350da65c0167db4939c528d8f5c1e7810ae54e44c4241d7664dba292489349c2eba8306ad91cfcdb87e823b4412fc46838980c9fb0208783dce941e645c8f47d8558d6204f5d2ec81b4335cd2f16afcfd7afe688ea84786ecddd421c0e649da59fdd186c2693c730c7478e66c6d973e4881e75e762a7b08f64252f9f4b1211782c7195b4ed35539af8670a067867b3afc2f5f7fadd74815efb7c6f15af3979b9bba1847bfa1dd9ff96a83b86eb91cc574569a5e2daee78d47533e027683d34434ce3342a99ebc7608e204641bca3ec59ddfc5fb698474cd71b00ae08cae23dab4c903abfa31b149a71b9434884a29f1dfe790dc559d2e3d6126793f72241dc11b2d8bda95dddaf96d8559a50bd7656e0c7f5fe71e717c356b6528a4eb3b9ffcc18e69fc5ccee4b6ead3bb974d42bdc2923435a7823f107f13d30abed986fd34aa37f2e05ec45bc1c394667b0d985c28ec80295940f58826eafac6e893c155c040583d027b8125f8d00c8c42afa68df4d5eaf30529d0026916e415b6924721cada5382601a52e310dd7584ac8bfa49d87ff6a2d0ab2bc8df60139348840fdb4612594a3281a753499d68f1f41cee7468e89aaf51c932bc03168c778a4d512714930bf0f138b9981d3373334501da714f1dd3f6da257279fc9a23d72a44ebcceac91e169acbd46d805338de427832abd0bea7b871735c24e5fe0e18f2124b4a26c6c6c27d76d20a19269e5a1fca2728ada447866e408e862e6bfb9e29948ee59904e27e082fcb49c4a57f23197537138c2375de7f07681660ff18ea999d10c7232526a5081e159fee0eddfe66eb9ac0d2d8f79c03cd727022969a5082e6ff1a2246162f8b19e6ca25c7dfbdf9fb533721af59dc85a5a371e60892155a09acd9edd80bbb7a233be7f68a05f1c5e96d8ee616a0d7a0e78822dd927d48e71850d2919bf86e8af17b59f542501e8843328410e96e9d058e88aff8c27bdb34dd244da8941965e1a33147eb8d3c505dd681b0a2eccba3fa8fd121f2fe11e615e4c14c87de32ce100d8e95ca184800624b013da11dae44caba995c6de865984bf5d754d7c854559d70ea84901f2059bdf46044cc8bd4b6379a7bf460cebaf4de3348647203b578653041dd6f5f1bb62f928eab9c3a2f00f401959b226c504ad9f0b4608fa511986210ff7645a8a418aea4cc0573a015e6b42fd1ccef57a7d47b83ca96f20ffc49a89c9f6eaf971b2422e1879f65f3142804f4e05a962b213b491bfcedb7932907f0f86edb1aba606553a8cb1b9fb8ec51a5d6c0e6885587952ee8b4ca688933ad3c9d3714657ffd08d5d4c017f82f3d1048e677fbf5f11399687c7015cce1f8bbba1d6138926952a4d8191f9ed55d09ca44b905d537d8c78d522ba5ecd4ac9f3c2684c7dc336127ecbc024a3e43f705d6d6babc3d4328e26a15d02a86795f64888e7c7f62637b566c6eeed6bb93fe19d4e79a293dd3eeaee56bffa717a34a26b35cee9a777192027bc902ab3aebea190201a8b204b2bd25a5a0435409553db5d12826c1c9c86e271dcc572db461561a95d2c2a2d5f19dbca7a7920735844c7efa79942ea0776d0b730123b8315eaa8b308335e62f53f89efe01e859eb0c89be4351592961487193731a8800b23f9f6a3218449debcfbaa7098c74daf427e43d5cdeecf2b231f298a84e912eb01696b93d999955dc33f4ae6690e67cb7351ad0a12e2685e1b981cab36a44b917963a2c6e8595db5e574e52f0aaed66e2bc6b8cb400920155f9434469b7fc738d437f661b1dd7894e2e3a86321a41888c8f0789e436b354e908991ca349af1aa88b0a824629b1bfc8c5b90340a29925cfa6aba12d2aeb772349bed97cb7cc5b197f0a57d23539ff9ec0448980630078f7417726a25efad37e93094fefddbab8274b1cbe1dc98e8027cf54c3e03c5cf626e64ec010cc701564ac3c2683422d482164b56b1f18d7d68c1c5353a5f005fcf54e61d423fc7688b649eb577a30b99e99d471f4ffef0dff88072f5fb7104da4ca7a5b712615660e1323bd66e5d91a655d25960a925b202c0c272744296b4d3548fc2315b3281d67f80fb980b03738c64a65e832ff62b4e9e60e4422c289e3ab78ab216a5ca096b90a0d7da7af3493f6024a781be2e45ec8e01f3e00d3bad35b595a7eeac91dc77963bca6d9ac4f31653d3fe7cba568eaea0b35a11a7ae2f28f8d1ae9e09c447cd15a7fb32ab658491d2604dca645ebd198b1eb33bd80501914f6a556343c36110046e42104a51ab952f1c5d657324a7038ca2d3a60d3f77b42e672dd945e4be2d01433a85ffa9f1ed5b794ba0c2677252ca7a7f53a913a2b38327a2df50e4d88ca9736765d1e55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
