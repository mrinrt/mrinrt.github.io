<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ab493abfa813d6ba67da27fb55d2df44809c732d103c4475833c2102805a5981364cdfa203a7faf748d147876c834188a6448ffcb5cf15ef8adb0e4e571e6cdb6497bbc5ebb7eaa20bc3e3e7d6a33209c53a972b45d2df4f7c3e1fe50015ab99a797c6b2f78d49b03d037492cb41b87de486a3a4f8e801f0ff1e8fd212b6018704bd952b6050974370b934f9dae32268c81c2813488b043d79386e9fb68536e2ad512ee82eef4711cc7a1bd0d9d74af1d57c26b616893700f2f89625ebd0e674fc1ce2e5c7b836fe87fa45d3d016b8c593f7be706b58a24d4fd09c22cfb37313c858f9ae8a70b56f19c519c2fdd0a89cdc209ea88b4aca01f95c2ab1abce68043310e4efbc25fc9f947ef2d81082bdf601ddb60887a620b5642ffb77cf18e40301b165226fe076f9386dd3c59d49938d7070fdcc65598f179c7f75aaa0296624f31d4c03042ce0fa0dd6e463651c5942f07162316e71c5954c1f58ea787a02da249b29561b36419c911aa5858ed380bfa18c67c73a7f1b5b0299ffe8798bd493430a60494561e90c11a46b382e1a4d2a1920ea72925d56744ce35567123fe1771099f1dfe6ddb1a7ae8bd37c9fa381ba19d954a70587ff3324d879ae3c1f01b75e9e30c9cb589d6fee56795005f811fdf03001e9cd070989640a52bd7c177b103f83b7f013283e23a848e054b63bcf923e1c84032d10318556963a0e8d3f41bc5e34aa89d7d57425fce8f3f6365b40ff829cd3b165746eec56d125b8fb9f203674f10b2f822c72f3adc8081b1e9b4aabb79feccf179bd75823b20eaec8f784d969744782dffaad47c83ab39ae51a2548b9dc1e81e72557f5607d40bd4dbee270dcbfd0c34e452e2639fbe23762910d51d72d895296c1b1186e1934dde699ca18c1bd83c92502849352af3f503a6181edc2fd56a74fceab041f2085e9a6f4a38ed6b954a09b433eadc94ad09e766eb079edced5fed5cc580ea9c09c65fb4a8f1491c996b6b46cd2b1fc0c2d1f08aa719d4ed0365eaf7005b8dbf94cce773519470b2f9482060a78bebca5679d0c31b4d97d3733de758ca80199495c68ffd72e415b6578faaf17c4f0d2be12c69bf8b3a02ce86ae324bfab5167249b344d6dc82bc03d7f5a7192e0ab3944343239a5f0611616d63a7ff142fb01ff3ac5337e0d2850686b3a0788a34ccbc0acf5c0f0623736639bf0468f2bb2b422db74d7582278a86b82bfe9828ad543a4d5c0a704133306d6ca6fb01f5f44678dcf12d0f7d3d77afb224ff20a24b9b1d66ce42b8a1aae9f735f67c0f47825d19449b4e0d12128ea8a6bed2eb60fe501a787fdcbf9fb61e746aae2a7c86729c3b680b9d65f66c857cbcace9fe57cf2a3991a24659c35bdb513ead6460d8a7e1b6aa3db0f3960ceafee1353406377b9f9c77b0579bdbd708030fc200803cf4065acc7f7d17496bfc3a077881707c721353691b7a0e6eb856a144f30b88bb6dfb32cea425e9c63b8b854bee4c82b56d2274f5dc25b257df6c7a90570371d781e17cf2aa4141c7bf88f90ca77be8ed86f432d142017bff9d106a92d9b56eddb73251b32a9ec4728486e94c985f55a320e5ce458be2099366c3a3d90f8ecc6ed873ce582bba2828dd2ed7759f5d3e7ebc2d6e1c53d361717122716d19646dd8936ad637792d2f4f094deccc44fbe3c4b935f02bbc564d10aec876b398f4ad4497adba67660c910bee185ca5879c2a6c53591c194520d95b19314fa96943ad5be8fdf2115219b6dd5f43b8432f513bf5f2be2d5582658429e7e90c15467eb92ed62ffae48b906dfb53ea2e8e13ce844dc9bda6285af6321c77082ca9bb966cdae497a80da8d0ab8681b7aded404d128a502c1a5709adf3cb15dcdea90dd43d578e85ce5805c8a152bfcd9b027698149a3560c24ef035df8ea634168c7f2bba9ea33828801c565055294d8e60e8746fe789e1527071c6dc0417ff2cdc8f7f3178dbf0bc28caf0508e5fe7dccdf03c40eae6efabfea55abdf5edfdbd05237d670b8e61f6d6020e6307e1b4aefa8c84bf6a16570c518e015cb5b5a9f9725205bfd1104cdf8113d5188fc3e6b55673580229579408450e3fb16fb6e10aa2bd051eeef0bc493ab91ec2c9fc70eedbf71d43f1e496dd594c44f7b710b3dda35318fe54399b5cbc5d8bfe317cf45c18a6889b88e07a2c3d1a1e4509377276028f65b0b0e2226625d716ea384b88e07bd9282a8466a1b564ceae765525bd5d332ee337481402ef4f0799695cf4739d7a8beb5f2472163c17c25ed165146d16aa3e568de5c9be0f435bcf137ad9352a825d926f7fbaef870f934aceb1bfee202a5f41b6817641b4e8684df37b07c86dde703981f88aebaeebe346d005778e0655634d0c9b13dabc238460dff7ef811b17b06032a7801feead323bcdfcc25bff33240847f0d6e204e2fb1912c7014a4ff4be763c17843ca7575798a4b3d23ee1fdd9795fce364c40a2f0a9764d91ea0d23d5fa6ad1e12685314e45f13dab490e316bd8da0deeb8faa9c621af8be7b570dc84798bf5e1c7b897a6705d629febd12e5e970b331a7da7e09363fe6e0090f2deb45c31394609c452f943f0f9e97d3e140579b87749dd064701fed650eeb1d89f2fe3daea8055fd0b82271864857ead34c7f55a3a9bce99e660dbdf850321739282d8839fac670ec428e1873d03f0d76f23af872cc426a5a3e70a7f494eaa05a1c0fa552d1d6ac01f5fe1a55a1f7053cd2e58d1ff799b994ab85a621577464d16dc5342ba992a2eded00d431813c0c6c3d4cd07c517c30ddfe875aee0a848e9b7c062b0d79a6d7dadf1ebbb7d819c2c1f1c56a418356bda49a769f02d910603889a8077d74560d7bd6dc96314780636012c062cc1da499afa640c7910a13ea796bac867f6a15cab840f1b1fa6acde126a042f2b0d00fa0dcdd49f49685db1837df2340a0f427b60fbee1fb70055f4287b9cea6b6c0c227960d8c17b8ad339d6588bede6f0ae688b1c749ebde9f2377be2d12e87d15e906ce843a7bcdd0d89726a66a5adbc24286b98c2c1868bd2c24f2075a1655ec8544deb6964be69d6742874acc9b662ecb44747deb2aa272ce9ab86a6c9707ad1f0a752553a55c11c56486e19dd248fe0861c5e896966416d71064dcda2ae14bd97c90649305ad733b2477a3ba7e505bfa94c8723ee4dc3f35b8c9fa8324ff99b9c21b27c37b3c8f0cc2a1b1ee6eeb0ddc946b26734fed67518a4ce38eefb6e45f2b798361a9eb97224717620054fb66fc2956562451de6db15de724628f0eaa22a0b06ad1e82a5c079bbd655f3d5adb2feec5525f4e6ba5810161308848d9ea0861e63c28e6cc270a665ab8156d64ec64f91bddf14c686ebe0f94476bb73761a8bcf6ab815263521c3445ef0c01a6fb33e2f55a41baaded6c222c2acc026655298ac6361643873a21699613195bab0a88ea30e52b30bf34402971c9eedf314eac2a5582fb2957fbf61bc99170243bb4678c9273570f8eba6aacf1922a3758d5c30b60e15ad936152b16cdc4c54731d5098946f7d134436ab5c034702670df081893965221bab1c38496551a93b788c43ac077562911b0c86a42cbc06773cd55e0fb01e1bf171a28d85605ffed1c20c9c255d898b345f25bff5191b9020e0ae428a89254c52ae9d0722be8f68bbd87262c2cfaca890e095e64c62bd832beb9cdf2d6c469e8ec25efb08c8cf00826ec98ce08fed4cebbde5d1343aeeaa1d0a12fa0136c73058c25eccacca356565c7c4671d69120536276a61362eaa6a5ed734856d7ff54c7f4c43323c602a585f65b96881882441651fd092c7d6b11bc542fb31acf1cd78b1d61098eb1f4162f9c3c2ab89b32bfa780e7850c5394b925fa174c23c77115afcd7bf72aece1a379fd3d8636e3d9eff851a837f675a233c69beb7d420fe5f4d7f0265c59a9cbae588be511d23fd19e60a890e45a62f8e88a28246e01f42921827344f516e05b95e5b2364628618f08030e61dd887b2cd2d56ab119881aa18e9ab05ee80e59d5195f0824691ce6e0e7efdf8d1f7ff50fd0b8e6d91884c951ab30eeabaf3c2a13a07a7fc4d23f4c1e48ab9b69dfc6099734f8305b5a0e122ff02112f7123e2d7729778c054fc7a6a83bfd8a627abf1ef973587b1fa4c04b3c41d93b6c38c10699035636b99e726df82e27c01fd93b66f11f66a02bd0c4ccaaddac6b4bfd83d85b2098d3e1328ffa899d1893adc647c2638357edee1a404f2b4a9aecbd5f2c8fbbc34e88fb3238592118af42631659d80dbac1155e35f7566bc1babce8d07dca1140d835109296d61d4c031d9dfad68d2cdac2b02afff4e02e19fcaa5183ab990857bfd880e71135c49ae01594d22240efc70aa852c88db81ae8299a99f3f341195a8e48eb2dce893f061eba64afb25e739040ef13bec3f769d4de902031fd9e6b291a42d9b8a23cc6880a3446ca5ab41a02372e15fd41151b1dff68b7156af8228a8b65756d40dd76b8fed3910298927647327a1fb172fd6111a80c35835b68f69e7a7fe6bdea5731483a5511053b80818f275aadd4bef73fd84e18e9dc6f5e33a78650ba975f8922b2e76397ec867fc89710e26e659aafad7697ec533e6bca84247c1a973e33b4f67c95322df4fcdad09705e59e0c9f8bfe5e9a93a624ab1219e0c2453225b2c232c156e9a4026139e641ca862441a70dfa345668b622025acde88acd5c11b401ade146c52ba17bd3105bf6862c399a18210652cfced56bb008c0a9279f70bdb2a06e2248d5a3797cf425c610475836b67ef7eb9c7ae6367a6341e9f7cbaa4acb10d90d73d2c884496be475636c1d0c592c093ab06aef71c1d41885b79b29d6398386672bd69a73165a84a6e515f3a2951c767f65bb10bcafdb729c6f335625ab19dde7f28bbc599526b6387d11f0d732835f2c394b36953b8b030eb7c4d5a56db742cad66f502208097019cbc7dbfba5f5f58464eb04822e412d59005df6f4ae6669283bda645096536008eda936d28b4494c7e39dd2b9cccfd45bbefeb42801eeb21a9e3ee0ce866cef39a91aacd543cfa67211298de936d35d736f49583bc3b89234edcd10d3d9ce564fe5885b3867378b194293b05a506913ed1588d24f969dac4582122632084d5b367378d4be6479ce73c11a08981c5997b5cb44f32c1a1fde2dd5236160b6739662c83df06f6561bfb7638a658a9be1ff5f78a54881766e3b7066b3bf012410e977f8f932e8a6555e494b2e8ac75fbccc949964d5939861ad02563bc6d9a5ab0a8243a9e1c09a39385cffc5a0ce25a7594f94edc9087ff30a56128a066f4af3cf81d46c48be90fc842736c65cb24d6788fce5932abbe681243be5bba5629dae761c60efa28b253de07d3d1bf3d7146c4f96f1001d04ead8054ed5a3a2b07c5ac99d92012c52e75855c60630bed0ccf870a512b923e88aaa2ae302714b6aba41f9b722dd60478eee1189af19c9a48584808c59c5a549f44aadd69e9860f2dcb83fd4760278a10f9865136b6510c83797a51c6fb74d3a3de955d4af703cc384d49981b77db12e21e11e65aeb28a7fa560f4e17bd019809d735f10a6a2444d991c04123ac8189d74ccfc23983c20769de21dfd787ecdba805d9dba1feb4daa3c173eebea882b6ef9bc6ba2f7cb4294b0e3c626c5efe38d7b7470ae2b27e70601f2779153278582c3c3c43c99471a699743c2ec385b27951fd674c7514af06fb354d9ef2fac7dcc46b21ebe983a28df7b93c6156ba08e66221af7d6dffbb62a4e9665af6523038f75a6b03da6f3c8aa13b876bcd9a5538a3c072ced15fcd7a2fe7000c5de254766ac2ff13ea72fba562557bf3b9bf4051593187f7440ef12f9f7ab07063feda7e54fe949c0cf6da3558c2eb052a8378ab9a8b73d86fa6664bf0934bbdb6b249856d873392a1cfd07ed3599a9e157aed779a17d5acb4776fe60096e27f57997b91228858b6c5bbf237df0a60700c949095a48edfef47a6d86957bbaea6581e8f9ad8ce6bb4dea37f81fb1349b79956e43406e4d07e77a773f0b141b19cd205b0f5053b0c803ca551c8de4e7b9fc8d7c1bef52273bbf3b74b320ec36d7d96fa46b26b865464bae7e01c190433774e118ee7892d396f58aa3860788a93ef3006d3ff35b12a2b1b082eabbcfec2392252c365c1f2b2fb4188b500606a92940881e9badb466a36dfb4da47fd96de98dddd084b38e374055094077a7f80c3e2aa6c6d7922eeac547235f333cbb45611c0ecae0bac2682cfbbd91aaed14f0902971b65f36ee1d9dbdc30ef4c8cfdef13c0825c0fb01f0328b17e6d668f463b326c87b75de8e862a79ca6ec6b4b779d6ab6dee11856a5a076c1af6963da01eba25ffcef178af792007aec60197e2bd21e05a3e36c52505bc73cc86c816007e5fbcc2debe37c2b45ea501f439118ca61914b1f175ce8f7ee00ff983c496a2d2c4f38b03bd23c8893e45f0f603fa63eaedbeb880efddd862fb8d9549e68efb958885c57fd4440dcbd5e0fd8ddde28e86897fc2084cbcb0996d98a7655d5caf32c23719fa146bc3b5f4d02ce03dd1e652f200c222e7c371079773fee995d3609bd7add613c959688864cc77ab514d8d2623e26b3f7df9228c515b1a0f1a99db3dad5309956d284a2cf976d04483e58ba69c59c32ef4553bf244d1e513ef92b66de03e6b080ced397e97ba0f9f503890c91c8c5277841b193644f86a623abd52d4a1c1307ec0c5048c154bc435ac6f89f39d32480aba63650b720f9be7561a6d6cd2a6ad0825f3583005383a3fb36b27fc320c179a1a3833b985063c8c96f41554f12445719d27d16d16e751cb1bbdde85b0b7d69245609f7d1280b9b5e0450181ab7f5f8876eb33f7805ca96b4490ceeca81e9fffc6abb01ab042c3436659289cc10ffb14ff8e4ab1911a3572e218a4b5d9270b9364db69267cb3c17d125775c9ec28a95811308ea793f38a834313456f313a77753eaedd8863bef8b340d17de33223a63fff5e9c69baf8a0f68f2faf44f52a46b4a4f49cc6f03977255b7ce4dfca12d3421a93a6c80696db8e9fddcffe34af4de6e2ef898051cb940a861819c483020904d6b6dc63a3f21618d9fc382a832209a7671cb3b345abf90966982c1716b8176237ba4f35c492201235560431ffbd27cf699941bf11979daa860c46431f078e4048e646bb06a2d246cbfde14f95d902b2042eb4a54c6d5b34cff7b2d3e8d2fc854dc3dd6e9c52de80ea646f73839c555c50ec1e29ccdb3807224e8c5dd22bd6ecfa78453f9b2c98ff23a5743bb1e0a97d5695dff8f1a095a23531e09dd39b3652e873a7ffe62b198e056de2de817ee607e90aac11f5af8498bba98d11ea67c077f5e229ae51143a818968e5d5f73ee0c9ac2b9abf26aa07b31ddfc7fcf8a24c1b60029c3e7cf4f8799cefadc5a9c09a03b8f72112e9c6c6a9a405460995f3b1e453eae54b0b9190f5ad4f867fd8a9756bec9ce2cb9e33820206baa1c9fc9b596ea22232ce15e90235435db884a7f28dba9548525bd990771de12ca6c7cbebf09869e1995cddf7dc8519a0c99b98de8c3ad2f34cab72c33ad9017ef2dddafb265d20e13fbf68fd92741e4cfe311db62923eae7dfe5cd06c1e01386a78655e7aa5dde1f550723a06fe63f6b367f596a1e2f0fb4b61c3147a0b20be7c8ea0010e135b279e48d59a09b430a3fd6081e0e723d864351f7fddadb41bf77635e649397b76ff66bdb2751f61251ef921354045941d0b7fd509085b6764e5e0c055464f0bf00db61baff9d9fffbc0b9d5d46a51e58f2e29a5773cca6ec9e8468406e267588a463e9a90dba0528cc169e766d9f611f4e5e52f066155ff601406bf860fe0c97c6d1ef9ab1445431c6e289342c38eb56bcf465fe28f71abd165258e83c986c92df103696ebaf6d00122a30963b4a9285c451d408465a469574e1b4fe3f0915cd60630b6fdea880fdf4b30554fb5b5eccefbb8a15d3875ec7782572bf3a97128f1e310a970eba1268fb2ae1f78e748cd5e7049b6e035fafe75024028bdf8c480426bd80c0225d13f1671ab8d59a307ac2c24ef2ea9eba42cb2ccc2db72d3f8471bde3761f8237af1e8a5b3b9f5113aaae5e345b06b6e88489e701b764603d0b60216975139c5069100c8e512ce90b16710b10bad7e080292413972d66be72c7da2bd60d92d6eb18aea93445dd3292ee7d8578aff14806533acc39474003361a8bdb3670b7e118a7a2f489a2add19688949cd71fbba5b3a9583184dbe52ed0e29d9c36eccd12cb7a45b5d4ec9f88a2587b573eca847b109aeccae2332b366a584db87b6e05bd49957ff132db2ae375acebd8bb7c2cf10c616831d5ab3a086e39db4eeceae11af1885e2c795ee7e138a773e1ab532930e2124a024820633408775e60878732f6ae815bdfdaa96527c3bfa11bcf6c656d2ed5015b3f5e5d35ddffd01f40695180919cf59da0c18f750c348536da28320eba5ea6a7b5d81bb3748e3c9782772d425143f4b394cf981bb2c099aecdd41a57f7ef5c681ce27e3f2ac428ff91167ed1532149b4134413abe73c0869edb7f330a12bd6d6e1e86bd1fb6833e42f6237147ef812a5052db364feb026af4210e341cb12b86828025924abb818256835b8734b6150a77636e08d23d4eaf8251f261e4426623164c8f20f6186871e8fb3a54989c51bef8150bf6f110dbaf3a43793fe7fe6a63d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
