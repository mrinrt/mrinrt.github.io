<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c55aa9f292ef2e20245819347dff1c68a33e0838f70f71f57ceb2ffb2380956f160d858dade4c9e88df8269c8aa71b4fb2997b930b1291407da81bed3606a76037985065b82436688d846ef362b2d97c22c4da7b1696b0e39403ca046d46be4be173203fd14f143402dc4e7e49cde5b0329d9190102c440de2c7d6e25283c802d231a3a1bd61bb4c65439d34212a2356a0f82017650231c4592d0cb45a9d961135a958e5149040ee211d3e73727e4ca0a5a29bca517141010502fe308e701da234e295e633d53f44af61c44cfe4f21b3b07e10cc7642f4713907a52d3f73ab2c24630b02441f966222c51e513a582e565451d6fad8947c35108e1e216b37d88ec0fb2f7bf97b257e5415d0a62ea39691004d8d061feeac3bbeb5566d2c65d312acce9dced0b2183f888cfd95a5cd5fa3aa3506933c5b87be6ce4be0e7977bad969b44fd4aa45ce6d4ac3dd5e9fc0d02f61844b55760c8bed60abbfa1141fd095ad01a6f5958e7d14626a48425f34f7914ba0803f4fe8848300c18be971dad5683c6f7292aa95ff5ea74564b2086297cf18056e6d0cf284a9521d1b2410bdca2c15be287daa997819c242a06a22303cc8fd0836f5e998627fdb346f32017d325378991dcf2038d6c06674092d94c7ca6d6b4b2b57aabc85184dc523c75fd092b8a38c6aa4d996a6784b8ccf96d0a237aa3f04a77535610e820e2e9e93954ec793360871293dc70f86eaf8fa39ff492b0cc2e73ed924323a48f60fa601dafc2b95c151a08a7593cdd2484661bcc47ab9457705bc09e4a9f8a7349806879b31d52160719461aac4d41ebb742a20e4cc40b874fc3e0fefcb367d2dab305691269e88ad15efda410b08a31134c2d8bcec2aa6a673cac06e3d462baf08f23a5a89e5010da7a75e2229f4dab86aece28708f862ec5b9710218573dbb51868dba8732b8942e14dc11632d3939bec19dad0a58ec7bef6dcbfbbc2598bf99dedfe1248adabb64891a0caa75501b5a7189b4f8482c30c38f5432370516facabd369ffa0403acc5333e963e94ae099c67dc36787e6c0fb9617ef7a2cdefa58f7023fb68c5b1c4809e7ab20f355145c296626d6dd5f80f8884632c98dae4d174e902a63d168e60b0d589d910dba726180a5917c8a1ad47e15504847519db26b60d1a55cc9d647703d2afc4d9c4d75a99f08b27eeb1de0d06b830f1f500935a069ff48c110e5ed0c1b588b50a4546232ff05581494b40679aaf1708b5116b26002c49841c358f054d29fd86980a682c7423ed9e2b417ca7b8ef574f00cf6b4a5c8b8b27912c3127a6c7f3f1c264f72216076bdaa47dda205dbfeed824fecdb04e1b1475c37fbf1adf777a6167fa8c6b88fbebdda6387f0d0e88b38ac2bebbb13ba7035af7acc2484756576e25475cc04739f8bd88052617a891c0780285cf43947e02a727d81ea7651fc17d5bf3eba8474ed60984e04663838f1d5701634659a3acad8b478b9defd618ede356a5b428537de839508cd6e60c0c7297d0c068da60046fd9b7b1ee4e6831d06ee5046591579ca82eb87f19cace50f37f818db2008ea7d28ec43cdb54402bbd62ca1cfdebf96dc40874cf78e627caaa2d8c17c3e4ca7241baf6aa1519a8942d2101a88c4782693809b6d99de32ba64a0d692bba1b6243adba7fa35e7e44259c0525a3bbfc6e4546933291913f25fb82e5867bda6c5ea4bf7d8d61eae69e6718dc589873142ca2d7b6994a0e4767caa8df89ab9eb0daea49202f66d81067fc45c4532361e13b96cf66f0f859475f0848b28caa2f53343c221e27cf59266c7c031aca22559aab0413ca8a2a9fddcfcbd43bd6aefb37238a175171dc2e786408aab8a04e2f90d57c97c33bce613e84747dfe8030a22fb0be342e53733fd0db92f33630a9e80f3b82bae149370e1250be4e7356dda1604cff59d42c6ce2f9c5e604237701ce5c5b3a98e1d92a0490fcece50c74076b102980b6933b4bcd3cbba39f8e02ac30b04579939adc1733d7df521b960313a320027fad4b1849faa9b569a2fbd6b6aafb58f7c0271a3521e065980296f39a99e2ffdd3efdb3beb477a6bf3f39b7a85a4ee30cb6d56ece43214650ce9a0f1106b01fc13bb4562a6d8aa9df56a68e9d2df7b3f26a09e115ff4e18e4324b2dd0de8828153a36e60abe8a13062ddb9dda0c81a466e5e6cab762dab37bda9eb7c670ce73e940386619708266360810156e4b60cbff5af9eb32e07cc7adb81b923e0c2d827e65fad7bb793c65400cd9dfff19af2b99749ea5b8a6cfc3f2e9721381de7b91c6aadfa2840a72001ca94578a06d60c42418ec2d8d45609d6a86d6750b42c1ed2af76b94441ca0ae65a62416d5f366c36221f7b8e9cdd90f05197946abbba52dbe70c979c560018b013eaa5576fdfb534ea4123f3388cf240deab042be71407de4faaa710cf9f6863544414d8705213e0734e3c146df17d4d9b7009e0b0f25d9cccc024e48c959fbf1769c4f5e62589ecc36bfc1f818d5a7edbccb1409002055bb28c3b00e4c338dce0758587a57009c238d133e0653cec7030c96b8bb69ec3327d082719b25717c1e746fd5d674960c446d1c3d468662d84864afec3a1becb74c4e89f32d3487b1fd46712492799b6ba60bb563ef88d1feaa2eddbd80f3285af4043a6c4463e4966832671f65104b8316b2351360b63b41a627e95b9df4b9e5bda68517033b4dcf3396778d97712545f32c6914f1882a335fb0abc75e6ffe16f3bda93e2a96d9c9574d4cc3f4f2e0efaea0162f48fb7112bcf8c88a46e96c5d4aa83587a12fc03697389240c3a11c174ba7d08351fa11102fd162cbee901719bebc655b7a046f4ed236ae9223faaa34de8f90ca1e042b1d88e3664503bbea0149458e1a14e8c76c056d9ac4e4ff22220eeb75f5b89c21ad6c69cf9746f3fe5ccbbd815d4fe5b6af83da86aa03773f0abd240f15b04ba49b21a7d9b4d8c2455f0c81ee670ff140afc817f2ac6f8e8d11d391841d339a17a129ed82befb6d618b92f2a5885832cd08290cca4f500a139f7fed96f6d0d812babf147c637a85a8afa4ab0c4867e999f5be600943242a9dce63b2ad30712bdbefc31eabbbb9fedbba266efb62fd88f61a5b9d09a304be52530712969ff106acae1ee16e6295d3e62785c943a9eea2409e00ca47ed53f12841752cbdbc1e1af5eee7603b387d94e60d1a74d50fefa399f1fe5ff56cfc86018e86228fe60f5d42827d3e459859311e5e80190a8d8c2cac24176023b95f4d1a9b8a379fda2eea9edffc8e847a245ad64b50d21a577b1dcdc0162be1a1633d978d75c3832eb1ca90216da399548d66c56e1c9a50c35534f6a7bcbd5ccd49c012c0b8967ff7f7f7f9624219936bc338d9b08fbd3d71899d9580321f4038b235a2e05ce1819640282d3ddb07120449c4841a2a5fa18a7303c440c7d961f027a90e57e5ed6c5a0f165f741581019090f6f39f8707c21fab6c38ac0bdabd58d69ba51ced69b8d9126a3e65bd0e1f9457d4e149372a7a9003e0b4856777fa5d5f859ba8d1ebdf93387bc4e3211224e2abd99d128291c461f21595ddf562bc1223bdff47f32925125ed6ff770b05301648fd27773d161278d2de970abae5bbaaea01d37422c29f328e9b2dacc496ca058cc3d1400bfbc79cfe3c97384dc9aea5b621bc0ebb605f52751250f00cda0f51c57dec65804cc3fab43af88d6aef10045ae73a94cda59b6351c4250ecf42806292587dd8a6fd2a7519adc92a2500a5707cd13df67074e742fa2562211917ce3018b50a3f38d9cd43b10c58f2633a78af843128d54c3f02413e0b75d9e38f4b72f52e76b6e574b436cb57d1bf1acd22294873ff07dea300480866034365c87133197195f2d2e6b0ca355eb28d6cc197c5d34df19a2c5a0d79f8e36817b337608d4f849f39591166292020f9ce0c11c55b94cce47f40540e9ad128252cd63ea04e78e874d1feef68ab3ecb25bb35ca28e88940cc3c7b95ee573d9b7b0e2ac23c9c8553e9b5efac54235eda1f4b38843cb19c576efd7025d254145f640d53ca2adcf6d33f0112806f57d5cfe4208e7038314588daf88d308c65b4cb749c056ae19ca3956badf31e6573edcd87f86d42e51d948282e6c4cce6fa5b3b1a449e6b92902d64be6c2e5584c9e8b71fb607267821af8fe0cca9939712790f1dbfbe0641f512374746dae34ef653f8d2179713bacd3cc50a2d886e3a8b585ff07f459427b98c0dd120aef170241012c41901310816f34b53288dc65f84907694723e71cdc4735248aecfdedc30dfb3bee1e09d229f808f6798367d6cf2a5a4703f9947d0ae3dd9bdb736955c6866d90c7dbfa7be7059d66f45d4d5c55166d646dcd31c0d1b1f2a383d8649f3495c36ebc2e5657753974e7ef5152b8c4e4d7f56e2a7be0aab530d6a5f1245873258744a1515d57aad6590b8b43fd9c37ac21ee09cdd631f8349af00201939e77d1e0d5d8c09e64529b3aa0a75d16cf02d79ae1b9729993073b7d38637f1db87975de7d007fef8c22ba1dae2ffb50ab257466c00dfabbaa6d3671296f61c6b37d9b666bc9b880ad22e2ad0ca9abac0d906936198eb1e7ede228bb1ead5e763584eebcfa4a15a6253ea60e326eae1682ca61014efdc785dbd0ff1510d4a8d22f3c59d56bcac67f4f80953e9a853635ee54e634123d2066b62abc96c08f9828fe159dc86fdde60a891cf031a23e127c51e91d290b779984fe482b91d007a6c477f3b52c3b533f31bcaf49e9bcb35c2929c07b28bdf1b23b21e823bd5b8afa505bd979349e6385c846b1e6b29688f25c0acea716f20dd076219a729a90b35f50110997686b6033a0397d648ef0b028b0175d30869c35cd2ca510872eac6d305cd52e4dd6e4428f97a73284b89d249b08bdaa635213029df4bba2c84928965ed564d87785945d30e5cba6920c145d7969af2428925bcd738b53f1616356e24ee00995153d417eb6ea437c1e12a920f45b6561948f2f327625cc2b6f50d36e8691c000c97221870300df05dc48247b19d243b3caddb2c8d2f18f3c29db49451c0b0b87c4456ce1cf76ffdb21127543d3ccde931863c8f8d5ab71497ad6f8c6f3c5cf40dccfba1af80ee207af56ca8a7e2ce847841cfce178c042eaec4007611e3140bb08d2798551ff143d3f0681230824b2769d2b081882be38a7c84bb8379e38ce5405099c673b6199c52ff2ad8a608f612acdf377d541f1fe5022b32cacca9e552f08b4de18f552d3a59000a7add6f02995d5277b2d1a09daae6092286ae85c09f21477a401d9057bd9e373fea186429cf289f5eac85a1b0f04500608ba955dd7d2ca4c9f9bd239928f60a31eb7473b0853be1c5ccb25f74d53894ef6fef8daec5782c29574bc99561a05a12a5b8999b511b506dc7aa29ee6e5ec3eff28d71e974511ec54868710465953167b551270a53c1a3ac31e14f616a0bb17b1845b7c1dca282ff868b178adc284652156c5700c8979143e71b8110cc4697e89350f67b9b307361eb8f2397770ea2f707808c2afaec5fa6f7dc760af26f8ed599b529c72ae7270919de309c89ffe184ea73d2150dae480558eb3fa23b7f0911ec564f0a654ffc81f23a3e74e199bd369a517a4bbded5ea450607905a4c9f5ab53d34328b72a2c33889f976d95c1bde72b92603ba27373e78fde49a76fe49e8151a723293c9c8ff2fbdecb18ca2a7dd3a2acfa21ce9419a3fb6603ac913dc87ae27bfe50704a263d97240a8350b3eccaa0abef064154256eefde657e425cb0e73f698ce0a1294b2ce3bb6a87f28881e094adba4d9eb90d7a3b8e87c3bb37c71d8850a1d755e465353562013aacd1f7224bafee41ab48c385b520d212fef1b672c61536c60afbdd74c56652943c2317d180b306099ad8890bd75c45b11ee6c3acbfa8610359cf02b7634388b9d961370fdd2a0c9faa74a1a50082eeefa388b93bae92bde34ee04ac21168e8772e9779e4e13e52368db22128b1995a31812211bae7669617a621f2c1c4c5e17386b09b3a67a5d5ce8ff231b9907141eacff6c6a080339fb7ee1aeb1978837b9ab24f64ad8003e4e400dfabded620f3691e97cb302b45425a59025d9c59d787fa2c79b7d203eeed1143f572d9271d0c6b25f80d91e6cf3535ceaf8a476e7adc37e9e57263761f1202d3eae571d20b56bd2ee015134c6690b202f082788002fc6b5f2744d556dd048d640ad2754718aa8517addf47e710e61f094910bfa03c5f7bbd60b70972f52b2ed7fc7e5fcfbc0bb914d7a49505ffef71dda0966fa8611f80dcab0b8ae5f343e6b87486177274e61140084fd70d284afb40280c804d8c92067d6cb569769ce718e95951cb894dbf305fef3f7c8f409f8bd86e2a8dbbadeae72c972b0542c2377e22c23b3d3a282d3d7303deb301c8b7a093ee6e947e8fd447386efb567b1e7eb7e6e091adf22c67c9de98e02a59d33eff349063b7fa2529e251ded544ff9d0f98d1d32295a499c921a7582350e5880709b1542315c951fe46dc8e0c1cb72a2d3acaf15a2cf20ed65365fd6fa8d42b07279c299e909c014445e4361e10ea192f52b6f650fccf9afc0533b315e92fdacae1ec9682c37e43972ba6745b9551a30356e42115b0aed35a44974d7c5e17ba4206e7c245e5f40cbf0f6e9f0798b6aa90551fb18458e549db79ae5ae788db434b88fb7f0c8174d959ac1b41ca836b80ceea39efcfbe8324c3d3150d4c88d0e0e4cd56420360a0e205f6086093aa57d078fbdda687f9d7c6d86adda8802a33b41062c6be4ad11286d4cd44300ae1adde7bbc3cae50303b747ccdef67c416d16d177d49b0b3c83249faee80746e29cf60a0cf3d0c39ce56d0c6c0466d6066f2aa906094f06255158534533d547459bd4a79acc689e12d720b16d5456935fce8667694ff43a4163","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
