<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55a07bbc745dc71e057b7c72d3e5b666255a18e808971e0e2645bbe49606fccb6b59313c859177d81490e693650ab19d307c1da23b5667d1ebfe5b6df1e5bae991c55197e776bbc0af162e8e1fc792a6f3abef4e7172def2c5fd6aa50dee496b4fbcb352f4f3a37f60e18cce912367e01fa49c72f51e02f91afc48595931439d51a63fa417ae3aa77a37d196e7d41a3a9614746f0fb9a3979c9095fcdc21395a3dd7c24f1c50c5c66be95ef1d6eba4c0752c1b4ad440b5f6e199502fed3ee65f0115c2718df0fa8718b76d10d638c913e460a06aab8dbf2927dd07008ceb03e64cb44b6c5ef1acf0ef2c6b429ef169f11b4459e8983bb8b536fe9ed5615e02f33f6b9b21ba6aac2f0390d379029f34afb131e24fffa7a09b1a5f295a4b69a428c18009db688cb6cfd1d6f26974f58154fb050db2ad83754aa155aadcb517897b47c349a360d7824d649e4af926c098c15c677560bfa25ad5a1d5ff8b6408a5f5b1d8294c62f2012d4badc9df40a225a69dfea285b994d919db4ab3a066d1090017158fbe866c748be5a88f1e70f64af1ed8148d038559cb3e56cc59e20f38d875fb775dcd06902e47d5169bac1cdb7784c35597cddd6bf7a251bbd5b940f3ce163d15dcf9d34b5ebd0fdd30544ad43f2feaa1fd180f089bd494d0de9d62171e918cce7dab76b46c4cbb4cda2f564c6b80d867cc65d91abc181503d0c5b04796d2c9d3b59793382fd369a706d57e2c429df60165b92e1f774dfe9751c37cf94fc3b68e0392aa78e320cdd8b571926f2ccef1eb787956e88e14ff1d4f654008a8252e548b2ce8f8fcbf1ead43c99f6725aba79b414db239281cd9f26fab9e37ef679822b8ef70fae44bc00b9b795ea6690df939a44c957ff1d95106672392c00fa27583e1533307d2505c2de11672591bcf504b7c7cc209d83b6beb3eec3f2ad7ce53a278b81a932c6965659b722d77d0da6729e319338d98fa8133bcaff79b7ecc959952021074c98bf19e31f4bac8e1649112a6b5260e5b13b9b8019715cf57c9a7baba1bb7086e68f8861cd0ef632a48d24cfb88a9b29266939649ae646b5e71498783ce81faeb7c0220b58189a08cd54878642c8a66e9ae804e2c3279c0978bde13636d169e95a5d8d9d6e936ef96ea3c0be1512c749803039b2fbb32d4fc5ae67cd3b6bc2dbbdb6086e9e21eaced60deac79d8a50960e75c0548fc285e90df0f4dbf19f3ccc755c99fb337093d895223e6d654740350d75fa5833c549f46ff3ec418bf0e23a23e11c4203ade47cc92f73e90fae509cc723424d26fc99890c6a7166cf6e6eda04559127291c6a5a0cfd452f4d9436e4740b4687e14e6cb08efeb698994e95c9439221fee82d186574bc74b4eb43db4c98498ed412789a329cc8e12c68d01d2a4522881ba1676abebcbaebe32d108f4ce4f0a4e3f89d50c73c7d1c06761d0153410e0a39b2184a95c61f9fa7808fe2143555084f6262d0c02aceb3cd18d9ff923deb02d6744334e9b4f56ae2fe4e5040c24b4ee3a2d76e8e1bb49e39c6f2781bb9499d3ffca21dc8bc5ec4ebddca4d46b8e6a224fdac629df4e3a2002722a48cc90835943ecfe4ee111b0f28cdd22ee3c1c23477fb9e5a34ae6694b9df6ba8bf654ead71003882f2f242758f2534bc01ebca73d6dddf9dae78bf4d4e172ea9479d28ba8508128bd500710d5b0f99c88f800655580454953ae3572c17b52154d08bab130b73b79fe9b6e33e9c6eb35198041066472ba2021e000e5da5a2ae4a531c10cc094caee89945dd876454b43e03645db17ccfd009a56dabd6fb8e0d25543820a7fb1f7fac14ad171467b8a6d3c4d831751c9e95c4cd46bc54af91d6cd73008bd4b142e06ba4e11f63b7a20fc3815fb3597b57cdc827d1a686e76f1491812c0af165798590b41935eb3777ab1f4004315379a5f79824c5ec90f0ab1a4f0082c9797aa0b56cdf0658231e7fcc1d97784da9892db982a242cdc15693e4f2b553baf3106234752358d8cfada93d0e1cf6dd0e08b43316cb2884be11fb7bb396d487b80541caf96b7b5dc4dc3ac3dd0f86b4f7ea9671baafe91378d4fac4e68fa4e5d3da5b32cbfd1af5d0c754f1d5f01515916c6a4d1dec68b441a16613a067bdf209a66d2c140ee11a25b9d11f23fa665126c0a33726b665bca664a9cecf14a576a1a176b9a0e454e1a8d969e058df2b4a8528d8748e05b7ab4e6b403a657a2e373756545f2290a151cf94973a9228f5d37fd497697649efc0f5c3d6804a91e389ca8c87c610d30204483116f7f526f29ef4844677042e8ccef27dd34a5d377cca644d767b52d59a4d1fab284ed2a92ded7e0195a3d3a6b2327424b519ae87330eee78ddb5bafb66c90752fec8820efe2cfe6ab84f16ab53f5826fc20965b3549ec1711fe70da3036b3b4d6c08475bab2244219f05f95ccff8d735e74bd033f91f2a050f87c1b1bab4b692c6187abc950bce17a072e7465f97046761bc8363f895bc623ccf1a7cbc137f246621258176681b8d0946e67edba9a8902e375a20d571b437bcb5ba5149b2517c5d2fd21737b5263d781d8dcb2ce78e9bf4afac6db9f2180b418c889f7f9cc07718c738be15e2c89cac3b29e909a2559fd35ead418f943fd4607643155ca4c2ef1c318cf6e3d7619f1558349416f9614b3b2fef7358ea2227b818a3d955131ba2e6d5678d79c904a313a88cc10ae87cb5f2eca7d25a1959109e5f4a54d84879635d615fa1ea3e137d502d16e4bd7fdec3f2f976e5d4f9eaa2336ef25d60cf3db441c3bfb6b75c1ce09e5d5c50de26eb26534509d0a70f37e7eede8c67b398ff440f2dc32add3b857ffb5cb9f10b187e71983be0f42046e0ee7bea30c2733cfafdc9d4cff050930b9084bc1633b6c5db7106fb5aa95c266bfd0acc3b7e480aaebba717dd9ce669212b8789539fb3fd3025c97a1fd810897b53c46c686528ed7c2ad5519745cff4614f5a534ef54e9735e224d9b09133aef0c2763702f3da81c3b879e26310d148a0941429d2e37d203cd58588297502befabe4f46c2281186d90908aae913886a5804271f01c12ecb15b62575cef9abf9513c2dd9cf53d70889a2ac1cea5b99d52db118f778e1d30d9c83417a6f31d30ebf08cfef14890e88d5e704bcbd19ffa4b1d9ee2a634c9d093a32ca560c8d3c2bea9a599e81eeeca9db5f1d71e9e08b7c611559483a0cdcbd730a739e42e9685bcc274a47fc77ec585ccad40a6894cdd0a54dffdcdb1a0ab7bf6acb5f253365a8cd6d3ca16efcf09298e44c84c9d0d49bbeb2168428cc086093fc557e7dc64c1f5a76aa35ce5e7dbade0245246534611459b413e48a495cddb1883d313556e79fbc4006088d2486ec0c4ddbb226159a3b739d6cf18b283bdf1522751c0d103128bf52ce6be1f24892905d4e97dee9f337b6765e3f91979d9fdc34d7e91d5be0b98a8be3ec690c1f077307aa2f83c2b947bc7bb9ffe695ebe08cc4001b0c48a028b69d9daa1dbdb21f45902f9859aa7e1258ba443a5327a960033c4b5f39ca665ae77f34bde74e7e7e0bd90d1b067c1f08847b48e95fd1df38e34327556257484e98eb83123fa18bc5072c6d4ba9b0757658dbc9f610062e091c513126b40891e75240e28161f610c310369e1b051f66bd6e1cbd8d724d3c449c32d3be2588e87d98d88ebcac755c7eba47c00ecfe553e5a5c9c3da91ec6e0bfa3f93c5f4177c12e1e3f55479ac660c8ca9fb1a5670e773ddc05ec8b154a72bc071d243a46ddf87f44a9f69a86bfd7a068e0f0160d88442362ab1d4e079f4524bbb332f92aa524cc9d3993f88e9a7f4c2de4da22d1b66b7185ab4b0fac6f4f642238100f683565335777042361261f8093f9e6f5556dd6b4f959f587d5c3a2e5ba38b083e64a0708788fab5b061bbbef0c546a576f2426d9fbc6a6bf0176256fa3c0d36490ef64a00e92ded1edae193945b2956c7fed02b0a327e6f1001da661113ef5cb55a3197c516e8f1f4a0a0f625bbca71fe47e75ecba81819b1ec1187970ae953ffe5721d1dbd619b967301e1af91aef45e2fa9beeffe104c16788ec62c047d35b29d1107f3d48ee53037fc731abad1a406c259fe38de6fc7505ff11a0837d0f05fde08a3c0baa20b39f53158c3b8165198e4b113e2b99a868c1fd6ef985b3b88577e0f145a07cfd8781929452e62f0ae0b8d57aefd47fa9e6eedad087eb2e69ec2d79803d089650b80c34b620035c68f2b99ffd30903d09a7554366eb616dc6ef94526ef1429996d967b47ce82ba9b67c0c3a3811b248f9d133cc82e8f6a6ff944eb413df855322b6d6ce98854d1d4c68add52400c74b6bf9e4109765f50d462a9a03c77a2044167da8da3275ba38cbcebfdc32c646b94ac8800f3891b63d1f89952f12c0eb06e5a138e8063a46f3049e38bf468f3d0dd11c9f821a04ecb34bcc27ceb22eaa026077acbd84c75512ab0c68d0616920f3d6ef72b75d0b5be4d7d0e89374de9c9a353300b1dd4f314926204cd422cc77c8ce29e358b9ac970d23c493712f0e918419f84222adaee0b380ead7bd383af8ce28ceba99ffe78d5d1e4dbe8117cf81c2e7ff8854dd3059126bdc16ab6267ba57732f6f473f0e31c1d255b8a455353eaddfc7c5be422e7da13d838e753db5bf474922213179bc521fdaa49b708af9d71b6b3ea45d4580ca53c884740c8816e1fdfeccae4a3adee30b32ee9ebc4a8bcedd2fb4e6168c92f1bbb1a3e88db83b932744020ae0c608075b981c0578c50132f481810327b4f46db434dcf206741f8537c51948c365f8a104a37c84b1d220e1a620957877d213748edad003d49e739799bd5a5e634167ed8b419b75ec99f3d256545884ee002d26daa556550deae286c0c5ce716ada4ec8b040ab5d679be8e4de181d5fadb3438c3d9bc01e2bdce9f8da61b5298c40e8853cb0b0c814065abe14ff2293cc0aa130c25e82b7f60413109b99c981aba72b6df97ac2cb720b8855b447a4fbd0e07d5d44d6f1529b972fa3fcba184ec8cf9e15063427a7b6d0547449961835dfc33477894f6a35d8f972d6e8255f0d5520a6e2381f7c535a023f650b826078e3b862e84e3134a4f20d413f968f638eb980955ac76616643c5dc2b4a64392ad56aafed811382014767f00a0ac7e28ab5d0d081febdde43ce4672c1a70b9c91deb59bd59d03a2a2a0b00de5a7fe4315810fd9901be663abf86363b41db78c58fb3503fc864893ad28a804bf94a4cc4db076061436aeb2a0fc7663303f419500b75c09f0b20976797a26dce517f444042318d8949703e1c6018eb11b6feb3f0032eee6a8599fd8e2f4550c3953e58bf18541ef153ff644e75ad641a07faf5c2a8835f5a17c59ef774f48e2300a1f230190c6f1d4270ac9395d323254900b8aa870af7d8c9fe563e1cedb80d4bfff3aecb367eb96017967f3610da823fdcecf5f6092d4dc2d3d9422656dbeb39055a0e5cd9ad06e5a828a4611a4f211463414792df863c627ef3c8254f153f1dc9f5b7ac0113ab5dd062578206cb601f04fdbe3682ad1894312840f8f67e3ca758dd1f95214ea42a7ae91fd8a5fda2dfc668fcafcd48d0de9ee030246c8b2f2732cdb40e0f193aeba1563f7f3c0cfd2e90dff3bdfeff1e838a7dbf495e78faf1be1b0969f1d717bb804fb3a2d210c2c5594f9e357fc54a45a503ce85f6676ad9b058f4310e599340c21640af400a25be16fc3b7fa0a11b15687b06fc70d4b59b2a1d0e67761581b62c448c834ad8e3bd695016c7e1b28aa676aa5d9dd36bcfea433412872bac30f61b8128cef647a8c972b9dc32db72c665ed5c56030b47f1039120c05780b4e1a3c6250fc5400a7477eaad4d326b38f3d117117b05ee8f75906ea96dd016faa62af5dab7e0846d51c30dcd535d2c0053e0d5d95e0a32c9a67a292bc09cc398fb9cfcf31455eb4fc58f85ea1d409d21bd57c30eedbbde3b8e53a2e37e22912eba1b8a52b1f21dba28f03d7445de4c0560d04dd147efdcdaa3a1b93f6062773c0f7727ff2bd49ccc85fe9a94ffd5c20c3f7565c0c10159c302bce1fa0c2fcd15671098aeafeddcf9b594234514caeb55e084d91ed63eda283a0ae870e57e695772fba93eb0db2086d62a274718c96f36de94d0963cfcf095e48911127cd69dfea047670dd81dc6661ea5e6eaca0488e419698afd4f26f2268578b51e37fffdd2cb4e375340fe0fd58cbed545510c13d5af1e678b0f73c10daa49a84ca5925132676bc37c4c2f8a05d0b3119f200ae15bfd03b1d94f1a7dd9df30eaf524b631356dccc4cbd6dc17a3b05f76e28ba62620116fdee7d7fa375b82187bcd20ca8b94102b20f7df316cb5be6626077bbb62db4cc1a6809849fe4e8a0d0848ceb802fd0d24026f9ef673c26249e7e9a69c1c085f555ccbc7b4436c1f3ded5dbb0465973f78574477b2b4506fb2ed1c23746d0d2b915b8d7fa2f8cc4db8e281dc827909ec549e47291a98c88f7feb4f2d48fb24bc746810f83a1b704144d1ad2ffc767c02f09c797d494dce78141ac325a1294e23b310d65db6cb10a8c82f46e6c24ed5989cae611cc5745e1a1f4a206407fedc5e0b3b5107a28fd04d6717680d9524b0c725409d1e7e768ee2834a8104d7335aebb729fbadb428c530a2adafd7cc2634129f0d25399025f8b618375c5185c0f23f4767adb84b24748d608fc532d4466fffaaf20c828484ee495ee9cce0455f9c0592d82be713db72bab7355e32a420a9b1a7d4afed40a4d02cbca208d9f1b1857c46edac836b8c0e5d0377c48a0311e5fec9480c093b83f55c0153a0a45cd8bf698d8fea8d9b0e47b4d5cf79012d7db8e900103a66b06f0e3a1235a82b3bd8fb10b88a9d8b108cdbc6217d8b1d644e14045c62a46f06bdf80059610c8526f73634cffbd16bff6c122e07e82dc6e5ddf13ae4039fb678cf0ecf11e83a7cb17759911ac4bb0c14ae44604d06bbee4acae2a136ffefe0170dcafbc032ba02654e9c5dd6697ec2bfcfd9f124222a48ae2607423a1f3a61dac83afa93a977694cc07287d0603053f3867c3782ab7a1fb63a18f1953e3ffe55445dc1d2d86cc2b41d4a320734de365bfa630fa5d97428eee995aec90c7e715d0285b8b31e0a0564cb3a1005f53d006220c681802efa3477549dc844f7614007652c80d6982bada06bada189a21768d184c8ad17b790c97db61b76044a74f60583c8ba242b478f5c9c92b2fc8c4fd19287bd0efa2fced6e98cb20689fb05de272eaebb871bff49a583468c1d7ccdba69b8850e870278f7ad410ffda1886382c6690e136db4a8840b3ea9001113f1742c1786e8342a574d01cf58f5f55d507f450aba5c940946fc27a7622f664e5f588575b4bc97cc3f2826a7788f9392139aad5bb8c083d842347527a8ef6014b73a2f4c12a50f74c2c6ce670a49be3290f743a7d5f9e2022fbf01da12c02b6aaf789107bdf0fd8fe0550a061343d6fe60dc940c274ec33811660e7f1b6d7042b5d7b029fd74113ee52e016a12a0790ac7c4a447222e594bf2934cc5921f40246c30a01f3b6f840a30c4ab03867a31c85077ae613c7208955fb86dc1e424bee1e955e4010e4b542b40a454d4701449d037783cadc0f3d778d37ed9dfd6e6177ef8d0560a2c878ccb73de7090b848a0a619bee7c04c6f1dd4cf6a656bb85042b37eede23b30e06fff98551e76fdac76862791717c20dce4221e952d6fb98973c5cafaa53786126c341974944ac65ed8558e1995fc0965da2e8fbce300b449f736e97e6cd22ea246b4c348801f1667cf351adbc819d79a8e0f0b44788448fbb1c8ef36340d2fd0bbf04cb7b10efa145a3bc37ada073fbafd7f91b9d1fb34e325cab94df6901dde48969f212b1c2fa42cc591e1d9f2d31f81cd2a10312c35cd6c73659b3fb1391f39d60fce6f11e47cc4d2947f0aa81542b09deaeaf82fe187ac5b72d69942ac414cbef8f9cc5d0793fda070826321292d00953cfa475c726eca4c29746c90823201d4b963e36f1b072d89e0c6a8e1200f770913bb88afa7cb3b5d50bac19815f640cefcca2701f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
