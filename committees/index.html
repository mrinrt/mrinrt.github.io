<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b7b663bf5f2b1586bc19dca71fc06d303c5a4289b57d68545f54bbecb805188a594a0fd22726b4533cc89035ec772932430fa259fa129bdc76e9308cfcd8d237dc5ef36c55955806d5ad412059e97b5f318ccb462142e5da8b99b7290772d67d5efedb0ccbda47e9f3f8d1e8cfeebb782af2f7bcc8d814b8c61e97d585ae9ab63746c5ca61ab6b943bb4cc637476150defd6876e771f72c9e448d8abdb04f363d62fb15ca7cda6b99ed9d969289cafb74c53cdcc3bb5335c9873f3daffc99ab6ec85975ff806b84848de9ddeaf007849439bbcbff18b17cb93c7f1730a7bc0e7f894db897b7d23b9b1e584db0b0ddf0da80aa8dd50102e063d736c991e25273d02c4cf328bc671fe9281e24b29a27b1b60483548f07fad7710382a3f2938cd690d28ae9d2f7ae909cf3e0fa6f748274207a9a213027316c3ea2e2dbf91d5c026be071413af9ce8b18b767e953d3b5af0fae0b254ebeb93d1b705a699d8fbaad9f8e84a29841e8ccc377f207c64f1103e7140a56d7895ffb5fdf7799b4e8c8c3b1ae635d82632aca8b685faea77c3b169feebe54ca2a916edceffe9c687db73babafcc7acca424f60adaa597cb002bf54b4e32711abbe23aabb50252b50f00bdf731bbc1eb097462b9229aa53402ad758085ea374565b962e56c790c8a557233c58d0e69e3d45eb160e09c957c5229c1f2618bd71994f66316ce85ad5c02c538a1a4b3d6323fefb9086d4dc8929e1a5e6aeeca840b1cfd0a7bf611e1dddbfed83defaa44cfdad7d6585d0ab9877925d5aad1488886602b309ff61a1cad4522e38c1b3892afb927cf7877c6c97e38fd5974b21c28a22ee82b0fe028ab120365c4b0ead2a5fd41e597432415ea2654d3f602fbd25134514cb2c80f828d3a7d91875bb8b9a49fbcb506a7868eabce29243dfbc0e1b6c674c65f8ed8579c145a669774c54eadace1d896cda4254119c14b7284a1dbe6d137d007e0ff75212748e385a78b514ab945d8403f7447bb20d8b7346619abcf79183d7c7c60f0574cf8ca0c796e8d569184f7c2df3603b8c807a22ec254d617cc5772d5693b0b2bdbeeb11fd8ca1638bfffff0135b410c51b5bf8e2f6b37eb6a344405c6ddae07aa7471315263d28bd58caaf1b1ffd90083c6cbc8d295b01e8f29c08db9ad1a1d57d1d49eccabeb0fdaa53d331293ddee548c3061fcb12a1e5e2f1202a92632e944cbca2d5677ad90dd4328f7184b0ee3af419c6859d0e5f76e806c7cd50e14b067a1a7949007849d8333f7a4568241bdbac8d92635882537d829160846022dd892cebb3e5ed1c68b4db510810ebcae1611a7a3f0437813d8748d20148a5e94eb4e9295892d7ca5de0b9e7489df60a1aaafc20adbae8b6a9d88b5d9a2c0db66ac4c56da23ab7c8110310b64700b34f6a7c99a50d1f6d70c1ba8359fbf30757cdc87f402e81dd6c17f9cf25d920e363c69ea006ca4f391cf9e6b8862a8f2fe6c6732baae9b314529cd6740430067676cecac0610169f9d5d3e2f82e5ae390688473ec1345f343a67358582044fb8e32035ff520c060057c4e0d40cb1f1fd87a308d4f863ebca0fca62b5dc2aca1d2ea556d745b69a8b442bbda4e5a4071d3afb568338bc273e40309d6b3759ee4fc19d9c68227fb4958dd19ca5ffdce6adb76b5433914315b61bf686172ab61d27fc17fc6c334515fdcf7395451635715a4ca3b946165c7be1bcfa645da97b2a907929f144ce2097e5cbc8b7ac165cfb3c3b60b70578dbd632023b46339e45385ea72a41468ca58823ec9b3f699a54e03b4fd09a16d73a3e83537d5e0fb13ae1945cb69e1523f69a897643a874dbc45e5da1e98f9db5a2c32e5f40439fa7c254ed6fbd88c7ff91f385f0e40a1dade90e19dbd3d8100afc3ff2d4414cd9be8efca85e41b82dd6120bbfd8dde11fdf8f95cff15a226359abdc4118de5503f6519d578ae5b193258f880a80900a805fe4651ced371f8c8c0de5b5d5bb0953cc7162658dd04d7ce4e8284594c1e938950bc7e75afc3f5d12fd5ea2b529d18850bf7326f3589a2514585239ed96f3324063763a5f3b643137e2b3408d54edb4c63f08f5553f7761c2ba15cb84a3bd7346cbbfc03a86df2a04ac76c727d19ea3b2a61e4eea8b28df4884d9e2cc45cfcfce7e9328363d1171400af0b851046b6f2c49e84ba1a1535b596d0366518feb1044daa43f983238530495da067b8499f73b10cea14fe19f694cf169fa7776e866bdbe0b3e3bd52da33f13f824e5c61c399fabb91d287ef1ea3a3969f473d3843130bab0ef62ff3e4f0608eb6eb439125f6c3b21a24654c1a5e2539f3f09ccd57244054f0c284fe77a0d7bf0bc395fb213ac51ef5b6ee049670c964df26bec0e632cc0eae87f5fdcb4ac89bba148ad133832404c8f16689e9b49488bde7b3e21e6953a4fe5c3a16b8fda9e3e7531f413f4598ffa8319ba0a71b690adc79ddee2c6315a819ec505b8c68ccb7cc8bf11987b6f61ff7365df510819e0173870ceb6572cecb457d3d3a3f80bad565b297815eb3e2e518eb390d51af514eaf9174ca58f0e7e6a1a417433eff2e99c3677f6fd50960a13019ad42784be5aacd345b2a0378995c2f934fb644370697e1bb37618f2ce2493753d38dddf460e78793568d8ef0ea2054058cab2d53de339e89d2552931ac2951a6f673b3c5a4b81dd980b6b8133ccf96a27278364129d734139bb7bc2d8ca5d631e244e119396db8ea3658ed4c2e4e83981c2cbfc1820704558a0d9ff6c6fa312cfc61cc14a24db1b06ccc1d119ef140ca3180901b8e08f34f57028df6ccd9ef273b77cb2243812bf4cf401b38893e102c0d29bad126dd05495716ce029c168e51c35cd6f3b2259c45eb3ab215a31abfb29c6cecd39152d6493eb8abd8c91b7460420477ba9d224dd3d503640721aab2050485a7078e634158f5ab9e625823625f4aec803ec9fa6ad761a596f77aa48e18309e2670d3bde28dd2c0f4f74f9398c6df10f0162e4973a566fc1a4fc158a18d1e7a130fd811548812da4bcd15c8f5f7788806ad7d36f741d52c2a4390d60280af7312aa15542620936715f8d4e89fd59e3c2a640241d36304b051898afb9ac65163a48c5c90e104d7e8d51210fbf5006d17a75afb604cc63e9705e37ffc6c06725ab10a181aae44a71ba277a2a9827afd126a2d54b0a0e6dec4c7d8d59db0284479ab004cb003b216faaa83e75d1d4c4624c8ff27fe82e3f8e978c46acda4c75075aa7513f0563929c9e3bd6010565cdadf4bdea85f9727db47afce9582decff0719ce96e4fec6c3d7e618afa4a2c94f0ab9408d242d92acdf5a2603359b333ff0792584d33f39a48763c9156f73e57ffcf49bbaa21fba33159124d447d1997de5e5c0fdaf6153db9b1b77ea7ece5331034c796fe6c7430a877896f8d9ede4b271af81e322b079a46ff3d47045ad796d859ce563995d3570a4003830057062b29a70b205f4d07c7196960f0565e4caf5b86d7d05508e7d2cae9bffeb417a4ba59341999db55822e8ed58996aa82e9ca90067bb0d27ab207c9b08a2f20e314e7817a86e6972d788e5174ae1383052b4553040cc393a4bc67287276057759690653f16b7b2b699f800e07fc57a30699c3651ca5cb1fcbba472f02219906e7775db746d541785eccb2ec1cdc91285bc3c894a8e844c527c84cbfa694f567d5287e5556a3b03bc0ee20ec424dab47bd60a37702059b87cf7b9644c0ecc382ef8c5168694513006a2a634cd19dbfe38418d6c835eb52e1ad2a8d56bca6c15dd90a312d4d652e75a3ec7b22a7320b6c526fb457442d00dd1a9c079d72c04ac99fef17459013ca3c77774e7ad10c1323bce997fc4bf5d7f673542f8a825a58a8a10d0ed67ebbb2b8ef7f03448df537148f13a304030fa0cb18d8734478880fb1eaf154797059b288a187170918a67d9e0ae39d6982f04889b8c2020c6df0bdf7218fc9a1328b77f37939ed3565a4f1e42354c8686e3df497800392e10265d9709a9b45e3fd88d76be742186e27a40458873f26393ebce93555c913b7e0b193a28d3fdc766fdb4a3695066b594c270cd04511ecfae04ca890f6fa92922986dbecb75751a5e196bc97f82a9e24b14577d1e0ee33a2ee920d7b78a393829e29bd37ff830bc610c814a2111358fedb614cf3ccf73e68e39a4532ffe96a5aa3df2d55dee835d1d6c02980f79f339bf21c0b198cd2461d75170c02355c4ed41f8a0217b5231f26980c9bf6ab7158d1065b68cb0d449e77315f0b9c328d0f6bc1488699e0ea86cc4ca1707137bf1b2a9a4d39ae776a98872487fc1e8cf38047d3e0d3b44b2b35142da15675efa6d4d9f8fd453a803f097acb49ee83b71291e63559d371592b1806598a4e4c606f1658e79d27f8772ded5276ca65f7cec883010f674bc3bf47525256fa10eb642236658dbe92ecf071312f7bc32b3f01208d98601f7b7ecb3bb62dcb7914928d45c35dae34f19634e1b639cb0f2487a8055e02998ee3cb7ac5e52c12b5bb67845434647f32bcc1dfad20d735aba86522c2b5c7bc2b0e9b98dbf7ca6405367e8d4c5b4fb1caaae370e37a2291d215205915e9935a5a38337afb34f3873ef6ea9d3a6c1234522ff4df6dcf72fba534fed4b911dec0bc257c2ea308d9e3547cf6f8ad8141187044aee2124b1ffe4a62cb78b6ce2722c49f122c053ca99d5267c0e7b06b3393962bdbbcf7deaa435d44d86b905f0bfdd19faa3fde24ef8a3561370844deb7ce21b26bfcc490147ee474dbfddefb34492dfb8b11c898a9d21a41eee45d8afb8479c3035ca048bc18ceb6453c4b62c75beea03cea44725303f269aff1d2c1c3c4c3c6675b33bca00fc4fab17d5bf93d4672790f329716fb68d6e6b5d9db90742640a2195ef1a63fcc33e2919136401df91a2faa891893ffcd1d2b08fb050340f36611bcba57c95dd9a1de1e748b9edd0e7af301d65f0c90363eeaa8a7f7dd972638836f416c9e37d242df6f269715ab891cb1ab1c73bbfa6864324e46a688828d6f8f4dfc35012d4ee8b7ab0a2203fe55185ac4415d5b96ead56ec6e7ab1813f847ce7534d3d2e364d053dc327052dc2eff55803255b50114b3bf07962274e8c40b072b8ba5a86b66969ab135e8eced72a3e16ebf1abe463393a532de9f1a3bc8f274b47e13501ec2d972ad44229ecbb64e97c455cbe19477648f28298504eec1716e802610c7a6478969013635afc28e1ea82cc22449055627174de99908c28fe0d11b87253f29a8931d50494020e02d67de7f4b3dbe66ea8f5807cc0a1b7eae193b6cf0bc5744ceed63955049f47dcc9ebbe9a473a971ca4ae7f0f79cb0224b43ffe21c546f8e14ccae014dd46f95ac058f48e57ceede92e622550315ce7d01dccd41ca1266de30ad548f22311218bc73f0bab2abc62ceae76705841909cca7ef870eec09eeed6c49bcdfda75ec4247a423c2362a921041e53cd326b0a394ac52f1a11195b672e8068d547e41894cf01fec9c90c52f1bae17a654808b014e1230cc5e6df3326c52e1f37239d872944dcd1a1fc3bc2155000b669bfaed2b280c8e8f5a6fa7b99c76e9cac53b4f332bf0c9ab70bd3ee41b252b97a7680d74129b360d0d504da55165a99edfe8264b9aa75137aa03887aa6bbed48ff5cd45c21e81afaf9e499ebdad06bb544c96607df476667caa8454f72c67f1855fcff7fe2e83b0e997fb874199599140f22e305eb13ca6599be56b275a757b1a15b4d0e7a7e5834fb22e08ec9cf6f3cdbd345d5bbbcce2c6a0d6f869816ef83d481cf7ce8f1c0a509b1f5070559cd336e1791320b054c3b4e1805a120d41d31761892eed10ebf9718f5397bb8d4996422a2a1833c655cb4014b1b04190206beac80cdfefab3b7fd8e1c0c9f146f6d09da10560f3d5e7f22742e88fdf85096832898f1d694fc4929add9f79c325f67dc5696cef1749237f3063473d3f99b8db60aec24412fe015a24f27af9180ade0f92f7ba5b5003b4ae175d12b52f590876cb2d1a6360b44934b5c3c2ec67f6437c1fc20961cae48419b715d252458810f83e6501eb07bb6214d77452f8df2071d0ed92ac0251018127d37a5e75c39fa443d48fbef004f2cebda314d023959ec2d21bb5e493caaea1e99dc7c07cd2dd7c871a3c4fc54004a11aba8ca601d81f7abe23bfd8d8d9321171ba5d4afc91f6b11871facdddc6398ca0262b243725674d2f685e667b5ee8dd0df340649a016afd1587d81d489d444a4558d7685b29932e1b27283e9eb590557d79238d922434e47943a69c4d83c5bb425bbca52e2648ff0c6c0681c5e481567daed10c9363603d5acca72bd6a0b01b9c40dd49c243a92ffec1857803adbb2a48b742386f03192a3b6d0c50cf64d1629ec15aef421c878e5b0bd44b016ff59a0a761961769f5f559164c2cebe1d23f52689130f042d2e140af204fcec6b5899128ce30fb7da7bace5331c84b42fbc1e3f1335fcaa0ace37c3401c42e9dd912181194507733c0e15dc754ce2616719e973fd92b3d77172a2f69ef702ae6a7768e0043f640529e2df5ce21706999c407e2d5a4dd4fdd133455a6bf79d7038b5fba36fc0213f048a9d2656513ad35c231a302e2973c47bcb397c71e960e5e8174c49d5241dcfb307560558a0e860e77b24c0a4379252c0d0ba13d5ce3ef84dc18dbc00e5a7680f95817a79e40eff21789a9d7b06b52ef8485902c43e56d736cf74800903b526aee0cd3984a580a6f71f8d366b12bd337dd25fbf15146ce6f57ee08627a263f734eb1814c9d9f47d4e85860cd2cfa5a9ab515a72f7548ece36edbe39be273e73dcf15e937f8f6294e26b1cfdb3da2aa9d225805e44fcbc394f2e536716797839a8afdecc6a2fb92ff2d4f1df957b88d9af7cfdc9788136b2a34a1684f66f18cc02ff73a8117809d717729c8aadd6f9dce6468204b33b4994d731baf0472e81e8853a2d45fc307058cf2bb713337aaaca9d1222f665b96a0857b3805323ab8968b52d688b7b528f5ca6adea34463d6233e569d384927f3f3a7a2cc81f143453a26c9843ab3a30413a6508038d0f35dd3bff5e46207e658d08693a623698fe456e657eb1f7f9ade041b27b12abd291e4600e72f3250bceb663dd8d8b8d0b1f4954b1eb4a211226cd4d66aa842195b57538686eadcfdaa4487f5df246bec25a6e763dff0ac4305f3b33cc7dce70228cfc420de511b62511bda4257823121fb494ee3f46e80f4347b487d7c089067e554eb901e18cff27464ee237e6a59ee9db2569e9600f5bc7635bcb561df2ed20f92bcb0eb958be1efdcd35f0b61bb3556ded553993c8b92c896705c8fc89bbd33578eb9467d5d6baee27c89ff768ebdf9444085b151d1910fd476ff53e114bf522ca58fb41c1dd0d88775d337bf027993154f842c93e53a55289ab1cf1ae2765aee2cf079caecba81aff151896c6f0391eaa60289c498999e487a8a573d1daec00b54272859e45e953d97675ebd4742a22fdc84b92dafeeab7b881173fb3387ab0ad16b24524caa0efafd248ad90b907fd1b503ac8a7927f4f62542ae204fbc51ee1b4b94f3933f1e227c3a647288bb678c85ee45b20e5f8d3d601420b026cd8065f1bc5690c3cc6a2a75c1d47a314b03b3a0c135260977a7bbdd7c43c87fb1baa19bb3be23b91fd01a1337160de7156d185cd74f1e81bebbd2049943d2e4955e09e4c9612a36d7e0ac04c2a57458c0c8ba3d6b8cf8c0a6bbf21a298eed8c929faf226230cd23c09a1063a15295d4bafc66358fa80885f81942f91c7e1cb0ca497119cda69583d15538de8ac930d22b71ab4c6635800f254b58ced0a9f306cff5778b303f92d0229ce7f47d382ef84fa168e4e5a95a92f6e94c4efbe2b1e7e32186ad4524ded98eb74eb8ad5d140107c91892f97eb7f6f0703bdeb558718eeeeb230ac8b968e2729f6e97041864c024f9ff85d10ba6f0e2c9755291af5ebb39b6b116ba6c0258e8bde310d632745659098d14074a165d1a62da59eee57814471715a86c122870d1069131cef6d99d647e04900cddfc50a168fabea43c56366bd97df5181661e0c12f28c363ecbd7a73028cae5610d2adbedfe17fed3ec2f49f8a3cf6ed300c037eac4591492275b0e1edc22db2d0a963c981cdce69f58e3854655efc9de1ebd228d1cd3b71aa0542fb73329637b54590950f31df2bc646e2c271988cae6a88c7c556c247797d9c2a8f666980882e69665c24e6afb3054fa23c5d61f66fa0b00f985ba3762f05abbddf5e57a6429d19608b6c84fdf1cff019b82ae6184f292e97c23c08351880d4cd2132586206e01a050e56a8578dae7881e2f94d9f68803c58efc462aef0207db73baea2505c91492bc84c3685c3e1db091f919cd84b79b75967886fb63e4703bfabec6d83e23c71bddd635fca841d455453866dece913ee28b45b72c6ff51e4e3a8fb2aac6698b2500b24ce2c6fd63ce20389efe309bb7e8cc97fd61c8bef86ce6ef00ebe45a22922bd289c70798f82ec4507267846951b60f8eec2a1643ff25416cbb6e4e2d3033d0dcf4ec34e1167097ec8cce64f85b20d1b5e017329715245151fabb12de4cb1e595065435cf846016595db9e382b3079fa16f3f00411f664a868805701e914772e607e107b609e5e52d6fa5edd24e2566c82ad15671e4b68335715938c549cd37cf17aa61952e4baa0dcf50d8e8c97d52139e0bfdbfd82f8d3950a670350b9d4e3d888f833d6659a9d5ddcdd19b1bf0b3bb1b35b22e40275fc0ff2e77e17cd16e36fec98071b71e28adbc673619e323ec0bb5534831b2b38cef6a636c94255397f42b12c0dd976f8ff4784f085620e4c78b3d47d14ee36fa2f1e3b7d7428a999066d552bc85b35c4cc4392c55885d9c7fc0889d8868be973f830e7ae1035e06b83313804afbdee1f7efedcec8b7a18119a53f96c01c458c294300ae174849b3107d0d96b0b1f94ed77434cd5292cbf7920f7212ab6a975090afba87bc8becae03f88cf2d78d2e8e174d7fb6cfd2fcfe3dabc5bd9e9aa8ab1f9a7310c31e0bec34fc3792c84ef97af45aea200ed9d70a972b33f8f6c090df1240c0ff04c876d697d4a6225a491902b1b19d8df532eb838e6947a1f4189c86434d848c342382af26eea7a3a7765cdffbdfd6a258f4d09334d108650cfbf9fa8177f9cff300e9cb32f5d1e7abd8d938d16a2064483a0e622c6e7884c5000accf08d86a0bc2590db4ea865030ca45b2a1bdcd9c2626e3dbf45d11d690e16a9e33c1d592053f5cdcf37750f36460e7c566866a9712f6c01cb73a6ee3c2f7f601c8ed9e3cb49f46eb12f12eef27aeeb6c6c8890c9ce2dc57d1075a560ecd676f45a87813a0804e4c22b3be6696b5090724c55428abea5ac3a6f8fec983aef3ce7edb2886e5a1495d792505c2c46d7a8f74394d402d6018c834d464d62d94fe755adae5e121834ad3c1ab382d8d8a2f7fc7a46188833a2c7a8837925876851f436a114d2851257feece009a458e015db9bcf24e5b7336805d78c40892fde10668ae56789c8c3007f32324de275af5c327412b97b732c8bab095247b1a8915a7d03aedf492002c9d99643148b528db406e219850411d4913097191e0a9d79d69096458dbbfdfaa700f9f9c524c023076be5660bb70842371a6ec066fd43282e52a431d72acce944afac29925c30f668cbffd2a9c59f9b4ac6bd1ad563ecf55c9ec02b1d1ab48464dbd75b6b4dec5c9fc1f582d172292d606fe37a83d35ae84f53bd652822497683a2818dcdf2e78a00fa78666ed0bc6c528ecb15794f35f510a60912c28a0dd9afbcc5757dec25357cd3c80ada9b13fc67fa5d4b14dd1bb21d38d5cbfd62926363f6d11b3e94475ec10073d426d1e9df06635f11014e6ce7f77bd80df45872cb597e1b3b69b8438fdc0d7a886cafb65c26adabc16a9dd1d9cee8276baa3a808cbfb00a473f3c3b85d5ac28269889ace4d5ce97bb59648bb6543922bce0208a3835b39c9aa57824a0b4c97f3a6bcd5c479391dbeb4c792649b9204dee710c794f743339fa2ad97d791701166c004984ebb5f9fdb6b1959ca83c889830446bd4404a8e053eabfeba37715f8f1f86d85c7bee97d178797da894b1dcd12c249fed072574fc96657651564fa3d4ba2e758385efd15b9dbecae27d0dff3a8fe3e55962af8c2d9f5f1bc635bbb3abe9c1b1ec8fc65bddbe2d75064df011615139139a8265aabbbdf71f7ff914133eedcda96b5ec166bc7747b7000c4206587df9bf7139477caa74c76575875e296c0a621f7a474c71f79aec906a91bd423d1853e8d4bc0136889fc02508d73a09a7cafe8ee231b31caa50b93a10af296beb63f3721a2dbddd68d80d2c1d299d0ab7fe158ac2cc52927518b8ceeb0f21c0067e62231e75bbe928df75cc6c2e0a2c906c4695487c5279eba47d5d3f1ea13107d11a08ef98b99aa2e9f98ed9c16a6d5f5fc082a252078cfeb1564772ff694c8a2d79174336a8ab8b303feb72044e7319a7dd4a25a56b9045d5dc7af6ca52cd15a9477f7c87429ce209c8c29b6467ca1383240606362e57326e6d45a3482cb133ffc7ff72ff9a2e30614b02a34a916911653412d21e3b0e32334807d48c407aac1bcb8a5a683d77480f55557e7590612b9b38cbe02dcca0f1d9df93993451c901e97751d14d5338408b1cdf27467b159c61a2dd632aba49b094fb3f00376824662c9e29904defbff62fc9cb514cde72b5c0e4e80423718ba722e8aa6d82a4dcf044624cef15ed9e3ba45960788cf2b7f933792948d3d9a3de2978f88981a4cd1e828830df921592990a0e0cb0cf9c21c3b86ac62ab99af68fa766cb6603ec8aa4f6f3f1de0879fb0a31c2519340c1e7888bcb208a18f4ec8f20094f99b41ca2ceb974f515a863b7dd0fe7e2ab66814ba2596b75bae39f3971a262f587c1a7d42f778a8b9b552e81fa36772331c3a0b459f900b66ee16f403c411a866d215231341dd0aea963b23d2b2c4b9923084cf8013a67491e22353d94a366d6617c9d4ae46d3a449cb9de6d5e82b13b4b70c3e09ecb60dab822c797eba3f06463cc8f7b4c99e8266b68160ab295465d9d5698209c7a511be994dc25a1e174180ba1f0e57c80ac188ad14b4bbd28262f92a5c5875ed3b66a09f7935c4db895a5770d3322ab233677d5947059b6542678f0edd3e67b405f6fca7ae987a4dd48b03c0ce40b5443fd91a61417b66dda4cd63f344d82b956e653ab08df4864a8a28c9a8a59c7d1893e7a0325d686ab7c98a7caf8ca49d2994c261b3b0b913740cad02c44558baa7085a1933a83d9077c9b538540eef62ba404e302913deb9196069eeb4f93ba6ddc059a93115909ba183413b5d1658c4df88ca7b096daea387bdbc5237064847c83094689bc997c1cf17f6e78b9599078177875df13d4f29967c4630d03e11e5b9c9de3d6c4e5e1f3d1dcffee32a5ea0ef16703d46a53de2331ee595009f8ffdd1a221551f0d304b31b3a14579a5d5494555b03e30d24a4d6850eda8b4f032f6d4f91407a158e6939f0138e6484abdbee787fef353bebf70d88599fb41875b4945f80b0177063661b52349fba342b90d08d9e14f019fc5c0df12136201735537dc15ed282bcc8a783d9e41d6988e84019afbe091352add4a0842c4e442280e30caf7f2da5c11e15527105e60cb4b0f3e00e69f8e11ae28c64b06f464f2ea66716293aef0735181cafecc30fa225977267edd34ce277b6bab8b608eea7bed3f26df6fc47414459c099a3ca58f6d8e9fc48216873f7c08ddcd253d1c3078e92e1f312805621b37f8e9aefbc646dc835636e4476d01d6cefeef0b387f7bc886687766eae499ee4416fc246b2eb7eac5b5f3119b886adb8ac0ea54a3504a222fbc3c968f9004cca067d6eea0748efe8c2d71aab6fe4fd4d2830ec5f490e8a7798a26c009465c4b952396362eb3ffa4e57698bb08eea4199bcaec360f9da4d89ee5fa6b6ada32c071a63084edd1943f05e80318320ce44ee22dd9cb9acc1f266d889e8711397cc6c7e2e894a4cd79dc7206d08c27e221bb300dd79d83cd090406dc262885181cd723335ebf475979eadd5f5bbd814abbd8d21c8da54515adcc49e44ddb98c149f3df6d475786f7b0873f24e85c46ed8963ba956d0d3a75356e1eb131c1f0c81438cf43f70cd1b0aa0af44b4c7703eb04069f7e3c8a76adc06436851db36cadd44cd28b5c7e8ecd215a56764f90323a8a3517a1db58ad4702735da027d5e241f081c7450035c13ecb7cb37438caa28cc38de053d9c50114466f9e11bd7534ba29a7860b9f53c4a0da130ed5e15b2cf1355d15df8f2864a16e82e9f4c2be0a7284c4dd2400a4e4e0056955f0465e2fcf996b715934a818ce398e3f48d64f698a4113d1e09b2830b6f449d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
