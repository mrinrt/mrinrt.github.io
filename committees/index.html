<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d3f9cf3457a0d324e92435d39f1c2785b29d3baf5dbff8c8e7bdf1478dafbb3c989176157952b3f7198f4e162a08c14f4af873aefbf23f175410705a3e5b899490c21d8eddb78c0c722ca8bfb74a84127ac7c2a4c58a2bd6a8e562b1bc59d3475ee1803b0473d5b9b7da97d1fe43db3bade70258e58073ec1ca6a1783e8f8b293c2adfafaf0fcd4897469583bdcdc33dc62a3bc5027a37a2237a157d894806a387b5de959e1721bf0d1c00278589cf11c2f7a15eb93189e53b7bd77d30e53235b14855e24cac3d9f59c512cffdfa87954e8043944cada87159923470ff06d1583564dba8f950b970336041141f2ea980f371cc46f712f9f69b8125cd358af9e105e6f49736e816f157b1e6f1ac4792400daf2559b32bb862071964086622b774437b3ba542816a1aedebfac97a457503a1d812798cf2109964f4e82a5a6b73db396bd464a091c47edbc9f8ca4afa991485d6404f6b2d8f3b937ded456af8c999eef69bc95814c2bc2c39414c5b13aecddea0776e571acc1a879bf884e4ae599901b0d2e2227d477acf65789ee8caf61bbd4e1cf6c35eaf4668695c5759e9f160cc51aa6ca5bfdab0cbd088e222b0dbdf3d1d6864f09ae82779994065cf050fdb6c185def6bc3fd4b5e461847741315c312b84c8484a664aded518f29625f28f081c24cf45d76b4c50024f3b0cd762595724cd804b87a7fc5a72a7eec4d4ac685bba782241ecfe725c426112f366fb1339e580599561fdcaaa533a932994708790695c4e28525a74a3303803448ef58b78b3639a783a8891bdb563494d0b3c0545a71b51490ea7c5ad411675639aa517a65388590cd8453ee32402cc402e921d24b88c2839f8c12f4057b00be0595c2c89c1d3335bb359497a7f0d7a23459fd01a1850d94554ef59a1e57ddbb5d9c23de383483f6b50c2230188456473975b791e5564719a2e78b36a34ae535683a9c8a3d375643b9f81b2a63201fcbf8484fd746303adef8b8d30daa02ce4e6a9c6281ae22f55bf921f32f4705eba11109857189afb3d66aab0ddb37e30d8cf106c12d5ca8b55613676ae6c960009fc6a47977542b880e26c6ffa05821261c208f40d0b6b3c45b98de28ef4e870b823715dfe21999b2cfa7a7f0983f86ba8b9f270aa820efe5d98bf11f5ab344f4db8ec3e815e92ab03655b371ffec9aa2431a142af67d991a7f85feb66e4439f14cc4a7d52fcc7f1b556d62476ca00c86b781e6c6a9b4713de06598cdb773b18bd7ddc39ee1305e8175aabeca0b2c2655b15e32dd9f839807c9fa277f526b43b8ed2e6b40f42652861a32d5dae4ca6d668a7f052775240342a4767a73422e1f4abb871d9affbc383b5976712a0b06ca5d1f2a5c1c0f220da03986b19ec33d5f7f613a8d924afcd9f903ee507a6e8145d64271ad9361cf56a5f10a7f64eec1ddb1f42a23702e2fe9d9a4f2f89ff2c52427842ba34fc111cbb2b8b4374382b68204ab6cd25f9608c0714c732c85cb4817a0b8a87a97d24e221d7e94b38bb7f66f492e3a0258c0ee23d415bffbd72e0822233781dd23eb5358fd7eeeff1f73416b77eec3e99ac8b9d0e7e05c61680abb9b1c77cc63e633735a4829606435d30b6a84e695fc0db42056d5226f608fc3529b791129a861425f574b2ec03c21ea5828b98305bb386f51efa5c7018dd6fd37bea29c4f8900a755ab98ee04aa44b9398932b49f7210a675d44c7fbcc5e4d36cf0baf5f2773193381415a34474e01d9be1b814b1c66407fb79e341c3eee0c764a98752c942dc091a6e1b091e580d24c69d5cc2d263ac31342c5baba416d43ca3b5797dca9f35c836c26089ece773b7c6ff5c16483ac9693fad6962f2bfb5b6b405e05016b7938fde029335653755de038272aa2f288e6bb405d624877a8b7fb93b0cefe506adac4336774bb2fcb4d33f225de27abf92c06a9ca7fdcb9c02bf18ca5676b494d561d539ab4bee8fbb22138d3b372474dfb26ada9a20b289a1b516a12794877de11fbdc276f74865b0c0f0a605e1bab3a4856b1357e2009ecc0ccd326d767308bf485db194964632b2e16d3cc1654bd320e71906a33c07986982d6aaefb0907b44e3d39ccb1c5fb5589d113b4bdf146aad5937d5ee2bb7c9243fc2da3a62be9ab379c2b5f194bf691670037a94877ad5f00e7a8cd075c79d0198835cbc73a6bc58de13e80c628b3cef39f06038c40b52e6cf503a3bc48b1f1a7e7b74fa486aa0362a7ac6230e95ddcb9de3b22e45b2e7bef88a24f6a46db075d5684a6552f2d85cd51e246d30516720b8c829e9f3455b1b7774467bbaf9ad38e9d46ebedaa455644c275fa5f3b0095c93f59658f9bcac91e341369825317f430912a775ed435688a63a9742403b52e725cb3e6d313d33e2f1f6c38dd0026117235503011c1bd759a3ef0462275100ea9bea1fd76b7cb4f4777327b6ccab5a6bb291527cec5f3f1db29918fbb009b65f3a07505edb0bf897a7ee558e966bf07bbe534a19ebc1c4ccb85ca00ed763d1b2f7b882c82f1903dfde41f321d2292ba3ee4ee4d6f05b9142079dd48d52719c6adf592b51988d2beef99445f55ede50b9fa45ae0ef2863aa5c61413d080a90cf514ca76bb3de9f1cf9f6ea344dfebbee03c34dbe1cfdb772e23cb992999662f423829fe5390a17246574478475e93c416e9e0e6fb586bc201612ce9c41501cf3e48bc89d0067dd3ec7426d4acc3370997b90558fcf1d03d7590d18dd3eca18dddfa2a9794d6c02112872750eb2dfbc5389ac566d94c6bc1effabf2601e5b5398ede2189a0b0156bfb782ab978db83af99177394f8dedd69866408315583963b175d9d91db53fd1c7195a33d1060754898bbe9d53497d814efff356cea51963ff343b27d2eae13575711f8e2b85763c1849adbac579c1f179f12d9b016657ee4de4511c86e6172942c9d66d3adf26a4ebf738ec498ea0e0da32dffc1a4f8afce6337e5ccf5881ee4f2707e06f83328dec622ae5a85a1f2b0b770f4346ef3ebc366c3b5950acedb3ef5fd3554935bb544ddf947874c710d91a3b771b1fbfc86a3125c2218a510133983ba7644a4382b2f73a8642df63114a746e3a147f19e32e6b3b247a44e31e55817746b28df30d70f913ef79f5fd2fbd0cccd79008561f04ce6f55472b021dba67be83e3b29ab17fe384a18ad49d8846b58e35711d8259a944836db791450594ed8bd0b50d20f2a638c4a0f2eb0aefd892f0d9371a1130d9b76e8c56d6d6d9037394ae7b402e530f665fc858adfb47a341253034bda74171a069974da73ed2804f232356670037a717e67bf30a40fac0888637c9d43693eca33e626f18844a81be26c025c33b42ae9753eb3585849236423dd02274ba015e90fa2c8de361eb193897766180d9b2c5b4a4acab1ad62cb0de9c18109433e4ea5351411d222145656c7abaaaf6a39609035982f3900c60ce2f7d7a483818cb03acb9caff81581a5a1e95c4fbdd985cade54a1fd5be14fe11bba787000460341938a608127a5adedff87c9e412847398aa941f940cb36a8b317c89da1d266051195c540accec046292a86b994fac510ccd4cfe59c6972a70076f84ab42dbde2ea542ba565f020f8bc7e948b0aa5a04dd82a91169a8b0dfe8ce23200359aaf6a37e4787f785fdd440d24af2cd02da2742d4ec2fd4dde656eb7fb47b38145bd625ab289db3e389d30578302564fd0c9459acb4401d61383d9e6c0fb622ba9143338a80ee313f87340c76fd04eaea35fafd89cc90ace7807bf0d17a56f2930ba6b78f62e672f3a7ec8c610672afc02271ab8fbdfe8333813f4d57f361f3f655e27d7b92289cca20d0dd41e23f5e4403cd6292e1b536fc801e4b9cc265ebb3f824c6b5ef22771e38bd4ebec8e6ccb4bfb569203f39fc75b0b35a9bcbeec872122bd4309dca252bdf6b3fd81c243ef63c30881ab6d5f6a404d8dbb1c3612695b015c4cc18ab248257f0055f08d94529399e3b99e3c6dc11d960523f4bfab2a5de54105d5daeff8699946853b1cd552db9098d40a254ecf9943f9f6dfd033682bfec2c70b63c83802974ca701cc07043877a64d2ca79fea670594e162413dc2f896d23041b4052bacf0aec9591deacace89f380a6a07e23cf39e51b0b7378afe9f5de02f23a392cdcd65550579431801b07c73fd741654378398d0c72e00d03ea5b1ed2cbcb5577e9112cc94e9053b921be694b9a3ad59475839a64cbe044c6b02ecbb609950e55c16c618acb67f76aaefdbb6ef39362e6ba52052ad87638aa3038118d056ab1eff451d7596a6e72d48014b21d93f7f70c363439428e4aabde307b8f36a1be7eb4f26acaa8f0e5c493aec83f8eae98e65d6194af0c077c1686bbac64e2c91a029d9131eaad497826165a91075d4f4bb9e2bf53694ac103c8012d8a6cab84ebc17e3c2a9dde18b730707f937c761099ff64c6c88da70e386ce2fee54e68d22e2b0264fc015c2f221a264a23d70325640e120a432f3d3fe470df4887941e565b0a29458ee6acf86320cd7604bae909f5ce240917b07ff0cd0fcfbfc6a60ac2e58c2ee124dc7c889148a00e6470159177fc313ee5ea37f147e7906aeec736a9ad5f0d532ee24803e8e060fd16dd7425bf0c437e2f07eb567ddb502a039d8a6b9f1f12df6d13600da54b1e62783b9f7008cb136ab595691f05a044c62d1b8dcba15d9586fccb68b45211e447513f668b9d5504b677ef6a091d279e4f1a622d651d515feb03493f823549ea88a72ba5c115f1615053ff774f45aa251d7303ec52f3a058d21a56efd8972386147e424bc6436b09079ae4bad193f1a00010476f005843701f69ea456da55687defbe9e04f638e73a05d5bd385f5ae86ebf86530cfc1a911590d86eccbe2ed633dd5e543e7fc87c7d2515beb68b7a54caa65b6c36afa9739d233e80c0cb9cbe9c8d5353045b7efed26f4ee1a8973203867c0128e52b5439d89adb90da5351859d8d003fb962f51261bbe2342dd8cf326318a49c62da3647be44de4f934f89709b3d1373d7d1058a5b8154157042e61ce48d4fd50d424e304863cabf958f79c4162de34669bc3e79a08213a7b13464986ca5e33e26d0813ce70ce4385d68c4426b205323d385ab133ce5e519799d74f653ffb7ca69a676e02bb2e07a7591630743098a295e6ed3afbd0b1a38777cff8d4d30d83643e8c472bd1027e91439c30cf70814b862023a09eea552db92aa95d035d0782d600944aef643c2be653ccbfe913a29729a78fe0e4f60bf17cf2da55d2500c953bbf72e4a0d998db8a56b0ed04b0e4e3839897355cc0e8633fef4fc45552a94d8c644d8be5cd258b761f595097f6050d8e3fcc88eea3c32f0163654af340361fbf295f0018437cc4a79d7a0c248dc810f2c99820de7f6f899c07318efe72f7b8fae56914bae4a91c283cae1edc0f54406cbd12af2806e7428c99c9e91c5f23e053b422512ae799d69cc4fa98c5098d1997dd78dd43fb63ee4f691035364bd2dc3eeb27eefaf93561e902cac628c0190ef6b473dd306aca2fa074709ee82ca0a27251a0682ad77c7f7260fcd61e2dd291b65b489304d83b3790b0e3d522484a988e71ab883e31466965a36fb8d42ed4e7078c465e0982e8b45cdf047aae5186f1307e973876e2a96c0f2468831a452aa96cb6bc20236351207207ca8322ddabd081e27d57dabf97ea0a900dafe73f87bc84a1ceb45e4be43e8c3f5a6d2a4d1affc2730b4113a2b4ad806031bf25e808fec6e6f4bae4ff036a0e1da800f33b62b8d903e63ac6b65a05ef96aa44b2f90202cd7873900db3e5f4649577b06751cfcd1967c7c8284f06e6aed444473ce0e38d61ab4b85441d7b43e2bee10820299bf9e23fd720ffe314275525a9b4e5af0a746649d377fd130f6fbe812b2c6940fb02b09dec9e5bf77f775e6fedd905e6ecaea666eb67d9d40f97fedd2bb2ab9ebc267e2bb325ada5ed23e0577c9884b56abf991d146f82e52dc8d8ec6d510d9857d4ff773eca0ed6f35034715e3513ee2afa7509364776fdfdc62dfab8c1bf63ac301a1fff53ddbfb58906b2bcb4e57ccc1c9960bb3b05c175c5e9a57ab1228bb3b42ad3a55c0d58709aeb0f46cf36b3029195200b8d6e7ef1bfa296be7fa5a3b14a12f64e95d8cf75ee594acc4cf0423c24e5b361ddc819d29bafcbcb971cc9f1ce3084275b95cecc3a239c994a20c9316dc62b383dfd0eee4f8dfbb8f6449823664c49ebcf14ad20bb2138f38aa8ca76a532c66a08d24e4860ab92d52c36a0016ece0a8f49860dc5433fec9c3effd8430ecbdd6ec1eb6cbb17750104ce2c9a38fdc8d28650a573d2dc211461a53a08059545b0f596d5c61bcfb2b7f210a92836ab40fc08fb1757389780d961aaaa30fca0e28ecb839548c49358016ff1e513f90424346a9de7f82c70265e8d61f657d12c22fd1c12601a573613ae1a8ad49a4080b2aa329d5cd499e5f141e1a6571c83ebaec6459d9b202c2565ea7afd24470131f04e0ec04802e54bd562d31e6311b5be5a37598182ffa8730ef868b882b374e9cecb004a92b8f5715f00e83726129919c79487501f15126867e2a3987555bb833b7b6c8c43bd66b9db3bb4d581126d64d17842bac245eb4b29d0333b6d46b1cf993b114fbb733f8d46eed84d71ee78c0fae8e4595d41e25bb895e6b95a0b9a05cee09169ec24f7cc0c5beacbf0867b9d6dd55004d86d6e7d7282ef75e0037ad8a0bb8537e46a1e82fa998b189340f7bd438f51766ef2bb62b8723ab5db7f76fc66ae9571b55731a0f89ed4a2e3f242bbddcb24b5732e8f22ff01ab8943d5988b70cfcbccfebfa4877b8f6ada80cbf37936085433a34611a420f38149765579a09717c5fe0a914aadfbc19dca11a0f7a9129ce14032b9c8b96058b8c3fc0b6fda905e5261e790cd1082f7b5b2eefebddcd03acfb33b1738012135ca7638d586daf182cacdb73a8d5d920e910ea36bad812565b61522baade706d269fa0f1912f7aae0648d6d8f766f05423746aa6719f7bbcba1952390f003a2dee148d9de80fd8f68efb9f5a605950b9e61c6a6a10b846da65159b6b31d90a9a176c90dabc0a37398e35615a645414bf6c5375070daa27f1680231e8efcfd57c3fec596428aa5ad2911d54614c8f4542a89eebc1275b1e833f0b4e19a3ec271a8a857eca983115f3e379fb1b57ac3f9afc39f0bd7b92a419ade8ae6d1dba2221c6f1455cb0ea16d98e63c0e8d9b6f96f23db6625feb3a96756ebcdcadb62c778421dfeb4fdda8ef6ba133be108da5e57e66a87816341b6c6aaef82eb2f8e643b812a639c53389e5f94597a82454b73b1402f7c6007e1ace40476f2f8677ae3ede3c9bbc9601d7d819fa4efe153d7a589050aa28ad840f7ea6d1af01e0e1fbaa9ef3603ce4fe0453375da15aae3929db014ac27b1594b121e74875963465f939f1ca396ba0f41c5f9125b8ad74309720197527fdb392ed8b0e88a3c58b3d76eca2ad40c06bf102036d812f5b6a1557dd07f6c1ff231ca9dfbf8eca26a8f96897f32ef246b175a32c875eea2cb1eaad535af355663ed3c384e3f59e1d0f238ef4ee6840e680ff715753bef4a8397ff2b9176ec920f60988f956cdfe9e62abf60db11b826ba94486cfb13b67617fff33312b394ffd5508d5e8c40b095cb6f4075a13d07453913cf0738338a26b493d1b98e294804001fde056c528fe0b89ab5b9435447c408eb7d8eb9e9b72394760499eb25212102648de74213f6f8ecc1a16556fe5b22e9989461ebed303a0423ccdee76162555e694bfd5f703d655fe0c59d61542259c7ac65de22f7209ec45ad5085186872affb99cdc858453179d306f10890d2561f9e41add9de269a327e37a3b0b11c70aad1355c52654ec4e4d2a12006041a7af36be3ee41cb2d25ac601a06812639fb56b98c9ab7adc68e0d674f7a8a2740e54f5ad9f31adc3e5c617f8c94bfb3eea19058b5abd3677ced2d75f46ddd6adfe1d7a0f17572a8fc0dc1dd7756a78c9aeaeb5564348a108ecb94b30ffa77c6e3f4d09568d788be483f99893bdb3dfdd5640b190bc6bb8c945929f7a18c520188277c6344471dfaa9474e8576792c3af412547c002259c4f536b1182956c2d096fc021ec537e7cad69e4776036c46ccf2622786bf815067b3fbe82f5bd786a5f1d86f1d901a1963bf4a2708dcdd6e7bdbd83884828c5be1b6a6234063596016ec200d3143d6e403fdfef675c51bbfa3dc3dceea43c959569a217e237bd934be93dee2ba12232456c06063606c1f8fdd7e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
