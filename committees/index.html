<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"feef31bd3f95c6f67a4c42b47966ff68b3c0bd2d116e78097d8bb4c845d3728cbc340559b571f2ee14b870c96e516fdf885bff1d8a9169f8458604d95782ed3aedf7611a77ef329109383063bc4167667ccfb148365a6866675bfd74e30d6951185afafcdb23289d6dec9de0501783f5076cac3a34f42e95c4bf9f31b990df236b7573372c3a8af1d98977e20a80ebd8bccc95ff74c81b72abe207c2c8c7025f74c97afada69a5203470d38df4ea9c4a963992ef58e30e7bdc4e1e839f1386ccdfa35f84759c912e58469f96e1e4aca0eebe205e5f1c67b2e832d3eb59432acc62f3e736216e8f97f15064439b1cabe8a5b4812121ad78b245cde1589e02df2fb732d6817961d86cd3cbb0423ce498a34174611504521a2bebe230eee53106424c3e138a2c7bc92c44abc1d24366e7b8ee0f61a44294b9322305e86ab08ee0b3f5e841b44a2e509d29f08d02e95d358a541b6b45391fd45587d5706448a1f0c9f656bbd2e174baeb1b83e8d3743e8b104c2a64ab5008410be8280e36087ad273d30894bff01a4ada6a90bdc85841f1586d3fb9ae4d4bfa0ab0593e1385a66d98edbce973fad501dc46eca85e05eed766a81d54429d936982f354b79807561f53a2f7f9f0c30acd1bda071f48ca9ec1af710ad2484a9fcfe33988f6c6e082394f62d3806a14ae0bd55ad0fe8ae3b461828e288c790210f8650e8b817567aec7bd5915a5b56a9a506a4d23a4f7438d7f1a841cd62392de3587f9a9a9ed1f6ef55c33a5d49bec58df68d13588d75e8e06131359dc6e4c7b8b9e65d77ef5731714812c8d43c09948d1aa74f3737b5abaa9331ee54defa4607df8cb85ccfb9b670fd3ba46bc7889e1562a8ecf2a3e1938904922448cacea67420c822a6feef363b74815bc39669d74c0133dba67b8a43711da79731766e7fef1fdbcf91161b411c09a2b683722b0aa19bb16a3ab7ba9fb8eb039e7cb8b99b0d5200134aa451dca05f7605a18d38c152510e17a9d363fc7dd72888201b57683d147e840596981db263b78fdb1fc8325958e8790ac82e93724f5da13d353a36c664d587d16c2400f6cbbcc567cbd5d65b7f8edafa18a7b8f79f5e9654a0c6f807ae31a42186988500744c2e0eeefe80392ffa335032fca7ffe207f87f0c95dddb05d282441eccc381124508383b4167dd7cda7dab8cc4e14e42dfbcf708af891b4d2a273f1c849b0564afcecc0f7e2f6d3bb1cce699977338fae82ec5e2ef6541eacfc3b774e1ace18c4a699c5e4d590b036056425130e5c8855e7899e8bab345708681fb931052c000adf5ffde69220d0cf84e9caee65672954fbcb7aee7c1f831ad6512daa5b6bf2e8e895ce9ed69f6643fac911e6a7d004549eac9d36863f65da53b8dba21fe8db7de2f41c4f927ddd9c81141afd87d6d20ea6305f3f08f132b409ad3e973b3d5bdca9a78a193800de0c2b08662adb437a5912fdee256c0ac0211812d45cfa3a7e95c5248fb406a322710377a9f5ca9fd69cdb9b1ef2da2c708d7170a2928d8babe689487ffedc4438e4adfb1f1725920d0738a4d6eea4b45d1c1dd201eaffe6e400cc8ab0b278667eb1a0912069bbea4ec1b573297b9dd5ff9a3c7e4ecdc0856f30b0a3d8f94af58233191157884f6c7a73b162e183158bca9f7996480aebfd9262dc585bf0e27a044766ecebf9bfcae7ffd3cdb62f3789dce702c7dbcd9a91386c77ac1660fc42fbf4e105cd0d8af4a4181f06ba5f8bbebaf618b246ebc24cddff7f68d33814c3126bee3e9549be5f5fdde948d46197cf84cce17c7bfbbcf4dad62b5851cf8995a2512e91397a2155ae6d48f8a1df2fc574fc7c622c23bf5012b1d0fa13bd2485f2410a1bfb0f36678229a16fd07b991e863fbee5958ea277e59a12603ce90f79d3d2ad2fd419c49fba461ca7f0b4599e698af7db9e525dcdaab5bf8631b6c3dc3eec776ab3915449fa269a07169d62ecb1a33a8505bd32e6b651169e940e053ab1617668cce58c89b1ed5defab698a0ecefb43e7ad8e55b357d5ae957974d115be6cff74afcd7b72a701f9229cbb1a1034d6fd8bd59997c6c0e3509b7dfe0173b345f51e4eff8b6d9843ac1a98702af1d923ed9930b5a58780653049891a71e64bf7190d981bc09613e97e58078a91c42315c30d9666402e8514a0487c6125c8fbb40fdb89c18d9d9c5d59e8d0a7c1e596133a87fa201ee8b63f07b1f2c16100bea9fdca8496f984643b879e55d5bdd8bf7c2fe9a1abdf94e458bd572fa01a82e1d0c36648d9fa274022a5088bc9595a1983c5955e0cb7fbd642d2fdfd6af386e0dd1d0ca9f037004f4576929fbf4d3a0f59586388d81975abbf3547d78561bf4007cc0e3ee8c30e099eb8765faa56dec7cb3a926e4723346d2851023e5c51a921bba4a77aa9df502abfa773eeffa502b482fe3de66e2d49a0f1caafeedbdac5b4acda4141ad2e9eb4943613a343c60f64c42ef2d1936a789641082617614190f10eaf1b035c0c8b11c002d868c38afd061e73b5579afc2afa3b2d346369ada3b9a76ef994903f0a7eebcb666cb6d3c322a7f2ce2dd372dd1944f5ff61e4668f4d00eb73a2b8ec623e473ca5a99dbd902d437dc5254c500c6874c0cb4c5fa77ee9626e0d73820dcd2742e74a170e6bea1aa875e3ad84fe9ac98ddac2e3eb50eb79d5c284e65981a8271a47c0ae54b8f3e570d50e9f0892ecbf1441bff33503778bd3d99bb66a74be081c67c93d91365a652f0201efb30b7653f5c22ed3ab5cde57a58bc04507bb56f4e40a57c3ca26e813d0a7963de51ccd015d12766dff8e9cff4109c652132ac730e017ccfc2cd5af72bdb658795e19aa68ecbb410148b908c1bab42f1b07901a4618372978020721e1fd69db75dfaa56ea74ed7ad312b23244dc16e3663067a726cfe684112ced89af272215c999fb7d79c13ab5dac0364b328a09f080c1e1e4e6678badebd2ae0d15c12aa34754640d1f45b02749552d10356829e4ce7835448429a5b84c815ac2dfe8fc7c5ac79ba03d6641f4dbef0cc398347da211f5933bf1b3a371883512b8081a215ebc519605ed65b394e82122de016529a85e082e0a4b13287757856e31f47c194cbac494803bb38811aa99af45be8b6f6684604e2199d59a32956f2331bd15e2d901d7a7cda4ecc9b3e379cc7d2f1f5039e604369c70b02f6246d7b7a6539e7bd1b0a80664a792fcf82862948506b0fe9c238e0f326a2dd2cab50da1e882228ba675225076370b75e6a6f56fe433808c36b01adf242626923bf4e3a886ce3f1163789eebcf81407f01214eef0e31d67d2fe20c947f29b7944387df6864f383e4d0ce3c79ad6e83712ac697195144d0dd14c035a00a3ea3aeafc759a3965a00eb3f1542da4761d1632837fcef22f444106385d0c39de9161a629758d7b47665583fa3312b32d82dbc996ade1a83684b43dc9cca1f51d46d9e0c87f8a7085bf730f10af3b8660a3ebbce9d09e4cbb962995ba2dd3684ca9b4f7df9f344e687776d6ec3f0ed80d21ac0435b27de1e7f814e4c338bde82ea51fa180967945693ab306ec316459d307e0c741487587507527f46c952b67f6f2ee696c8bce51c0104cbe089bf925f8b98520bf7e3eca0292d4039b29d19e677bfda6970a8bf159347296fd030d6ad0e0701e5e000bb6ad42009245476b78a185a185cacf3cdfc6361057a97046c097b9e9d7ffb9fba1d97124d467da852d7baee5d6d3000bb3d4a5683bc22506859b6025d9d5b6011068be7dab39825c30420befdb17de5ebbd404ec7ba36f9a07aa85a2e00718827e46b1036e90dfe58ac9b9d4c98ff59bbc11a0b4e647a4b7e5d7713bfcbff731ad8fe1fb36542a40e83f2d4fdacbf60917aee452e6c16d81b9a030373a76394a08280a56a256fed4a968d9fb3415c38a0ebcfe4b04993c7dd2da0fef2b72525df80c725a805926ae6023165d857487a5828c60a174d55541e0de53fbda4d59e394f96658d22e7365b95512b7715a7583fb3b53e19b47c7ab1f1091ef3e637d2bc9de71a72a6b88cdb501d3300695a2bf07750f24620b2d9535a0b7dee7721f0134cb5462447b97289746aa056d6b9ad82e83dad91a0ccbe24313a5c181ac2587b4fe417b2b2824fb8b4354d0ea482ca480579643b8b86397c0f620d8fbec57bbb398bbb8dc9fce3dff734ebc0658988868e064edc0dd4dc294fd880857bd02ec19451b838b8223fe9a4e3adb9df894cef65c563d97dac1d1d2eafe2f409ee6ecdd62d860f62b4005d04a4da3eaff3db7a9da2ec3d96ac37bad32185ef1efea0f864db28fd16c33704c72fcc7923094b0196bb605e950777a0b4d87ed010ee276727edf5fee79e2f6368c1494e883f695a4bad82bbd7131d7c767b1df3616691fa6ef9cc3794f3098714fb4550fefd25984fe6dca7205272c6a4312d0808fcd6a3121153686a12c6b3f226ae22f35a21443b16b4a446ddfb87ff9c0c22b8d5ef7d43962bc1b956633077e7340118138411390701eb8d669de8ad5624190427186d95b44a345dc31767bba8773340e60aeacdd3d98d9c35b5dff8317e8cc1abca327c80246dbef73364d841eca6d2e820316dcdb255fbc7c58b94895191134b0cbb82196d6ded1bd358a5eb3efe879054057463cccd595afd6b3c1c44b9ab86751f1cc407f72dfd50149c8b24e8d19bcc886704ab003709d6cf9c68b4dd84d093fac4899714163afa650733dcf946e1356e6d8b4a1f22e0c09a600b43b38ca3b789df2821c2e6f564d958feeb1380d92f004f95596aaf9ea30bc87b30d0bbf6858d8ea17fc28facf23d4f551c514ad4f6d237365a6935eac4b557db08e93d944f1e8646770e857126f890690f2ac7024431a24f43c22d79a4d784215160ff2cfc3781a14e4c01ef8487d12405e931d54d13f0aed8d8aa23c9e34e32af92e129f53d2a12796b807eb7abd84a9e0dd77551e5cb3ca7ea31c86625e7ecd5c4e43a9d38b5e0e0628a78247fba8df85853f83f717599ac759dcb0ef80d941d99e706cd2173d4f80ab2ce3afcc5b29d733bb9553db5d2b8d4dc676a17ec85b2a5f68fe3a09ff7dc1c6fc8eee6cf3df4c238c98c17db727d934b19ece42f6342016a3976222403bcb7d51e6c4e0a6151de6230ba794de9695cab3a386b63766edabd3db3bc2ad2a6fb36632713c54263d0f466fc9f89b93e43675fabfb6a2a6fcff3b8f04d36bc48303e6e8f27795cfb0ab30091bc3499a1561560ee8ac7468237b52d28a1fdcbfe8fbe80a689400242fcb71f6cb5594dba91decb7562843ddefa917708b3146bb0d0974d1394d8d557b989348f7d110331a30da0ee2c8eb6aed37f0591d8a847818136891cff4ff28653b4664bd0457e45384b35d591686d195df39914a23cfb16e3feb7f8402adcf49747b92e00fbbb64cd7f8cc953a5e48aaecb184350204108f9395f4bef3f646c98ef619ac7fcb5eca18653c711850a6a47c3d28ae5500cfcf9753c62635fb52e241a51fc9aa643023542e86660a6f997b9292355b79fdd5d13f86d42cc66931aa78e6467684a66ed290ceb2fdc703cb0dc80edc651e36b7f559ca8d0bfa66297fdaeab80b8ce6f15473cef45710e022f9b7a15ba1a789747bdab4abb062bd22c69b85f9ce088ab9666ce24c228d235e792c3a3ab47ce1d10c673f9e8de98727519f9384697dbebdcfc4d6284412acf00086c77fc754a2d910780564357ffdc646b77beb8f8989653f8aeadf34c372cfac0ac5016d8ad8bff050eeb7ebb4f67e28d2da4b0739c9ddff5ef19c3ab0f091e9342f6a2573e8c2e5d111980078c03da7b951c188fe227f6c9606c093095da8149a27f9e42a979131d35a8613a3d65f1a6bc89fe7773ffa9d10cd4c60e8b7c7d0748a3ee9860ec028a4b8cb2e3502a0dda097dd40f5024996723ebe84eeccf7383c926b8f0150eb80bf1dac47e425f357791a3e5a9733d3daf1c52a40ece0f9e3175e1ea64a5a3d4e26e8422ad0e82a2ce4dc9583ebfd70aa5b56f48bdad3e967e409f37c47ac68a9a27fb7e4be9bd99fa78c81621fca16b4ecc21f30e94f1009e4e80607280826de68adf8fa4681397a2a9e823082993407129070702b09fafde15487fbbc05ac885a27694a719b9982cdee0e203e4dfd14bfe65b5b556c973e8259843dcdc1004e68e7c2d9ed4597b15488c66855d35132fc4833ed8a829a6e2281ab173a5628b09f2b89711e7521cd1a4ee477983e678293ccf3e09b8b0845a4c4cef4e7fd8af0548c3ddaf6455d7b6599c53b3c8ab829daa3d309ae600351bd9e5f48f28058b6fbb31ec7423ac1a6ca4e48b87390a52aac9e4099224eec35a1537da8207fd2258e1bec6fca71e09590d5b90e189b57ccaa75d50f1fc86b11c06eb40c71a104b55e58a57e9ab316bd0881affebdaa695a367988788467b57311531e3905a4dbef1931c011f9e6abe286fc34ec52a8a4d8738635c19a9300e615d28aa3b6dd2ac0a7b218284a09262a63a9ef30f2b69482ef0a622e508907166da5845549adaf64620abc6fb2b0cdc65597be029a89918321aeb52a4ecbb5c2cffbbc97580ca91284d5ff958e5651f9a370129be7fca19b6f6b60f9dd257b7f22b20bea4f42a17aade739433917082bec877c625501251ce1b8927f0b0bb119f97f04dc4f91f7d5447dd01fe45b000778ac3c5c75cade9a7371f2f96092223d7fc060ca897dad9e4003e85197ee9bfc381df0f00888d05d8297a7c1e33c33e61fadd27c9592ddec7b8e257987264d55473b6edc3262c46b705970f8b5be898c6f335d84b75ffad73df6979cadaec78e86bfba8bc1d364ffcecea70ad5de2d73cce29ebd92be12b2d24b2a3e60ac5dbab84a0a068d2b703c11ecf0c6398a5edc3e674fed598d0b997f834328d5c3216642fb4ddfeda338636416031dcd3fccefe09f5e0c0dc972e22411122ba89cd02e995230ec3526e70c49036ce5d464001c6054473674bb5f4f6cb27bad1e7bf6491249a07a70331d2dbe274e533aae364fd7d9a748d97510ca7ed89543284a4a3d4c8ecad7946687c08c8aa19a7590c7fa3b6d94f8183bf1b847fb09227129a1833d790a2e95570ae1a570be4537adbf8c5050f6f9451021272e213907bf2a8fac312c6805c90f4836a607823459893f1cff78b514fe60495e9e4d3ed4c9540b642a2f0a9fedbae7a06ef7ff876bfd3a2671fa9343ebec61776ead77b0d878c5b944aa13b15b4a0b805e9be47842fc2d469ba8075aad8ea1052c87189b764b13222435e71c44f952b83fb8bd3e3aac394796faffc2272dedd0beeb489ac1899fdba6ce65448a9d19a8e91e46930510924ecb89e7201852b2257ed1eda8d18a56eb6de119bd5f8828c6d5e0dfa28a5f1ab9f9059293d7a6e722f5bc1ddf7a86e8559d7a92e5bd43f50a2685b384e2275d6b09cfd9877ce63cd9d547d149b42ffc4876ffa8af167549df43c7589a0e9bcb7c6d45764f68ac8fa511f686372749680b591d9db94df44acf7e57d820a5510d2e8e674cc897bf48045da8b048a0ed54786bb671f8e8f3574d68c6a2b4ff8569c2242a6c0bcb78445095d6d9dce71fdfb6fd41d079055a356f5b17c2fa1b4eebc80cade249ac1f4d423dc8a38554f668ea969e499dcaf8dfb35eb62e42b0ccb07524fe703d782b7b11d28651e6935bccdec5447275d1872545f7a88adae626c748e1e4768dad1af7ab35bb4bb0051572b248c9e8cae0f942f9337ebd2fb7a55cfd168fda2b719874e0a3fa8350b07c9dca7312d1fe4171b782f55f7bf8f72c8c619b23b970bde15564e753cc87431eb2f1d6f1f7604c91a41f610237e513ba45decdf24063918dc7b72949ddc1098d2ae8ec68016c56d3cffd35d7cc3718086a8b12b6f2fcdfc2cda68296dbdae3a68051c1ec5474623778febb6776407bcdd51cdf38d0f26c81a9a4f80484744fb7046f386b3b495d80f9dd81ac3f0f0fa7896bc1ff95408bfc7ee1656beef0f3ce392cd0e5bafbb9511847e72c195f7cf94dd47f50b88bed0784a39c57536edc8327157f9dd7d4c21794e486bc4e485c36b04aab4e91b9f8f99bf83ce0ae345e0950119c1217aefe2777edb675f92361772a9526d7fd414462a0dccd18075047ba29ffeacba6968c95262e3bed46149e3a384dc1968050ea4d27ec09ad016e48d1d08","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
