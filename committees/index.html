<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"640afa89439932f5fa6b1410b5df8cf9777eb04b6b1b5dd8e47d88b20b8324df9aa7b98044365cf346056a5053b10ac92a83ad265fcc42c11ee544753455197947714b12a3ed9b51b342dfec25db727a3e95585d4259bac0da20d8ae211c8d528414313bf7fccad96f9637eac27aa8c931506d6c20b1e6931a299c076db242a50922b40826d671c1e1b6c5ba7cf1efdf368073f9785f7663a5ebc4dd5b2249765a82c7fe725676628ec48218b263778046bcd166c9160ac5111370f6a1614a4dce518694a2cbc7b09bd412e44555ed6f56c958d3feaee7b71cf03384117eb735992669b4a5085d92d5e1ae3e17a271593d6c36d3fe8cf6d3cff791c7511467fd5f2d0c2e6aacf50220558049e1e5c2e018f366fc25bf0680078034bf7dafee49019751dd6cd81ff073ecd9dd5b4ea3979e6d7133b34c32c3252b1bbd8e9282d675e5bb840b876fa5bcdd8b119593313d2f7a9bde0adcac684acda6923ea4c75d0543da07166644cc4de5216d86bcfe93c8c3da1b51fec1cd7e183f1d8bbbdb8dcdcac09ac12f7912bbd396d94260e5c4e839d864c7e69d7bf38f013a445fd886de2b6d3b7a23904bbc7c8b51605678547acae4eef4e488a8673c6895ddfe1f3d7bfdbd342ad6c89160d05b3dc1e7c3d70426273cc4302d8663d4e20ee7a7763271240807d2b7e9ee1c21a86db75222b637a157c4310aa565af8ebfce762773d2a00494b04b360509ca08a5a316839806b03f10987be0a7601a758b9f748957383b39e3b8f5158108e77686306896d9553f1c23554928e2eb4c58b1bbf36f2b1c06f3fc365260f7dfd0d9f0bc929db64e004347b64f23c66a5a9c1ff6b791d30157651e01a22632545fc04c295c596e98a1f58c120d59feb1a71c7930f20470ed1326322cc84b5540bb08b67a48fd9a0a4e0b7088eadf485eb5330536214cfc087404e13d1dd47500ce87a643c004f9032afe3648f9c3d0d492ff5d0117fdbc0b8a833a033bba293c61879a9f7bcd0d2b62056f0cd4c763517019f510131f68aea83c92616e20fab28d4b74ca8304df8845eeb3754235d45a59019a65d43efcb64e98f11a0cb61bb5ca21c733d49bef7e0c979bd1392cad1b2cad5218f56992d7059c294e79e834f52c5cb2fd8de847a19017897a5ca997c0195fb2d76fa8852ec19fe72f216b0019dcbf5ec76b11c33d90d1a685f8f5413730bbd5b258c9b5085b0e4cd92c560177e9fe0258b9fdc6d267bdaa41a8b4828d6023bce0b432271160876417c785f0f69bccda6a63370a6dc4bfac1503d897946bb42d6aa6b114df74851babf2b950f3869e4fb76104ec14e187759ccc9db30e214727f95fb7dc599f0e1de95278c2a8bd00e956cbb65820352468db2f650e26a14a99c3a693430cbaf4ba2621b081acb967c9c644956919ac74390ab914b9a450075222c0f46c11c5ed86eba16790bedce5277f07ee108c3c95262a40425f50afbb4235831f1d8139c25df1fabdd7fb2011746add1c045b6da64f4164457bafc7395773a3056ae67a579f50b6a49cddb4dae1ffd82f08a4d26fce15c384faafeef58508f7505ff380f06000c8a838986b52218fa0bb64200f0dfb39ad8487b2ae3b879d3bb950fe4770a25c8da186c9eaf67f099f47d95d5e144fef8ace0508d22428b4f7aeb28c3042c7a343ed0973ba4c028ba5a848078618ae7cda3ab76a1a2091dc91ddf4d89b4669102fd9cd77f313924650a2751417c8ba841ef09448026ce3962153a63e286ef27bfab7de1414f8bc4928970550c597268a1deada63b24775c2e5e7bb81b83880ae34a4cd0f0da4ab0289a1b4f16c4561461de9e502b25df634c3b6776185548ecbc30cdc4f774d59c660d26c5149fac68ca827dc331c41f671ca260472917c7ba3f9d99a8db486edc63f1447d16b85e09c627803783891013d2bcd44d7560d3b456911d57bbb1a49ce708dbe572605af2f288c1c2f622008505ba9754e73c621fe79c274d773a95954f385c30ba987a258a9f0964d35a2b885283d0f0ee170460fe987b873ea428710f555d733118a2cd29a62ffeed22d6e2b4cecf2a1ec98145963290673b768aa095c3697e91c3d3ba818bb86c17b52b718df26a447cb2141ebcf5cef8bf6d93de39a2a11ad99b649d8b02d70d52369c2e57e537b39f1b826027659c1a24fc888cb9cf28274f3302b0754e9c6d5fd2f3964310119288af06c4fa5a8065912b2d7319b6332ea03fa90854a569e23202f460367a197fd17b57da865aa5b82c2386928a68f066c6f8e5376d547b87d458a11770d65b7dcde473ad58f18dcb9b6a20c3809a0bb28e96bc163a053547748e97e9e3c8acf5c50f49b6bc8f021d66ba18b4aeecfbc2ad0eb3cf7ab77378de29afff77df5ca09b8d5467f1f989d10289f3db1232548c38b346887975906c66c118fb272b930c361afa9556de584e211d32777ec183d84dfd496b5310c23dbfc2b101e88c2a33634c45f6fced31df6f5a98df1c9e81353a5eef7082f705c97c96d05f15d583d9ed627608858a1dbeb43e0b637251f6af72b94a85e0e0ddf91091bc575d20e1b7d5da4a1b86435a24ffdf97141159dc8ecce89a3a2baeb97d9dd39ad4f01788aee7dabb5f5e3af4726c8d7df87dfb417a95e8476ec48609314e5b2763fb4e16b589e46deceb0e0ec14fff9eabd142708948dcb8dd7a006635e41b477109b39ea32cefdfc13a2da2182ff072deb07046785f2359e979e94489b2190de1da428a5da6d0721da6bcda6f611d6f6d98315c61f7a214b485d511405a64f09f62bdb610d00cb4ba668568d8ad2007cb4dd385729e98ea035a6cc5e5b64f19f66c0c9b4355f633c4610be8a20fac02682a7210d21380b0cabe02148d8c24cec790c9e1f3a88f4273bf22ed793a1c1d3758e21e327a14708a1ddb771ff7a28bb3521bd09d3afaea8e9906a464fb5f8ed8de51ace7dedc00934e3df7b039196f2c6be1d550429ca7333a7cf27737399b9d2769f92cc64730ceae412f11c06100511c52c05500995c55b43bb75761dd4fd10285ad3d59a11f7c9ae83403213aba4159008385f7c12a1f093d1ea9ef86ce57d02ec0eadfdae98e465bb58e595e5f60994a1ee9c7f128e9a518ed8c172944c7f12e3c681a095cf35347a8e0c81a4f007db331b8b72f085aa82d1edf714519e95df532855fcefbecaa750c48c13f552777965ba18864edc7949074667e87efcc6fb713d04ef1d82fcfe36db9809bb5a0cce850ce1d1fb413d61e34bc18ddd99cd747cbcb68d13934f64f4d2c02182339cf49656fa4b3f65030d2eb276820543df8d4ca24b14ae82200fb111aa1a90bf3aab06fee9534ee16906ad3aa1f9a226cf5a952a18bf774b7324b54cfd97878c7840221dcc1bc7a6ce6ddb97dd7ec6f1fcde8ddf9a4ceb9c9bd126b1a92a2bed0d3a284f7e025cb47545fa4eedc52b8e7ccd32f8f8bd49adfcdd8eabf02783063e89fe0df0788eb0fe50d8955a37e86ed4a9ad70b05c77002991cc17a1c5500b30427a4d7aff528cffdd2fe9bbd496482f01a5c6b4bdc30b46a1b2849d258d2b6554226945936654f4caa5174bec9253c015ded7c19da4b853151c88690ddb50558781eeeba126536723ce6787dd95ac1ff9478ff8d8ef928985aafa1830f261577b221905162def1dbec30a586f3781b8db07e1db61e54119ded941a1ef5c348a20fbf90fea1c4c2a8daeeaf6aad8aaff7907894f7b371a62abb8d4a041a55030a4e17174c0e57d522a778f0190ee766dec7d1818c881f014ad2d8762e09c89e3dbc03a053c82b2ca5fd0655a949ce229b72e6d2c918143506a00bdfeb579214910ad2e96b40706e1050ccb8b0644e05271915e98371f28b26d0a5f496ee4e6e0f3d6abd947aba32586d1e0d773f2e3e90895bc65d4b9c986c92d24cdae60e016225567604afd9c132e32f01b5215370240613af5666506010dc63ba0633db6083115105743944288b40e53d78313d1161ab78ca1503abeddaeb11b552d1a6f431931f3d54b3d1154369a58394e31d866ea224afc4a0e66d0efcedb06149210e1898e0625d678febbdffab4e8e463f1fb8f3749faa25f49fe02de86926d23f1265346ec5baac1354805920e5f87efa86ce258c893209d94f289fd0a4b140a48e0a3b497d1842aeeafa7193e569cddf2f1fe7d3e855733255222cf2bf8e86a5bedd43a2fb5ccf5c55a38dfb46fb3dfb6619f625b29eed36277841bd11f8e3eb48898e2986ed99d748780380b9796fc282a4563e2bb394dbfb86db8bde8d5d9d50e7a75c4e56df29ab6d096115542e4cfca3472ed21910a22a8fd157c403bfa720acd890415202aac5cd195979cec6346b5713e04e3f58140e9fb28a1170a800a550d963a954d48c5fa6e4175ff1299a206bfefedf30a53612b3a08be382eac1761f10eeb076349de3e217da3de6b4daca014c183389caaddaf34217897fc24d9004bfa6e72798c06a100e96b1da887d389773378699933197b4c1483bcdb1f8e23d1f5b23ac6262fd3446076f6354c97b79f0d207b0627dcb4a013fc322bad167b787b92b1502256d6e21ea5783e633c65df121d673f821529e8f93d9135e5a7512b33c5a52abc11ce1d097583c684b03b5983eca4749d45456833d7ca6be2a0fc203dfabf67097a1bcb038ae5e0ee0ac86ac49503f32017c9e8156857ec9c50adacba57f09e8de2db9065ca19b2adf3eabb41c1af02e20436475b6af658d3b1ec84ae9800a1d8e3fc5adbaaef7c0a5493266afebb215a569a499965ab9f92334920c4f195301199fc0441f5e03fd52214e811e058859e6e98fec91fe47316a1fa0f701ab132d6cd55e656ba4cd11c2e6b3a32eda561ac94c98562ed607221c9a27096db782631c9ea0125f6194b0eae6f6ffc7acaca4668b03579b4f271e8574f09737c3b9e704761aa35551db475ff0e51a26987092fef8430e5119487b177962b1c12c244e62e1fd43f66aaf293bf9f094cb1c5fa5a42c9a7176025358acf7ff8274e9e5b85927ebbe4824c248f301d8bdeb20dd21a4e85674337d825997a38173a7ae7a0684bb0f5106714f49434bda36ed696b8b4fe10c3559178589c67e91d6dc2e4f339ddb10440ded9239e758743efb4ac1e075e08c7d611de065834aba5e6263bd81289db57ca82eb5f6c621556b17be9aa802c277288720ec8f256eae5ee464fb3ac1ebf7d93b35c3026f07b8dd30e841abb929c3bfbb7e985454aa26ce289fc65fef469af621401f06da081b9e76420c4bce3166c9b504f66ce96ec54324f29e28bc2de26596f6494858d0ef7295f598f526007833a7283591d2230f50beb5cf237c229d9211502301cbed7fb28b514b1dfe4e6a4b8bc256a72ef15c653003d505b92990508d8d99c8a828f69e93a47ea9d3a08e70460940c51a5f8c59377fb229bba677257a6c15e32ed580e2277e7e00a3abc5fe3c579d238e953d3f24befbc884920ea59a3feab8c56df6483efd7f3f10f3e38dfa7ad3d26a7a6c7a4939fe5f57429534a9b50002118862be26d3a3b8142e6068df939936445ec51852b3fd6c7fe45d23af028b7ad9faaca347390381814314ecc251facc9855e33608abbb40e78d50ebacb6b830676fff47a9dc7d86b0b5863bf26e0bfb514fa4414ee026369dafa549e9d53da18d1c723b66eab212679567df62e00452440cff3afdd8527ee373582b381f7481b083d1a99e7f4eef366861b6be13fc77f7f29089b2671c81271c5ba88ea02693a660c2ddc83be1b35c893d27d35ea2424c85f977de04fb31d2489fa3076af054b68e78310276c2fcf442ceea0f81e5da0eb5965f46e2d3233191ff8b4b8444acc33c48b856b604aed237e2188d189ec6dfd2013b8f907bb95038b68af4fcd75f06336d10b623a990d3ec5b6da3f76a0c9fdd55d7ab81bd13524a66ef52dcca02daa5b5544d7b7c30e75a60f848e2b3225b36f0046254fd57d9a717438442ce15a6134ca215638daee2b7cf93f1e70184ef303bb4766e7a07eff08d53ae0bd1a695dbff2457234d11a01461a8655d84adb50b0de92cd1480d8f5f3989b64f4ef24c668d0730f4fd51c7ca6e59dd7729f8187ad6787ed3cff2af4aa671238401c285bdc8e6f6b16bd7ac24cb5738ee88d28ca8260f2bd53965f86d268935f0248c1d47fa6266c2068010ff561893937c593a184b2435ccb8005b4a603c8a18cd8434bca449a041b0a939c2df7cf97ffe959d80d465f0f15be423e5ba591cb46640f74ee1c1d7f0f56eb9821ba827b118db93262da73cbc22cf85a9928feab16437792a5c52556ca8e4085a8c3a5313487b02f62a17907759d5cd5ab904e3353da7e75432fd344321bfd2ffb88c4bdec711a48007e024162062d4eea9d2c162f9eb56fc94877bc2ec998869bd6492e50280f2970e042dae9c50529e8a0d06b46f7d5f2dd0e64ac3063fd95958063b7bd2edb8223cc77a3d2b13447419b7a03a1ea24ba795b25f4e3f528edfa5cdb759a6efdd133ef91feea5710eadbd8e46b35085513faeba97b6c0396e53a708d1a5e74246ea160d9ebf70db5e468a4542bf6c5956de5bce3196801f51ab439639b98b12613bdd6833da45ab7473eceba7250d39266f6f3e213fbbd2d88dbf5a6c15f8159547aace75c7738fc20aaaec1aa0e3b903a84a6ab0a35fc81d8dd1d3278b8ab46cae538b6ce5c8f4b4aa765e26e82165d95e19d832cf1d6c2d8da9c50b2568fceb6bc2ec87d645c370baf0a3af67e06e61d005f1d271ebef0fb14d750ab38b9f4506de722d6a0e0e76b2b48e0ec22603f30d3f08a402cc5657cf3a9e2aeca244fb0e96dfe64a7da8e7d08992ed1c36ec0761a8702fb6b93261120936198e6af89d882e2e7b7581200ef232f25863d77240132fe03e2e7043dd7654989b70c3696b9d4b090218883a2f7b474ce4ee6cf9fa1017e796125fefc45b69944683d248f19820a9482825dc679436c17effb404ba1782a523108938be27f972321f6cb758a040054be21baf4f4da60a64a4afd99a10133c37c0dcedeb08d048312ea23d378e23c80eb3d6b4543e89663f6da0d0c77e367f64b079c8103f2f6e8dcea5fda7978bca246b4a04943b275883dcbc0b4248ba146b4620f98f6fe6a3d1d35d742380fd957aad5c1d38af2f7f33fbb810d4f60a7501c37c45abbe2d124d064eca724687f7bf1ee1b712cc58dfd3e7db97a11ed3d96ae03bbc68d0dcbd58fc4af154ef665c404d7297ccacbb5519c7e7c9be5505d9b085523c928c4d7307a992589d17e20a754a4fcfd3827005221ad31a27b379cb1c943003fdb285e0b222906bec2a1910d931e597c4f5b6c03c7e83ee6bf52c27ddc6ccce3a1832474112a6aac86bd2d9b72539c103294cb69d2495e7edb4d04193d2c0c900eed5d0c27b90ec49efcd5f214e02bff783be36fc1f83db60bb425d55b1585741f6a152269284efabde5199547b0e1381da89621e00dd223cc15fb5e9389ae8f1d27c3204b28780060d1e7cb34e89abb37011e518cc6063e03c827d1e53da68bc870360d946bd39cc9d6d24a010d54ba36a8da79c8c95721cf0f9934c2337a32b55116189bb8c0253e3f84bc9ef81b5146c349592d433cc228557a69900c0f3124560e61e0d57dff8da72be2c5d1e09507ed1936a11ef3fb580848739a51060d33adb6bef8d073083a77d0bcf256f485c3ed450621a56ee90792ed348d94730a1049b8f97526727f1545fc2f0a9a6f68659389e4aae5baad564182bd1e249e9d475fb6f2ba9073296d5f70f22659f13ef8507df0a8de7259ac601d1873ad07a2a413713a626b200ddc397769f5a90714e9be892b7fc1b41a614f95b467dabf3fa8fe0016766592d253818968b7da86b400aeec271aaa98a28ae7532a18f8e749e66a6df8b8e0d603b067f3f22acc51a0904df25f81b4588463b91adeefc2e16eaac09c1bb65542cc854561b671934767043994ce9aab6db1768569945a94f20d6da4f266af376d56311d2f98942252a68878fdc066c525b2300890e486184c3a9b5dd9fdc4a417077b5bc322ad3a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
