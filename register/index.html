<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83239a33f34f5b14ceba66983daa08aeb10edbed0bb34219cfbc1866732e5c1807ab09e505953cb23132f52da99ee4be2fcfcce359a459af84c732e2b2f68210024cf51f2016fb06b0ba7f5a6c615358028069ca405172febd04a9ca839f220ecec28b13518ccb2904d957b526c9debc3910feaa7cc43b176bda0952bcaf3416f4eea554b08462ba4deb91d1999c861880b4eed7dc9311df706b555b75eab290d8fecb47b10afd9e2d9c1ea3a67f068a76bcf35e8b1af752fa8f801865ca44fbadc914bbf358f28472b9cc113a77f5e39910ca72a88d2f5d967cd09279906821a5a17a190ed1fbce603ddc3dcf40469b6e6613907cb95362b3418b16a86b00a0e6e0d0ccff9c6cf3988869a0e235bab0eeb285960a55920125239e29f780d9d299833f748d47782f46279b9a6ffbb875adf89d6a16867396332de2b0e8309fb065b129bf9ba5ccd08833a300caaee6d8f7a11a0c87a314307e8f4581c94664f7542b23a7d9707547c026dacd6cb69d5bc7f58946daf987fee06266edcddc4234b78d7bd132917e470b7c446c70aac1bc6d4872e68691a7128db7f2eefb9d3da2a9dc0cca9f681eafc1aebb9d4a082ad9eb6db98673f9c4019aae5a782cbc87ca71b34f4c76c688219cb32d18f3ac8b694750ca8698a4caa5ed528cdbf980b65287f2d8d2dece17a8c7ddc30d6aeaef03f73aa4d35fb3317e2f676a723ea6a19f23378eef8ecd756059e29d130993b6e3e4e1c2bb5272aaa668bb50387376a842ebd8841abf2d88b2ccf257935ce35f1198a364ed28eb65d2f7cc752a71d31781a884e500a1b69f6026f0d1a9069b49ea2b146459d109f465562ed9abcb1a03ae17a2b4a9cf5955e9f4682a304a27bbff71804f595a8bd3b7ce15280fa510b965504a6bbb63cd9f11fa8b8751cb5a211cccfdd3b37e48ce0f11e3abcc72d7e3e339fc8abfde95c0842593402f6a2267dc8107b2c7e27dc732d636fd76049aeab639ccbdc0e4e48d7d4b8fea17bb07c3a92bb8034060cd96c25ee8be5d59b032aa6cc06ad6fa9f0d92c6bb5a3d2e0fa8c96d79c955e47191d57d6277f9bf07adea3585128460ea03331b0903a8de87c7069b4fbb534d33c8db030bdecedd44bc5f05e654bbfef325e9eab2bcfdd9bbd2149dda8e43023b068a3d33fc13f11d6e40cdc701d257eef5672e60e913418ead711fccdd417febca187faab3cae82d245fa735e8da9b04c1aae3c758de4e8dc2385109a9bea8ec19abd2b97c6510d3a0aad17e00c6fe4ebdf9a1194997c85c399e6e234917c6c2a7df16a68ebfafe76b5c0cc5786deafbfc696b5026d190b5483b5518b82f97c178f6f70f3a30ef0b9466f700bdc01da8ac46f65b808b928776ef9966209ba513df4d17fee14b0cc8d571ce29b2122c7457fff26f2141a06e1cd95a833826b8ab8f0f0b722b2f942e16e1ed3e69290db79b0949a6fe1b779203c609a07be69ac4fa10edbb40cefb36ab3a68bd10c68adf0344eb2b2ed501f220037ffdf796208dc413da5ec79184572d0a4959ee640f77d599f0ca772e04658d3d415e760ce20d3241c28c452f457a78850b9c0d328fa19f959cd336ea8de9e159fa86d2dc7678de48f8132a1380e16cd22d2c1d459443edce0afb83e36d66c1e991b8a8f7774c187a26d5d3cbf648462bc080622e2c8b9d68f546506646207067026e976109d1b3822e918791b69348f9f84bd653092bcc71d7a0396e5d994c2e5ab609c0de968671b2709be2fcbfc16f9b34d72d7a39c81337f80e47f11c1cefd04e9c926c3c96495283631538931238cd80d41df05b529bb4b987c724af83ca1c39f35fea33b2ec088d0935565bfdc9db9bc9fa8e5edc44c08c3a91304ddfdb1d35f64e810463659db7c7086dbd15499cf9facbea28a5738c661b72420b4af1dc1c651f9a63ad4467ecee3a223472ba7922c6b61c96a2d60226036e45519aac5685cfe9cd0712af63f56d8912162c6eab3b92faf1f6c83f9999cf9cbca058c24401aaccb03111b960f85dc9b19b5a82ffb34645f45a42e725f47101b1f238ec1ec4d82dc0bd45ad3cb24c71284052736bda8bb87841f119c53fca221320c91058a54549789069e87c8f567050a8e6db940a9cd73eb9fb33aa282b5d51de6f2d0ae598c946c0f303e7b4695dcfb5008854d46b129b455f8be464b61ce19257bb5e19a0d5461644bc4a3a1d4266612650bc286786e1a9ba7bb7cd3d48b18a58329499c20adfb2e7d8f556724372abb2f25e70307b87a190bcb1d990c2f9fc0e14130b73eab16bb27353831b8afed5c081c817c49aaf297acdccf79964c77cd97123c44be83872ac25b5521d3bf042bc76ab5558cec566c389895d24f51f883e8a5ece9fbcb9df41e1dd86215baf90ce7caa6e09533e86f03de57861f14e50f545d5b7a562b40b2d949df868abddf463c7cfc427fac52b5f2da489a701d67868ac27351dacb093a92731e87837d190aec7a0369d23ce90096e3d0c31c40f1d8f504a103a60e0bcaa59fdca90fdc97802f4a16b73895181e70b5d6b32e7877b8d4abbf35b17fd5788e4e6dbeb1afeb15f6c18475c16f456c8e809086dba6a6d7d7c8fe4b8134add9731afcf564a083104bf5da144d1c5bb2f4858e259205cba425c72c96df048c2324d360d78f63a36952427453ff5bf4017215265cb40117f5ff499ee17a9de1ab6b11805930de399b121eb31e8e354e43d75b527b7241db3bbbf0f652cde57ef02346b14493bc7e2801757195258e4ced5664cbb5b1bdec4661e41940ed379c40986679dbd9c5a0abc8b653ab1a7626852c80b0c5dd92e8caa8b9883c0a00193618a0f8fb05a3b9259c48eb272f62a8fd3f678cffea178f08709be5ce0edfc14a0e1b44d342e9ff7dfa8b57e408444835283b4840aa06ebcf56c0ba868bf42ad04b8811b2377d407b049b4c79f80b2450720f78979812e246bc1f60075bdaf2f82f424dca5285a6f2061d0d7d0496f14f12d728037cff021c9392e8484b6de039c788d64d09e4390be840d53233f6f78ba92967cbeb43727f56fe176b6391ed9defaa41be7b392b268e2f62406e64dc2aae677dd3198572acd81463f1d09baa9fcff353c99e51ac0398a33ade35c243cf84758165e42e29c71f0961fb28ad0bdcbd4289351b137fe3151a76d2f32b35304cfe6e7635bd5a04950e8d98b7b938376c10625b69a7a72810deadf160e42d5811157b558c2967344b00f499ab2e86728e0af25378a6b48316119fcbaccffbf194f1064c2f71f7588707d38b7881ca6571f558c0de3b9919f31f3a71ce3f2ba7f8b0e9c5f172d9ab598585fb633bee0cd65ac51239c7d9791cacf384173db5753aa9c820d5870f886f2df5e38e30f7ce9e6949379456bb3ba29c71d36afaff4063b802b2edf5f95f8729078e691d6628fb3edba538a1eaabaaa9f6038e1fea650abe53ec92d459a90b38a0721fde14e59985bdbde120fef56b2a751532fc05a71006af742d941c21933394e58472cb3b1876aac51bacfd1c03299ee42135c621edd0db856ade4bb4fe71b800dc49035ca72fef354206c60f0107ca7626fdfff9b59ab7df71ccf095e8a58c38db1b0c2ce18abae205c6d10118775326fd071030b43ab05f49fa85ce3bc7b1d4f73cdba35e6934381548d116786a6a60336c6e576bd3cf574a719c92f362251565bc7e876cfdaaf8313c93903ab4dec4e625f2136c237b2a06cec7713b7f67e4845b46bb0c938b21fa4159461a6e1d672ea7bbe04d5a9eb8e811ee57555d988ad31318554a3640c56d136e6ff348b550346b09c82d9d832da604e423ee748e79c0c365c95ec52f793bc75f811dcf608b40d048ea889e87b2c9e09df8404258cdcd6fa8c4e1787fac593d7f3550d1f591a6aad75c4c2576cc3baaeaa6f4143702f199dd3cfa26299e901972e99664c3571c54df1e19a06c24a62b3919c373b385b00e0487dd235bbc8b387a4c3b96e0b27f7a501f57974563fc605b3fc43190861d8d58658733c5d2f3e025b063a369bd508e5b5bec19448b67a69489d0b724c289d4868879d805be14e4ad1c0fc4809e887e7722821ba21de73d38c50b8ae9cc1bb781d14c4cdbf9e0367f835e040e3301d129caccecddac5b037cef5bad751d3372610588b22f61aeaf0990c24c7d46327072712dbc1ea5a934823c2b5a43c7bfe4b61943fa6aba5b4a4c1da2c0dd669227c9e4a8fe448d7a370c5bf2c641e2e3300bcb714a490d9e4d3c61437420df4fc78ce8b23de9070a092ea3cb394ea7b62efa189be3e233de70200b5d57b69d947cf7939b482e62995798fa0bbf4bc687aa8188392cfc0e5c27ba43c739b1ffd3f949fb7754479d91b11a7ac3315375697279ae2ae4e63e7d5976c86d9c9d5a24ecaa4deee731b7935a243857c39a93c1f6a8c2929bc74d7904f8c6809a5a4859a77b33c529900fd2732609e1054305b178a8370d2191b57a6875362de40faac1e3cddff614f0b7075dfa8387769bca0194959971508f0fbb36850ba3dac585532b9c48a79c54248867f7c440172fbe7101d2385650f5ccad59c5f3975fa7ab57ed718d9d34cd4a098c98b60056b81152c865bfffc36299ceeba6e0caddb14f6c308bbecf308695bc5345e7a4721bb409fa32039346ea9cf1f4ae6396b2e8125113d8b220f149b167d2f657b8db8b9754b3d6e1168adc28ffe042a60e95904a406836f544079d906d031d33742f3a0661ba5f18b4d4952d32cbb119e793242d8699d36dc833d551bbee9ca14a20fb60ae41ed3637e52bae3bbcb84ab6a22281076a119d84f8feb8e0323dd79db082adbf79d844b340cb0b6bc08740c93e5af730c950e4cdae42e23482fc7e61708877c98be66177d0d1768cffd7023649dfe26afe42ede30f114186349f84df4085c5df41e52e328f7ef3e090315cfc480e2fe1b9bdd265861fcf54a3ca0b697e66c78478c6ecfbbec050f850a3ded25dae77c3839000588b9eb43ad19feef3451e05d387e342e8a01bc9c49c0153ecd20c624722c27659b59c672bba258618503df2e33ed49526acb7f6d1fb2d01d3945dd54fbe0f6fa7a443679cdbe133a104f391387882740a33a634d497cbdea243aaf3f22605d8a458999c286c3b5b5c140f641a494bcc51e8abd8fdd6e91a2106004babb3a8404be61c31109ca816ee2429127a5c05a8701bf64a3bca58386f100b7b223ecb12f656677fee55822da231c429d67c3c8a5c95b3c17a046750e0cc6383669e8f19c7d568759a657b2ff4696dc9f987684d920040e3543f20c33f0c47fa2862278e4b160a2dc5c75b5cc5a1f2405135bdc792f73b70d5b565eae0df7e61b5e91d476775b21118f5b53a1d12058d2ae4578140719ae5964a678fe07dc5738c7b21d52f3b0c32873acf72a01f705ccfb37d50edcb1c3a9a457be417e852a8e328ade035376c9dc7ac1059654837178e88a05740d956fe817a26f4555e69de91f51e3fca6234387cef512871065bdc1fafa34edb3bd9d57ad0d223a4e018d2eca070701de027df1563598c88d8c521c1da0afcf632d765ff8b163a180d8aa002ce72244c997f866f45c534c4dc9dc3972b6937d0ac63fab1d91bbd4560a37a0f24c9c1cf498965febca8ab8c903b3ec68f3d3297e911ac7d9ee095bd0711e1bba94b16e31a0faf9fd3c5df9cc4a48fc2b66e578c39aab55513b08f4a2aef3368d5658583527fb6312f7c21b6474e1c61cd956969af00b700431f92380a94c020ff8dbeec61525b67c93da835f760635e1db2d94af40454b7e6af9fc630f73784fd21ac0323340c28ec50e9063ed74aaf0b2b089f2169ba6a55339692435d5c5eac1ef996f1bafa1d7507328188b652bcac1b9c95a4a65dfa18dbee15f3bf0121e4d1add9224a720c41d19fe5d7edf4a7b6c9754d94aa65e44517cf2648a40d02984a3ca5cb5c9ec38183c904a4e544a03a2f928e1242f3cbe3e52e63334290d6de7c560695e2804dfb7f2e653a199036f4da428f6a1c1e8b7b7c8ddfd1544fa7f42353c3e38a45b3b403cd281600244a7122beefa14306151807c968c60b469a1656c8d3705626de19bd4163c4a847e0d5a573916d20c8bc7a7db26eb346316c3aae8171df80f88a77e8352346b0788a6d3a47b5f861d6927ad34a66b342012364ce49414134563ab86d5174eec23426fbef63ca006383f5f151645702bdeebb14dbb297d983516bd9752219a59d1b2e5eb11c83b4db4c214f3217188ab641ab2099a0a5883e6ccb8681ce1473d71a7bea802b72a3f3c4390185c7bde95b1b2ab677e330e3c5ad4e5ac96c405e01da4ca22f75f5f75e1e9761a89b576662f8722dcef363656d8232d0ca0129e2c21712001500bf20e7d4e160f733779e002b522abc0cc04aabd45ecb6c6e465b35f28433cc85466dfb64ce01bf0bae562e90267e28a73094d3772eae84c942f661ced86f2d0e2ffe45dd9e905803bd5ab20d18a26d7451981d1eb95036c4579c8cd9f448175b3818443c9757bde379b05043ef049274f7b6bd23bf51622cee3e7ec06840f7bed8eb4944d3d759f8a577129da798352f5a76a47dae1d2dbc130c7c34a43e4e7ac59456c8d85945411c7b12bbdfad4e4de3bf9df52b25b310e6c7b32c51442493492a20721d5bf7b077ba1ae75747b44944afb029bf6fe503d0b96ad68494b65969815971ac1883cf21c7feb116af94ac36cd756f23761d42fd3310ad5fe0329c6f6ed3c97ddd6794c89acbe72c9290517744c3077a777b5eed1bdbc0d845df43f6e47c8b29d97a614ec520b1d7d82a493ccd04bdb718c232b4c58f9b4cc36b92b9de2ed18976f2371584bef739c01159c963b50c51ca494df8d82a0a29e65a8a74b298191243164fdfa9fc3b25b62c6c97c1b1744d23777a01fca2485f946a88443810055ac9283f9bf0cf3a2045038eeed5ee3c9799801c9c5d76bc5a866b9b313e6d68dc0a759c498c0ed6f96396ab0dc8da96b04212f27ce70730ec5f8d9ad6ff2fea08f14b1ff9abed015f7856b072bfdec30397ba18d711e8e3a8591c502a2441d51b38b597ea583bea1f2db324040a4a360d051bb9d0a27e44888165d795cbd8a328ffcb745b3dc954148eb72ea434cc4f30eb56cb74256d92cf0e25a4c8f36e431f9c1255044b8a60f08770ebfd6a515ffe502d4c4fd188d1fab5aa56177467ea76f90edf589fc557448b4067e007725b8ecb23343822e961a69c325faf118ff73942226ad694bee970291a43a16ddf6522a9284f6196cb4d92f7350eb0fe6292f61635c1a37da1a13083b30ad48bed49f39c16f1e40fcc9b080431d3077ad2169371a7e35bad32a321ae47e04497b7bdf7e358a62d23f3ba947aa7f26d7fbfec2ca582b7e01bb83c236977b8145150d113af6485200ef21220fa8dcb7f932b137ce6d6dd7ac157c3ced13bfba0aaf9616f267b0387016b30bc73388a8b72acf1794d2ed82bc0dd08428f22bf6378388e5bfa5bb3514f1db30e4513e558bcef1e1b4df7876769d95b1a0d8371d263b6e11d223ee54928eda98dff9aee670a52598b3c3d3f47979f4fbc0204a2f79bb277a604e9ea1b6d996f910adecba199b28f9d4b7bde1ffa5f1ffbc265f9c4cf11c4e0bdcc8e9236cbdc80759d20ff3401fcf3d04973029b096485abb8e6a3f3ed90551bef457dc5d8d5628c65842286a7ddb908c651bf362f411d0203385372f506318d3156788664b0b16e0c5b3a1aebb9f6e79fa56da5b744fe453ca774154526631498955b4759e093bfecaa1157e0005b31f406c141093beeed437e01f6f98761a2ef386a1540eff7f4f148a4c6b9ee3efdde84bf1e0ef5fce72af52bca3946b407415107360417291cb07d6b075d8f00f510186f36fd1a28807b3e97f5596194398766ba341f5f42a84f04c85d94cdf09e309985d85ef84b41e035424f76fd56e82f8239128dfbba04822fd48f59a91b41cf938bf68dca466ce648abd5dab85ab10418095821481886c1a2b5f89b8b3d9086460c84764b681063c6c785bfe63efbae7cfff83b70b84095eee1fdd091b0505b6a714a8e020015c492d647c6d24df6f2a255e890e91bbcd84fcf64f67790dd8182c001caf3942fe5372ab8c11fee84566e161a343ac5b99054a62e7fa74aa685193016d21bf34db4595c18e081033f19b92d1df0ce226b45dfe7d5aa31167f72e3717da769242857a7115fe8e2adb707889b58716c0529083c5b1cf8e09447e49873c3ddd097b920682de18632a4b529c8150cb568efa279cfa5be578894c1018e04117eafc651f421e1f1794e5f6e8ae5b2a35c89029a0558e1912703a63bff4ec6fd001c8a712c744b054eaa2f60c84705196fc688d13274664337d81afbed1944653fa1e504cd378399a4e83afd4a2566e2925cfb3b4d58caef1d81fca19b1c8f511a486e0cd6f481dce0bf7123a70b966fa4b6da381805f2a7e092cbec4453097221c6864e40061e6694e84e3c335e4fd4f94041d91dddcf691eebf5b8c1375f7ace799f7bdd5d8495db87bda38204ff9860e16eab4d4e1ecfb52f3b5eacdeb92900a2adf9b78a02a95a2fb8fa939d33324839503fec93a265d3b9cf11b831b78c65efc1033673e7a1d49e5cac2cab3acb6508cbcbc6c2f9705c1179d541dbb2f2f252c92adc7f17b79ff5da1f527dc125899c188fc440f63d0eda93dc75f38a404e0f4decd036813e361fa89c93ad5ba33d8c78c9618c90f22b0e9c741da725e6934e23643e4377f0f3c451316ca714630d81c1104d79a66272f11b78d3be1d554e911ff86678821b6a5d57b99ff565aef2c4d737a580a9d498bdde51d6c86b3228d39eb110ed23b17bf43a609963bf5862849ebbb45dd8361f839d59c067b87984282c759e2cfea020e6fe19408fc63d13e75f5a2a204c0ee34118188afe40204303c7c7bb729affacbf4ddbac22a317cea9735f0324082cfd8c4956252c029769787b675c24ab23b14f7853efdd41581a49854588c637897cc65e3e3f0401ed5dc1fac3422916677efd7e62719c102885ddd29e66b8371e51fb2b4b4f0076b88dcd95c19665739b9776e28df3f3283980083db4115106c02ee2b311ed4fde62a4619dcd75aa90cc7de0420709ef9f19decb2603404023bcfcade9bc2d499ea37a3857c8b0be13a4ac738222885e67679e2fc39d8486166218040731566b3aca97bb5801eb30766c31b2c2cbe26de85c200855b0d2e1986ac9109e5406ee9704d36bedd26ba064d76b3f5c464250cfdbd789ee4e6f3a869b303002f055cf7b77e185efab4e068f4c308284beb96255294b31543c7febc25eacd2ec0fbcbdac230f1ed11741b838868f62295ebe585d9b4df25dea8ae2c0a97ca0806341a8b3db74b3f1babed6dde345cb11fc89ea976f34b6bd0da9fceeee3d7314a5c96cad0ac25b6db57c04f31ef35a0616d069919bf12ef8cc588c0d34efaac85273911855c35f224dc348b3b6cb630e7310308560e9f6e99f16f73d97f2b8cb9d5ec1c570dcdadb82739799816c10aeb7510b90f43a2ad7623358ecf071d21a5547a000c0aff9a23245d8a76bd8f98b4d1bca3c2596ac3c8bf6a078094b3c23f1c08cae885c979e5b999a9053541b8c82a72c4586a01f7d2c78d4f3192dd734f764d8d88a3028fae97615b4d338e035cb1d0909e21928a2b59fde560b60a8eec4ded78a0cb428cfae9df2da7028b6a95286ebf3d1b091c0ea4cf27b09b7308bbbb576e8ac80193fb1f6b287fd5fa7927289877827c082ed7c5b449293933b324067421d81e2a22ce673e80dbc9b6435425cb2339745f092e36bd7f25da5fd1107bce87b52e2126957ea136a4184f021114b5fac7f974c5dff4e43bb3702a70128899f81c76bdb1a4d5ea1641d3bd6538ec1456496f15da47d1f39b56a1be593d64e48a5b5e0e471221356112237fe6888de9542e12096e32720bf0545bbe2927f9e3791eae364af2a01320d22b80c0cde2e59b973fd710fb011aff856cc6a8a5d0b3c0a5293d1552d4adcec20530b37c6767ef30e68b25f410408ccf97d4751293ba3e8147894c97c3aa5fc6ba379d322a06a7e7a5cd3d69a77565d25ea2b5be28dff063f374694e65583e05fbcf45f0be55b260eb974d19d3ea7fe982f71cee95a36d63d50c29618274861f39958e103b79746f4d4c0f881cc5b7a6ef52ab02ace255c6eac2a134b382ce1cdfab38518946b952e4924698a62e75f6f99bea3335010866978f903fa6aedfb918035e3c59b421ad5e39ac39cf49435fcf65b034ca2147660e2740d568821d54634d9d4a82f814449ee93888fc3781dca3e36dfb36bc9924e97c443569139f50f15f6e6ee84dcb2b8257653cec61d740dcc93ada23d8ab6250f549a02265811cd8fa701c11fa35306134b9fbe87342afdc565ed347fad0ee37c12f72523c0f03090fdbbbb625ecb127202a239a77df307297d3d1ae49c1d228a5626166832b96fb62baa68527803ff6e5bb75d5f05d698c46bd12810732cef041fceb3e1bf88dd4498d0a2145f1ba5ef1c7c2e7b47b290abea70008cdeec0a53af4f56094effa2fc3ed7c9434b8aeb17b61d13e01863de646b289331bb39facfdbeb67d31403d08999a580062ad464f605cc4212efecec1653125c11312c75a6c133648499f3394ea2898783eb2dbf2230cd3f5f2802c303d71ff657838f1dfd1ff3dd18e6d300c543fe748aa62406d291e585d06fee5c99604964a56ee931380f4abc8c552afed92e14c93da20e60d8c8133993d8a5084acb8efe204d7db643b5fc98a8a2daa7547ebcc91f28c728c8da202f72e1410e95681a36b1c810014fc9fcc8a5dea40a4b955c66d2604d6fb2f6af3514c788713a02e0fe2354a0cc97dc64de98d99e0434572ad3b52ff8ead98c75f81598ef51f7ccef9df4bf894f6affde5621e01e0e5dc88067a4a5a93ee769730b3ca74876b3414fc54ef32413b2c85b91839bd9d2f30c629a539edc86290785aee70c97932a4bbedbb3358c2af22b29cbb73d0bf0cde66b6d417e5c6c602ee15ac40c40f27ef356b23aa5b0a21d98da0f86769dcc99b71d81a32ef61af66b8ed9a4f7c87b66e765b1b36ca7a7316144aac5a5d54aefd259ded6b41682d0026b332e2c5b60a3060469ce6ab023958232757cf3ca95f1b9cd084fe5aeb5b2129f1165ade1bffadd9c965ad83b95c2293c5e96cbbea66fefbe1909be966af782af65e1acc539d903f4ce8a20bc9b1f72ed562e3c558160e51959e7c07d8be9d7b885b87d69fe9bc900a4d96d5136da9b468ee6f2c046d4117e4654287d91a9147456cb93627d925b7f3290f6cfd8538b2b9c121af15042ef2fbf036aa87ad5f40b85465f77baa489800bdc3c1ba0874a96e5377b8b8b8c73ff2827e6e358e6ef405572dc85b5ceb3c49f2eb14d332074011554673ededc7c8bed22480db229054ae5d72c6e5e1e77118efd9de4fa85b909c26139107488ae3e369a482ebf81f4f380dfac62d86e47f08ca63daf6f2adcf30f5573131ae6de140684a211d58c7fe5fc7676d54d2f86154fbc9f7a7d252e6e14d0445ffc93f037caf76abad6356116c4c456fc08a53597dfe9c12b891bc27e119471fdcd94c578106b30df6673c0d23ab986fce4118e1eb91513fcacf7f415c7ded00fcb780dbc62d32337bc6b03fb36f39e476ab03fd6ca0642fe7c3c208b837fa42881b31a399c3f1e9cb08423b4ebbf492a6b8549592e845dd65d5b219c9f80b8a390efabcd26ca6684db2bdcfac3308150016293297b5d7e71bb7f6cde2fe612c3d67a6e2b420b4460def62303842ea82fc1ac0a6a4e7bcc2a869dbe3c0428085d8b653c059a7bf061bb95c9aadef3fa54c176f8ae03f0ca8aff4c0ac6d8aa7ab4c1e90fc22221eddc019fc98e17ea850dd45e238b996f5f52cc93b618752f95db94470f6a917b9d312b0e4e4809e8aad9973c75f5c729d4b0a54a56cb960ed732d017a26ba0f43b068ca9e457e9c75de662e29c90f26265737a4e579256222c26a7c9326ae44e5daa5e5eff2a7d73099f2e4376d3d372ab66b667ae709ac932eadf18a10afe6498f94086b95682c39ba1f651d36e4c56ad8521a960bcafae3dfd7fd622543aaf01e7525449bbf9579a05d70ff4fe52811c84f1f4435e4ce60be06b350dccbdc853aebe83bc2f3c6d1535ce140be310f6d81a2ed8ebb07d2fcf91deeb05ce050f6c18bd8ea45d706b2234288f800b72c132f831d0e296c086afa422147608c58d19fee4911e04448b9c2a7cb9738989f72788458a1d829950bccc8754eb9d37650a7260d4a67795a2ab4c8ccf7228d7c6a89d8483ed451f671548930433fa5bde154aa2bd5b5ad79f03841641365aacc8fc33a4d5c5130de7a3f315c7f46c066b34cbc742e8538ffeab61fc22b48fdb4a7fc7f62b29a31354e9d9683cf5e064b2591d8065d57b6c86d9e832b9aaa7e48ab7b83529afb2c5953a602cf640ed1a4aeb1a40d4e37efe9f8229a310ee599cf206a3500c225a6fc58e151265334dce8793465040be6c7be8008a70b1b47ab7d00c708783ec464358358c10b8a2d82f8d77c98215e25c553145d23a620350aa60671d884c01320aa96d4dd92837852ce45b35373aa399b18c3bdac9167df276f14567e6782fec4d8a59cd41c07e526db7c74cb232652b6f7e2ddd5452cfa8c226c654144baa49bc8c1007b7fc48f63b4882df5935dd3062053bc802c5c90a370001bdc681a16a92655e9f4578396f1c5703a53d0edc37dfdff6d10cd786711cc0c73b701f73e48aa2e7086e475c3bba0ce53301c75dbe39bcc8752fbcf6ee9688fc6aeffdf729b1e0601e90a5c1b6283d29b2446ec124ee95b509ffec044c1a99b3a248c057700c6f3d31806e8aa3d6d7333adc94fc894eab3953d28654312ad5065371ab1ffb8de3c169f6165dfde6f4e82031a270f5c1198844e6752d9e9a3265e853fb09643043adec5641e35fefb5d6f6be3ad259c9ef33dcca311dcc93bc757fc205a5dcfd5807da0e5bf4d62b9397236237b06e45e085daff3ebc478060afba75a1df16258e72f7b40194527ce87f2ccdf0978fd80d7a312b9dc2b390147876ac84c481642154105644207fe7e3c131be6c76f97caca84888e2226252938625f8ae498ee5708d055acde761f41f7f2027ac849be89ce8dabf131c01210ffbc576612d9c1f599313e3becc02a79ad59afda430a1ade39b46e9b0f18853a5cb123ed6daf565fd0e781e5584900598ac8d6f750eca719426759b5606e297a4fc85df9edcb53d1e76832549f779fe920fd4950c655c801d15b52935f81217bc17f8d73bc7a370f1e6a35f70304bd46492892154d0ff51fc1c0eadb5464b44b5cf00d9c3203f5532be12aaf5cff88d27beefb52c0fd3825c0c68cb4879c7508ce72ac9188d78381868f8a956faf86c5b4bb7949c33122f24c5e964e94c91c074e9cd83185c72acca70b83918a5c05c5c50afda634d59e0623360089d2155a6b9093ddd104679c4cd1c86ca7116b4bc1f7531b177b41085be0849bd6749b779397328a38e4a7448602f39e63aa3458bcfba749497a97610b2b2aed0e16315dd628a996090afc213535c1e432342d6d0e9005210aad4f88e54a4f749a6e209f121797d180eddd734aa28efbbd7b8a03142b2c5ab5d975537a8282491e9ae3004d5e5afb8202db5dde60a27309468b099a5946ec53575503ea188ba6737cf8e653cacecbef6bf221bb811a936adef9a3bf754942f57bdca6f88a59334c2c89e814fe4e030fc805f055389dea40c532d2d5d639efa31b4a1193b6a99f60d47ae165a336a3fb82790a3e89aaa0af0def05ffb4c3eb2ba20482d4303e36dfe44256a0b4997d43c9ed00006d20a1d9e5917a2db3088d484225f9950ef3772f341dad95ffebc499b4994c15ca79ae84e08a04b0c4bba82f2ac746e45b2dbd841bc9bb4fc30510795a568f1f9132f16c061d9a929d59feffae0138e910515ef14bb0adff00f6829aad0ca20908dab2f02e563d21c8dae2aae145bae1ca2276d605bc24dc22506b2b862dd532f102f33249172252f0534555347e2577b1cc818ed70e058bb3e64767e310eeec760ee0232400e87f4188baba6643d72c29f6d063c8501ee3332c0742aeac85d9732bed8a9b15f054bbb332482adcb65ffcbed0182efd6b0f35a26bb881786a605aa7b93f400c944d7426394258cb0939e855ac559d8ae919443dacea3795a718c78093a7bb3714922dfe4931a7ef46942274ec65f375819582b9b7810bd49d4f9131561ccc15e9b9ffe71e6319e325ac43fa01857580712e2a2abb2ab68474ef24970d2991cb1dd7e27ea9e270648ef6229e04be102799ab3de4808e38116076462a6095542b7d3889e1ea1864ccbffd230b3ecf1e264a88bfc970c5db5f59ab478ac2bb44348805efd159eae28cd2e1c994f3227b535c3c285fb8038d2739f0eb77093a667e6cc1ad055581a8e22d5ce008c8256cfa4ac90155d05d73d3adf935cbbcc616673d44415bba2bef8654b3d1ef3e24a5595dbf2088b9ce6038213dd5d2206dea5c0856188343248ea418714eb45b02abb4c33c8e020cbfc4ed9536624332858820e59ecff37ee48557a24657a69136db2cc33bc884cdea65fb79ceef3c152a1e0cc04afef713fdf0f6033e01995d1952c624086f861e895be3b4c8d85380930f8cd3a03486f20795d512f4c6935b9e652b8ece15d2d16399e2ce3d42a4116809eb4e012eb96402a42fed97812b3b67bd504b1912baa3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
