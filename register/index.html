<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f72bd23bc98e1b0722a5fc537fa05bad9db51d7f53fd879910c7e7b7b70f6ae599826691c6222aad593b1e7f36f99fb5f4b6a5b8b4d3112a77d2939b13126c2aca1caae37e73c0dbcc8b3a50e28e9114e61e561715d83b91c62a677a17a719fc8b773e16f6e355a1416092ce59b1e03c5fc4d9b9b7413b79d9bd0342dc41723f3a6f6793078d298b7d631b4f5348c20055f786273ca9c96fc0e43de489d4d40cc37c6008f97b14527b1680964b9106d3a15ec8cdad9d35a78e04e5489fc21ba5848f14bf11db333319b15dc9d989d12084e82129843f23fb8259c150476341ad5b56f38ce0c1b15b945fb6232550e3bb8844a86a83213acd9405a8901804c1534f5231e1a99ff63ccc2108b1e584b81a9ffdf783255b3d2a86a6801cd033010432ce9e8bbe1e0e02ae6704f0978cd81fc6b8870c57566df01eb3408ad721a9fe831b6c20c146ab3831209c57997263a07622c052eca81d588b2eb5ddcf674fb8fbb8270557be21475dc1e25afd4aeef0bdba26311869e006dfec1af0c18a0b19b619d4cd88ceeb9f32370a411375101bc92ac041502249c0b98152f96ad570fc7eb27dd279e5715a76076f3c3b66ed3ffe5bd2e8c125c489641456b3dbdb7d8c8dace7c3afbfd3c7fe94a5ef0eb77c0b0ab3a83c66647917c0c6958b9a9f5d824b8ec4667d122898d20af5c8464348c56239696f9e25ee602bcfc16741e0de68479d469efd8521612239eb36a5137a75b11a8f2dc42c1dbf60265fa97565de78d2b91a4a74e14fd3ec62aef10924b00091c9d55fd97cb57df2b4325b3e4b3389bb36c397e5656ea2216f239d035bc9d726c971d9533a264ddbb2da9a0351b171b533648d2ebfbd0ccf4b9dc62db3c947ee2203ed5af7dedcbecb13b4fd0fcb1c42f5533c17a625c1a107a9c879722440c32625fac418e658a6eaadc82119780709edb935cc63653eac351f5412a3453b1f9795c2cd02f153da4d0dd0b3a92584ac87ddcd503e1dbee8dcf8d12994bc3f87b9a8fc964df0bc38581dbaf24867ff122c64ce7d47c8b94679a497fb6d0af1dcce1daab0b1a48c935024066e548eaa656167814787f27e3296df9369f37b40f96dfd52f973af4eb9163dd722d7c05ece6d7a12bf72e563d97850102cca76e53e1a1765b48c74457debc1a3d0cc9c8ca833777803d2ff94c0fc4ad82d7daf2bf36d0d1fc6744db7fd6e02f04d4f01d7f1aee6a9c3eeccdcb53a3504b5bdee941498dbcba4745629102bae57240abe3fc80a6ee0bcfb324f8db07a999b3a57386d1b00499b2b4821fb7ea5293e4751c790bc7289a5d3051436a6813bbe99ffd5be73e12f0c392b6be59bef0c74df69cc861b9ef13a81c569adb180e98b88f8eb9dc3a21dac65a02225fdd99ccc97106f0a909cb48285ffe1494675f3b0623dcb4a1022b5acef3ee597c831c971fa68da20562ec481e4a1b3ec645a9c0133f59db3196075aa8363353db0fd2597eeb2924aaf7a3c1090a1b1e4b530a4c387783273b86013935a61e61b5613089be44fc51645f505db7c1904430d8503cc0685e075efd080aefc5625221dab40573cb66cbbed65fb0be8fb2151e11fb4b2508988840c49609165b595353c25ba61e00fbce24bbffca8d68ead72e454efa2882acbc5cac2c4851daabf306b7a677ef2bc25dea51b9e7114f7ea8bbad8981de91815735c973e80814a8ab013d59f84ef8a76b7a5bb3bf958f983a34fc6a23629141f9ae8b1acca8a8b9da60591cfc300e546781b6cbc0f8eec88dca262e30759e4a55ceacf629a26a1917d4979b1971445edd0b28df861782144401f3a6e463183b4543067353f4b81e35aee8a59ccf45c40353c2c8ab6c4f0bdfb3a4a4985f6c2939a24c7a1928f6b5d00e9637f6ca9ca3d43cad564c5fd8bff4fdacac254e5842f3c1a4a85899d36615c32085c501afc7686251ac62c00b6baf6bf043eafde52d10ab97d82dd68a7b00d291a344b6891b888f894d89358751985bcea31968273aab744c396888b9e7eb309b0724d5d8d518216461d8d91ab00c50142f228155b202b76643c70365849100c0229ca08e783afd398398f624e1747f4a6c9aa94f2690a27f54d6897128bcccfa347a9417a35be3932dee72f5d842cca660e299aa3278f90977a694f4047d0ba2de9918d48dc9431b858f0712ea7a849514c6c9a6dc52e08c1212d54346bbc69aa536bf9ec29be06ce8e9df160b803cb3b26287e64225d9df54f280c9105ab1979a24eacf830c2219c6717aec05cb1631a505c6bc8d63fd00d83a31f9e9a25f2a92afd78262957374bea6f7d4b0f86338b4e4d0e8d3e65a42a51ff5b2d3e67a22a649bfb384e19aa410ed490c69141902fb833e15736c0e1d4ef03c4cee9f8a1efb01fa92f414b2ab944f8c2067dde36bf4933cfc2e3ef9dcb950170d72f943afc12b381484c1ade5d3c686c4e6048eed703bb2224bf5c40498ebd5e0e74d1c66c03de701e13cd0a00495c089320843afcd1e1decaaaad3a3253af08bcbc1a43bd286d78c51905c7264c35c4bf65e333837cfee7617dc7920a91d18edcdcd721cf9db9e4801144795c87afa5976c34260e51855a3c4bab6f70fad96c349c2a3f698256327a723b7a0647033d4a7d6cd427c443b6c2f1d468b6f3e5e0853d1837a166820bb750949fc323e5ca701dc6c2c391f1d262094bc69761264aa449cb14823a045cb5fb4fe4cb919a7e80675f99f9e8512ada1024f0ae16e6c4522f8c97f73d7c57abdb6c6497d2c473ee502535773320ea9607e7bfc8eb9a56f3249996f209f62d59d31dffac60f730b753106d286dc121872b12037247ca1162730b4476d820d322184593b1de7723a7631f3abbb8aad459513f450382a7d00fa4a188c15db27f446867a9d8660b1f3f44ad3aa1fb4080d5834ce1ee3097866d83e4107037464529db0491a478f8e421431c12232f3783cf602be27b7b1d71abef92fff98e95c65b3335075c05a432e701e7f04cd368a0d78f1826a6fa7fb1ec4aded62a8626c892eebc300fd91f0ad16c1917756c20954e6eb20138b13c0d6347f9d51f75c77f5da74ea7d60d8023c23404bd8642eb23d739e870ce2f241830ff2270c15c6bd90e79e594ba1ed2de02f641da1ccef29ba6827bfaa9d481c7370b0f2107a42e23fb2fd989c915ff5280142d1a8ce7cceaf3fa78aa9c3d409247fb50992a81b738cfe1eac82bd343e02e3d937da57af317919c97d4cf7efaf9803150d94e3db8aa7eb0cc1d0f2db47ac3dc579faaba6a805191ec748c78221a5b0be1b09006ae64c89266555b3dd47ff33146eb5b8df8abf74c49d7b076ee80e98ec45a9a02c83f129347dc94a481c9221f3efefb812ae2ac46fca17abbf587590fbafd93fcb5b0be84287393fc713e585a2fadd9bb360b0a3216e127151d7afcfde815cd66e2468cd1740236933a1380ba25572ede281ca0a420f6ed7028db7c19443d4f383107c97311440d3d53a2353f710aea22ed0dc446a4cdf9fcef30d4b14652196e32ffaf4082d2e56fbeaf6be6d56e78b8825ef60fa00bc938c330d69660955de310e24580de363606da899cb6b0663c7df9495b383e2611444e402b282c81fe7a60f9613883b54afdb90a957c07b1667d912b41cc1884eb5c9c3347d292d63d4ce56ddd4376e64fc090d7bd3af5100fbdd3c4519adf1700e25a04ec8e38193e36404fa1c960445aab9ab95f9c2ce52cc628415f36a5028dda3283ebc4fe09946f85982d547296336b054edaa73391e31753db5662a6d051070d3da8071c6baaa7e2f68a9a90bf990587643c81429387ff358144294c4b6ad826c9f6ce918b4d4d31836bff552abfa8e955e2e85c47fc94b4095a9ef7b92c964cfe99a3172c08a7cefb41bde78238e34a5d9cf7d3849a752c50dc0bf295235f4ac0455fd914c8f1069fd2cb60293062a7c456c58dc5d5251a2d01c522a01fe67e53bee7829554758536d3855b596cd75224df9b2c2d15d9440e668d5a9e413718913c42f269a5b87569030b304cf99068aaca02c1d2bfd6e2b1a7746525bff9565bb2736f15eb86516f9d127c7bcb35569fa727c291d544881a209893ca7fd755f54e6e8209412944d19d50142a4a6a99b9db5fc28387a2294cfbb609c4d86ed028c994c21db048dc225bbddcee2d4f38fe79bb8059268b440e7041f508074e21929e79288a4260ad67f79d3afa63c05d6b2d7b3f3d7357589860c499c1a91a984a38f88faa97ff4a117eba35be6975b65e71411a13eaba4dd30ea353b14979a31dd741acd9a487e9ac0aa16784cf167b230ae34ee14efcdf1f6b3f1fc1b36c370d2da8b139169a6ac79b4fc829288799fe02994f2336c54734ed3129ad72fbdef2079ee44c938c71e0c8aa77c3dca074265a329a6eefbcaa4bd822472b227c3b0c1ce23522a86685e80ed798e7674062d7e34524505f96d2ff1ca8b1c1c7f99181f330dec6c3530fb96672b27d8ce7a44ef54761c22a49f53e9523401909d8c3f7ee9a7d883449a2d5e06a5cd09540aca54425d838ed18649f53ab18dc943cf602f68e8351e083a115ba8a403342cc398e363190e819be801bab8b2b25d9b3ce4aa696ba8bacb548d137c7be2a28c3d7c9626c5e5f112d83fbd9126069015f12c1d1c632b2c1b5b84f783290aa2134f84be379713d6e41a6bc4712dfdda0586d50462b23b1b52dfc0c54e30dda605b6ace7dd5d3ef61d8cd6cd1acdc64b111b80903e0964861c37d946a8de4d4c08f396f35ef0a9418e28b70f3383f83c4df4b8371f7efb1c2021cfb2ebde13ff69e6c1e7f37536fedb3f4bd8bdf8401cd128e8ae15a66355ab1e6afc78f07aac3b3e872671f8596a56feded23508e3e2de611ba513e9adb50bef4b8502c1b22e6f7559f390677ed5209dce5ca4c758d23e75d1b62c298da13b768af2a2a09131e1786fe528744a4879e1e7faeea695dda0d4d4963a84278ff09532428f8e87f6fb5a49a2af76b3b083906258314725870b59201f3dd06c6b85a26fdbe798cfd4214841ce3fe5bac72e9ebf9e772fcf674d42094195575f30bb05db4e94422abc9349a5c9539b9b54e558aac76b18e804dce22623b2287b88c367f4e457441b12d8e762cae3aaacd85a97ca0afcfd83c7975e9236e76372cea076fb6c994e709e36e1a1eeacd0cb151981187419df300cd8deb4bf1dc80a9c401abb91393a3f6f45df6fba6e7d392434a1cf3962b65a672e0688bb017faaba03bbb29ed70ad1180d6e17ea5c5999ae896e3c8e50836f07f48dd033d2f5372cf431f8ad31ee4992f68b5fe3457c288c377d900b1bcdff17060400e7a0249f9fceadc6a48fd75c3b7a51b5ad440cbfbbc5e356c8b896d69a89490332aa3929f1633e3cf05784b6fe03f2761644524e96b736519659b2cbcb3e948b49ca88352eb56964f902202fa66c2c9d6ce00ee2e6dc6b1f9dc61aec2fc1d47c83e3b12c1843e77727c9f0bd5f63942e66deda0f1e343580802a27bd56daeba5eb9a37ee64f1376615a66ca59a53397c276ff8e64ccb73318d4349931e1299f2e0f67246ec8a94a3cef55dab561bc504bba12d3a704d423fe6d32cb9c4c26c3ec6fba654657a92503f07174a2c89c3a4c23b93fc9bb95134c050df9e717d91303af752958924a786628f4f353318a38e1b73bb66ade14359b683831343bdf3f441ba16578b4b095ff46d52bd26e9192bad8e1a0cc28f1a7a72ba6807b3b07f7dbed06d040600e6279948df4f8cd1fd0012eff2a76af8e557489c6372eac1745d9a8cd019dd79e47dbf2ca39c34f77e5bf614cf9d7122630d2b00b8702d6c5eef35e137c4a10d208033d4782f3e28aa4d188b8ee0577cc2bad9477b897a993e6f72bf9a1b9fb23aab44ba1926aac4229376f298a032e0dc201f539f2f4634ef0a14197711923cb73a57d56e6bb842686111b611f08de0d5b2d946b8b5a71aa372596f7eaba54bd4d027d223193974c8420d06fd9240c94d6c4104d9ec0079ea3a85950792f317bcececdddd7c3ef208f05e1cc241d63a7c53e9dff80192027740fc2803b036d0d2f593bb7c4ede10f2427f455b321ee8a539f5dc3a045adbf17b99b2b58a6edbb1eae6141301cc8e56856b2b6900c9692bfc065cc4278933689e38b0513e4b2fe7df7bc5e8d965a8e5a29bd3ccd027bb548a623c7c87d7db5753102907252c4281ff8cdbac29f8c70a25babe1332d7b26d80cd69a3506f77911169b94b57a379061035f012da4e1f62810c53dbdf956a5e265ea5abd3b4d65a6ff8ac2a594cd74a784c3b3d0056b678eab0a02d99fd7f22e5a33e9c991eade87c812343868aa1d0d4f42277cccce61eeeeaeeaa1cb337f4359d501d25a9e47befe6776cceb9206869606b6c7510c3df84a4758c53655b29905aa684c48baf9a3bb5bfca15f58dc6ffcf73d9cd4e663ac32292a9499c86550eebe732e1ba0a1e143cc960b9a8a275ba08739ddb9a7225a86f62b5f2d635f8b8a266d710abd443f69bbe8e0e551ee25b0da2f2ac645b378bf2dd54d44e68f7b365ae7f272c5e83b54c0513e84a416ccf0b2d4b225c074c4b36a76682312ff4768da33c90529a4ae1ba1febb21c85007c996c79bebb96a4d01d27e9840b26949809ba4f0be003eebb6c23a6c2e75c42644283425b83963b11ef7e67871658ae3374d690c443234b884d1d8e96046a659fe67bdb8f7ebccbc2b6b64ea5a1febb57290deaf2bc768136076cd25c56f27b93df9fed82b811fdb02923865e281ec0b70ae56e784bb46d395d4df3cc1929e64f041665e3e38eaa5f6779bb8724245d943b498ccb614c805d91fe947769a6f66a77cab0427ab092d13839234fcb7f5f59ca448dece7aabc8c135ceb63c336d5e646cef98a661af18ef38cbf535fb56b3b0a7126a5a83a014cb29c8a5f8794e02b3e4b4a1d0a44845c8e2963617b27755cf1fd0075717b500c093a481cbf5c3da0168c4363f507eb5775e8824df6760954cf316fd6a35a16033167e6c09bb5d8886aad66c335bbbc608764f93e2c9f04cb63c7c7739017c5f150b673edabc278ce17e5f14bb298ff2f4f2468847cb01bbc688426d9ffc7b86887bf88b92452bb64295e665e1283bd7025089523826fa7eb43548521e7144231820a0464c16a04b5fb864a615e701f02e5b2230d96480a807343f855215498312d8fd29cd244914bb3c5f0722b8ba12c743adf6708b79f50dd6d865c2b2d15e2c0eed9e28318797b1aefe6bf3c186547fbc56b2f43cbe4448dfa54ecf4273bb0c2dcec60f39484b73c4226bd9b6dde58efe574636ee29ca5eef0812c65aa8716f0802ec45318bdfbf580ca113bfb60be3eef42368f8dc68b81549c43ec5d74e570eb9b9578fcded6b5b09f1c8c5de0b3d1b638fb2a7fb2e1324cf1158236bdae5ed357197933585262157e03fdcc635288baa5e2c0fdf9dd7e1c0decf28f65d0ad63e6a577bc75d4e2e87a033a98f63fdc845513c5b6e75a4925617fbc0f4e737731f7fb806b45ab0b3caea701ad70d627594df6e22c3a54b8cf08ba2a96167e5cfd2b4c710b1a760e20e80f700873f607e31402d6474f4fb46eeb38634408a7de48a20926b165e2df62aad523ca9528ae5da6bcfc70fac48ef02bddd37ef00a6cd1c46424d8a0e8c8eeb5c15c67b82667a8a50f9708b00f2d0ad778b7b4b68ead97a0411c99f4ae1689119cedaae39cafb2af954b82f12e1f3b8513b03cc34f2b8d94b302b54c72f05aabde3d4dc9b83a4672245e658c7cb8372ccdc6cdaaa6021a09a0f3d6a8f48762b4bb64480a53170d0257c1f947fe4acd58d8fe08faa619ab46b8e92ab4103a62e1a49ecfd3326ea78f85b41232652ec3b9444b87debd2306d119ec13adc18b3c73c4aab3940ef19779a03e1f3fe240309d790aa6bf42b06b51fc4b13cd11b7cfd8f4a014a9a93d128e0e7bba08132559aa79395f7178e75cc5c2dabb2fa87c26559eeab3fee7cb4d64864aa0d9116bc20c687d91161f9dd2a7132911773d5d8fd667d039ec42c198ca2ccd0c33f7dd454e7e0f751da6f1aabb738cc170ce9201b622444e3a4f22790ca55158970a6c87685f07394c721707abea330f3808ccf619cafd04ea031b0035c57e366488d5b53948ff9c6a5e63ad860808be6cb353c5260c1160c7116cc71846a2a482f5817ef04f64012abefd423497c1f76146986b66e29248a15714e808d1327afeb61610fd650e603c901dbbee77599af967dedfbd94a5cb1d02144b9662c0cc935c0a8e179b29f82bd659b94004bc2ec123ed3e8a9ab677c59d0fe02d107be166e8405149852b1c460a1f6c0a47191fc183171fbe9a7741d358a7d243fabbb3459ec786e6b83d19ee1c3f3d0abf7d5df331b5cffb58c3c6b16bdc913f792186b4343c7ecfba545e6ff5921003dde427b253c252de79889ab96d07627a7f8029cdf3274f42e6ba4f83fe5b1878181f441273d7a00e0070db9f10af058423bb2563e09ecbdb1ea50d2e72d035022435cd533f00a4d2202088c6bd367443dd215c1d02ad8d813a1954f42f2cbf9b131084619a3d5c0a43eb22efaa222075237b4fc6072c1890f186318899e6f4c4f95f0928bd93605091f54c76de4e3f25083829d52dac09caa1a8d9a9361fbfdbfa5abd3e102029733a828cb55bfb9d4d453bed5abffcceac9c578a6eedd5f1f47cc4c75e83cbf863bbb4660f9aaeb6aa1ffc208dd3c71615554baabb5f6ee466c70dbef073f71da041c4a236cc53a6bf138d41698b9b7ad9d52766f01e0db9ed9ba80c7979dac826f49e6b1e588d06c61902f2269c690b213abe73b2ae57229a01f4bfaa447d38633cbb379547c44a17ff322690729d731a4ff0c1abd3fd5b2681288e77bb98cbe6d315fd28d5abb2a92fb33bd601b2eca5df4f90787a24388083e90f79a4bfb7699d03a7c5f3050c5edd819b22e4e259f8d34029d6b121cd1993b3bba8dcc79de3975c7f770d706749b3e2d7b291990dfd2335e54aa40eb48e490b1d21d998f9b5c601c41399d2b550a4d3da55e81907ad55f746703cbde7efe709c73d41d61be48906ebb43d973c3a2ef68d64a07c1fa061178df750d3088e89ac023d12ec9e3c5da72a24bdbf08ec37e40249d7c5466fcd24a12426669136f40d8075dafcb450813dc6ef787cc83c532b774e2b71c3878e7f971e87ee12acea9726400ef31c58c40fb58d010486742c9471ece77452bcfad03d626ab1d5e05076666ce6f975bf496cc5544f44b5a019ae7fae59b61d15718558d9d3ec30aae9b2e114ca36439a79d8a6410aac74b7642702f3980a17f50a40ef86c6774408b494c3e2aa7b33bf0d24e4ec6dd3189f38f3cefc26ee52814e8cbc01498284f6857ff1b4cd7b85485ce9de2f79b86b735fe0bee35232e592fb223ff2b8dd3fa9a7ebdb9bdfbbff5fc645175c9de421f8509bba557237ce93d6b1fed11e48d389d1f334c34faa3fb7b6ce9726a496bc5e09cc44748f64a4944082cd80927359153da5f5eb5528b56254f57cfa56cf9a74e600b81111b419b1959bdcd0cba1abe0c980f2099cd344d5247fcc1756e1c599df1d4f7c224995cc48ff3347e2070c8a715cc27fcddb72a3f7e71d75a6b7276ca7fa654d222a23af35524acff4dbf3a8d0c02c0b5f6f153a060abdc1baa15e7da8cac199de92c46371d9246d933f0eeea20575e117479b8b8b81dc799f20821df6f1976bb9df773e798083617eba4659d3fd0b232b962943458faeb7964cae65d94862814982fc641865890cbdc29e12c882d240f8f9cc26c82430b4970cee434a452492da841014006a321b856845fafdd7a8e8effb5043be18bf4de42bc60ff9c902ce203024c067b12e12e9a95668434d6c85fef35208153e77eb111957ff4b8bca96fb808cf93f8dc185bde77f512949d02039deb7cc3987fa5d75068ef3ae0f70c6dbbd7a91bf7b8f6e020e3068a2deee92ce9c83ba0b5112f361e95dafbccda6ab42bc3da9927d8c34a89884b1fd3d9a7ea97eab1c217c87c73ab880ee7db3c97ae90b3f096071d726a1bd77cc555485d8c4f1740577fb476b88c0857cb0671db84d227da97662d2ab70d8ff34437d38d9cb52d06596640b07794b71da2c0288b1b55047d103c5e8718810b564c21808a2a595058a7af83cfdb11b2c8fe4b9d24941054092037110186952bc98a64db6a5e780575c91199d10dfaed3983e9f708ff2c308973512c2805245ee04288271237a853ac8d3dbf263eb67ba403e793ec741c0cc9c8c1cb4f5d4364ba070b340791a4de73d00b0e68536c3c57bcf0ddb780fd3396146da5328f0509a3273851f664e2dc25f9c4581df230fb65302776185663dcb8ae0424e6812090beb922ed8a360afaa522d8a7bd07cc9b0f20c293a4267b2dea02083ed64650fb8988baad1965877829e9c1fbdb69e7646421b831d6cdce52be52e865628a4dc5191d873a411f27c57b5a220e9c3655331ade3599ecdcf230cd81fdadd181586d149b6b9aea34d8b7c2cd4724e621ab1b0a173b8136fb5575291a11e83e4e53fffb9e06508ba5560a820e97a1f30c78c1081a825ff51719d78049046c36298f7628380d83f400158f4908b2408faeec73d03bb3ae2af56840f086922c5cf037746976b901c7c6d2b9cb1f23f80812596dbe55b997c624f6afd46d517804a4973bc327a2f374783a65049256e0da8b719584a06e8239aa89149160974cb2f2fcbc5a02e13c0c3e1cf0bd287f4045371de71dd9e21d37cfe4fb8935a8b1f4f1083c593bd06c65f71b9a575b7246ac249baec48976501ed1475102ecd9f58178aa9de674b3d1ab46c92cc51fd2d80ca3f27ace0ed9183076a1b5b7e4037a50c03a68eeb1b5c0a415dd2a8591ceade0a9813883d0913c7a630731c80617347caef2e6e8fe037e90b78158437c54d4e7fa8f12723e0f3995095fe0465d60bcc0432a528522d5f24c53328c7676215884af2e3080fac45f86fa6b3ded2bfee309237cca833ed75e52dcd84d6de34a5e30d30db297fa3cd2827a7aeaba51c7d36c2b40afb48b2f731100bbecae23ba68fc598d9189fd05bc38b224b642cd18b72d37039fd1fc497568bfe98b0d6a9ca8c6e0e03b655ea962673c3ad5d39c7b3a7c108be7fa812c2a7231ac285bfda62d1db511f58d1504371265b35a3ebd46f53c277297543419c9d6c66966af31bad7eaf5f1712e235e8247b3a04e75ece291f66cc1970c1095fb1a3fe42be5a9ed44ea6923e0a2fb045572a6a48ed155b85b9196dbb61e3fa225b59ba7c657e6a2aefd86b86baae046cc6a33e7776288858ef3023f3d85047e0d6c2fba85a7aaeed051f8954b789323c9c59ebd72a112e8c0729e59dad6dc5ec26de4b9cab9c737edbce3a18ed44a1425550686696556ac0d16ee0d1981cdc863609e7deea6cd97cc798fcca36fee5478b27ffa996315f78935292ca2e75772aed34ca480c428a287120b86b38e3382a59d029aab18b9f62a471bb778115a7d142b97aa830df94a9362c966283ca690d795483095a8ef6f988f71223e8f032a2caf001ae12e1ba157538bc93e423f20dfc54d7b3ec748e530ac4f0c7311930247228d57da650792346d2d8b47e6c6846bbfe4a163b5e5432522d666c7401f702d4e29c8b56d644ebc9a3890c17bc9a64696cc67e0732099a99cc8f47bb91c87e12bfb6d7230fc2a6e71c9a8f5cb9723478757d0638b6c3f8eea6867636bc618e8951d875ead8ecb1c477de491f30c9717ea4994839c70a1736ede97a5029fb035f180464771c6a2ba8a0084793b3b9aa5741664dc3a59101a2851017bdcb30dfcca4c007348eb9d0b76eb51f3a0caa0b792e9bfc5b12cff94f46ab61a32f62b6f3a9bcf99b482dbbd2c8e846c9c579b41750dbd88192f7a352d854aed784f07dc0d7d15d30baf26386925f1cc7560e4ae9f3344ba5350c1035bad7fd59a699fa2ec656a293aefe8144fec6b53fff4c0d237a17274fecde2f6155d56f9513191961448179a8dd950b24c97d6bed3fdc0a49032d9002dae33d7579e0deb0737ac956589f82a67778a7b4fc339c19c2eadcc265da611c5666a227e52a89500e8b9bca5cd323850dc19b43e6d0c64416469a09ea622a3bc117e7220660f247fd7b928bfc31c229153ae0ce8064d96f5a6c919e6bc8fe308f555bb92dec6e9f13d2e7135c5317c76b7c8a670f3ce5c9a96a7dbc5511ac0e4aafeb7bd63ff906910467436242a0e3a46465fc3e8a78729a21e85b435e5b95348270d0e86a521fcbc1cef68fb84ad8500890ab6c6fcc526eb1d99984da95899af1011aabc9ee38370e3f467cbf508f4e1ce19abd5721ab0c9eda42c94f386e7819466d529c99e5f74190ee388447cc339c6a03be146d688d34418004e902807cf5e933511656dad57058b1f7a375c7248e2df690f4e8af04ccf2ff990b3f177999db3cd43623a89a1cb8de44acb61df4cb70ee6ed070da632d206d9066e4b07634016912f70657fe4f2631668f1775bc757307c04c9accfc126ca9bea8bdff87c2a0792775dd56efb3d7ca8bfaf540d7da92bca996435ceedc6dde36112d83d918cd29d151ea671fd1a9a9a5bdbcfe851aad91215a9d0d5bca385fff17b1de5c7b945c79cce17e80259e1a1f766feacaf59dbee163f603b7b1db6905e798826b2377ca73085c52f90964b356310ee6c4e7dcf2c642cb323c4034f1180cd3a9fbc9d7680b613c051fb151571c50613f68b856f7912e7e231956d7259d6af1b590decbd3ff46f0873d6924694665d7bc5f6c04c92bb532090a6fb67fa8c8c481957f0388c48b61836c86e760074f12b8805e2fc553a8d0330d85135429755f97244046f9e9594bf4314472193778ae98204232372f70e18df29b17543bfb49b477f33ba9e683c489d9cabbe380ae987a99e35442bd83653c01f5d3905b83df63262bcd63b742a4454ed727f570ba70135ffe6488d46f312dcea42701e9a485e672a33ee5e83f3d2e97bd6cf1faebe46e1f0415254df5a6be8205d69aa9fadf7916f3ad28da905684bb6ce384c4d31a36a04c7498072a0fc290bd5e229bdfd68b6c32e51506fa4f2fd9dddfbffaa4bbed64d398691baae9da8df3a2167a1c49ee13be78ac55f5aae8d7d5b0f2eb3b53f61c5562fd7a3329f3ef4f52e783be3c2386bb7548ef677aac585ccf5464b47dfa0cc3c393b1da5dc7852d9f242f375a630b95a74a85e8b94c15f728b462af392e154a9378fa21bed3bd66ee086ec2348b91af5b05cd1c46fbf2704a8a9b44933fb5172bb5af6c16fb8c1b1d7a7ac1c98e7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
