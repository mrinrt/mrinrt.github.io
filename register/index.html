<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a7fd11bf41dd7483586acb54940684687c5f06fbfd8bd7b5dbcd4e669dfa4bd5b2326dc127d56bbcc2c7996476440f5b1f8f6e0e6734a2468b24bc69a539d90f81a9b725f977884235715548af62361812d42b8d1789c81fe8c49a6b7f0747ed223cd588c98069f21c60fa583a74b43bcb45dcbdef446d04d1c25d873af00113c93582409f6f806efdfbbde7ea8edfd7fbfcfc1f493232c4618019619a18f657255ece0ae0b0a17339987cc02d3a257e2a4110afc629d97778d778ea0c4ea22fd3618b61af29a38147b7ccb4444e1d299831be6747a9c6af30b8db1611e778a92cef2d0b3089535db8721645b9a4048557770b5b8eaf50cd8698239b7eb53a1f49ae601f006c8d3a6d426fba63529014860e8cd4d7c7d6617b1ddbf284b735414841f0d9dc8dd9d73c68d247a5d744a87f78fc49d32734550729f0e07f43657afd268d5c230087ff726442a968f70ec259d8bcf2b1a7396e7e583bff22295d27b6bc458ceaa5e514455bbba646b4363a588b57f1a05617fda7826d557d63f05ea43d2c090234b255bef8f233e13402393252b1c90eeee14294d503fa42e3da1cbd17852c7fbefba0ec35e65ce22b75e9359bb909b71cd152578d326b6bc8f7090ec01353015bc76fb22037edef1a6f19216cfaec2965272e3deda59779f78b944ea9289ea4b3829f3ee83bac1bfad36f33c39fff5c296f0881e95bf7e0c3bda0387bf330940c684b5a56ff3ae1aa1c3b90b321f6d2f777163f4e5ced1786b4f77f8f7b3cc7337539eeecf9fb81d1871a9e52d1f2c32bf4e6cdca845cdda1fc5b61dbc5c9373b141b630005d5de298fde8946a2b2a64040b8f339815b25f749c959d62036123fdada9c3b10d4a6390737eba586a1b34fdbd91ebaccddc69a89db645cc30e2a12f9f04ec603ba4b8766f6afe52de4c4e4262580553604ad8f6b36e9dd85eb832b58a93a126413564d03c625a1a7c8027d37dbc22353910071c6a847b3a1aa8d6211e286a01c12d5745fe648ea8117c34a27527700994c4254dbbcd98e04435aefcb4db4e31a74ff1a446803e9237ee1787553ba6371a38743db07c3c4e2e8bf823cd50ce8d9f439628913a44b45119f5abe01fcd37f48c2abc72295dcc607cbc8883b9c64c0b4f861d035f61c6bce9cdbf466721ea8d313998aca531df265cb206a820b701606e0e1cf87a57edc232b6ea8592990f7123f979ff8a285a2835279b57b3c663068a3b1ace1978cbfc06f12f90b6a7ce731fc9149cb724031f4d1ad229a7b05cdc55f892dafc55d04204788da080d1809e8d6c404844bf46d70dc663d9ce93c74f7221d17608be2af68b8f9a3869a03013a4b8d0e66d7aa9d0f293db98e27e335efdbbd962e786e1bef7edc5119533023115bd62755acfc71c4531cabb2f119d3f4bdb7b9ab78894fdd2fa517c0082686756912de8a8413e45ad838537ed7293c44c7c1368f3444d603eef0573ce03dfdcccd95b05e9276c56d774da53c80f2b473deef0d3267fc53689728b7a931c3d156d7c9f5be0f70c72e23ad4767332b8a67778e2505749bfaac0484f59ac7238668cc720c60b440760229c97a53da8bd36e95a5814b3f884abc84f35b972255b96cc6498a3b16c9d22eca7664f20f595003d582fde0b533236543547d43f863c68b8fa34b4325ed581c8561f7b22abe1333da4e27a489d9ef38c5b4a4b1688b83027247bfba05734ee63e5426dd88ca2146fdc0c8bf8cb9dae6f42537dc847d25d7ca3d27969cb4994f402801103029ee2e303019756448d2680f15d1aab3c555522cc14654dae78d16e4957dafea24e55ee88c2acf1de607fab1f09c5bf0171dd23b578f58584bb7d080450c512c05ec4725d04e3df9756822d06cabaeac1014c0ae240e6b1924874a7faaf5b85f5910b65bd9a68fae9957d2e88eed7710cfc32916ec94d96c77919a33bfc47b71900f79c1cc057a0769eb6adcdcd3093adeab5c77c7ddf53b524ba35b112bc0d98e5243b341ceb739784645c334fda294341e10b92bf58c7fb63353e81bbee1a5540619796d025fe865ea30effc3b81c6b968f3437476abe321dcbd61ceea3aec0faca1b9ad7685ab118b178a58cae0b912a63df6679ce0fab83ff7cb38811c8508287dec8348c9bf9012a55906ad1b722b9a6583f3b5e07bbec29ad0359573ad95f4cbba5c90780f20673c5d5411d61a3bc25b6780e1a4659bf119757579985858228714b060b6d0999c87b8c6be0eadac3e36adeb11e86c53f3a468f7bb91b9d384596e0214fc4fff2a06d92a9d5471cd8b4215fa0d1bf9bc9a63bc958ea41a519179a5779e26db98088f7ab62e9afe39217052bbb6b04bd17d92f5256cb22f3be75212b51cdd08a6dbdb6c62494dd3f5412b985d26f661ae703f3ecb019ee8e7252d825bf93e119c342190fef0d116d037f59c2a979747fc1fb3c9cd8b326b7f4e6df7fc4c88871c48f0ec1d3240b31474740ef2a833b9ba61279d0f2b7c377831444ebb1543e7262e96e2f4493363e574e6d23ad32f69c293ed59cedd3bd194bc2b8facd1cd1807b0a9907a193dd7056d0a69d2d69ebce2dbc4bf808d04e0730d412422b2eb908ce8f97cf128c9afe545b3a8b418a0b68e41ab49d224199426a32db2bb26d20e0f458b96c42dd3644245f1f0816730f519aa99286910472cbebd7437ed9147c5b65c2d1ff55b70d4b7a7a3b52f8fa91301118fa771ee4d70310fa0a9366da43c937b8373386e4a0bd339e0d2c3ad0bac2b2587ea9f58ab496d696cba96622102f221227c2fc807add20c2303efabedb69b8259cf5dc425d4f2a3f0160692e61ab19ffc76cfcffede901ea82c4cabfe5c9ecd4f552ce215b8087714dcacbbe799c5a093f0b1161dfcf328f56029ff09a54f15c69f29e21505d29d1af23c50ee2944e5ad36c8e5ede117a8c0b3e5a338f9553c3bec8cbf67865d7fa0c680a34de23880bb283640443ef8ae1df3ee94750bb3e13ab774c3a97ffaf24f1ca28f1d1a51188d708604914aa6dd9371a2629a1f5f60b1417d8b5624d677b07857d308e5128ee12cbad04dda023e25be7ea147ef33d76504850f9eb6229c35fac7d0368981d5e507c886d1edc2773719c7bf537ae387d63b5440a7cbaed344abb96667de4b796ab66d7c0fc5ec0cc98c7a4eaf69e0202e9e6f275cfdb25240545c9ab612e5e57f693328d99db69f6d46dbf3dab7ba06dfd34286184951d4c73a90ad790e4c36426a9ac1bda183758d16865e6038aae1cb27285b34441ea176109c79f13cd46a3cc034f0ed8446001117bfc171d7997ebed15a38008f949718c1bb33c800a0eb28b32e70f0c119d39f9460a157b8a60512995e597fcc1f75f86490e80ffac1c3a975063815d9842512384307e47f35d4cad4856dde89d69fe5a6493888bd7a17f7257872e892d5e478e8d7be3bf7d08b142d08fd1a87be10228b0b547130a1c1839c6e7f509182dc7cefc70d3fddcc4c706e2cd5868c3459687995324e649fef8b53045db006765a8bfeb51a0c4a54ae8bc8a3c041e407f722d65a0d63f4141b3ad4b8fab6fe238f1c60735d3af6037162a2df25a07c93dab0b1bb3d2bb1a6b32f30e35ea3db8d088c6bff3bac311baa9f16e14691de829166e1ee2aa05c8b18aa92a47aa6acdaa64333a19f3a38055c54d797fe6519cfd71465b0732925e95c838a3268a364c9fa14cd311a59cdd24f39efadc3caa371d233a10bd9de64485d12ca3f2756e983c3259a2583075de17f3d971fe6f6268c34550c220e46f8f5678ba01c240800dcd474a157329a2eff304f69366ccb49b563cf93f159fbb8d320df1c8e60da16af2ada281ee052aaf61028134c7623625f71bea47367eff63e0899aa701712f18bae235174ef4088705c4678670be09ff880e97a0c57a9ec52c4272018d8b385fcbc335e70ed2b03fc6687e1c872990c5654a691f2a617cf464afaeb055dfb96315d3249bd89194da261b765412f8021a3e890e858ddcfbfb14ae27661fefacab6f87d473c7a6865b3adb20c54be074dbf8d3ca6bda4f84f2bf84fd17158c0b2ca058c51f094eb462a7ceb2bf086590f824e41ce372cf43a92a053ac418c3d182632acd324c83092017c855e401b365622c3022f5eb1debe9042d334d82a14ee1c08329a7a56b409767a24b3ef5e7a0e782b2b21981e678a3c1f6e8f5efc3d9dfd29e57af1c093d92cb90ae8258a975b61cfbd500c3a15513ca5b1325f874301e47e84c04fe8056832d163c7603898a2940811c86b26c88c14de66c08c603cec923c314837fc7c969c9fdce1d52d1f312811c800b6b82fda39e6974a3f8d774dc6ba242e1689c113c8f9ce3145bca232982cde912a1efd024a132b439b16ea417d20364f99be5c2081c3281e61a57584d330064a1d26c0d2ad398363338dedc4edd14d2ac3a3f3485a6674ccd77e9565981593d2901ba85f3d41b136ee65a8dc0cca7602eb252ee0ce6a1f489a97292e7a98312e5db9a2032e342720ad09828089f902132e3a67e3ac06c60ca07989c0ad191f592d3f8edd74aca65cbdfbee6c70300730247124227de571a6e3555e60089dd2ff2cceb1afcdd0c85f93e533bbed15f474b779124234a173239d603859d91576d724814061b98153ff907c9e37ec9771895494732a38f0af1b4a52328cb1d13caf548de0ff1bfa02e20083611f8ff7e49d28c3f31fdca26da7dff4b295a6d6aa189aad06518b115cdc260ed5d6a22cb474ea23e7e33d3b914cbf4d6e8a5f0f009893c4d762b68f37213af794f3b6c88431045c2aa08d4040f5f67aac1f3cef1eacff4cfb8e6548ccd51221cd4db5159e7467fba93b35d3bbdbf059ab835de06ba7569f7bf56971b7cf7eb1ca4aebdc3bcb3cc031bf60fb8871579a12f638585233de4aa32d8cc561f817be063c29fff627cc9520fe4a929d786693967dc1917b8d9784a52fa003566fae1d5dd6ed64e2dd2fdd0bf1ba3077cef7953fe0a9f2f8bda52710346ecfe17a3740018ba32d9c9bcf08ab75540d1d66bd59bb9d7f31846135aec126345fcbf423914b59a6a641b0d872f8a9bee532b8ba4449756cbda7eed1a831dab3a7c35b9f36931ff979b7104015996dd8fc9912f0e60b3e3923ca1db5e5404f7f181af9c8d9e9bb098ebead68b3847b8c3ef511e661affee1880ebab36e7cb4f897786b587a25c877f219367d9f9fd703de986d6ceb0d1f955fb8f3d5166ef02a0959d4bd7d5236e277d8813015a53a7acfa9376f9dac05bfeac21560e0864de96882d9d6546a6effd81fed193a3e998b0df7a4565ba305da8cd69be4c346663e79db8b46d02617454cf6e7e5eb52ebd504963418ef7ef59fadd99614c20c38c4c01ffd47c23a57414f21f38388dc729e3bfa23cdf791014f4bcca2ac65b93fc883e4f4d483dac285a78c974cd043a9556b83b0ff4e894c62c9b9ce5eafe2eecd317c2c9818752a3f415492d60a9ba206b3c0b6d922b941149264c7c9edf37d53033343babbb6965fdb88e3ea3e577e9a447f0e695474d5b1b592fcd24a8ea6d21dbe1b009b7c35ce9c7c7884041889774bddd92d8596f42d7e0ae3024297fb11938a5f2233e15db421989bfdb38f3f63a0337a7a05a37e3b715fd7d8982e5c0ce562d9fabfed4604e22b8b033caa74d03a6fc32b4aff0ba920780298dd9d9bb557367e54778d4557112a4b6058c72c3678577e964fd503a3c71e1a292d4755830359e553f1b012a7c96afcb57d31f21cd383f58593c8bc0f143e16925368bdfd31355b60b0b70ae5ee930a9e4b6225372e45c19430c78cf6932d7e5ad894342d2e4f6bcebde0126a5c1f19c90997c6aa4a0499df4fb6dfb9ff0ee4fbeb2174a7e0e2dc17de4f98bb6dc5d67efab2ed45a9bc9a93a698da81453b5c9d6724806e91514cf9a4baf1cc10f2a8a87e1adb859ca71349c59de71052fb42d388b1785058f433bd2763c8e8603ee01bf345319f37ef8f49f83b3a83fd859a376e9a8dfbc46c6766a7b63263c88839ac211af9b4475d2d35be7698c37ee5e504cad1b7f57aa58344f4dfc0b7560dbf88e3d461109ed0ebc5cb9f8ac153b54a2b5c49e8961172672575041342ed10fe6c0f0f13055a893269f729698dc6d8fc6aa2fac0d8aed16c1b93941261715b267ae55c889d4c0546e2455bbda946c532b5715fd32d93fab5926a983803d7ce1c6543d7bbab0330c8817b0dbb6894a1811b0de0eabb22f3177c816af71258191250464c56791deca7af071b9117ad38b5e8b73b7e6266344241d06b06504463186dc1d11b0b66c1029ce815082ab61d4e11162517854d391fc666b118c28674667c03fbfc7344930a8b69f6baf8a8e94538a3cf3942ccaa97a6f2abb468de9c7d714d0c85e38f26bad981ca0ccd8df2d18a013c828770367f7174438bc2b81ae1cba305275b2dd39bdcb07e8678835d676f5b9744c6808888a58a4428136b4e4f203f015ba8796b0706d018ad7b6a7ff356b02856d81113ba74f14a4d9916ae68c08af71b1e424d8b628c94385cee685dc0cd7172c6f735443e18e5bd9a7ef5e4d112503ad3bf9660896b941c6cb1e77dffefba1d77c6ea48431ac077c686cb2c764b38be15fffcdddb193803bedc97d839942848060ea408366ecf08be75fea07c92324cdb0a0f09f7041be2c0a85f4569f8c35a44e99b70e702ae4f109ed703076a4f8b12e59cea60ae59db3ad001df2dad789708fb92e8647d3ea98940b229e39f27cd405a3febd2bb59faae2b7967016f884e9aadda0e1e6389bc5b85449230470250487bc37b2f4e96937dfd5e88207e30789b0294ee6ac284c7f5f9fd85de00b3bea21a8789063ce0f6b2fbed0ae55fa1c480670c16c7e0891e8d2284516311d2f46d8e5024f07fffd07b1c69cfd8ba49e78c0925e74bd70ce46b3b1612663705b11e4039c2f99240674a8231eabf11165b813902c846a8fa369600c3a025a898228e0c8e60bcfaf82a94e09a667573cb10ee04fc72360e6697cc35b54f0927b29306ed436b92c1cb2f9fa2a22a26c86f49756e1b14ddba3592cf1a770a65f7d9a9810f38309853a337899d28140e4e62032414f4202c87c81d77ca8f7e80b9d6072df93eef274fcb74372e971dfe2ecaff2ef0d598fbfdf464bd517c5c6be6f674bf3316f96b0c83e034fbbf91274fc8078286838861883e5f45fd83c1451c185e4256a8d286db4c305647e6747bc48dfb4f651d4c809738a59d82cf2ac893413a9db4a37fbe9ac2bdb9852564a7208bd429307d5a3dedbcf7e66f6b7d06827d2b551177e2bd0f70acbc407abb9b3abdc7eb9acd94d442173041f72d1cb6e6183feb54570a3df3fcc5c156272cdad2fa6b591f571eb4a5405563b7edd3b91d04f19d7c5409feb59649da359ac68aef4cf94d8928815f0425a09989d4990c4741a82a2ff70092dc73d4d4216229dadc7220c7c127ff9ce535392e799098f2a5d19debe2b2cad0bd92e77df5b6b762a42815e04fdf5341056a7963973cb0c6f36073d72f5f1f972bf73cefb9cd7d99294ddbb9ffcdc9a2c4bea624699027c3eac166c32b3150d68894d2e63e207643f921f71519160c34f1ad6587f34638ccec3d7d2321bd70c401902509c7a865a8b654a03ea16387a23992e8a68e07515598ff97f6b67602c23217373843963b51bdc3b672ae98b9604553e380efa421605d3fa2f71af14b94839b7e36aeabe8b8b6e7d913c8f8a2dd9540b661eaffcfefb49d09744a5ee28d35b13ceb47d1bb48e46a1cc8cda58d82c8e44f50d549cfeaea28830c649442e14896c13fb4caeb220931784a6db25d4bac945ea01570b5ff7e3e5e679abcf3758858ece3b531b9052a14a19831c962dd5e710a9f030ab4f3d864c888b98526948f84415343685657ac368196040633be1f735976f2e576bafc713fd8aab1c9d331a9e072ff65c061bd8e78d98689c0e7d7d89046dd728d509b5f652344b050e412de75d641f1a327472bdaf3382e594bd521af2c6a57e919fe8b3dff9a93d3fd5358068ee9a8bef8b9d3168a507ee911f1ddac19bd336e49226cd42cf2d8ac196c7f7b17d2433c1c68257b85f64ea62b1ce640a808e5bffa98c01b5ab8aa52c4fbd87c59b6acae464891bdec6418aeb6b642885b610c3c15f0f1f1b045152b04dd90327d7aafb8521ac53df6edda951d1fc9a8aa34d482d3dd5ac650ecd9156b61910d945fcbd0b158a8cf67d9c6a0664bc50a246fa0cd49e0009d77ac9c3b79351647d7d2274f8c55b05db40670f888feb3b1fb94892c7e0d0cf39ccb4ef1945c444c0e8825840b748f4e2b8141c37c63ddca1c165d00cae20029585e07b03c7d2ab98a0ee92a5e0e7cc448a6e23687b8ee094e570deb684cb513f5ca8d7d1f14ff21bfde7e9e5b705a6ec7d69e0b6d09bac9565de586bb3c2ed872d2d9791916d8bc44c57c43e06bbcb7fe111ca91330e53cf13382669eacaefcf532da4bd368c65bcb17d23e75fe184de2a3f537c63c5f8408cc7885e039cb207f82e06b504ac0eaf317170693a34b9acd245232c1aa5d50e70db17cded74a6cc725ac584ecf95c226c6a2ada5de9c99173c3921dfd085f241a41ba5598254500a5d56ca99aabc44135491d99aa78c888d783eccdf2c3b4b637c9396c07fdb439a5bb9fa6956d7fa676df4a2777367c463012ed65c40427c12bebe23f93a1542d9d43c24e99cb66305893f426106dd3da93fc9f54e3990d52c2bbf519a25b0debab1236af0c9ecb1ca26bd43b4f2d4d637fb1a4030bab12d301bc278595cbccced676e98550fd425f355549fdacc7762ea46f10015c455c017630955725dc2022e652ae7a61c59fcca63bf11db97cff2d057ee3ea827ff963cb6cb7f5bba7bbde34f40d5744c1d0c12909744e7cfebc143f3c16da1bf575927ebe8dcec12dc794d0674af87e3a894604fb499c1e081f2ea132d30376467682da09db9e0bccf0ff98435e55c93f9abbd7777a155251280d7527e96062f2976179ad25d3b45289262a798ffa22a22eca6fe22b77136c537f6c23baf37989fdba4fcc8aefbd534427c51ed0301259ae369f74bd1545d224bd54c3d8e25964c9df64872b77c9b082eb009974854cce45adf2f95a4fab5159e51841bfaa35ce0395ae2a297b971fa75f59ec93f1fee7846cd891dee33facd12df6d75d6468e9c684ca430689bd253e27d2ae7673876e332ec0013b93e1b29b0859035308ca4b9f482675bf427b0a9fdd2c8ff424dddc0eaa2e4cdb0d53ddd928ac9da55d81c5631a071e2409279ab27dce20b313221dda75c7263815696f8ff2de6316d474cc6e15378cec74152d322168d7e598d2a44de219bcbb84c414dd31ebba3acde3ac429d96f351bf41ada6e5f0f09ac77f8be149bcf52837b00c8adafd8d6b288d7232ebbd2ab9dbbc5be38508b0e981902a0807da3c90b9976b86f9c4a4654301ca72a854fa1987432d92465d3c9be47aa69ecde9b19e188d5bb24254fd5fa4595615c7d2f77fabf4727ba827548aec237c17462ba899d692f618f9b619e674555bf9e9e55a838e744d9ea3122de74cba8f95b000aaa81823565491f96168325c8e3c9fa299ff68b642c87e1488c1a6d2e19c60ffaa92c2d64953ec3b0a66f884e83ffb4c6dc12166928d0ebf82378644488f5316841bafe50a4ba74020cd7c213839de19d9d4fb00c5368197609aba1764eb10b89917e1ecd63d07bdcc4ba20802006672807c8087c7877ed4c95c720812dfecb151027d9f2fcdf7b6fe4c97842810ab4e213a5bb0c4fdc6b72d6b5269eba7056da79e90f82b354403ba7c7cd141bfa3ef50ab3377142a26e95cfc2ecc4cde78f4d12ef24a49e806512a7b4f98d5ee8203dc341c9d28a5078319b7908020c1208bd2efd9f8d9318f765f55ff3bdabbc06087b85bd8096d743b76e5a6b25d7582c074ce24c891cac6c294f87de86d9fc8b0c68cd0e76524e76676aeb9ae78f079554504ba86eac588ba9dc0c707fcfc91487075dee1ddb3e9f534eadc396fb5f27a41cf9d9dd5c80a6e31a2ae691d0825b5125ed11674f1c8481f1e095653fced362ead8c86a125f978fca2f655c3a1ae36399700a9f0f844e6d7b92abae3bc9e521c16b485c11c18a10e45ed9be0ba93e22696c92584a1f86ecdc04d004596c85fef6e81fa47e837b483ff374b2e2b8112b23c2ae61ec0e03baf7e510d2da3130c54bbc60ba36dc8c64d6eb84aa272c6cf90562946e0ad85008b7c42df9da9558591316025a8a428b6a88209216a220f84a8244a56bbe5f2c162bcedfbd7e284d0277fe8846d39ba18d288281781d76243fa3770cdbb702a52f77be6d3a0f8fd3beaea39a647aa56253dcf9688914f08dfbcf6b588e458dfcf904949125892371c9639edec8eff6be5443c75905f9f3eef6e636322a2d5136c3e3d78d9cd976a543ba2eae023c80358fccea75ba1f10da9192890f921f742fbcc5c3a0032bec33b77e79e222ea3612e6d4b625d8f9b923fa3d101d84bf5ec18ecaebf4e1ecfcd943c096486876442ac03d4641e29cf4a0a58c0d00883b0579cd4be9bd4cb3b3e1fed5e250bf030fc63870ae120badd82d4abc4784974404f503432f0a99b03706774422e5e305b20e3c233ed3d4218e7fd452fc84fa0d6028df8287f6572c9299da1df4d6f91d0a419142e2d50eefb04aefc7ad154e0b40d8adde0e909facd15ca7e78d488ddba6a73000609e5cfd4fee03b85e8dbdd5a196103c97f265afc09a2c452caaa5a3b7ff9852618815f0b32c0569ed5714981331f636efaa5a2d42a4912aa1c3d929b7a2786ca50302ffe05e597ab4ad12eabe168a320eb8f63dcfd84b101b36f69974c8cd6212da732fe1fe3e6dea6ed680b27533f79e4fff4e7ab0d9dca462e47621135597a342377cd3d3ce6bcca6d6ef00e005f032c0fd717213e4c4f3035e5734af6c4ce27ad8bbf231b5f20209f216a3feb53efea4a897608783abb9fb3c4768a142f0f24d8f6b0e9ed4a7a871e1f46f2e6fa426b113a6f131ad4ce16f85d681c92027870c8313ef13d732f067294270a616a86738882d56dce877a0b7d6cf0315a2f21e426e86f13129b95aad726c789446fd1a730c9c0b130b085c514b845d7a562eaf1698521226f36b8438392ea301d5878eadade467cc07ec10aeb812c229e91b4956a789c50c1937ec8e01be2ae276102d744d44007fcc405b4b2a0209aff18309e97316ef312c84750d62f89fe5ae3242f5829ff2889eee0919fa83b713d1073bc50676047b658605088c1de54037fffeabd2bd9139072fa4bcc04a5dc85e6940ae3dfc3a479eaffc0948f7501cfabc41a6cb407e7e31326c1aaba45912c48c3b9123b92268ddb3edfc46c9e2fb82072359edaf01aed23df07d5e5f88cadb51d30ee16816340ec99293c2668c4e28f4b95611c057b3863018a289a5fc1313dc7cf0069dca54952d9f8170355123680a591cd03070830d6f58c1a48992ebd786f7a4d7b98898f1a14f01054174afa1e72280db123821e47e2b2165d22e30c873415d76d8bf5baba41b2c77ab574406092f7bf37d950bae92f8ec17e9e7bb07e553e3b406ed3ee3100e21d3aff2644101e96a2a2d2135898e714fd974b516c4d528e76ce14acad6e8a6b4e9cf99c846e06451c202c4cfc859f106a960ee47b6b21affe5862a7874cba5ff9147ee6fed67953aa219aa4a6b6a156836915e5e3be5e84015eeba94aaa80c9a29ec2bdd7bf8dd78d4f518ee23f7b4c6d447cec5ed0893c45266a9622cca5b3229528b83133225dbc10c4743f19d831a72e15f3ba373d9b9867d1b8d4869e6ecc1c57e8824ec4708dc524d8f2d8e4a6e92f835cf2fe7264fe1b5af3d909a7f043f2162f2832f89c511c361dc42f3c70bacbccdfba86098790fbd610c266dbe9d1e9b213042bc3cc2914bb02a4342734b0b9bb2c5b37df6f0326240496969b02343831142b0c73b054d62dd905ab429386cd0a291e8bf3cd10080ac78f9bf243f6e7a5d6c4106c619f8ef2e150bb7c69dd06d09d792874223b818919610e6190dea4b5968d9d4e2bfce2a1f4a5f4cafc4e8dfa41d4084d5769f7528407751f34f60724caeb90d1c11068fb3a80098afa9625d1962e09b5e9248f569accd4734c0563b19c036fcff445c839591186a4fc90f5d2dbc9adbf9e2a4654a62f8b18d9ab81d033fe4311dc1e479ccd3a9379e740c2a5137a376581ddf07d42fdd4e7d7962c1c3eb984c25d99dae5c9dc8616f6f0ab6826ad94b036e85b866685ef4d4de2f67a70e1abf788fbdc611020ace6107a6320c088c4cd711f219f53019e129c4b0011dd7f2d5cf1e004b4f6a0d0688a564bcc9f35fe2062242b991666d54bdd5e9fcbff72aa02c26f779f265633a3a676486efb68f9e2057ec55bbaa375cf164ff5306999abfcd7cc12ecb7f07f4a13e9e9c2981f9a7110243cd35b61b1a1bed6709e84297218661419d381ffea7458f1faa0134ae2b38ae13424abb0f12536c9e89a50fce8ef8394318ba0d3f966aa20e8b5e7cdd25b2ea164a2c982c6fe18df6d405084ad11caa8537e3b2a64d8d00e5c828b7a9f4d7763de19aa1d7168e25aabbe1c1c0304bbd376cf85125f3297309f77467fecd236528ca7ccba67ca13353176bdb83f8d0125cee9bef8d69ac87785b2c7bd3056e48817a61bd55331fc203b1f178168b9f17d1ecd63aca33d0fd2613a1645509609c6fd05801f8b09116c9759cbb7ba1305b24391f344ca3736dec2e241b72cefd93002155e2f32409833151962c0784f7f5f9a604154d2b48bfd33fcb19c89b6d84b56c4e78b523490ca179c9c937aaa3142d5c4a0a558bea43a8e4c38d8b1f2f9a2a6a10ee205c6000e506cadedaf2bb2d992c8deaafa81b81233dcc8c24ef64039781a0cad1af62b50ee29818ccf97d19a81e18e3fdc62c176702a3e6030d2413f58f6bad3dc97caab89800df66c57b10fd5335f5044ab8e4f4cbfb1d7c46ccb2f2e5f83834b7ec8656c5b85aa8a01c09567482f7ac2203fe29b2e0cbc96678b461329cbbee9f1819aa35002c34afd042293e7928dc9018a5afe90546f38c034fce27b66276e9c31fd417f218e93668da51573fd5dc600ef49527d2670bd7b9830ab962fe54dddb9daa0e1f9d89b67d50095fe5692ba5c5100a01fdcd2e311dea2417a4e25c024f67bd993d78ec6e05d7fd921492a0c78b6e31ba9ee70d0845eecb85b3dd3c0d0a12760e24259757e23d084a14285af8361143b45b8b92a7ee88af92d2c326e367d28d853d388a6f9954b083f9af6c4590f97124f2c080cc0fcbe6182eb8a859e3952cae3d6059e313da2946ad1ae59cbe236f564e66a09d2d99fe372089f3888f168ab6bcf19a7612e08defe5ea596bf12d829d946c79eb39cf3babed6c9a51c6f0519","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
