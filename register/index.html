<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f4cb4e524834e1dec265cd5b557a5157ca438f7e8c44fea63e23b5e71b9d8b996d20d9a5b0c7dd718c9ce92386873b2fea0769952380fd1c7a2ee306b3c5d12d53ea91af6a713df7df9e0b2282ae030fe39b43f35a794885c9c83add456e2fee9073a5a417e883c2d5345a6c2f14b0e4ff6a57377e01f3b1fa0350c15a075642177159d250b08ef6324663b686909ccf3e5458324c7434df07976e54876f86f73fd69b931cb03ce51cdd7aa62443a9271cf67eeaadb20cbe751f0bb06012010e870fdaf0484f4936c656033d8f70c62b4c2bf7476530b689992aa90326848a92600561a0bc63908eef18c2bcb1139c9c9cefd2de6737a9693da8da879df3a5fb9568dca4ba937d3a05987c9c4d1e6fe826063ae65af2b00d01ef351856c892919f1668465df5d3caae7ed2ca6571670d5e5534acce03d36102461315cc440c50ddf56f32282b4e9b7ab5ba41ef5697f3454b07465414f692f5888262829b5bd2173485a243cb14d32dececbad5823b28445c3b5d90108e1bb80ae50dea391c5d62d1d4f25f310ba960a36fca0089e8056041454170fc401ab8f26792cf6bee44ddf3484be2f2843e01531630cb5f5f9e3d5d54b470df2927d671d9e1d1d69ed78b34f50548062e52c35b476bba82ea64b0d5eecf309185ebcc2c8217be377b54ee554fb6e7eb846eeb9af2959e750188a700868525504ede52d783ecce58d75e66e00cfc0a88ec1a925dbcdfcf615e0f284afaf09badd6a8aacc6f756c527ad1924e0a9118be2ac06e59885ddf9a11e957e8124f03e54c6cd868f857160441e323c36762528eeacd766e8200f1e0304894a28c6dcd79ac1f65c4622a35b95c26f78617cb0885563e8870431106d3899a7c83fdec78eb68258be3ce748eb422289b20b10d2620df64359e2f1f7b019b7d282387afea74cf68966a9d54cf496dace89712472cb6c6425945bb8d259f8dde4b423328fc7784fc6fe97068edd3c8cbc17ad13308176fb2d0e23a4b70288a17fd7c1ebd0fd066f8afa1c23a7a6269099cbf1d0d9b639706bc296ddc3da39484e3ea31dbdda117f3f834c703f863371c333481039f0c9e9498bb55810f95e3d19e27dbd328284081570e1decaa4fb6b94867b965935051da016054f76ecb49e365dd13d4de08b5d839c3c162b5dc3648c8e56e9279f66b8ee2acec369ff817ca7455f6da606872618d06d921c648def6c6771cd81d43fffd1eb9c77947e10dcb33e63d6bc5ed7312bdb67fb7f255fe5388d1c5860a6faf659c96e625577be32a8c5210b0235f0f9656cb4b315c45436c7345297cbae913acae7b6df292bbfd0fca29adb49be5d6c9400dc7e19ed45b359e4635699e173f833bc092d6f1fa25754cbe31e09a4f746947daea5d2a7b9fd9b9349d7859c0c8809168b98728764cfc08a828b349accab1edc30ec3f4996960747834390b2e4b54b53b4c6cf341bcc1500355c6b12c2ed9be7e8aba37a99f1e67fa91d76241bbcdbf0ee44a683e6b881bb370a4b4b8ee40918fd1b104818bab5a51286dd7634f7f71247f4d66871327b02ec0f84e9f6a5e34ab88f28d43c661fc5477610c1e2da1b82b7a4cd3f03af594d9ecc17adcf06da64c2e0e7ec9e14dd9e8981861bba0d4b61aaff394505b1ebe9a275a64db3acde8edce4d6b20533bb66c0bd0973131485c1afca428485cb68e171b096dee51fe7630ed71b0e3ea879123f1b3a07ba8364b49309d4fcdc9f6f74e2ca3225e0fb70c9c96c1d1bb19923bc259d927ce215e13ce38dfa3dc0a9154e37a65638fc51b43193e9eda22dbbe154e9cc0007a353eec00545a9161da3090069798636737998bb25f82f6b3a59e0bb420b67d7343da5c11fc58f39c9d08505f17dfa1594829e1e47575852a9fb17df778956dd4b6cf31e8c01b8b02e93f6e7ff78db300511a09310bfbc34ca29a513f7b4ce3ea60f2f986d5f4de645baae16df6d914f4108dfa90339d8b1460e164b6141383176f3153bd6f55be888116229c1ef7db67aacaff731eb0615c3ef6d8201cc5d07d674c369f8ae9550933eccaaa26b2d0ac7731182ff5be4bfe0963dfd2e664d1ab932e6367e44b2e930aec3c2cf139003d0a851a91aa70c12cafd6e01cce1eb10f78c7ea134a9ffaa1a906842ca5bf0b750a129a8c9ad1660562ec11614965539ec0b0273f5741eab91a9c234169a21b1831172953e00b7f84572540833fd4a438320aec7e3384801aabeee70771538effc6641bdfed6f43fc93403c366d398eefc04b1df829834a49b413f1a5a3bba82cde78d3ea9cbe77f2b9aacfe6b16daa09dc2612fe70124bb2670716506ebd2e64e7ea46c5f00eea0d2b6422e03d6cac8478ec76325c190a7fba73f9805217086b2a83bc0fd32a59e872977a7d48dccbb0873bc9c17879ae0e427000ee1d9d4bb73101d3733ed32a67106b62bf328a4002baad0fed191890f4ed8a6023a7354e886df523a95ccd67ced3edc6c07ec7757a3ffeb9bf3a6a009ec2f08d35fd458a9ac44a687cdafc081c233fc1bddcaa851f71e7c9c29d8600463edc86896a5618d360cd15019499500769ceef0baa1e6d74386416edc7c2390ef5d4cfafe11c7d150a209061cb743450c58e81c6dea47438f46eb97a226b649efde224011bb9824b352526a4b37439c8e3199fa71fe1b39a4ed1ff020e04c3193ce1cbb4f86a8acbc312c60e6fc4e1e705900c23360fff2064b7c023651aae54a5eac067cacdb700913421d9af4abb4268288a10b230c5d20bfaed2b259a93396791d140adac7f7df23b3b0327a29cb1dffd6ccd1a78b5884a5e0e4b5ffcc69bafad39ef08cb59d13d716c8b7844198400f831228a1861d4740a14bc18788f0d22393df422e4b1f34f3d166243f607b9dc5f0c9ac4228d09cdb402969e32157463839db9f095fa190d5a96d19578e890aa14e2d265d0239ff86e318e05f6064d4392018602fff018f2f77c0e462b811dc9c239396e68ef8843b85f3d2bfde312361a13c71101bc77e40f6fc216b803669aed885fd97c522d0b2f9083183cd4431b87cff198854aba0c00ffdba8cb8081d8ddf86801e944e23cdbdf63a4c2e9d66ed925827bc125ae5383d19349fcad84ca60bac33128fdb0a544cb6f2ddb063c34b0acd622f57315b8b1dfed7541e29534afcf1d67a29dd162cc453ac725bb570d7c439ae89b41678833c1e10fca6d61104b328a1b0f02bcdde05d2e2d434d79e2b60ac8cf703cb80043fd0222bd55ed6f8935f013b82525de568d1f8150b5e4f72fdf99c7f3ab778cc2bb2ad25d9a0c4416af445b798ea84e8bdad75a2deb5a2a2afa268f4fd75d356e28b9cfbc61518a22615ae85584e30a3d708e14cc9ae10c4cdc6d66f416ec1f437120e0de6d4e6bd19664e9c098d4f429a3dc7c1520605c35253c0992fca4bc41405625b174e89cc0a67dac0db30d7b9afcb1849d5d6b9298f5235a3ce854d4d371cabaa9c9dc31d7df04c94833672ae590de70c1eb4d7a8fb398e5c8e8cf511618c3ff31121c9f024b8db4192d27b4807e6d91b08fb5b1a6661e50524150f41f94c4d19d4c1b0506a02d9d909eaf155cea7197acc07ad7342ef5fd0d5488d8ad74cfc09b14b84240953420f323399b85d9d2ae6d5000b32fe576e833990d908a7b2bd4470bfc63fdd799e51dc8a48b683d11e7a085f441e9bb40d6b342e240c8a21132372cfda52f4a9871250d951ca2605dd67d6416721173118955aaf65154def7a09ea467f312fc46ed0a1d175ce3eb7fb414d8d21e1dd6d3342478267b1947e0a9e07943358fd4e777ff012a8eb3496d6d7457c8639d98dce2924aeacccd03f51769336d0798b2f59ac8935f199c09463680048d28692d01168360e21af390e167981207289349d5d191e01a688e1ae89066692d194a07e1d8745e26b2051ec9f9cde2115ce04460a49f62091b19394be54f70e8849402c4bc63a0046d18462bf2b3af125c1841bc45d2e520bc5f14f1dd0fd4b33eef0fc276a1ceb88bc8660a595f55a2b6c02b51381ade4e6b5d2c9ea2942c2143674bc6b770df100a0e363b895db135e34033df6adb7fe3ed4e01eea57b4837e114e598e71cf0babd1334dd564993617800d1aaf86929cdd30f888b3c5ad0677f4bd1717b4c10aee3ccb8b138040509cd3d06aee38becc7ee8c50f53e52c56b386998be86713ad07fdab17681c9eaef1ed3af01e189e450dbea57ca577fbc781a6a58128159faf80bc775033a1fa4820f2f1d3bf11dbe35017d4762dcad1385ba9bcc36070808ba64d2cf8d31160443da2fdfd2262fd14dd0e756e1562ccf853cb5f5d5af28814a021dd19991e7ab4a87b557403ba725f222db69e66d180e0ba707cd27642ddda24fa95d367ef45a5990ca9b87e71f28e2378759de969e46e4e3a6bdda0cbc18a9b568efd63e64722435fbc1c86d8a502143d3aafb4db6c3a394cceae35eeb080c0b226087fce342dc95fdeeb1b02ace47469cd0c1b81d3978d7cf888bd0d01f7c3a1f9ae2b54705f27635fe2985e344dd3cba4b522194746c8ddb070954009e19c14f9c2aff08f67b9efa3f6d55422d20145d83c8b6cc3882065a9679d183a2e0a57a789da09459db10b0dddc5dddf55786274812f786e7a80bc9a2d19c3a5e674cdbac4b37b2e4b054909d10e8d484ba005083a165b4e80625f2826b16dc6ccec409dc8a240a5f173a14f7699fe2a3db4f6e45c1a4b1586814c28c96a672c440c10abc0f998dda9bf55e8a0b66913d5d0a68198ae70d791b6844a4abb9d9ff3188040c854adf6bbac2f093036f288db5d3aeb3fe18f8443fed99910852ebceb7ad6b17bd0ef787d8cfbd9822d873d8645902817fa3f316535f9612faeafafe1e6031767ef859e07fd796f8398c284a57225e28f1bf2f2dae15a2e3085849a1219cb01b9f6ab7a907a972bba959731d1d67112872f64afd07024ddb8714aa42d21286bb4e37b5af4cc68b433899137a533656fc72169af83d076ff683d01b2525272b7a2b6e5f2b44182042d07feef20cb111666b7f1f5bc9d16f2142c97795d90039cb16d025f26ebb50726929be53a9deffd2f1ae76b435f4459023fa178987924769187a301f39d74936125a839af86d951a35b8c91abcbd02beccba94f50befbf415490ae5ee39cf32861ec449bc06885cbd5403b5f293e3041494ffc2cbd10b60bf926983f7e216af86c89fd28c9400111fbc23ebd6aa160dd38dc645dc3da5e23907540b493228223f3fdb81190cdd64bc913f57e5eeb10283af56a5415bd56b639b44bcbd00fa180ad8bad08f5529f4411977e77fcfe37828c04b305ec12eeffcc888c4bc0f98c718b5a22b4121aa9de1a3f62bb99f37d17a6f53125dbd72cae4ce83108faa3e95c13baa35a5f90dbfcac26e2c1289ea167a3a65c2f7f2301327a111afae9e1b21ae679708a740fdc28628967fd5e159cef99ef4ba74caf22d5daabbacb68c845295104940cf91c87dd6f2f9fbb2de98c2d0482dd071f336eadd81bf0dc82d3809d3d7babd7672676146b16ad1f8ffac82de833f497fa919ce4e8f26efd15955d2d35b04beb5b21fb4ea42ffec9a73cf678a61040d7fd4adec286aec102f59b656c7ca7cf7b52418874a54f319c450585887dcdbb04f365830fcaccc239b993d5aad4c887c92064f6bce27c01bf9330cf0329f984a95e3de5d5c5694ead0603c7dae360c7ac17e29e90eaf8689ea577d63930f51de7bb028657ac76929ce0d5d9b062ea3933feba0f3242cecc08a4561b0102eaa5add3ccb8ce62262c7471a35ee2e7be5391040c405852ec0c0ede9b1d4551f2f3a6a23f2c458e7577c32f39c9143ab019691c484ef97f681bdcfc6c2f6790d38807830df102f244ecbbf9deb3ee4abd5a0bc425d41e9c8b1ff14ab1a256945ca05690b0629eed6121e74c9050b517d71f98036df8031d7df36859522b1656656b3714a19c859fb1683129693ed7dc7b0cdbf5be5b87d09d9e0f307f184979c994ae558aabf3d05a0557f49fb86efdc2304b7d36e804cca16b7c1437b7e281d11bd32cc7240f6b3262c4c8f34eaf5b5e4995bb8ef77f633126ab58d5cf532ad4ad8516cf272ab5da965d8ceac70a572df9f09af60671a6a0a086e001ea3e9dfb1ec8d82e66b28fd4a4a2ea685754f3119bbe6b77b9dd348f0571342fb01caf7ec208a419a8868fc3d6f9764c1d4a45c40434b615f1eaaf1e481f97e4102cc3e2ca9caadc2db0e62fea51adcad05ed80f5b6c2d2d09162e3c81788cd89a4f208b04375bf5360e446b5bbb279b40de0cd32ad6b69d0cdf7ef417902b4039fa2cc89a3b89c658b607fed2c6a808b4337bf2509377d3a1ea2f4ff4e778fec833033ff969a94e0ea6ac4642c7c7f1ff7eb0bf6dec577c3f71f02be5780a260e2d76d8356c3a8e61a3e77b09fbb5443dcee8c315fea7c7ab64e56a16bb9fc3939d401446d019d5341e259c4812e6685fc2b9bdac20cd2a1e8dbad4bdb12a009d275d1b8ef15029af98708b35ce00a92f210dc6a0ad1c9984b55483b31e0f170f65b8126462d12c5d3628f4d1ba69f5ceeae3612eca1884fc7558561bd496acb730b12ee6ebdd1617450bebb07934cdca07f0b5884959ffc5ba8c310234e77dc106a097fcf07385f6905c6101fc38568b7cf67d1b4876b242a3f5acacc14e072f50d942ac1470aa298f943451d935608572641b07cdfb3fe74ac9e2ffec458032dc1d9cecd5ef5a437093b623d16c2f96c9fe0068709de58494c05ed4af7d87170a0e1b0ee039c06635ff5436d8388d5fdea4c8ad78619613276714f03338721944d87d8686a3fff00f0dcb73286bf7333a3d6345338a786986189d85a8ec3edc77898f57fd43d9f09716634a0dd4ff29628ffe0cc3cf23afe697a9890f23048a5fc38ca12684107e8b6385ba113a5a085be106907edb5144948ff0e568001a999130edf3b638276b36939b2f0ec3bb09f3ad251f3e6fd4787f77dc98f0580cc86b71555b37decd8090850c6b46082425befaeabadc615166773ce7d3f019369d86d8b79290c1819a9e349cea33be5185596261a03842a4e1663961faab3b0014f1e0958ef255a51bd1636295341d3684757423cdfa3031607cb2f497f97ea79c5f77ef1891e946784f988427c436630c677725b1a931f7689f19a1a869e516ab23ade0342afce1aa690ba939e67d9b342200af614f6bb73463693c573c4b4017e50a62e2acff9f97363c1f55bdb077ee6afb4efcec94c520efaaaf5159b05d4ee235c1fa308a204d825d8dd2b151357829c31fb37279af8d67e4e5b9c69ea9ffda7f7a200a6a122420ef2aa7a5f13b4660d70e14a72f8c212cd0bb434aceb91dd02fa26204aeb2721fe9a0cf52eef5290876829d019a85c2a3ffdc90d2bb3251bd199473cfc1a6309a9b927835c6f97c6c9f7a93a9db86b0b0b716f812eebb0fc84a6b7c07dcdf5eb9e04892f5fd29669a3588fee0968e7e3315565f9d5acaebc86f6a1cc7027b6a508e949c09f68c9ae1a07f929eee4c178e904c1d53463c939638fdba4d2b09d21839b43b31082602eac3cbcf0bb7962281e4edb8b5c2b54e67a0dfc93844393685c6189ae898f3a303d9392e6f0e4ffdb7a261cb5ca6e2bff21fb44c748bb630a9422e7cbd517d3228e366a7b95f664d37e60019b2befb7c7d3799a7f77958f9db0133dae1dc597bc1fa49d59d103a033764618d7f1ce39d71f713f39a93b45f51874b92930e63350b51019aa4976f8aa8995734f154eee0b63c9ce04bce3831227d828a2ac9db180e11e0ecf3aecf1eac62033c7d9f29c59bec61b7d035191aeabe670bcfb0d51fe6b1f43b99e2f2faaba81742676dcb8bfd8cfcf5b6c6707813be5b3605dbdc0ccabbec3411a6f3b2f3e08bd82fa43355eff2c961edd8fe5cc0b62574e7b5797e172de0ad37cb35f80c9bf1ebaf1c35ed31a75a02141aace99c14359b16ad97815be9739a124088db3f7449e7ba5c411c5da5d16a2998e32ac8237343ea50139fddd7aad5fe846f16f98b41c7e78af3abcb11cdb263408f9ee89d6a4e21e3c53ea64a4205cd4b9aadbb0d05612bb0b0ab97f2158b3296dfa9d12ea25bc3eefea26d9381362e71ed8b95d021a9e50dc24ff5604af9b382faf5d65c5961e7e2dfa3de74a59a7359a0e78dfe61ccbc46c4a032a02a63ac91a56e613aeece8e40be3370b54c8a22a2d7673853c088f8c5f7570d798511eaa80c630e88a6a8c14593a44f357487cb979a91ba903eaf2f06e1c02f74c47e35df9dcc95b8c149a8ec73cc637b190c78fb77804f85b99551fbef30c2a8a8a409eac1da84387340ee669804cab925a4736c43101696141135d4e08e8dc80c9b23761bf349d1db6070e001b02209537d0c999c0c98d30e228fd23bf82c21b4605224e74edb69936e55fc6f89bbfd639bc9f20093a0fe54e88ee4f18b88a6b9b9940a7017bb6fbbe6c9d483251d7541752028efb3caf630e4d9a5bab863d32e7a8855a86236e39a5fcfa0f141bfc598a7e2126f4591239e188a8fbba02909c9e3505236de7c77f514bea2c8437ab2099ef558c468c0d9e8c4c38e2cc0f9a624d2ad9a9d53322745d26220cff7cb91bd8607afdbcca7f529b8b062bfcd5f9d813b7f0255b7ed5049e7fa821fd8ac43131ebcd4308242279e7109dc622033a67ffca8d770e5940ce0abc5e303fa6ce739aefdc7b2aa5e8404b1c7a0e8cfac248e74d644f93b8ed777ac348dc1c1b69ba81660ae1fa545755f00e5a9098cb14bdb9a833f2e9499d528fb55cfc5f244fb19c54a4f55e8241f77e82392342173eb253c7bbba4526d600aa897c9b43073cc2619d500bbe2c1f18df20bbbac6497f56c9e489ac392bd8defaa6237487db7ae87949d1ed631de318827df1198e8bbc1a0e8878f9558795d6a59f26c2a270f14232232944a50247cea2971db2cb6502c0792613f4dad421af0c96aa4bcb98c2a500a78b84dff5c2ad9a47be5e046f94767e1b31d35feaa9a2978e62098af3f883279ad38baedb3b8e8b48828287dac02c6ec5df0a72c0d8bd949e29ab6085304230cc322c078e71da64a49a82872e8a0112fd3ab10fc161386dd302873bc6cc86cfe438480a5fc0312e8503fbe9b238099a16b3304071158bcd14e253c679ce0690a71ce522f7f9badea5d4eb53b07b8689592152fb7fa90e246b11857ec5be3d74696abc5887b497f6db83ab4fdc79a1ff2bb2800ee2d73dff62b674d2a879b2edffd0270d52764ffe9e621b2ad0ccefab43b9482298259fa16f71120dc02ee43fcc2d05a1c166794cc8951441f18870bda47c32ae69832378252bcf782133149125d246ae6a2bd89ceb7a80d7a0aeeb58aed4f4b50b2e67e9157a1589d5f6c91f8474586fa64b1c207f4fa801585f784bc53de037936e3dfd708572dbf00959efcb268b777935c211ef1287febd81d45041c13b4f512fff011f020715321588090900e196ba20c53c11cff1cfc8ff5758eb6015dbedb20e37f85ba0515ea54c3adf5099d492a7a792a1e222de7212614fdd402bc7a4de51ffaeeb81efc14bfb7089a402afa7164cfa7879d595bb8967cc2b9f81292b68a0521394ea5edb5149843a6910a50ac085602e35e7b32c4186ffb0e1eb6d15621afbc1e5fd2be763af1ebfd3d4b05582a4fbdb0f4ce7618f40f50c00ed660f9a0c37cb922797ee98bcf55c5c62af803bfd174cec0dc5f5b41715134c8ae06555fa40e907e2ebe07a85a2a1fb0009cc0ce35eace7929017f528728beb0c5fb1e16a3470ef7983aa6eda7f212f6d999dc31f872528c107652644b0eaedaa95ccd6a322cf101f54661fe33812025785b3467169620d38777a7d484fd05cab95e7052e450b9f778a9eded2a1c240efcbf4bbd907121160613b276e4652a088e7dcb8adb40b9e719140e9269a00e7e848c9b61b6810cb235a9c0ea7d8c7fedbe103eb30508e197d7f3eaabd0b6400bcb665ba6fefa01410306cd04f241244cb5e8aac14bfb1e2c7d74041d7a09b6fd367699a50742ab7728286c7d63ed9af000cb9515f9d60dfc50eea79abb96f905a11c06ecc04ca175742ca5551ec63903139abf5f504fadf5186d0f67e9487d271014f3196908484ff84609704696c26f265058b309040d0450f74236ea35e9024335180b40206efa0d70aa5f70cbc2d08669190ff89ac14d42835b41c32a58e72d3160b2604f10f8eccd8c08218e747525a8f58d49d3021fa6c423d7215bb501c802de7ede30164a3f0104b582a580119d49ee8a27bf370a9ec1df4796201aaf09992bed822660a0e65e5076447a12c32cda1f6554ecf01b3a2cd0379a859e3218a2727d5bf74292f59d0ce211b7f4f6e1d72bbe7767e501583315cd2e21e559d1fefe67d31a772409824235cf16b1aef17c484ad148de6d9663bd2b937b86961ce29ec9bd372bdfe0e5f99334b4887d45c69e75efedc5f2a451f82eac870239deb81c7bd9bbf38269d32f251b0ea1344b49a75d8dbd088f069a7ee2540dad01a10933be0aa6f83a3d17163c04075de34bb82c8994cdeb73b2be4b9af1c04b744c9b7004edded7c2010eecb0cb79c2e59adf781b6d56713be06a81f580d077cbfcb1f2271a9402e3d0132fb3d2f2d34c9b2e98ca648720ed5d2e8e328b538b05a274c38eb249034a2bafd0fe59262386be7c733469c4ebce4a5adacbe0738233e525d66c787a6dca2ab3df9f8113c6725d282d70aa5165ecc3517c2bc1b68214139bd2b00fb4b1d93c992edeb7fb50f761d39042bb9dffcafd65e2f70f66f4ae7eea3e21b9609715d3de5b68f7e3c089e667fd98ca1a73e159d6bd1320a83d747adf027e6890e47d73e28a42a6c56a9976724e69e991c754cf1bbea250dc0e08412152e7865752d1dd62841a218bd64f856b33b80b9ddb0f59b952cc7699f28786fa1719b30371c25f4b66063a26034f29b39596ee39e48f3e50b82c83dd530d5c28f13b87f2975a73468f1a70b05b97b65a37dff7edf73d33d642cf2c08d18f46f642f81e596cfe5fc756e75031a8f6be9e0fb39e640503a0d782a42ef68167f8fba2ecabcf06db99814df4bb0926dfffb281ca02e00c7aba4b89f47ed01bb14f34471d94ed7262e4a4e9397615eea58e8b789b6c1ce9899f07dd0c5417bddc3125f43ad705d8ab82873152566fa65adcce71eecf9d5c056122febaa1776bafa05a11e1f092c7038c322693f4cc4745c3fcb5ebdaf46a452d7952156f0b83569842341d1613c9f6e532a7a62bdb737928e022d4008395121c4f0012b23c04348eb3e70612f6585b7b4dd05c29d3caac68c5a6044d8050f479b4bdaf80a3c9a43dfd94d9345af94341bf41dbddb47088b8de209e71ac00963a76bacb6e830f06d0d8c7eebcc551f819e558b7788a962be6d74cc9949114f5edb30282fa9906444b0ee905816669b2fdcb838ee3a2790d210d9e88ddb9e625ce7b33b88c21fb3fd86aa82d8802fc5b243703eedf45340d63ce40c00c5e2068151cffb471af122c235bde5a936f6c88c15e94f4e90550b20316615aa00175ce5c3dfa7e15c735193a177610f2a99ec88835d72a7b8ea61d909031e8c5c90b0685d775439b69f6ad96f3932e24941f459124a5b0ef5524c2e2bd480185b13f9bde54f18f511eb3fb2951f1a5a7ca364dd6d99ed9afa88dfbd31c2e9226de419ad6cecb3edd2d70ae72b5dbfdfecd126eb047e3165d042187b37bf348c7879fe90b9236ae976ab3c14bd359bc25f17cee407c3fb00aad0c2c06a3241b0f653ca8eeeccaeb8faf7613c99acdcad7b872ec058af91d9a1f431e33e8bbb3541b179a811ce4a9c38c430f4237a01b23130e66f6050c6429e913b6ca7e813ad9de6358162b67d2eeb80be69d264548966efe4d4cf298ac4d48b6b895f53e85e83ef3322aca63f26090fd739288f15f49d587f1c8ad03623282f2d8fac6fdc39904d9003e8d3752c16a08211b4d6247f3e248eea4aa02293ec93d18cf77fb5fa8ea68ac012b273c4d375deed865022690c372b116f16311f12789fe41b19eba1296da93c5f51d260efb17628ecde3abed14318dc86d1f238b52c147c78c94661028e0a0fb23066d9bd29dd7f81ecec38a8b8f91578a88fec023d773dca3b96d63440aea3a65d3daaed0214610b0974047105c08f8467d35e2db530f1cc6add590730a5b4c32b264c5f48663c9d9e1461f7ba71f3ea4241a33fe33ed8253f481559b2852114dbac0842d3c1b852ee646bb052d2bf7277ecfe7a4c338865a7f9063f2e1b17212d33437c1db1a5820f5a24f769e3fe9c7ed78ff66d04fb9a86f03aaf33c3d45097571c779d49c5d4746510b25663f31d6c02a4aa5274220c55a7809947c8620f00caaf67756133e3838be469de1251637ce01f18f1304816f51d4c380236fcfe036a4a37dd29bf691ffa97567003698b47e13ee55be25143d2a061d0e86901e878f3ef42ca27a67f7df741d51800c17337a803c62e669c6ddfda045c2b03fac3edd966e012dcee426c07d2a111171d06f5e42b28cfc8c3a56e733cac29b0a7672dae3e8e12bbeb378f5fe8feb4158e8bed9cc9dd3218dba2b356faf266e5a8a756d88ce9f5b651a65524a9d21bda75f9cf4d2150f5dd4e4ac78e9d7194ac7efd65c2aaad4a751b16ba8bdf8e406b658916a770025dcfed86f5d62611acdbece4f0727185ed5dd88ea2bd7bb46297f604b3d0f040647b183971f5a2a31da512432e9f270249665b8924c051af6c35e47b67fb54cc9abff09f0d6b412b17e55dbac1650920506853ea8ed4d378ab24185a8ceefd299612949b13998d46f3fd78b7052eea0b8bc0b70d2b059cc582f1fd420ae8e0e4fa75c33652a617b605eaa13151d847d58d2a52da344280f724950188f508f76abd95ba835b6a388f84db86ba074ed46e44a0150a81f72945b6551434584fb900436ef7e145147e164f5cc46bf312d8231ace866f16cd370d9333c4f5c975af8e228747804c852f03c1be9e435fff33b5d8fae9b0e5ed0bd559768279047f3853d8dce9cf4d519e6912766ef98df41ffeac05e5b8c9906f10478e39e971e701293fd01131e6b0d082d2e962103d29d0e1e9a996743284be2fd1bd55b1354cd0be84731470a8cccc431608b83bd3d29bd6c8c88453b1f85886a666f0cb1349c5bac1d06184fa147de2a4da016ae6a0221eee1608508ae0d00fe41ae85f6e29682503f58c315d53044d17cf0b17717a998dd1a26bb0f31ea5dc2aa43e55e410aad92e2bef339c3dd6efafd39c1c8a2dea80650726534996babd4d96181dce67b338fe54e517c471d38d4c8392d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
