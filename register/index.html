<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b86c2d79e03e24c363ce501b2f950e4a130e26a517ad2e934f0f4bc94ed85fd201b52a3b9a90e3047f9673ef6ebff43d4b4933f3b98cb947515e329542d60a0fd4f57493dfc2ddd6aa9aea914a3f21ffa3aecfca04b0c55a015d06bada704980b22524bcd380d8a0bc3a7f15badfe2e2e41a478878f8c42622c971053b168635e8979a5415f477f82127664eade183af63c4fa7b034b2f7a5b228dc3dcb96b50055df8bb707d0588573ddc956974d305236df277371503747895e10465d987d7ff6b1036434d4aeba0dad58d84388a7dd0c48179fa9cdc723bba127a531c6f1e7ad3abe868583c232660dd4f43d77abb89a9780e0a129a0402e87cc1f6eadc1de2bf783b1c9efbcd2e74901635763ed6bfa68b09eedcaa33faa12dbc6aa3afe9b0692873f7e3f6576769a3495f613e4b3d5d573875f19d43a616fbff3e531b085659b9a1092f963ed43e4ee1006243bffe9f53decfbfe28d61efd0e5425a232d5f29281c5de2a924af9aecb665725d186d016b70af0dacf7f429bf09686e827a41321a1d3da4ded49b5029deb401c6727108c8606d09973885df219be28106c2572b5aa7e96255f4929d683360dd7dcce554bbd49f4b6681d8bdfc6ff07cb83782801fee0074356512fec1cebc3e4521d7a8e215181b127825e5781269f63e22b244dc14ac2db45af404ded612a4792e37e16a2ffd5740af7dd3f9839efa646801073bf425eb8445422755102d701de3d7a5f07b05c86c0e331ae1289df083857d2ca7bc290060e4ef7eb10dddb72c4c7cdc8bfe7532978508e70d2f1d04412e3e788ee07365cec7ab34a3623924e2f7f948a4a521d37caebc27b305aa53b9d3ff29fed262b84f4e0b34d828162c64e443f407adb1830666f04098f1a3e443e9eef629399f805c4e2e929459f32ebbd4e93673e898daea1c9d2d476e58c5b07d0f5c641ccbc4cc769091846c6d16964db4b551aafd322d64816a1f46127a91b0f3d195de2ae642c263749f7fe6f010a46d230d29748c21ba9649002a69b7a523f1927cd6219828a9feadd225e54ff117e45448ca1bbbf8740d5d1fde53d6339111f3a37057051344a407ae1afc92072ccdee827d6a86ffe5be02b00c1862dbd499391ce2add8b44aa8ad48a23ef9035982909fb5cdcda90fa8456d17f7bc98199e23ac9e9f6b4d878185a96f1e72c2eba3dd1e3ee476cfb9605b57f46c93e3ac9d4d7735f36cc84b09a301b3f746423e8d6ae67412af46caeede61ecdbb0e08b79dd566815c02674948302bf361affa04d28255aa3c38793bf7dd1f15bbb71a41603775127ed9b2d859c4e6febf41e02e5d6f3a36ef0b6b9000baad48f51cc9e27deffea352787ce3a03af24412d6e7e8a827755c854785b2d26d2c8a8ea047e4fc2ad07835d852a7b8c5bee38d1070ec33436e599b0db883633fb921aac6478c978fa83a0823a3654a28359fbc828ae022e6a39dd6b717e4f841f01a91226435e512c23390cf3ad76167530df0518b476bac54e48bb7e23857198adb242d90d67a3e1c389f4c91d3ce0e52737b2c9835fcd59bb7d57c52cca38b62f2f86222ca87fa73d1e9fa98edb328f2cc2611c0bed6998351a36b2cc09687ef1fbc83dbe9b92a74fb48b370758bb03b6997e67e8c63622bf3a26807d55d1cd681fcc522af383dd721313524c7183bdf70b8ddec6a954c4edd275028ae18638efd1b577e6fc00204eddf6673f9487ecac3f2fdf7470e190f0b69911bf6e594e257e8000c140ad61ee6bae12b73ccccfa0cfd68adc3a1b6b3a04810a6a61211d17f730abed2b53223b23ea6bc45a780c50bfd9e7708a6864d9d47dacbd988d3b28ca43b8077de893f8f6f69701f6d09221c2d130f22a6394ad5adaf4f1f8a58b76564b3bbfad4a2b1f05c0d1bb86fb91cd28e315fac4237614981a250870e3de1a8411807f9b24421e0541ab928b74e0c178ef9267bb4bb469cba6450a49b2d7d6cc4fb7ba42e2977f975b907300985849db9d402efeeaf2b27126a672a78f8cf037c0b3a23b8c321ca8c26157be6f022ee69ef090b6c78e5d39fec79aef2acc8bbd71a718704a249d87edba92a4bcd384a96fd578f15492208e04233b53f8d28cf66c08b228c476b1403fbf69dabf231c4db1f95c3efd9d6be2c0f323a2046d3c6fd6dc360afc5fe90ffbcda67c56b0159ace9d6a145b68e58a6c968a1d1109781384a264a3fecf93759f5acffe9afc42189d22a8d1ac36f543fcfe2cf63e3515b21619c28684bef8e697ec3fa89be2b7f9b8e4a6a96b88a0cbc13a536b41910c73e54afe88e0280b33f8a6bc19cfb994f2240e7795d65488bdfe81c6aa9a7ecb6f155c90eaceca35e0765d627293426025a917c13206481161648d92a714147e50f6f07a0efeb79d30090ce2bf253453b75764e03ac26c3736f817a1e6f4fe58c0439ac0c426fe6f79eeab8f40d3a6910190a1562e6def21810437a9f1cb4d16baa2e0259f49b75274343be891cad8dc4767b0cc47eb16f18c8be81ff0ec4ec815708f0858ad0b2ae734cad43d6f0f8bbe877d1188d8d90186d3aa44f69453c5a7b11d8202e2776e1a38880491837d29a5b484f067d01a61f6f22eb0ffb0d9f42db6821a04d01feed5aaa4f866c891a271ec62f1d3eba087ea4f9f09e8d2a841c7a7844d99e5fdf6fbf4756537ba0c3bcab6f7e0853e60b8a7f1c21e7e726c648deee03bcb6e72da606bf2f9a3742a0e8efe3241b5d8532351e2f2bc6c50a4b06c02b4f417bce2949f0145ea08c977002f0e14db309031d658e881d6acae597c7d13e9d3805e7c49b1fb9c96257ce27d8f22010a7e7fdb74633442a4762a92dda61960c04b0cf2a85947d67cce18fa2d514339fe790392fa2bd03798e95630e7f3055b68ee5c3c700c73119b62bab94436da69b965a4691ab49eec1a73e999c681707d31b02617c459ffc474431ab81bc5b1947dc8cde13c032aabb68ef5e83721de767bbd5679c744e591ba671650d412528838069778aedfccc36574deb207b7589997619ad4ca747a92a0176d8e7a2b6a3d33b2c84cdff848d5e57551d912c608e26fd3e508ffbf7bee1060d4c9022c3618cfafd4cd5feefe174711dd07b381120d0095ace7a8adc06d0446295a9ecc0c9a515afd2126a2c1feae26fdb18cc2a44efbd5ff920ccf27bef2d49e4f464264b5789abef0b40433f46361bcc7006fe37cba829f84237da27ecf24805060859df19e0a71bac1abe6ef17f15db2290b63c91ab199ac0d86e06f9f4fa55f8d408c7a04b84fdf006822532a57266f0bf2d63f1f73d142a1f980c470e6fe5a0c0ea12884a2d2db77884dc336df4c23aa24d195a1b7f375d16e74337129fef53e4ec12ef45e12e76dc0af422a76e3ff8135dc14353ffd965fd94cb3f907b5ad0ae64b26f610bb36f9209853ac1efe678984c4fb454f5e23d7495ac38c48fe4cc3d51da7632af4295869219b2fdf15ecc73c4b7b814e8345e1e85e07eb356fd3d3abcd65ae29a886fb4e36efb6be5fd0bba0c505464d72ddf5ae6e6e0cf9936e2e26632e61cede7372834d8a393405b6c3f5fac09720fcf1cb974581579e9fe84347ac36ada66177d6afb901e843f3ba36305956049475a241b8111c265c180db96ec0bfbd470e1b644260a731e1d10e0efe9f41f2c0af14e3148ca9cadeddbc57f7446f819adbe340516d0031138cada7ca9a6b8ca8fb4b5793a81b2bcc97be50d670352d8a3d0fbb7108ba61a3ada30791b9e95096b67a98b291698f6e0628bbe0a043d5d57a920a7892036ab099236595f534020f8d13a3317c1cf3fa5e1e130691a549837f6b982c6d1a7bc0f8b72956b464b26a7afd7aad2118d5a3977862888478d405f38e4d129090370fd4e12fc3ddf1925422f574fc788d1aba7a2da8c626fdbd0ad1b597c2a961a06e5a297ab566db58fc5547ecd998c9cf1e7d85b965f1d7a8c028b6edbb2c6e46df065256f14a7196c7461d018549611b281d48294df1f5dfd6968c0a4af91ebf551af18ccd8ae0643558cde54fe502c08cc87ced8c99d59a281cacc660b026e56fd3add4ddb63f2017c0c076ed3367f4afa675525cdc7f20271e61fb6cd26b9adfae9dabed251f1de9d6984b755f2bc6e5c4b76aa35a6776198678dfca49ff8763e68bbf4ca4dc4512e623e604a00faf110c7940dbaf01802f49bebb7412f0b08e195dc35b8aeec1ac84a4e09dd7ecdea6563055050f2a5a49efab1eda3226e06f1817842e44e21c5a20924bf8d575977995f1567e30596dbeca845b2a8bc607bac7c6097544bff14a3c07ff3c623c24a2de79ecc669d26623017ca1e51b66646d51e4da53d390af25671f0d4329a9aa2abbaa90f968dd3203df72146a95124732bf814cd5d338fba2536961d6b8651c1dc19268d05d150e9af5e1eb040fab47ec103c0f24751f5389cde05b2c39dfdf5c75f30e96639a6c44a927ea8bed021ece3008ba749affa02ae176ddd2ceefebf0e9e8a77434d260240be077a6c861a7cbbcf3a9885fa19571f20dde888ab33c81cbcca9471e2a903f7042e4f42d3a537d5977b2262ca73e0ca884f142623a5a782e9bc241d45918e83b0a1fc0799c626f888518e94845c850656a8c932de8141181cf08ae426294e018fb3d0f41f07396a7308a938ab2b2d401b3c5bf6cf4d71e4db572cf7bc9e19754f3099e50e03d8b879abbb34b46940b94b582455c7051f9daab81bbbc6bd033d13b3c6ef0292fb5e522cdf106aeff2f2eb22265d61b8215a93b08d3128dfbee26af13b2492b1ead864e15bbf381d55c8f8c69b8caecc43d4a451a544a93f77e4188f06c98d78d5297808df116aa3090d6c9951f45771fc98c692cb356b6eb00a8505b8bf0722a1daa3b911cb7dc0e53e1053213f2759f45b2748f9a0abe6a63f830e2965c21bff095f54f61da39baee2fbdc607e904461d23c2cc90ef0e27aa2c39e8c4d4e841df003e0d027ad9ae59d09f0166d01a3b722fef460268098d547a11fe973427a61bb03712d7ef9274011dc2a2ee6bab402725e624fa5ee471107c3b0fc618aa23a7d8ee0c96f5f0ff8564df8f895c65a58f4d1b586d22e81c33a055b5ce4290ab0384d523050edb8ae995b629c8a27160eb51e558cd6e3d141a9f84686e9cde419521c6720e6cda5078903b01c48c6096c654d8e97b83f32fa153fd58c5cfd134b35c9c703351e04d90ae4e4112388731c5c5f7973bd7cdd9b702449759767fd29c22b0e8ee3fbca26fe8c3c442a472750e17f9d7768006eec63bee5bcc9c97c5130def8a7923659d9d417a4f802aaba59b7344f81fff6e82096243437bc2d85996816d3d08a613b05664c2112481120a0adcb12f39cc0caf7759c54bbab717394e59090d75da3debf0b8362d36b9e8cf69e16c9115dd36647749eb2bc8eb600da0952af65f31133f58576183910e54ba2f811e9532152539bf0dd2aa64d032c4ddf1ac8e33db15fe193fd8bea55e4f5d41f5217c7eef1536c9f43db16ed53bb65d36d029e5a8caef3623db0bde6fc2d4593482559e2083ce2e2ef30d15ac4d8e383e548347f2f5faedb55099d1eaf9224eaf78f88ffbf8e92fa7abadb863b7d22bf8d3ac901b6fca2a2ad66e7a7adda5158c8f91c7ec2bf237dc325a6a0f9424d08ffcce2df2d22bfddcbfdd2aa6c2a666be6d3f15e4371e8936d2f8b5572a4cecc6d8a3d1a6d6de4020c2d09ac9769f919f0c0fa0077d7eb40f634994daaf1753b50a51e4173e590e74aa595456646d6eb5c98e6fcef3acb3816089490f84908df3a5f8b75846bbe1249bf4537e72d44bae26e3f09baf097f17ca107c87f7151bab84117100110048d3010c48f68a0bb5e22fec5211147b94cf49c26c8c4db731f15e1ed332943889862e15dc8d0b582d18d39768c75c680438c140fbb53392277e6c3fc2a14b8173691cde7273239b1c72983060d72d8e18a461013ff93b8aebca3070881a78c31b0162bf4aba8393c445e3f01617ad5255fd408c5b17b8b1f836598bf1e724bd564abe09c30304bca2ed20e2c5ca5d8505f8e2b327ba41570675311d003ae49d24cfb02d2b619727a3e2d7b3ba6607229dd6ddc553a2f8cc9bd6402e4012baea3cefa85ec135e6c967a3e358fc6340dc693560e7f148f80572f6fa2128f53011ac663e01e112aff1fe8dfa967b0540594f6efa499a1d7f3e5293a1f37525cd2b1932e7a059fca36be87f02ef2f0b97d17d23c853423a5ca049f23a2024fb62ac80e2a5aaefc3e2aedbb57bceca0c5d1f6f694eb42fd3f2a02fd875dcd6afb9ce4f89c060f60ed116c73977c2f1d31fe925df48c62f161918f4d7f75cb2adc7d64f385f036a555bba0a4a0ef02993ff9ec53faf5111fd2336d0196de485990fa547826ae670cff7cc23594ffa4657ad92098fed659e5f3d20b487073f87e5415a33e1a61f02ee669964bdfdedb1e3449f3b03f15640c6486204ee4ece0b8965acf0358cddaaf4936336b8a83266bc38c0bd36548350d853d1920780281b8c7b68df8cf6221289d985309096993e9486dd19a7bf28a8f82d64bd98b00d8ac2721d56cf9db8857f04b5afb240781872845f42d404aadfca2d9ea211cd0d438f0777a79f2d03e484f1778e80a7ee2bf12f877d7555b19bdd1fcb5a4757019b0d79b886ee171fd8ff1c36d8b69423c298ec11ef061b63d812fe08ef723ed0ce6636843e48ce249b0807c4dbefc9df6a40adf61625dd95aafdef01ac55cdab58812e073e5bfb3ca009a54f270e08ad87507d502501dce2c6dd15836c00034eeac8ca74501b0b479f1784a2647d65aabba5f69ab7d698d1ca72b9eadc86071d787300892818f9683ac35d47ac83516476f68b75b06136635e2576eafeeb6c1c7a986bf2fb55428fa885361974d3ba67d83f2a5d8f0a902f7fd5acd2ab70753fc455b42cc72b338d1f81f82a241d0c76ca194087360ed44a9b0321ce2fbc9f94c9ea6d9a87b441b1630eebbf833e16f3f8f564760a7a05f9c9bcf6b5761461df32af5bf57a8243b7c233e097f9969f8d5e96b900a10b2d035a523e48b8af15763c458b77ebf3965b192cd8966387cc13c691aee3d9c9fcc506d332d2162166f25439fabf0d120d4a22bf7c7db00b96db8af4693e74394f768705c32acc3491073f2539af3eb64033db01e1c7468914e54557b9f4667156cd14d2071078d18e981fc5b0cb4d4d553645eaa63a613e948909840785de293352404cde1459f60f76ca433387a2394a7a3f7401f7abbceeb1e8e211af24dd5226d7296db8771e7d827a6efcfcf60f8e1446252aa1e4548fd314013b046f1acf056543cc962158afd3db1f8b99200699bab877f6b67d0c6d235ad62b3365549a0a0113ca199dcbe9bd0bc61d41d88b56a743c2a240c4a4283751df828b4cc16365ce46f18bd49c56eae0ede934028c9cb90e2bcb86485a50f7c8f5523e097e1d822d7674cca98db249a560b1d8b4d0993d09d5df6feaa33ad6eb6ebc33888b7b3517a2bc65fa895a35a8211f1e9673b6b8eecbc27a04e07d80cd72ec7359c58b2d826ca531ef460a4845221ab7754c4a08ae2caf2d15b4c4c9881d6c7bdb1f9e38d2cc91d2651451d62bbac44365e4df6d6253e9a9ac5c102fa6bcfe52613d5aedd2905e537a1030af0c0f49af0611e053ef7a245ed0d0d3af37156afb40beca68a735d1665f628c92bc17fafc65a72ee94dae836433805fbe411ee53aafb607fdc84033db1d084ff547cf71ab865c2e05864753c7c52abb3505bbd4a92a22cb29ae7c93334bb1cda969b08a2c26e0ee0b04967a38d7c14e9e992615b116218a34da0d01f615f57980c717678443675e4235523398d7e3a4e722fac1fbed743bc5ffd4d688d5132d3539b90aa280f152f6959cd2b9126f7092477494af7cd3437430a83672c31835243166caedd3bafd26eeb8a4640c7a49f166018d99f436c7c45333cb4e334bd2392063a134cd0ee97921ef844febd0fe175960a46f592b1b146b4ff4e849ecc2e84abfa572292b1703a95973a1379039509c0f5fa482268c533e41abff3e9eac9aa3334602493dcdb2834a3cd3a108726ac93a6dde9e5be02f64eb92ee6e85e76e47467475071a95f6f15df8f4a36535823676950a7cba1454854ef4605ae78c3f7e6c2d93d627a6033fa5c1e9f48167e2ab1ac76ed35f08894dfbe1fc538302d425e98b362641ec2cd199dbc62fa84c618e7783e7973cb1afa31b872772959999375021eca3c8b1f1d343fab7a7a747e89aa6088ce81cbb0621eff6f578145c1a90af9fdc394be6fc63bc7ca0ca9443efbbaab645735dbf30add0b448788c814bcaa50c7acf398315b7b6cf2d3254d71b6beaf7f0b17e1a0afe50fec6ffac0bc405bb561476b86dd71bb79bfb94baabe21011d51f8d5129183845c246144ad446a92f6d6a4e6ecc4f24a7669a979f119adfed7fc293a80304d253b5fe123861f13d81acf02ae253c3651d8b7d98a27429b14f41355e094993e597cd7da330b1900a2455797389a4ea2bd826ac7918552999cc964909549aeefe2b95a97f39b916e932b9c99a829090a1ec71656d40dfc4408bfde819d8aa49636f2f6b21378d761a694583cd42881d0b1129978cf57a364bc90cd0042e74c7ea8c010e4076580c52a1a07624b5fc81606d3c70679ea8eeebe71ce1f2f962970258655d37ebd6d85c49a798964df6b38489b7ff4e292c0d5db9834edc809dc1b913115904fc5b6c5e9579730d36bb7bde766e26fd049d345e3fbaee204c5fe3f550f2a99e5a0cd5c694ec7bbb8c83d316cd8f42f29d872be97b1cc0fc1a186753468f0dbdfaf6961abc67116de25e0f4947fd940b790ca3e9ebf782718844a273246396ff8cc645e9cffbec816b8092d88b3a75cb5f890a4a245a2e771c14df5a3c5ba217fea9cdf5bf2e9588898ee666416542e55d4053e83f6460d1a9b2a0dd8298f69067beff9332589701d2f04372a8047b92b89cc939c5745934cbf53577b4a5796ed7ba2b9a5d887267f98fb81e9cd005f3b3a712821581459c9253ba5e7ec6a0f5b823f32ea929030252b75f7d63d0dda37e1a0c0fae0d48558311d53e10de1a18bf662896868bad12f0db4fcb9592b21177d5a339d38c001885479b43e1bfd03c0b649cde353cc4c4c31469c9b4cb7a4a69463a09090fffe5c90460eace5782ea6d71bee1613f9d45b6bbd6092f18c4adb5edd72d29f8d0ea7f85b9bd249794701b584fbcb97150c9eb65b3808c8cafa3a7a428df4275a2b03e8175b600b547ed18fb8bdcaa75708b89546dbebe41a1286808bc88ecd5e1eeb4f7ad8ef8fc036d60350e5a837f4def32fc1e227a5d6663f8933d37d1290cd3c81946e5b66d15b8a905b689b6602c983d069295b41d39abe9cfabe260fcb28cf845b6a04e6b5ea39b840f58043b3021d9d3625ec75519364803ef3b2b27789908e56a5d53b13e23a16cd1fb1e1c206d829a8f78b0d40729957c6bdb6fde34351fbc6bc2efa77eced45939992cdfca20b0bf344cabf0b527fb8b2935e4573b0bebd7439b876618f235f0e79bdb63665c59599bb06bce422e395d2d39f8279e9877539f0caf5d88f3f071efbac07e894fefb37be9c0ea07536f9959579878c9d6d7efb62898aa91b73bc2e330a0c3c7f722822fef739a75ead18a49d3bcb1be617b74e30f6fc3e875da0d3f6d60de7fcf510225dd1e1d012c80e939f17aa4bdb2078056cc00a139693042f024793823fa767407f19cd6d23c5f348892a59c44083f41c279770fadbf22472af841e6a814fcc613ce6e2251e4d72f780c2551cb13dff1e6a01f34ff9f786dff3f6125179207d6aa75b008cbe7b51c894bb91ac1900c6646d579a5795f35a479890c268486c6c5e535be0a3bdb74ab873ac8ef9dff57dc8a8d6cc662bb055bb02e195e2f82ec3db5f1e0941fb4c9e2fbd9afef7febe79e185e8593759719baa28cf8488145cafd2188645952e51be7d4b3faa348c19fc0030f9c2418cb3adbc3b9b4577502e54cc1414e71e99d36d3aa94361acfe11c1d0b78415e68f94275b564438b0bdfaebf8cd749959254faf8daa7168ad4d0f0424bb47999df911a0a73345df6952af4698f7a4af29eb01beea9fc19f7000930c53568699b0f00b1a2c263468906411f4f6cbac71c4f9efd0a6be8a5434957d27aaef34089de94c78d7b5a7874e60591fa7956ad034049d9945e746dc2adfe929d84f1d437928783900b65174f5d8fc4d6190ddad7d3e29d665da58d06b3ac1bab058122b0c0f7b0d920346e605e806f1c81f71ff447d530cc8346b3c985fe2e198beb232c6039d4339d3a283d13a43a79b3a6ea83a1fe97c9daf732d3f8e2348a78db3eec1caf7e9e9cd1be4e9c4abf9064c1bb797d17614b7354a3ebdfc0f9589dca110e070fb75539b06cbe58510fe426ca95697ec6f7595a05f59ab2bf56ae1cc7153e83d453b1822d998d54508985a5b4ac990c63570832dd65d9699928f3a7131d3e1d66fe621911161982de58172227279b6ee64f48f39c8bdd94df1daf9a40765a8d44b61589e8d80335f6dbb15ea9ba18f19f7750e07e8e91868f3d44679b41eb5b54d02902d32843de4acb10546746cf7866bdf70630ce4309c0bc8a9c1c379235b413e883532b34f0a87e16ab17dfc0df1ca5d2aad3d895acaf84646222c42b18021cef0ccd74138be56399bb5e19e8be549c575d2c9c15411f6e087c26a14f5897b3f66ba916a59c53d6a0e4e848bcc7034adcc99f8a509317b74c0241664a56db258fffd4f209d36f70897516986855abf7e06f8a944c2192fadc0dbfeff421a5a7a50a274d7bd258a48f999bbd162860c84bf90d2f92950985a98d77d61b915245c603024f11103b5837daebd80f9188f5c9207278438e1f1807ca14d5db942dcaccd88bb953dfec760f14de4f1631339ae0eef0a9647e2acd42b6ac29b1f014f4b9bdcb13cea2f41f448b1f3497c229c5836a5d33bfba270bc6ee2d9d4d33c36cc782c46897222ecdf65d5e3d4c47d7a6cbc7f27b507973c0b87898a33c873851ad49f7b1e8b1cace689ddd75edce1c89e1658d1c1a8de0d355f5a6965cf9c086b7dbb370a5a48a1cff495b12e09bdd81c5f1b24e7e670312825637091bf49a3fb0835182d7d75f99f2693c0230f84debec1fc2cac31ddc8b064ccb0890f68c279a6f635997645c124ca5e3116fa7d9b25ca98b417d607dd4fc5f1142ca634d66902db29f835ca9841300760408c7cbddc2fe14e81ebe75b88967f12ee7899bab96c735f32fe126f79df28d94465f5a43734a4b91c6a13c1089b4d2d0231f3d35ff9a22940cc9d2decbe99f0082ffd2685631b9f2afa88e2b4a66d2f1e46c7f6ff4143fc8dda34adf368e8611b1517fa8f4851a3d9ebf8ab638e7fd608333308b47df8a0b5ec48bc7fd881f55c3aebc5d5a1c252afaca5580303d432921ff7b9fd0393acc37d55432a6f6104a0871ccd5c5f79862b88141b8886054faf7b64f5b70aae3b01cf9535d369ef77b10a50dc751b089b559ed4ac0a0424a3000ec00cadd4e4834073fec93ebf503dd3b658679eb048013b23a2a257b910e3271c9e3939a3dd479c90fec6a79b8e402f8435fb9d10ae65d5c5888ed91400930e8eb0fe0d528e7bb47d444134f50d7382fb507f8c493604a3b746a23a84405d2a52a7bad6b719d2955ddeff9a024dfc10c5450e4a14c134dd4dab7d49fb81606b4b6379b607186096bff533b424f75a52d7cacbd08b69d25a73648612d575f69ccb9879e057c2f66f3c8d5a97c5489f5ff88506643458dde5b977547b81cc736f5109daa7863aae9dedf9d16d22900bb45da8e7db375f5f76c63cde05f0213e582fdfcbd0d6de88dcb1ca21b7fdb97901ff22451c52785bee08c19ae56d0fcf966b7ede7baa536ef7a6b3bc08bfbbd554b8c358382c7951769458b431279d353daeaa9a78bb0f04a8ddb48f4830f373bdecd48288505719c1c306db392a4a9c7c7f87defdbd99af7500c43a3a9424267ee1d6515127286f608f797438976d72b24550f907f297b1906aba4cd55241099266e82cfe74396b59f8bb8be92ab12f37699eea15496eefedbe47c449b96cf2c1c0b38bcba736027327300e9cdf453599bdea63baa989831f810a143622d0230cadbeb8144adce8750dcd73441ea08c4d7fcc540694869a646ffc30fa82e8d92a2b746bdaf679b91e3419c2aceb6647e0170c7ce3e25d33bc8d18eb7a4bab25351e091b0382301b55082f57ef268bba8f0fe261994570dc0f62f4d0dc65efe3012d64bb9cda52a15302657041f0187798818e1bfa237b93c1cde0979806c9e223c7d1b70ed10d6f5dd275ea6fef95cbbe7fc1c419cf10e99fb0144a54e18f7e2302b98e4a06b425f29395f522ebde1c61c566b79ff79c76a79e4c5d24dd9659c00f9c035c2c740d6d7790a61ec6056fdbb03d9cfabba40c2210fb5c0808033e62679f540e631ffa6d97646bf86a68b5daa7a48299b81b0462d3dbbf2e9d411f74cff003be3221abaca61d6d66db5c4d1b0937234c077d54c97ffb95f10ed475fc7877144219a031347f29fd34b4031b17684edf8389babb730002d0476870dde4bba766e05996a017c9fd607616466eef1d49ce7f4e2f50454ab7351c0a5ed4540396186c3cecdc9f50a1847c14b9dd22e7015581e80afa5dbd3f72886f0f46205a0ab1884b2ba1fe112eafac70ffeb3172c4dbf4ea274b944fe2f081ad6d205b84497f0eaff032a1fe3184a06ab64081fbff03e25f4c9a00046504b4830e83a0c1e6f5d053f476531ef9ea13455d8e963090d8cce54ed0d04b3ebbfe7b4b8b81098be5b54951bef6902b33a460bda5b6247c9e648c8a1f297d679cbcdaa02ea34a0f2a236b5506b770eaa27c80159e104cf15f16c6ceb0ab8c5f890fe41bcd92b1800e1d9d49bc7ce233a91520fc5956a1a71437727448069f13b36b233628576f5afbc69fb0812e4dc610ee2cf4351609fed7057af90ff126d84c90821daf4241ee5ab0c62082bc335d064ffe177448bf95023cec76bdae4f3e67a4cf0d97f7742766fc393ae06b274d151e94925a3019e14cd512d06100f21a6678e6675651ae3beb5c0872891397545ea0ce928ae0739953f043c9aed99b9541077f3d37c75a702b1c6776d9f6f9185244500746dee1a83c1d388a121bad13c8c47b8f0abb9cf6fde6a648473ef5f116c299042e3b5921da87cc534de68d908d907d8016f8faebc494ca75771a684571ad17f128f081301a014d8b7a412aa97e976223d0d37fec59d8b8e1145d9f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
