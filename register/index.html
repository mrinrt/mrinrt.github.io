<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19b62101d99118485c7f7c750f85e11ad8a02bc891e7c0ba7e74bdef60846480dea3d76e14ee29d424653d930c02926ed0fa264e62fb5822d6b168f872ed6c5f7ae99272b632e08f961dc4fdd4ba1dd31ae9e53f40ab16176fc9ccbe497592b9901520d68ce7be82ed10f300f26a88704a50613ea268c47bd293a7693fed5229ef1cf01ac66cf862f371dca4582723333c70fe2764224b854191b0dc2fa6318a5175ff3ca7e746ffd67fa7a8d502b6dd688a5d5e50d06a5e3c88dea242871349147b2a2485b4b033138cdc7ffac8ca3e61c0dff07ac3bc982f95d271b33e5235898c6ef8043f5021b4f4f02309f234531127491d7afe810cc127641a937d2aafb1da0b5d3377d1339de01b58d271877ff0fd1f9a233beccbf44510c9fc09a0851eba52c42b38a973563da7e36ecd1e5386856ebac96e44192e02dc22884640b7035a4dc677be6eed9b789ef8fd6c96ae94d1d0bc1565736b27cff97f48f0cba9d28e114e07fe6aebe51859f8c9373cb8172cd083b85a59aa4503c2035a2b747c51bf2b936085f0afed78ee1189c7fcbf9f2ce41f2bfb723b92c128ddfb127a1b7d7d32ae1535c2bce20c96b27f03cf0cee740b47e6826c36191a4540d8e5ddede61d450b9cdfcc30316b9d0e700baab72a4cfa15826c38dbc4fad7a910a3fd927eee041c27bac1af49b9c8164eb7121a644778609cfce666ef2deb010ee870cfcfdab0a8b645ef14b936145dece04eccc86493e8d93149e26a675eecada7d735658f4cd7227af0f3623bfc4c2e67aca939afc727437c05cdfa6c140d9e0a33c0d2226e7e4b8bf3deedb627f1a4e959050c075d329b602d9d8dadf2b1727f213783e26037efdb675dbc6cdb72c6bb850f83a81a786a8591fec35d95b8b8da0baede4e12931e66c9ba5bc7dc0ece61ccacf279a35c434d147e8cee9fd7d6aeb0e104556913b38772ceed1f593590b7517910ad3941564aa693fba5bd77fb136d7831096e062cde99701dad9af533f5371db6648df3c1c4316ebfe021f008e9faafdc60b4101c9b54db724516f75f61d2879d2101ef7f3b1d16955bdacb92226c8670d946b6528e920701f67607a2a552e3369a2ded510d23f1e5d4687f801c1777d755d091d1d57fad10832e6cf26174a4a9268a0e143aa49f727f4054d4ca19ddc8805758f765ac9e6326e314e4aca4ae80a5bded886a92dde0100ef1ff87a9783fa47982c3ff2c55a326bcab4c8b051574ff5a141dc3e97bfb5de994c0a96d6dbee0d964456c0846431141d75b7f27dfaa41d2d5153c7c8c6afb6e6a0e37967114d135327629580183ebe28c0d6cd5443e418fa4afeed62e96bacbf05c8f40199fb24faa82d5bb9b62e4964ca4c4e135dcc9326f5a97dec866f4f9e373c4cfcfa618b99b34d60e863df8573ff87b04afac66b6434cb7c6168ee25bcb62e6fd11377c3f00706d824b084f3fdff1cc434d78fbdcf7d1dda32ba2d5878129db21d06a5211142c87d80b4733fbbca5f98bc49e9ebcfe9c890c819d2d54519cd3c9178232237e26397567cbed7168bb40c125082952a7237b5570d58a1e50e9fd3896ee2870f0fcd6e852736d46042c2af8eed84ab05acd2e034eb09bb0a270c87cc0417c9d7c65a823dac0adb0a84b91a487d4d6c54581028ae3b161d0445932f0c140d6d611ce4d8072df7955004e7516d376b78527b9adea9d50f426fa7ab0711db7295c3a5ca09c98344c9ed6f1e938e5e247d2a2dd83dd3809c8655af69328546d72aa09fa26bbb1f88eeaae79b4543ac7530e9e8a86c710567846290ed765f8a6ee3ce2cba8e63deacce0eae9b24c614afea26a8463427a9d5f4f7ab42cfaa3a9a5d02a4acd1816065109ae897296724d7bd8ae67011fa15fbd753d150bb67ecc6784bcdf715afcc7c22420f31fdb9b3ef75f01a322ede84cf3ddc44e71381bf3b39f28655728922a55535258174086bb472182c7b923e506a1f7408470fed0cf021adb06e10416272489986073b595f4d44adbac45329073d8162ca1da517fdaa885a05ca2328c15bac839f184862238dee4b4c380ccd3e53d3c5333784dcf291bb88392b3fd6c42202176645f6722f77346c9be1aeaaa763074fd3439aab945fca53b21e3dee5f453acc367d730facac5ed9dbf0be557a9d02737443667167bc6bb9a7ae08a3bed4e03f75f4d33eb3214b19eb35df4d90fc32a766d00facc13a74bc7e45476e9acea275bc4137a713dea1c17db7e06f340812583043ddc972705e0271a440f092dbb2155cb11d19c6cbc16c5968aaaa220c83326ac0a54508bcf536a61f9b04501a5b6119ff483b572a2ed7135ffc72378e125ea1fefb09505a75af5df5f710d5d6a300f49633f96cecf7882e7f70d5df7cc299f735c64cf7328473751dbfdbb5b413cdb6d6f758e078e6635132212c330ab9d9da109f6b0ba196f44a660e0b644a738d08bed94d220f470773bfc0c8e39ef3c02791d63a11988513d98cb0d5735a73e782837db3498132a029ce538c50e5b177cbfffb992334cd6430b07c45ba1513710b58093a2595e5151f5e6792e42a60fb6413e63b6ed9ca7f9dac7da7a4ced28d4a2cee966632ffac918e4fe7b62fa4d77811e0cb86230681fab6543cba462796a19ba9739220c485c226ea954a738ae081cad00e42209c216fde370f641d0b637e3baa7341e08c7d9baa893e678cc767db27a5d66b6ff79da3165793fd5b2a8f1d0fca50c730370c404791dfc034a2d38b898ac0b7586ffcc6b49b64a5370773a960290fe5782c0d6b6a481f19f609862c4321eacb22387b9aa361ef4460885817a0d99f6d2b9c7447bac180357e01956464f70a2f1cf0edca3cd6642cfd2fbc2ada54f124187c6039c7d910dc4bb572ee0a43b307d424b62c5ac9d555e3a466edad40d2d8b91ecd3b9d748cc15ddc92cead5fb6bcfc4ac20781cc19cf5afaa38b8c135f798ad3dbbadb53f46a1be211bd686ec9b6cbb9564742a0645a3cb0bbcd08452457d44ccfa74ef39ddeef3d820749630e007ea0bf03ff922e546a63b1a0f648b745276aa1f4247c299699cb48ef54c60d2f427f73f3c4c6665a9a2cbdbaefec87cc276df3ab4fd0ad09c3788928bb1320a2bbc56f87cb5e4370b4774647cefd555e3232070619d3c56ea7407a0b2577452b80b9fd007b0234ce5c12845f7b72ef78ff9b078d36308fe5a561f5b250bae953a4fad426159893769786e0da5408f712d92b9f705be9e52a639ea087fba079c79c8f9ff4ad0902c67a68d6a3d35e98236a690e53a0d92e22bffef404736c2873077e14f0a4146df51fdffb6160dcdcd9da3c849bfbdcf54f8c63ac93ff96a4fc0828714d1b1c7df286a96a2aa037a9261206476014d189b3f2a47b3e4e04601792eb34147df31a4ebfcd41eda6545b01bd9461535fcf930c59a4918b270548066e8fccf6e29274471057db167eba0579ed9f4a352524fd232a5be74fe3de80376229214ebb8fcff20e8770124e55d8a63f06fea24b7e3541728284214ca12dd159d23285781ddbe4ce92b16be7b4a5c2ec20529d925cfe56f2716437efbd34afcb8994472ed9f7af2ba149d2e3593cc06f4c39ca253dff1ecb43a0d5dc271318c25ed43ab032bcb33a62cbd1aec637f80f92de10f0146f2abb8be71eef0cb14c21c4d7130428b49b6c3e66ffeb0eea3ceb5ffe7656d95a50bdbc9a8f609af3e1361b69c2d6abf66753c9dcdb07e92a60f8229ec2ce4b8d7ee46e190e5a65993e4a47b40bdbb7a1a9e32e4602913c9458b212a5bb17527f16e5887e63c97b8370d393c58b76bf0d9c716d37a2602fe8e76cc0a843b4e9533989f64f4b16c13ae6823718db4dee1059bc2ed4ab135ac2b362b44d6ec8dacfc49084b8b7920fbdddcca0deaf681a8686d4057b408ef9a36e04f78816548f0a18fd93e7549f59484ab2fcfee920374d7380ca323a3b10d9c0d146884f261e804b4ba85e048dee2baac0fdcd108ca567008e3fc671fdb90ec79b973e1002016509fa494a22fa2c4452903d7996bd2d343ed5da49824a598d288c392d561ea816267723d8c94cc9bd8baab6a0e65c199d1f1f94aca4a0af329fc0519483f5edb5231493297c286520549e177630689e096110d829967d95df1b692195475711d22f42b501b17f33fa5ae7b9f5c631cc3a0d7dcc31977580f8d14cb7b313c88e1e5e9f603d197f037e3102e612bc7df79aad56d0a4ac79a8b5dc107b0bb0e9379f74e0ade9c1cbb3a6809d4acbbf817a7af3df47227d11ba4a155ac92bfc038279d9ff52f13e8609658c9d3383b77f849afd9739fa947b7a1c79374233143e48406b932127c35c020482b0263a30402c729dd450796273611d0b4c0e6f94e4c142a21d9219ca9200ed7f60fcdc9c9aff50ec3d547a4d6aa1be6d5d0f20ba799508ef2dedd319b0ff1785d46d61e438ca2b7ab58763955c13b507dd410647d7e7d72ebfaab785578c8e6a4bbc94540d1b452271d15fada1238564a76e5dd36cc48e7805e25a395cd507b293bf5a7677d0f62267840b07ae0232885c62dd11fc604306816215e3e55e741fe7b9e527295e2e70f1f3cdf7264fc82eb1a3d6b24c406947ad887a40aae0196bca5b7edde19f7b6f460c1140e3ddc368d8841bf028715617beae4e9cbef3b2a650fa30aa358e657395b0b9cc779a741a8ac926b7277edc54790e437f2f955da8d2ff6c52d34ce02dd39c29c3bb614e566b74f5260e05ce101827bf1b47cc34ab33730fa9c3d75cf1c7051b32a9f9ec984b93889f565450db312fe4c378fdaca35c0cf5f84ba41fef6ffd03814dfca4cc80c7ba033fdc48d9fcc35284ea259980839dff5bdebcf6944e2dd9ba7e9f9594ed42f709da27a5a56674f1ffb1a4166491096675c87d8b4555cc66d2d228f7984a0b30d78e051292d8ea6c43ac341b3a911c0c03aa739293c879911dddb376aee69504e7d16bbfe928b7a429f865ccc6cc4fe45d193138f396d27629644bc0e018bf11ddf14c9a97476266c596f228943a1c5dce5fe513f090d3ce98fa263836dde4f4fdf94b9affb91bf9e8a0b8b8e6376652fef8fd66d3ebc64b9473f48f049f8e8b8f500c44b2a08454fb0650091341b11e7733e72bcfe011c823dcea7d9c6d9dfff39aa423bf4236b8eb3505b8852404f339b2b9436a0c6831a90bb242c237f4628fe11f927119dc4bc72346d83f6e2e6f6b41ba76c4ec7a95d334642dc7baf9e1c5c135dafa8730cce0aed511d507fb55751d5afde3d6520967eac2a8e074025eded8832cdec32ef7db3db4da9567942ae0d85a489420c348e35524c9f49e76b8d67e2807c5234aa7609292aec91eecf097cb279776bc9e90ef111bf4134f6467f0aa4fdd79c66fdab18af307054ad91074d746c9b1680d656be473129607fb916b3258ef2c2e618d6239aeabe5a7b4a314b40a9395d7a8255bab30c6e498bb53b2439c8d681336715e531226815f85bde10b1856dfeacfa8376a1a20db0ab176dbb5343b9643bd18604a28da80f62f2d61e5ced714b77f42f7e091b220ee978566626bbacae79ac4c0cc4e7fcd95266c1cf9f3d89a874baa9d4c20ea2cb91793c5553c9a13d323e79ef998f973e0f13697f400d4c6c1bf753ff8572673c366c91116032f36818f66844e89d98454107e53941200c535c419df318170a5675f04e18d925ff220770f53406ea427950290ac99f956e8dd06a740553e2b5f64b6509a0376f521a290312c0aa8b63619ffc85f7b9c88cc9709a948594a67d400fa61bd9e50866b4d176221275c5c646ecd401ef46992ddb249c4dc4045a2229fc5de36be342dcbe604c49fb4d9db0fec1af51ccc8b58725dd9677635c54eae188a5663ef357527b655863526ab7012071208a3b7233b31a1c9205875d2b3d3bb03ffe4aaa233f7aa55ffcde34f781d53a0c7aa9202262c6b690260d44889a092d9299f0dc3d472c6b4f0e15f11aef4bf9dcfa77e9975b9d66286cb38739b72560936c81b1a53b4e743a4cac1e0eab401ee00f001b9440764a2451c3b98d42951c42287c2e0c56ba858aaa231b05567ddb9452d0502d60211df0be296a257a0e6e59e0d6c7c3a19633e8b6210fde5d17f4bb3f87e36eaa9a0ace4b63fc9ea84a9f0eb88399135c9fc183b3b71be480f06b19830950bee532b4d7eb8d6e175ddd6feeead3bb7a151b8ad5f35effd1bc8052a446e26896c0d77c709f179add3a21f5a9b5fd23c5e2f1e6253a47d65c6e073fbcf0b4e4d1aa6a873c84793729c376c034f7b7852b270de6c1801a77fe85208dd0494a5e1ee7c5c18d92ffd909c15a297a3ff5423df4de797b0bd5e895bff264313d175e17d85dc3ea8c6d5db7b6678dc9cc4c0f4b60b3da77ca07a6efe835cc99a0a64f2b392d4d443a2c7370a3ed44269d000b254cdc7496726ed262915ca0b50dccdf5bc790944691755350d3b7911d276856b7da991149df11c1a3c0e65b986523f3b66fbf3b5c0ff93e58c842e4aa3376a5425b1a861202a57908be9f7c4a1fa1a66c8f52d8f77fe832d2e941c3c3f8687af828412790492f5814c5d7772da86b55ed5eebdc0c428dec9a3a3e4df75777d5f46bc7b353c2592eafad224471b1a2e461ab7a6026b5c85de90ad809e0c5e49bbc76c6af0e67269e94d2786a55d9e799fb47f11e1c685f36b5dec214594f675b5b185993067e973c338bb6332461bc5286fe45a779538f79c2e0d302cff28a0a2c4fbb2ee5814023243ea1156b7cd05b592eae1ef2c1515006e700e5f80e6b268d57cf2998f046143cb4874d25ed49259a1d9fd191cdbe4097d1e15bc5575713eb334cf64ca08d6d70ed4158159d12116e50a512fb7c33c8fc3868a446567c309bc10f0179f73b01b79b8ea1cc8e5592f744bd108d51c5a21c676395cf9a1739a5de0694907a0c50f1d9550cadf8658c3026c3b6a47d6a94088bb493f6d56eb80b16480ffb81900bdca1f2cadac0f728e4d2f31b20ae1db497599863fc76b39fa4479612632525ccdea3789982977bb7fb2921b1823c44b34351bbbd9fbf48bb3cb5f745f6cf83effaefc8ac4362339317638390e277bc15b3468b8a93c2f53caaa90a8ea6df8cb214e6b61ec0cb2c912e389fab4d854beff76c4d511d50a168c276866e99af8340019eae00a383fe7629e07fa326a3cbd6c2222c1e4ecd7e9de20ef240d8fefe4b5a999d9f529d784f143777ddccd7b7ab942dd094bb8bdabeba9e4b1379ff5f344bdb602e560b0ebf38e5fbf34e730dad11429f595d0f3d4036b2d4f335acb16e3fdfc30c14f20c34cf73b6b287cdd54e0c4dcbcb9ec65b23599246bb562faaf017a4bd2f42417ab75d38365a5359764545d50b7597d63f7ff02ecb0f9d211d70d76844d0077d36f30ee7ef9b9b3412903ff6a3879fb7bc947f3ea129d6064a69641d7d98043f4e459fb79a5d5493100c05aff1eec5e4fe01da197212a6c5b9186bdee98545586bec0e3b77a9d9bc9f6c053fb1dff98693ce73d71f1b1f3e7106824f4d63f899ebddbeb5dc634aae07da09c343f574fb35a897bd6b757025dded6ac89730c6edbc84f364ed59c172e4fae8548ae9310c678ab5fa0426db22071b85c7b04bcbb5073a1223f0e82643b3ece9c5e16dfcc6b96e5263be02e126cc521adad709ce471b8da4d9af1b4e3aec6722ada97b6704933e19ddbb57c4b5528634f6d316e1cde486a07bd7bf597e55940317fc6c02aa624679b63bf8308c4c0f69c2308aa9ed7df71e020dee5aa318a91bb5e40a9dcf13faf3eb18b81dc39131ec9e5b111482480cf6fd469d6c20bc1ccc2f55a6e4ab401474cf311875922a77978987dc667912fccf2e4fd6b131a0a325700532a8f440a9d4dd578ff1feb5254e713c00a45191de8e3cd1a4a08704a7760f260b1ab367e05a3d41688093d03da864c60cb113f70aa1ec6f9c63d1203589337ad8c8cc44cdffde39e6ad372aa605021013b6c5cec559b6fcabe8399ad28a1938e6876cd06a66b663b5f8a083837f206a6e57056bf1d330dca21a01b1bd8bdccb7cca9f80532f3e4cbab42f538d853dd7c01f43ba3c604bfebc84f1477fd7f54ce6e9b4052b541357ca4dec007f4031c171f369d40a667e77c56ee2bc8cc1ea0056052d8a2babe0b800b4b89f1dec21982a73a3b8d565465379929da21fb118907930c70ba07955e174082b9dfcac6e54bc13762a2b611c34b922573e01b1ace1348b0f6e85e919389cedb1e0a9751003edd43c2b8184ac06b910f8c85a1be2b2cff7d010ad1e0ce2276be7fab26021c854679f0b1c675f03995ca3464da653f7a4f32b68e91bbfe84b762777aaf63cae95529b061a3b9c861fab5b60d9843d58ebbad127e56e76817c519f0df78d03185abf6c89550299dfc88ce1cd61270890fe7475012948782d03c2106a7aa15a64904a610ea96cdb241088c8a71cbb413a2175dc1f29f36b6e1445edc031609354896641d8ac1c188922e8d9e7536910c0921740886b307344b0be366287bd30892527867538c521879978100d47f288d2ce2f2cb0f55035325dc01fcb1da6356a25e37f8e9f684c55fab01b9d80241dc0b8528154332b8ad17ef76ad83a92eabfbb416c8896c4669e67fe427d3018070667d9dd707b5ab3ffcf8ffcff4c5a60baa380c3f8ad6244157710562d5caefc2a58507c312ae2330e71cdba68b021b0bfb291e9e03c4f3806cfd932787c513b10779dcfb87fbf4b0b5edd619dba4b4f77ec13ecaea9a4d2c691755f7559b8ac1baa951e58d7419f099b60b52423589963f696337d445215cc94a76bb0f12e3da21b0dfb8bb0c891707201fb82838e52aca2139adbd0353f4b3aae9aa12d475cadb3d8b9c390ac439b73d3688325886998e0c047be92a1a86ca6636d3e4c5cc5809568a0fa95ae47af75f6d0565a83c937c9e14cd8395e4367e0a281c90ef49e72e8956df29d46f57fee0544dad32bf1d3e6f3de69e2c5a8e8b57f145b816b834714263a36bbc098597d79102d653db57c63ada26b3560748c43712035eb55155124425174b7f80b8dfb19e4c1053db223d2c146a38697e65e2c70a9c4ceb9dbd131ca8c6576354a01ef9c3f8e80374044961e2f1d98d13adf650793f651804e7f940f8c0e782dfb1be26c6028772d8b5631d8c77eea09edccb6691b1fa48327a6182d39a802e77085c362935348a8622801426be4f5cb1edf0f793efbc7e2d91a8ea68af5508db32cb4ae7b025c7cdef631701e7050b6f12c8b8e8a0b31dd5806f2d4d74964d741542770858136459c3f53bd8ffdabd0cb7881462030460803f1188487c642f0a9ffa194c83bebbad2c500d237d5c0df385036176530e27914478d01af8497b24cd85084eba9a029c081d7917591865bcb8a52993868754fc6ac85196d528d7faf032f8e02b80be61f9a27784c37f77f09b179b735f50cee9c536f440884c0163dd134d354833d341edb0e3ec2dbf5de5f109433606aabf1e3abf80eee5cbb5ae9a1a205b6e29e7effeaf8af12d3ad9d384c14cc2dc1cc74f346f10b0a01296c8ee67460e55ba7b14212e1e2f4eb09c1cc0b89a749372c78a62bd982bb71bd395acfaa0a7fc58ceda609f02c29a514956799661bb2c08c93c0e000c1ca42ec8b4e52ff01df770dc4736590135014a889da349c97c2ae82cee1a484c27741627c0ad903cc0f52a69fe459ce30b3c18aaa55e47c4534352d07713aa7f81d4c64fd5f28d189f01b3d1c4e6504a8ae5cb737d5c09c7148c8d139fc6aeee22d6e0a03e07cca0fd00730136b601eaf3f4747026f19313ad7887b55889e58cf2d1ed9614f15778258c775a8c370a03722fd1ebc09b2c7f7a98607e2d6081a1a43547d0a575074a8a512852a9210c3b1a911cd551a582f79d3d5abfee8bdcd95da8e819f62c036cfa57641f59e20c4ae826223609bcf3a5c33754837093a286a47028528474c0be50d683327da3993e3137717bfe78cd536dc6d45751bd64a1f4223407dcbb190b32d198452c4a43f9b1a7cf933fe2cf7f8edda1e978ed2dbdabbd911ffa23af27ae9df052658c6990a7683d3dfdf4e4b0200ed5a26e74fd441c7c5497fbc3a0876a73b3d1f1bb7aa6d9da33aff3aef086d05616bfc799bcbd2c4d0c59200db9b8d3e99968d0499b6ea92f4e7227c270fe42f28361dfc829b774c9c75bd973871e2e7f3f7211a7baec265ba0f71cd0691f8a848d8488373a64154f73beb49f4413d19a547e2e7194784b7aa81a098821e62ff22ed2727b6eaba9729a6f180a24769f28c2c7d2768db2c7e2980d976d4e75ce9dde7409cd225e9c85d28ee5fe3100eb60245fc9ad091cf4241db6ad42ceb6c2c3d1ecc0f401b69906ca7ebaac7fc1ac039dab68aaa1de9d434447e9f517b422da509898573c8aed8fb54f168189b58fac0eac3e72a04cae48059d23429121c22deb3cb97fe9fbda3666f056af644bd062744f3ccf959ab5e018ba14c6c6a6f80cff49a5085f0fe74bf51a6817f8ba05563fd7f227fc64784df7502c8696f49a7c49130ed7ee65119ec55d4424c60ef1ab21832a5bc54311a1dbc441c28fe442cf8c338eaff843fa82c3857bb4a897c457e52af1effc6c44471349d5f9a7a35a1c5c79bb4258c84b24b57d5686e8733d92efa37b20bda8eae1d939a76953b8f96ab865cbe719375ac1aa6862b7f8586b37742e02acc4a69b7706505d513453641e41f1dbd89295db19bad9a16cc337a6e66916a2a03bd38101e6989f30cc5ee056d9336b361f616cd8f9dac767e5920149e896f3f6e0f2098811316627b76dc7fa3dbf50709b51ac20550cdab01e769467c8f522774feca0285f63be3a676eb4d5e3e14e1fe64c5f9afe51217af328670269b4e4aa70022941cf359e1823d7fa42290f1f12be0d7e3fb4800a6954dc83f1188c536820ccef60e5c8d7d275bf6ce6413816fe387f8076dfe689c38f00624e0e928ecad07af9751cffcddd5be05d490d7fd01e82042498e6116c58622d2bc9e9ee4027bddc2942b34c88a6fd7f89f6a13af125b6e5eedc665f488d92c8312f6514b1dd83e4496c9a176d030ab762008a06af409b55553f2daae2304c04d89c618e5f1626f314b2d73c68341587b6c0003c9cf705c5e583581a8e5ae6247a848f628d6d50f05b98fa4cf084580a551ba17f54b18411608a647a39716d671a29e53796ae5d938cb94f3d1f240a5a6369ab9f890a6a9fa5a8e7eada7aef694af9fce6b92549a1b324689327c692d851b3d53cd26a55e4260e8742a0f9f8db3842f13dd39cf4797d20e5b6d4b8d9bc750a40ab4251fe754aa69627ec1218a81318a96e0813f39a6f07049b8e9d175f3a314dc8512bea407b7268947b009a1b7a393f072183d1cac33ace05950316f131da712364ce892ed6823a952ee96332821df7eab49e88208f90a3817a1b0d0a020498a2010eb431d1a4dfdc7943274be97395a9d17d7bbfcc7e5165384e9d0f7fc017ae32fe6a94808f5b6c4eec3e5916bed6757974a1f6f272c5d5a0b57729ca3c31070cac291af940045d8a3e70d19dfed14a5a9969801119a89d8c8edc2bb81fcb37264150979c1273b48e130303f93fb546d772eb18c518a14745d777959eedf26306a36b155cde3a04baad09a5388d62eacbe14f071971302266a86e5c3cbeaeead62da3a621f20faea2b1f72ca9f82a36ea73726f4ee4b511da1012f3df942e313b96b0a6587ec16486aa94d156c8d4b3a46fe12a824928843db35158603d2341be41db1a60048b18eacf1349d38e59472514efe4a39337d8bd7a780b6b2c68f055cff9bba8ce4196d0deee0a6bceb0f4a237ca210eed922e3a94c552171f12c51de9e671e341cf0119cd8478df1e0a3c139e3e96171e70da23d075a8f8cbae53dec979835f69766a8221e484265255b093b281cbd87c84d722858b5c884875f304627f39bc36ff082fe365a7859f328df1da52adfe51f3d46e587fce31002d1a0c1f1307c37e575a4ee6bf0a0e9eeb190a9e0296dbe343d7d671a2b32766975ccee5e7b0d716b2b3af30daf8131fd0e64bcaa27e694bfcee53c4f1e1efd4f4816e0cd78854e7db0c35ab62ef1bda1210a06db0e88e6b311bba5eeb25dd05f841e5ffe7372fb6aa3f1e03ee3c7524d8539068062489b31e4d4df0d8972713d7a310ca600bdabd917602f1c42c9d4ec639151cea2ce97cd7962018f0cd6b6f667a82a81cdd63f93d219bcf3480898350f3e00e0201747140221556c961717dc6b23bd7b186b3a3c48dd15354b3574121f910f3b151291e65b9839dbbc0346749c752e51d2cd3cefeba09031398379baabd9c7e0eb18225d94d00f67c401eac33f3d097c774aa0c1f578058d763cac829833db00f78d144f55298cf51aa686039cd43c26e978e76ae57addf2d3da06992e8ee3aaed52a38614fa938317dea8a7bce6b3c446dd8d4a489493dd9e5c47c72ca8220ad9a5dfed90511bf84e0a49008ab310f979f603c28c7600275894f7e4fe7ec99957a36ee146fb1c52865d86aad08cda625bea53f5fd3f130a92ac6d61f5ff408fed5e482bd26b2b0e9d236cac78ef9a7ef01f1e3bb177b976ba8242c9ed7ca747d86e81691dbdb9a31c0fb2b7856e722faedbc59bf74fa71fd5e6b18f5c36a3da2aaab555be92079c0d1e7204852b0d166d1be408384695671c2fc19f94822006d0d80ea2a7e8dea4e06ddeec78732db9a3cf23d821bfb45993ef98d96703e56d94714bbda7b8e60f253f180368ca1b454f60f631069e44c66a152e9ded0a9b5b83c0c173a973f17ca544fb319794990bb0550b2966b20cdb595061cc30f5f5d7a60d002d23df618e4b03771d537c46bd2f33ce711f838a3da33a1b4b63c0670cbc861a7c60a645b19b99f2d822b20665168d3761d5d9795c8817f48ddd2e70acc678ce06991f28286d16892bdddfbfb8d9e5b01c57f0bdfbb90a40995d2911daa501f19963d78d436215f8b9fc1f81a56ac2c930ab32ee6cc91219c87f205cc5432cf77b89411e7e0e2abd9503f0bf003f4153dee961de698c6fa6182e3f0af210ec538bad131aa2b8863cf8cad1583ce5beb40a4f5a261635c5db7ed85943b12b78aae00d8704913f0c2765bceb949fff92ad14082b2db751b633a1917069fd7100e1f458851505ccaaac5cead1c108db67b32625c11c738d383ef65762c4b5e1f8c5f5b3a66ba71d07874706b4816322e3e1aa42639297de35df416f92ca073c44f0111e75e9ed146fadf6e9bb13e2d1b030745bdf34bdae14d5a2d4168d5a4221e9a70f80f83b1a60bdb187705f7504bd21b384a33e7e5167d55527b42d8d8dfb95a97e45a8a39924ce9cc5a17309e22d00447fb7aa6adc4d953d7fbc01d896b4710a2eb2b81e6815099fb73b95998b355fb721ac4a99d8108134c8f1ed5f4f3b94a5832f3ff461ba475aaf79123d2ad53b7077edf47b3eda0d7249d13c334125ab63e067b8281d1ce582d2761cefca3353eafa77a0f6e7db6c04b9043ba715ab31eb09fd623ad811dd13d0506f8f2ff5df7dcb7f0bc235f9af96513c459532ec64bb734a5e000c06df79b5d6b2de4b662db6003e5e2dd61213b3f636c9a8ba1cf0eb20c9dce97e1a194796a32377b9adf65e651b68dc82aade8117ecffe1e9e7a3ab98c6831e5701ff6f7a975f4c8d652816d28f17916cf37822d46214d74457eee654c540e5586c5eb0969892933ff7dabb7e6f99ade14817ed6b0a01a9afb5d2728ace8f28d7b72e3c097f4a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
