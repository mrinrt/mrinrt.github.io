<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aac05562ef444e9c60463bb8f4050412121b531db95322131017e6dda0b659f7814fdcb61f66f32aeecac1b037ed4714692b2e60685761105992fc7646fb568ac0d332c107d9744778991afac6493ad09ad70599930696ed3c04c4e3be80380e1ca107af7f3079a6f76569a16594e1c2818492a506c2e63b75def7892851b60f5aadf9e6cf51b0ed8f319d89ead55e04587833b10c78e84203d1b599b73540e2f31e16de180b9c53c40f9bfbd42c6d7e140d2609d37754bf353f8aa3f3a200c6791b1b24f1c73adb16116fadd80f373bf7cabccb24c7d53a694975c1951850ad24e4c16d84d9f0b0ff3b1835db03778a1e2a740900da5db87f546881fb4f750a0a787ddde4d6ae713bd673368845cb42b38281d1d765eb25f0b9de9d232463cf8cb8f7164c60403c84d9e4a0d35da63139e10e5fab3401e569ce7b28008456e4f036a8a2daa677efdfc4289889806458e6f60f227a943c9163a39803b415ceb92b2508a1cee3fef2f22200388f350292e2ed6f51dbea5486c9352060c0bbfbc4e7668c56b9133c40b722c09df5a10b57279b5d76628f5a4c4b1dc7dc16ae261c199ca27d9dd22b0664407695e0d307c9460cfb730228b94e5cdf6512abd3d639a25e864bd8e28e058e0965a59202c7166d506609f2d5061c748c1a17e6fa6901c4a009b372a42c9f4a20e6da72c6bd283bd485420c50478ff7d7ff4e1329d1432f9180eb061ad25603c64d676de9132cc7133d131fd2bc9f88cf5f6ce3a9a347474a6d3d3384e5ce0a839830b243ec6f65010ec49c65ceb83b7640d5fda08900c9e38f011369a2635ca76e5bb7d4c3314763e35a4c3adaaf02d88f14e6eb64692f7c7326caf17d57d7aac600800b8b979592f8bcbcb6d517b62274f34e02d2bb1b4b88e70f8501509a9941eac475a8caf882d532fe4796ea2a3f089d66e5dd5547096e055f9ed45cfc8c3230fb3eb13f7f834ac25ede5dd5ea7dd4c3d0f134c2d9cf784c8b8350acd06277b01a4cdece24fcb111e93d96109627703ed1cad522acc0d3da25ab4fe2501ad63d0e7a412ec5b6bdaa2f41c2c0fde96a54e70bf2993fda7e147ebe01e32614f4c29131c75878e469136e30e444c2829b88f24bf7d96220ae9f3fe33ed526bf90b99520ea947d48386e01cc0159f1176ce7e54b52010f1ec98c800bfe50d4053589d102acfe8fc58bd64bcd0872c3a75224ea5384360b085598356244ce3c17365b7a89a6ad20718561b3ff94b4ed106a706bdeff0e55ba4e297e188a25172e949c874a212fa8d1843c9c0fd013d5ffbf79575f80df711ecd4655bcfb803e38fc5817f24f3967c6c98568ae39dbbf1613c109a86b2a067dcf5e36a22c559177824269e42f0514484a47ad8ed1f77ab73fb98c1e817e02b22cf88dcdceb25d35f31b6806e7ed62bf7cf16eb7a239b59ea5e41f8f6d504373a0f50be4f28420542f0668a87b33af47fcd149ec8abb30c6d35315fb823f2d3cec500ef8f7710118ded2e9c04348027c980a3fecf700cab22aeefcd16caed1b52b923ed6b2e781c96bf7ba4e3558dd1a0b319dec25eb4a53f953039b7ae8e7c79ac564b416c7360459d5861c1040524471832a1361e985fc82b3edce8978d996d16941cd703beaf9e3e41e73d39d82b3bfa19dfa95f7beb78b7651df0a521e8e8eea1e8f3cb98213dcd87ccc45e042c624f363dbe9afb7428cf7db634a2a1da9ea05fb9c54121e94d5125c040e7b2de85435caa2dac54bcb270c373e4c7b74600e8bda841a29ffbf9c8b3c0cd7a06443426a0eb226a03379d6ce07121a1226c40463b75f2881d6c9946c41e81db58fbee89d39e47a728a58a0c431cede7541efc10c50e0641d11c295d8a8f54381bb3338e2a8ccf99a16362351687fae4240e12ee29accb1b3c9920608b13381b713716cdf1bd899daefa5e9828639fd71a3fb2cacce6b24cf8fb64e1516ee8a310c482570a5c052032cf0a0d79012c7807743eb1ecb7901b994c8e7f8009bd06b3ac9a1a62d6a2d68d45460d88340c278ec8b78bc271243cb7e6c6665329201726fee668b094e7bf35fb68bc0f4667073828236a6a5593bf189d8aa0792b502be18a4cf4ef3cd909a8786a68c5d49b2e9d67d6da4d76d1df61a2f1132e8c5050d25b7f55c82c46aef3198bae5166ae5e646cb1c4464125957ee7af7fb5442e50b3c8750c939abb532971c64c83b2801104f3fc3899ea6c8174e2a067fad80dc4fdadb0cfc12ab481b5c02c71c275e4c67c3eaf5fb3b4c8ce012c21e706162945629574db2e95a14275506f32b36b55e00193b135f6258e8297a8146b7012d92d594a03ae23f523b96bbc9494ccd2c8114223e1f167cec24eacaedf6c3ae82b9d8e42408dd7d850752abf6b72092c6e3ef9e080ecfca80aea2bf079bcb391edb37fc1e4adead23d90a2f47230aae5c584f2b0d34f753eee522860ce90bd52d1efabe58122f4d554a22b4dacfa403bfd3a6cc0cfaaff341434fa636c62f684a15b49897cfa8b4171aa353779c3c3a1f68f0a3f59020f82cd0445e08d625a7eda76680c43049f5bbc3526b900d0c5179870e05b85d32f293744039341ef93989914607f23e23857d08b432210ff2cad98685e31edf22123ee5b0bc96a834648910f904754c6082ee47d9070bd75cd315784887d50ffab643a5e2d74e4eac7de92aa19e1be3de39afa3f64ad2608d8171488507ec68995596867203c6a3b2109a57dc0ad3116a773b11764f90e9e65535c6ca3a4857e427046835962ec30117452c9c2cb1dbf67cad2f024d2638a2428b3afaa6f58b0583fce87834f5b5e52d10a8142889379825d7f607bbad36ab3fe819d9de537ce1c6a10367dc4585b9dbd4fb3772c2bf6e13830fb33ddf3613ee22eb63bef08303ec5e93e820676d7be71fde4674b1ce223d34cccfb4771983b0ae2ff72e77d1d8fca8b1d32faa18697f47dd63da8d52eb863fa3f3d1bbe57d536cfa3599a5059a75bf92f568c0b0de37e7e8c19a32ec269d57d0c5d2b0075f0fb452eaea88b783a50d0f6b3b7db508a67cbfc6115b01e0152d8720d129ec6dc10f90acfc0fae85c940cc6d64ba1c7055aa9fcf5af1a5784b9620c610e8b0d0e2095ca825f79fc052c80df03220760d6e5f3549a70c30b78db66e19f52673d92d88575b63a8880b3d4fe9febb9c0f09b2a68ad7e1e277fc2bd53b7e92a78531144cf5cfb69f81c855a3326badc0a690ee886dc85037add68699c14828f552fe19b023724be4673f387274c85e477af66d838b2ed2e85d057957daece961ec1ab482395b7aa64cfd5fe74ae525102f3b8a23dfa726c5160f5620e5e011d5e1a00c9fbf85aa750ee7c251b525c43d9b1b170c88d894d77613f4234f3401eccf36f4da7584c7c2028ea38a14e6925d5913044cf711846aa3f190064b83ea02bd31573ee9119037ae0ebad496a62b6f1ca54ec3975d738d8c6bb071ab7839a4a51a4b01d36093d37cd4846bfdc02de185b7b18c66427c7bde4f7fb7af049536be2d0dcc9e79081c792387ba209f2bab9606cbe4aa158d588579fc771a1dddbc60a322fab571a8b13484aab84cde78c9d32147fcbfaa838161706774eb91334bac19759fa5da9bba973c14d400c468f1f989be7866cc33e8389bdb77fe9d865a27dc5479179bbfdd25d9c73d25fc751437843d8c2c429b9937e8f602ddfb9c60e74e8e3c811ee382162fdb4efd665722db69be00dcee9ec802fc25886bdfc142de1f0f82df436b50054a26b9ee417f9b819442887d1d5e23e8a88b66b6d9d595ff641982affd3ad4a57baf918b5e883a9b05fa6ff8e227b5d852e9cc5235258f5bd804a5be09457d8bf1253083f2732072bcc61123edf4eaa724a5ab430425a896d15276691826addda803885facbba1513245f37030f0ec5b1408993fc3136beafa6a5a1c22c64373b1a0ddb8094871821bcdb8fd4e212d3b14364e7d7751736ed1631c294648536342bb692e0fb0f49ec2456a0c97672b90772057191acff1b2775ac44bcf0736dcca0b0344260a120355892672ab93af3de361b90eb7171af3ab627c663f828fb8fb445e9b36d57b656bec5e23b16b46010aa8723802bcf7e40838e053f7e5b74f6c702f7bce8c61e0f5d496e7caff0a820a1f9c9986a49443f451f7c9316b4ddcb3e064cfb9fb2fc18f1bb3e2ecced8107dcf12c514fe0ed81ff540146c58751d063e00b796f0198b12782a562a9421d31d170b3452d972b790288a68d0edc32ef2f57d307d407e50fca05f4c0930ecf8e15e17b65d23298a973c5cf1ce0f4311a9ebc14485f1710414bf92d63b35ff361832bf9d183f58b1c7cb2893df281b5ba4254ce23a61c7d2f57c6567bc21e1b664dd1cf8b568840de5ef7002dda41831e04e59f1da38f89386733de2f01d871e1d142483de9fc8cc4f2af683c01ca486d18e54312aa465733acaa4c4be514a4b89551f63a497065478557633b51c727526cef4f2d14e63a45184d5863f9ba3f8f66c548b61b89070830d73469a4aab93bd27223c2f0adc228fcf430803469797e3b5228e1a3723de8f3df652ec5d80e2e8f6bbb9adb297eb60be4cb32d6d3eaeca10578e8d17161cb43d4e9f47b422504f91cdaac017be41a392c3d46a10eaf3a405ed2dbb0029736ade4321a96a5ea8435246e06d182089f873601e3e35870caea109d953d7f153311e576b21851a1468e4cbe70c3c7e12d741db5d604d088b27b46367b8d715005272c638afd5764d707243de70287680860b04a4de840093035741d0ba02242227f6bf797be735cdd76313ee851fc1c16131fc0a65d750b2b4f81acd3a1ceff21bec53bc975af2bb8785402627cd88b61865af75d5bfeba01bb72bb8cfb4cf8ac165ed1ccc38c5b7d4fe6602cac17912cf58f31040829b155ba9eefeaff939a5721b9cfcf7779f2d49a03af3384636734343f6c84d46cee569df157d9cb7e2ce351e7eb86ec6c3769e4da7272a5b8b32e2f1770bd01eace9bdb7ee0de13611d05d9d0131a0338c02402662b8f19d73545b4b16a517ad276c470cd03d83df6bd516e80c176e07bcc6a0458efaa8e144fe9c7ab95e3d3b1dd0f85da33b515a65908ee488cb25b4e8864f77e6c5bc2cccabef81fe9a5dfe284718df5273665f5fb6ea2a9b712c570e7c8aea7061d6a796d5718f142358caa1d04fc9ca7c6449af1b57feb471913211a0a79db37f6d247331f1446ab1c22cd3e2aa6ba5063545c22fe88228fdb009094bd4c8d3ad30f1e5b841d0f16fad6494b78a774043f74714d5a28ca8c3e0da5eedbf74028b0c95c9340557d3bbe81b42bf3884abd5e61133675ed9e6eae58e5098b8b64572592bb0ea6a22e9734bfd1f819dd3fad6fb5ffbd708220eb8362ec62a16b4d5eb9a209418694f7e82a939c56aa8ea39e7095af0e3fae915a2dec9db887581e1282edf7493fb8b539f369905b02933f0fab0d0a856e56e3c5cf8d472969f9ea123c4dfdd7083be09be16606e0bc3c448a1257d29321cd03bfaeb309cd2000b29b9ad6f48b778eb59c88ebce2caaf1ae8152874de248c551559d6772db33e65515fcaf40b1d52aaf63dc20cdc8139815428f99084590570b578ea2a8bcc6a1d3b30d293e9b64559b749045fe45bf1f165667fb98e538c429ffac32978b13d3e86ffab442ed86a9fc69702612ee1d4698c430358ae4ce56432f01bd2ca5a9ba62dfd739a9dca6d486608e57bbdbe4137e842946a594e39768e8f6c65ad255dfe487f1208b8a26a849120e1fd008f7a9c60b7c332afd678e71415f4b190e7323d026e5141e6b4573d6b503b9ab5bdf6d77ca8a7ef52634e61f24815201ffc02803489f729e4a4bfd4b24b856e109689775063043ff6fea68ab0b5ba2aa11857c9b7918accd9254d4feadedc6abf54e1ea947c6f8b400eddcc95474678157fa3e2e0b36a57cc04dba8cb9c47e23745178255e303d08fd5e3e8aa572cdf05cb41dd4358e500a345bc136544ff9723a336139f88b359a0f8aa7740e9750d6c9eae0a3ea60dc95e6a397dc0f17ecd3a7e713b21e13c13d5fa2a52455e73680d382d1ceb7ce86f846c0dac49c6fd29350564179284b712b467e13247bfad5b1e9f0586a2f58b1f2790f4edcf8f08ab2d1bf0990f85b0f2f9dc717c8df305a077db1ac5bd04c5dec0edc8f1417c972bf6e250c9dd914841ab975611c5dbf03028d1623639584898de777621c94522c25ebe6ed56ae4c1ecf7d3184ac3f8755ed220f8f2cfe41200ab08b513303469d7341a7bf45e8b0c679d1abcf682a8a031e18e612c17924aa2aa097c40b9bcd208ad8873f5aa13d1eab9c84e2a21c08821c43def00c50a11d0b0dc727fb1837a342c0361a9277f5a9d4c9daf9f423141a82a0c1ba63ce4123cc6146928a2c90e8509d2eda3702338534219a9a2055c9cc49cc7cd92312b450129ca584110d16d3fc2f0ce68adf3ef0c6785bd7143d0d35c697e5794aeaab3864be4f1c6a236d2a38f74f55adeed583e2186e73eee28a3fbb257995da72785f097c0f1f8d20ccce42149a21c359c72462cbae60b5d8858e33e556c536ea6bf4b87a8f05cda29a4282fe82983640ddf5cf4f3691ef06d54d93a4ddd814d8af0de2712fcee75433f963a7d0f86163a43d749d4660a80b2ef724ee34a9e0c0b29ac7a5d913a2c9a36901d9f44eeb6703da72572a033a23dca1fce457e9aabb2637dc146b6f9de29d87d47e2461f6c3f143a09477e5e974035c954fcc648f5bf55d9191062542761eccd26783330ba1e68bed9ce4cd584d1339196ad632ccf0864facf424e5cdc4302d701322cc9d1c2a571939f3793de7c54e4ae9550276e9b5dea37dd00554b79ff1f0c3695cf3a22abe6fa38cdcdc5d32d5233ca0603d6bffd1aaa817eeba75f6474b7af5f5c9036920cfc9b975f40d50db7982f52293cb49590394ba544a5a0a306e8686bc47701886d625d418344dd4a30d74cfe004a02219edf47ebc0fdb98c257fcdc75d4adf32c2dde8275a6a7d0de1d913d6d14b8b0ea79947970441b3a924acdd2a9d430a0bdd26524e53e1446333cfb8aa1ee9b6b9b3ae6853e00467620779259f17dec9f85a882af98f344ef0ef78c76a9ddb14deb92be85e11d12ae6ebeda408694d81cd663a2fac81057f8e8d112b9b19b5e6b27b0db06226469e552a26154d5ec18960dc3f20c8cc74b5e0623231eb86aa71c7053daa557d05115c79bc26c088d8c62bda8d685aad2f7a67163ef6be858d58b0cedbfabf9dc720fa9a41a6bb7f75595cbe8c3a08bd2d8ad1126a14e71ff4ceac226b48a56af44852c4fef5e5f1dda12dadc74202f0eefa0f447845e408eb9eea0cb3deceb982b5757fa14028d0b15db85491b90cad71b7c5822f9c5af5c70fe904731f50a70b09c50a7be922b1634cd54aa41c0217bde28e628c45074898ce63701d0b4b1cf2b701fcdafcd1bb529e7c79575f803ed79583037bf649ebe32d24d3080a10297fa964f8e3c97cb2c171f36c1b8c60bc25a1909fcccda3d44a87bd26bdaaddcdf9a70f121e643e9fcc70c085bc54d065c99052be25704ed7e1c78590af69fc8131110b570bb756073f2247097f7b910a576003e228e551f6148c5603b3c80c54c539433032ab4c401cbe149add3bce28b114d2e9cc32e7bddd569606df2e2a04b73f49b632c625eef0928e6193289bf0bf7f03ab52c5cfa5143f219436f6eec48647bfdca1c854a27d9959a494a7adcae331f0f92a07b51eebc9478394fbbbb04b49efdce17753fbe51c3c922c95349a534d1fa6fd1e2a3638cde3a69d523a79a643041f8ca9e2eae56d217438ea952ccc2bb2f3017ff368a47e17b69f02ace17a633ceb039fca998c800e26f6b07d0db11f69367e2ea043d0d284e84237ba9abc812678fc8f09262f23f85a29abd8092281bc4ef7628e930bc53a75a0ce29a009889dfe25f4caec2364d9cb2e37a2c7f23e01e320055e0767d82c9dfaa6fa4164063e7279d3293da7b49ba59d2f80f1c5d923ce5326e020e116d355da21cd8f0213fb30f8dfb649b625c1c6f0859bd768f5c7c3d76c1c09fe387a29fe0a4f541e39b4d0ad782252b12ad5068670b2462f9dea729a95f72388f24ce0dd4bb2971368d5b52d4154f84fd329eb48c47f92d6cc5809c2962d6e125cd040f2ca9665933b8bf77b74178455615305136930e7a1687fb5b0f9e63bd7b89126f8447fe2973ab0a0a462f1ae3c02bfa09f850a4f5d7b298bee6ac6b3987762d5bd5c9fa50de8289fff022c013579506e09eecf6a5e938ed1ccb00865f840865aaaed7d1d38ceeba12f53a22ec2d8a5685f28834358abab2919fc84fb1fec01e86be664fadde249e8fb767ff2a336d8482f77eb3f96fc4c4cf58fb2aaef11649e9dcd4bd89acddeccfe9b63426af639467e3b3b539d67329816f4e95eba4832871041229834ba8835f302aa7c9996cbbc0ab1c3ce2123c9a7ca078d60dd95ddcee669a9e827530475bdccca8d84199bf09d207140266b41d34686ebd2e8fc21ad37c7efeb2f29924dd4ceefce57a9ed5dfda53b06282ac29ec73174856292be90968253b3481849915fb61705d4734a5e4903ff03eaf29c4b7e86d6f077faac3490d28e6892f6da24aa32fd67e6e107d15ed504051e72a3a4f6ba0281ab3178d65dfb3954c0630454d1c4cac31be06c20b6d2d783d889f6e25a153b778ecc1af24dae3bddf27d18f7d6a56287a47e40d05f4e88735dadc87921ea98bec51b3d298280448c2f534793c3ed79b75f9d71b5eb3962d9eebb21e152e903cdc3eaad2c266ac4ef0b6d5e27898f937bca9290c2167f4eb29c75142c63589132a2d198a82f5465907f1cf36556fd14e376ba3202882be26872c61cea1d8099ed6de4dc1880b77b0dfa4ed1b9cf0cc75627c05d04352238bea3376bcfb17eb77c31d138446df098cdda6b347f47364131dd0839ec3bcf9a8f5b91af876326997c0d101bb64c094fba35c6dafd744f239d9efc66d5739f0973d27bddfbaf2f7da7448a865a9f23ad3c61e490c0c73f27a70358eb8a12efc942d07acc6789362fe6dbd5ee2a7984847fd29ee1b56d46a2aacf2bdd1237cfefce857f4072d22b42f0df2ef8e5e1f0da52773d15e2ed20b5696eded16e2faa3b1bfa72b31b8b69dfaf2d9cff4db5e2b89ad3a1bee516ebc851ba2da224e7d20c49c5bab7f524cd63fd2919cca1ba475633df4960e09575087b43b6e18a47c084cedbafabb9243b81ddeb4187c787347ebb85f89372b61c73d01ea7bd4e32315fd8d275b4e31c499b7a08aea933e0bf569e2d060d243ed94b5ce115eac0ea2278c479791a61cf94c7582820e18752818af5538213adf1973c487b7ac0073cc6b444b7bced31fc066cdd0cc8f2883ff12ab784e7766073bf09f1f76eb181d0dddc3e49e6abe5be3b2361bee3db574964fc2afbd39b07408581a8cd6ede30c017cfdafe95be492cae2e2c17ad253cf249b85f8f4f7824f991f666a6ac55bbfdee4236d0c61cedf018e8b68bdbb014bdb10ddb80e7bc8eaa0454a66b01b491ed083b6ea18d82ab5db909337ed10532ae356a4cfa07ed864503c7dadb458feae3e2229043e477198df3f13d9e4396983dc5c3144530ab2900f2c07715d92ac620ae14052d78238f70ab565e1042be2d79b3661e0e48e1b7b7bcda90d216c7d616eeef7d4af1ab451967455d3335915c50b84209c5fbf2cee32e53d7c7c138d0c2f781e2eaf42117572403c5a0cce53eada2e1697e7ede6679ec616d118454baa5aecfb899054f14c6ad60db7588391eab405e42e054dd06a4572cea13fe63aad6bf64efa09b1a50f18fe340521063d0f42796e3155a62fa88337dffccf1dc642ddf9c2b952a5155401d1031258c55f1a1602669eae6bd78f3b1efe4bef3fea8de5c7663eb22f2fac982cf51b9132cd042411897793a218bd5bfde3633c2029b4fad453b62e05730c515653e096bb3d7b2e7946494c0f893501bf92f0c8c0f351c81137ae2dc85a91abe0d34ebcb093b4c2a6ae033e2e91dc29860e63ef9190e2c0d7401ed7b1e504554da409a134fa5298bd3f77ecb06bace08c58748d98fcabd86a0f3154b9387e860ffda938e8e3e8dc3cc73951e4f5bda7c6b0a29ccc1dabd6dc8bae3f35d67fadd49455ee1c5fc87312aefcc4ffedc6a16891ab6d809e31c9c07d216ea5450e7812189656dd70f34a1144a5882d4c2ac8162a5ba40d544fe2f78febde69cd436ee34f88cad7f1aa5a2b5601dae1a44ed6c4a7a2f0576c55812c5d2e20288fc4cf093fd76a79023645b8bf8a53cadedd7501ca6efc808bf9822a77bf5e0cb075f79c7f9e2af6fd981f34fb542cfb8587785c4addb8e7c15efeff3779d9d8204674209327805f203243b8d45861d1b8c3f2d4e87e770cb75170889ac7c74eda49ce3908b3056d715aabfc7bcd04c2ef52eb25b331d28e1fe06140021a1e79a38193efc6cb29772ae461092e87d308b0647dcfd00d933fa81306f7a98b2a821b160464ea4adf0f38925b4c6f53a7b9d625e98e9f5f12a2323101e29d1c8f843a512a7cfcd1c43e552f6e3a9ec252c17eb2b8dd770efb3287b4d286fc5e849a4586a852a82f10d395648d9e29b96f526ec3818741941a1009ac4c0fcb6820ab1bc1c3b6307bfa1f1df8eeb9b6f67ac67e1c463ca835c7a9785337442f589380d7b5442f81f1bf7e05c32675cd947649d0a2d812e4c2dd51d69fd92d37a1009f0a316d893a4c163f1d057a2288edf567620c0bc012e0f406fa6f5dc187976a681b050ad716f00e95ff460f6d25d582bfa40be354b7eb1a8ea0ab696da9d642373193841f827afc4a137d33c324530c7b0cd7b85fb3e4746150a2dda73a13473c37b5d903413e6b312b4ec2d7bf502b52539b14c0c69576f976d4dd121831def0c063bc5a3df0b7295eb68a41af9ff401e0d2ecb23d1db91a133a35bb028b3e7c36d803f47626f2bf4484d6a7d25088298ca9f4cf250a4b5d32bb12db443aaf913fa5c0da39d38f56f9ee78ef39aa6a418449a9f1bfb08ec8d80470d3a59a87908c25a5f3e221e19e34a2ae3df4519cd6d78fb84c57743bdc14ffed5f96c81633ddf6cda67d86e2dd758d064d56c380ad23fe2db413a04886b5bb0d35a498389d00b2be252060dca843026e05fde4bf5ba4f5a3caccca67f651c45a6bff273e210bda24f0fe3de0d163566a0fecb493e2dbcb402e396c765a2344cf80650fb049b0ea813eae9be254f7df4f59b201492308aaff33aa52cc033e8b45c01a0335b4bb0e14d69a8116419af0cccc22643dcba6c596e080550d86e15e10c7016cf7059559f0d5382bdd223d0e5a33cc65627101813d5cd7716476f0174e13ef1616479832196dcada66f2ad1290cb6c71bb7e4e99b7875a0758bfdbcfb743f034db7ecbc6ed350d31adf88cae2a1acef2ab119789b77edc5f6f66612f03516550950aff248618925209310932e075f9fd955844422812cd93c5168b3991c5ee03e770a4264aa998cb13263a088fc2b03bff9193ca3023a81d65adfabf18bc0d96a0e873d0479235983680570f3edebd4353a145b05f1ec57b37e9ce4d2fe5798756e61dbcd32de58c706fcd3bd881ca4d528b7fbe9843b1e985a4361d5f19b009e2799582fa657bd8519d98a54225f65bacf22350e6ea57da72767f2b8ab98cf00417b4799f54e902648ed955ddf1ab847cbe69337d74bb209cb65a7abee8e6c0b493b3a8173965120b992bab5576dcecd7d02c8d337ee6ce9ba9b735ffa6f089514572f393ab1566ff9dad014fe56ec92930c2bc1199d011c561220860f5b4c3513f0cea5296566a3d249560e8029fb29a0c5c20431fbb1fec068ef934321285556372ba505a99856475ab9c2118673b4dc7740053e59d7ffa2f13be1644f7850e0f8f25502ef7600455adfa4f929fc9053dbaaea9b7dd49293d93fe1f47f92ab295d0b6b07a4e3b8f4ddbfea09a0e6cacf5881305b8125b2045fb5bd47e8f226aeefc7520879fa71fcd3206ed998458218d17e5643e5ea13aba41b3323df13bf61fc0d78b5d74183a53b1b164dbd7957d52b32437211d7621eadb293a37371dc52b0825b6201a44c806c56619cb3a2693afd6ab0bfe39a5d1f72a3003a281348789720fb42d40d2264dbbcee9b1be200a96205cf576f26b43c35ca6a4019fe2957efc8ab88ad10f3e7a2ccc6786395164ef6939419af559a8712cd353b26fdc11cde68ed49c031f181f874dab6d6ebe4e282c9901bc3ca52a81b397ad50f29106869d23c11258db099467127e12acacd43175ae5a0a715e04d16afd518ed02d85d0927f6f54645bae188c9a38b4c315df833bdf7dc30981d1696080559e3372857fd555cc83db8d2a7d3d4ce71fcd60d40a53a280ead559a88c258696efc773c845ff47dfc73fc41eec8054b2880d60b5f3ec24b85bfbc71a55017648f4515087d255444b6e551873ae62e30a33f1e8929826d7d1493204a5f578adf359160dde3ac46aa1700af8162be48dce4c8a7acbd2e2d6b74a8b438b58a35796cd2a899cfc9e4cdd121fdb5c07eecbda985fc88ca21eae0913830ddee6be22414d234db46968593a621af21a97ebcfde198e352bcce6ae71e7df937968023db3e75830c3655b6073b622549526d3ca514cef005e933320ab074980fda8c742f65660cf43dafc34e65409d25fcc2b6756c9f35bd9b5ed2083c9920d59354befcbb54e5c9e227920506d841bf6f9e317695440a2bb12581061007eaa9c17338ba1471f4b51a6e26805ca3d68a130e4300842f5b5d8254226480fcb4579702d64cf170f7bcea2e3b779b7af671a57a5acd5aacb13223de034f22b7bcd7e3f0eaf40902700c21d91c8f5c31ae707afc2df72deb2862733d0c473ee6fc4437eb752854f67a813d41d12bbe696c03a4b5299a697badff6ee3098a5bed1380c4fa6ca62c730ac5e0076ce3943b53020d0c4d80616c77ef592d8125f9125f025c639d2c1e286d5f3e06f988f19ac33c274902ffc5377427e6a4382976e814e5074fe182d3248b6bff057845f1280c8f21760dd5e883a876c30d1767ee5c4ad805c377236e07daeb203c7787ce6682d6e9a78cc20053fa27694867dd35d9e9e4bcc1a2c259efc91acf3a9a4fb37a79bf67893034f1e946897dd64d8709ffc5d2f6f9df5faf5381ee27cd3ab7b9cc2c084819d9e8d299ee3bf9ccb63cb00060a348674ed7dd3e7c604535151d5af5386ef53b03ec29592c5d63c4b4a6c34fa5d3d4ad04160598f6204b69d789cbb70340b5e1fa6abe441c69ff44e1d77001c0801df5e29c23d49f8562cf3adce13f12fd6f918d1e6224e07a27bb1a1242f7d3b27336053a8a5ea6a11b35c310955b74457c419350a708766d18876cfb16f8a58b99c96aad149793c448f10f94679e454f957d84bcb864f1e4c187b2d3abb3e0817b68a22906c6d128891061b9ce4fe5e9d52d196ad38232abdf027251958f080e636f9457213cdc72ee16e8d755554011809a1068b769f87bbcbc8099ec45de130b701e9bfccc0c5d07e1e273815c1bd006dbab49b832fb9915891a3af9f935ced58bbece0437305d037d83368cff195631cee7132dca536c4187","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
