<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58478b59ed74bdc3e66de34848e45bfd1862a76644675ca6a31aa500fa284772f6dcabba92711b09d33af32579cdbbdce4ba997db2c1865597c869d76834cfe8e214f6e70c38b1c542c97143fdb75769318c256db330deed6fc4e2db646e7aeadc36064fd3e0a4513d9884b19702a3fe9f527ca9b0930d3793fb755b0d7d156f11bcad13a175ef1d8e468ab245ccada3fe2fe90e8c213f6760edea8c90f79c40e3be4ddea8a458aa0600625d9f90d5afaedfbfb5acec9f0c5b193aa89ec2ac216a895a74b424f62331880ca17fec7f8d3702e8048b6d94858a245fb42145f3aa0f0cea04fbed279188d84c461170a42efd297765116b5564015a6c7eb6ebec3326818a7008d8a4d1deb7cef3e9d219e1218e213a84f28115ec0e61974972d21cbb761d54328a8e19b587ee620bda3fb1605c4ccac90375ed74270d470bd974ae6335577e1dff6105ab9ec133ccd19560ac93b81084904dc32ea0368ec49afec73cc206598fa6461582835b2a070d70daeea5c3ee5a9f7bfe5594ca5e21ee3a71fb14770379543f2272038541d20b06a6e1a583750310c89120fddb63b812b8182794b6d8e105611c887e7e22347b65b0e10f5c4dfe8e7c3cee09031190f10137d56e7d1dea8812454a723dd9eceda5c885be5c750dc2aefed3e9e18a139d7040a92a1747ec91313f7ff14f347f0c25ecd9f1c70bbea969d65584d5f2c73676eb7c4e9ae3409b9e4e01079de064ff7df6746e973bd490ba7375b685c9b7ba4b1ff51b5a2e74a185e8cdbeeb6831e7bdf283856715526c9157a83a7af66c5990e50267fb154fc1c527047bd6f7cff758510469218bcaec0acc8564ab2bd869bc1a9fdc4aead4083a7d45a2f2acffdaa233e3efa9b09735e3d8db01f6ad1c8fa81b5591f641fe9f046cf55f109239d3f3c5de29890db8fe175360b1f72b85b0d6d503e896b786d8f32a355c7f8d0b249c360a3dab989e7ddcbaf333bd9b4d5b5b7658425970073298f08cc85bbe7047869c9bfa0f7728be61cb38d48c903a263dc1d14c68bd8ec099fe79d9173fab97b09b54bd7bd94a72455eb030bd90f705421567c281f708947bfbdea3a567ad2a93a7f22b314f6411e08a4f386f2c56f430a3e060f00f50e8cd7347e8200ac78dd82bcd7d77b5e0eeb92480438aa24a7daf2e185982c49400a27aab5f55abf6b11776f228057851e68bdf70d001b951b5df724779aee585133ad910e352460edcd2440d72c4e603f8328e30a3c37f4fa5f228a65459ca446587d6c4121fd700f62d48acb6805e542e702a4a19664d905958d59d6c0bb32892900609681ecbc59ada0b9c85a6c84b1a88a449055627a8c35f6c5dfae887702551e3bce81a73dff5efafee5798acf51ecec47225ddd0913b700c54929562c20a4e58681f3ffc1098b02d99e43bc2c815c672cdbe7a7006671ca1320cdf1c43686519afa87ea71a7e9e9800f10cd4354cd4ec03ef06ca8d814c5108dffcfb3ee9a260f62b682fa5478152a38572f33d3cdb5fe622765b50f1e602496708a57f73596a82ff30b8a961c1199ffd4b81b24b788c49f471fc9e5e4098d04fa1de9c8b7b8cfc02d67e219183f3a06e04a6d913178e8404c794d08e42e92b3663548ac03e9c4d020610b080e7c91f4005553b155a04da1531e4778a8fe5c4bd8e659656640e7450a4c858e37f778880c90991d056270cdc01d31a3e9b72ad1bd45d233c25bd047461003b789b2f113577b98b5fd085b3927825505cff541b9afb5bb8c7fa7bf6a73eb6242a71bbb53d59278aee3f2990542b16ce8828541b6f9f7af50aedf2da229c2dc293ff4abf08053a49d15ff50d8fd2b8be1c9816b6b981dc1197341d88e7cec7aaab0247c74f0db0c515ddbfa2b0cebe363257b1968331c51d00020706638d51c3ba40b685330dd483bcc481627cd8acebb313edc0ffa8a5451b194913b80d4c79f249666d86d195705f2df001ab98788ef45224edfadb63d2861437591cfdae94416699f40a6c79d319f4e05abdd7bf97c71ff9412732cf0e9efa05f2dee9f3bfc4b032e3d999c5ee35b07dc6819dfc76d9028e50aa9e687499cf7b7e20fae41c1cd7efc78b191c4c865a84135f3253cca5b5b11080665c6657f62b6d59470050b0966f0986cd4b83e6d5782b027b1a23d9886f5f26f900cb925d00aace9bf36654d2fd23d134da897a51bf5f085f91393c6a93633862c57837c13cbbaebc34d4bdb5042b1b0fb2a0e785def152cf8c0b31dc27074607e4c306a5238af0414fb3b3194ceb10baa423debd479dd57a6e004c459fe02b4f864c36555e02133bdce7251dfa5b510791afd8d5a9315c410af3ed318edd877bb3de3cc07b2d31b9f09f654abd9c7edff1ce21c18e24e2678b7932a25f8ae9ec77fd2dd6d156b29722c0983be37d491cf2d30150425b82eca1474867e5f198253b5a209e3cd0ec7eb632229f7162cbb35bfdfc27513f3f066a83e43259678bbcacb39a42e0caefe9b3464b8272368ff98b9d142a3720fbba3292726e616b8a4ab813bbbd19ea1a10043e62fd68bcb8ac1a2f2a8ac3817bf28a4105fdb0d0f1af4a7d7218c4ae9b369c7a1bebfc1bad032f6063aa02e863f29970e475fbb42615a83b72feb4efd508b7fce324a872ebe2da352081040ff7bbbedb96a11265209c48f3556d8a11f0892f7a7a71925cf7a738635b1e15115cc6a5f12cffa2f38e41be84ae5629c7834a03634f9349b07a86ea8785a3035e4630b81697b78c6be2eef40fcf89da0ad9a56d415c0b9b41768ce0711ef8df0c9a250be666f0511fcbbd4502e2c25cb2056a44b23f74b3f1352be12ffe4dfc6bf5a18ccd1eccef95f310c0f3935ce4e7e62bd1d7e2dfc92e245f379b5e08da73f41ea3844c67a690508a7f85cecdf9cf89adc132779b78de815c1df487421944a804781ec03fac11f10a278289e7c24295c216f532ff543764dbe89dfed42d6719135642efc68b5c28d365d1251971e4e4ad1d86bcc752989bbf027a69638834361297cfff65d82f36d5ddf24f03bbfc8de06cd25a6cdaea49a3a99856fe6eb7a73353834af6cdd23baa9d7cb7ce552016b23c2a8fd84c8082d8686f530d61e18045d27b1277055cbb2f9c612e668d0b8a7d59567908497539307a9f1e53369bcf59207b03c2e8937d1930ecef607bb695b2cea6c917d90b9552e651c3b9d49f6f5ebf7b3aabbca91941913ad9e18d0f75bbab87bc396321fa8c7f4b1a2b3b4d731112958972f3ffbc895427fc817e0c9dee082255a451521ad9b02ec00e071a2db9bf0a6b32533b3dc7b8d2989a20ca71df1afe545399d5623f875277a7a74ecde9114bc569394ac15f3843be11ae00614f6b6d734bf4ed067f27c9bf29bbcc1ccba53ea496b63f456f2e18795199f0162f6812d877d6422863b6806233036365c805cfd9c08882935391cfb98dbe3b66d43b0300ba30f9c8bb9e3f119ae32e7fe272340103ce4a1ef6bbbdb4073336584428c0958d3931f935f90c1bb0a0fd0adf5570c368d3d3d13dd8fcd04443f9f95a2c31b17d1a701f11bc10e378022f252b567eb0bbc788446582a5393766e9ccd8776782272108266a131b90c853d00ddd3160a4b74e8cffe5f24e8f69c59348c5aa9c8eb8f2df7efd72e1c25dabdc4cfcdf3be3a95f5cb8c77970e184cce213b05df5ca419fd21947f5a8ac918f7bfe31499e7a7613235960d599e4ac1db1e1774669d7b0361b3f8a056fb389bcf8b6a8df20e18fc02c2b8025db96ba4d76365f5110945bff05a8fa340b63c22dab43b56e5aa726db858de5453f6d65e55a7e9c4700d971ca7d43c47f691787ee6858d87cc19b316aba7193dcb1b3860205172bc7a228771a0b7b1c851485c87ec59c707d6401fd3c6166cd42ca86fb19d12a7c64506d8c44ab59fb3d7291ff19ffb1885c650c6db4cb42061928aca69977ee273fa6d7e5af32fa364311f59f6175dd8c2bf31818782da7e59497c308b7caa4b2334feea91234adf1eb8a01f9e77ef9ab88786c2dce0095f2a563d408b6505e9169b9d81cb15241f9dcbb88043f327c2b0e86f11ed2a39acf3bfd08653112974f497e97148ef3e5da9da5549fd7d1c80683d2728f1aefcb9a408ea1e257ce3ae05756ba626df5c93d0affd85e26bb64a393a0438ef2905bca78c5a0c5cb898930585163aa9903817b4bee4076d9f14dac77f829db43e545d47f716d0e78a3e409f8b0c702d0f5bc45371bfcba146eeca2cd2a630e8d6c0274b2bfef7e9e7d35c5f95c970636ae83d7771538eaca277970160d18862a982ce0eb8523f4f2ba3512e9e1f5c8d948d372cca0be2d37f74dfd2dcf67e6ee4c9ac85665c54d80520e0e9821e715d9d6f6bc238a5f114b37bb50f8a0cf1e3523d46e80b5181c4b15db62ef76b599d7badc0848888044cbd105e62a4c51c5ed278cc77bdaf7a48801829407eeb15fbe735b2392a455e5b75685744862ed67bb7d280d0261a1c34dd9956a95aef1e6c0e5a67bb8fd241b48150c34ee801df04ff62971b0994e2851476535f82d695ef6347ee7575d1379271032824973717cc91f84b1f402be5de709edbb95ca3236a77f3deca52693b58e1b636a01e23b92a380bed49a24d6ab3e9a7b6b2fa495f7fe676025566cc29c7ae3372447477dd1cde122835c1eeee1f1d6f4080f93b18e3b7e1b0978c3c9cfbd9d13668d43bd8ecab06ed4a77b82e4e575470dab871ce282ed4785c954c44525532bd4251a2a9a0217e0b63e710f2ee4a11b54620d1c0fc6ba375dbca418946d7121deea51c7986bd7fb6011c7a52090f1dbc9ffcb14a79676db829bb1f2819e7956977e7eaf9101ff2db3dbf75a3717bbac0d58bd07e00c0921b5c7f611f74afbc43393af170efe6fd0df7e58ef66642fd55b980a13a1c799c914a974aecd27dd15c24bd93b9e11e544805f45449a4997ea5977a8fba703fc23606d80a8585a80c96eb73e449a82f094be1cb641c06d24029cdff042f7ed68f86c67c1122bffc1d1a6f679bc39a7b26867092b6a6689c187b705b9e119b37177179308d7629853b5b123142c320728c9eec1f2fa3001ddcec88df3ec3b9e9a5cee807c5651885c85728db73a485b13ee64837ede804c6ca0094fbc126da0d2aae5157a4aa1cf9b80ef574298510b5b7feccee96bd81a4065459d399e2239757f5e5375dd3fbee21e3cc76985bf0a477dcc05893ffb60fa146541925bb475ce9f19ace9fad7a8cf183de47225ff67ca58e01d754d79b7f24f09cb8445f13df8ff8d6a3f2b20f390e8669a8c512dcb61a4e0dedf4be14d9261de85b40f53642f097c15e421faba73b0271fcc86560e10aea71ad53ebc2dd30006c0bab197e993df75c55a78b27c5a9fb5de050aa7105a714e64fa0f9d1c39df80d1c7532b8d7aa59adb1891576b9fdd5554ebeac3daa2888a2964b038568ef1feeff8f0ef99c679d3534411c925804bba14d596558857ec2d1cca53993483f9e6309c8c7f76bf38c8f1e175a2b95d1143e062ef117e81cd40c56737457f9f032916ff82f372750c8b7195a89cf1b8f4ef812bd0c2b15e07b32ce9293608c0fe61ebda2d6aa40d8aaa28ab2463b1439edff50d8981d12551112cd3470b1600a48382fa31ee55c1342721f2badfa2dc30433984755960981d7de5772d6eeabc0ca61cb3ea5f939bda05e39d7cd6d2cd4a88bc30343fb0f795baec80e7649191b57864fa9c4f3e96975acfc85a4bbf91ed69e1ea147986200d8dcf5eb4d6a2a017f0f202a7ae2437cb8effa6b65b7bd0024b9abc622fec771ebddcb853dccc41229bae735992d2bcc33519180226988688849b62d98a2de06454767129a31ed471f5a3108fcab71856d2921b77a04af503882e45558d1a106c346fd50c3f74ec277d91c9190685855ade13f13b1af2a8006f7f440989bb7e46df166b02288da390e09d3acf6f3c2773eb5f697024861ddd393276f9164373869760098725dbd4e6b92c89175dc77de812938e1c82e7e791b76e7fb4ebd30472af29e5d5c22eef1174e9436b1cc9aea152a5124df4717253d714f7697b437c302c45fa741d8edc554e7714dc0d58ae63767a766549a3369fe059681c04a9873760a6e6a08da648674ad49065d57d291bac2da5aafc38db03f46cd31892424b6bfb1f8f6bc0ac58a6fc34324be4e835dd74c3b5f0f7e156670be3854575873ac95527a0e06cacd0c35c3d80ce0414b500631fca08096b4d1f3f98ed80c477fa593777749844c66dafa24db32f41dc2adb4dbbb96b504b65a005ea34b6838f12e103c58cccbe2c3e2cae8d8455d9611b8d98a1279838c183bfb0aa4ff1b27602649ce356e50d7f9e75e93f1b0777043ca3cb87c0c0a981059646c96c36ab3d2e122f48d62a9ffc9fbb304236ea0ae4319833fcc2e9da21a771562340212b286910ee7d05d2a92ce941ca8ad2cd26cccc168db495161b9200f6ccef1054563971d604fcd90429d1eb616ec3b774ff1f53f8a0cf4e8c3643e48033541aeb19e340ec2769e482c2e81ed122a64637212fc573a1420a83b740872ff18f0062e16e89990947d0673e8b5acaf939e7d8a65b643e09810751ed1cbc714933ef174860823b30ee64b72c1ca1e44be1e04e51eb2ad9f01d2e34b61e8b127084fd8325f8c70f48680422f326e7079cf0b9fc148a663536ad5e1139b7014158634dcd2acd3a1d73756476f1d305e1e32b694c5fb8467bb83248b78275cc4dbfae196f7e2e51bac601cf7394554de2b1e7deda82aa9d898d7fe76ab83636463bb7adbb9d857758d1ea9d392b58ce7a08ca72f9ff5d4921f55fe181afa57bdbaff306338a863aa67fa8708bec2828c766d347b5d070df2bc8bc7ad91f5a836237190c3ff6773da73841ce3f0951778b5ab70641cc8561149e75a3fe04cf4577ff5bfd92f87f5416708ee326b82f795a22ff4b6cded80ded17425745e2991c9d729735d328b9fa130c00e615dfffd95c419786616ebc0ba4482da84b2800304525c715bf2bef1247651458595f2ce962cccd2e094968c5ea44395f097c599ff1a7166e4349a0561f31440ad82d5d0410b4849c12eea36de22f7a49f07a7165157a28dba06093a3deb25d1d05a63a33979aa1bd40889f0b3cb0d64a6bd5caf095f9432661b295a892a472a7cc68fb862345a328b0c7347b71bfd466cf3cd1d5beedd77757a1afbe334bcf7a681de862d98297824a54f3e9387970590f28c1d16391a38cb13aebc887209e1e1701e5547cdc33cb22fccd4b02bd4347f46b68cc225fd7d1333ccd0b99efede70043f841c9f278dac4c54208b1fd01b59f6b72ea2cecba4058c29d64c8791b8d1a8ac03fadc1697501228c34cc83f22013d1462f44dc80ba0e398c38c91c254b946281a5fe1d36ddc1327dca4285498799788b2e73224ed4dcfc1e34bb1004743fac86cbf635f5390663a15fef5dcd0bcdb1060ff36ccf4bb5f1a3adad962061fcc5b5bfd90e63c1185edd2ed24574049ada2a9895a892bb0bac6776603eafb5d270e00a89e654069f7facfe4466d37ef0dcb9c82ae1d60d97785952ffae369a7e0062f5cda496f19124522a5fbe5d850f2d2792067a281f1832c49a29c90dca7f555415a9814291c138f50691c1b109f62ee8ae99de65086a813aaf94998ccd9d50a44eeef26fc952da6a438ba6a39aabdc83f7c8d09ac3e370a3f79a0d5bec3692eebaaad8cc0cb718ed85a1f485c9bf7f6095c3124388c84443b8a3585d0896e732b7140bab34b7d2609bbe87905df36559c8c2c4b69848e0117519d7e8e118050c296167beb771067d2530f1a2ac929eb40f2694c23b4380c0b448150d385c15d83c0fa36a820192c8d3e743385bf2afaffddd95b6811666185f6822715a4173d64e0941dd086bf089029a1ee53b24fa56b2c93ed4e1de69c6e2745a548afa868f1bb01d0713ab4ec70ab40ea06bfe5f531c9562e52896b2f19d8355015c3100e336449ea1ae7265ce7b06d4c2ce1a174bfc5c00d010a55abb1f60295fb80220294d7c032043a62caf8a0b5b8593c3946bb3f03dc9fb0419ae84b0e040cdf1502fbc047d3ddac87d5ec760541a3a731e3a740f0d99249376a45997b6f5dbe23ab3286980d902c01f575e3941b2367e71ea02620fa628145c16ad5e16cb119b6039b8a2e87f2e0ccce94edcd8b3e9b34a6e14be7d30b7a68cd544e8b03100fa74185c2bb1ba2e05f044c14ea637be0eab2cba85223bd2083ca15cbe7262f74e6c16dac0eac4190edb4e12d2a3202791a03cd7ffbf7da1ec860fe46a6b6f73a87ac0bc8ef3291ee1e1acf6b10b3392c38ac14df03da6feb688bfee5a278a7ad5cdc65bfa6d5108da5fd5de0c701d372091c67fb9261b05b850a7e2ad650d8eb4e3b5530824bc3c7e430b387892aecb5f55498c983af5b605fdbf1606738f0d777dde0b1163e27809ffd52eb264866e7f31156038694802b04a764848c44721943b9a023edc22c4b0f1e4830b2e150ea5b17547e8b36e6da81919e8ead530554422f491d30eff14024c4ac71a742204508e8bf55770e923d536d7e248278c2932df0c69ef7e11266cb34b47479ae656ed42a864f8182a61ee537659f176d0290b4573b2732c076592158504c0375d43c790388f12d47d832c1e71ab8b2cc26125c922fa3098e20be8d96fdb5f7d8c9a782576b23d19a7c679d6c9dd2dc4072cc05092d09aff6235fe6d99bf6d020bc08810ba84c875101aeb535501a40b94d928a4d59dda017091029c08844da598a4eabe6d0d27094d425f665bfb36cb7dfd20c1b5a4f4c7dc8e90d0f9b578225a682c55191928064b338d52edcf1a85a995b92e220b00e82dca222e46f5a51ce906eceaad88ee638bd25fccf3b178cb82b8241a780ec3ee7cde394676cb34577128b0f811ebf6e69a5d856500f89abc85af15f7dd7c68cb56b39f4b71963a7b3aab5266eeaa417c521c829451feab0d5b24f6b887a6613d147d23bd61ff8642b853197ab46b383f831b4d32bea4ade83c41ade69639d7414d64adca04526530cdedd027eb4c8ae641b8b1d279a02097feedd121ff5d388fa4cc97793ffb415f4f7bd21d741ecc1ca04e57e5f375e8b36863ab921346ff2c491d06128a9d880560f4cd1ddcb50a969310e9ed9b49aed88955ef8ef0d13f7880b0c9b45e22d5438b1c15e1ade8b39477daeb564ac97d9ae4a5e84856053da9592f69f9845750fe448756bd670351ab1b926aae45e2a20252a12f2186a21d3b961286b7c748c7bb9de1bda33cd632956af2ad2a3f49bb03f99c9a0a98f136551b805815274908ed118ddadb850e14a6f2966a7e54775d120c9508b5c3608c5d20328ac74216b14eb14471bbf1a8ff5a4b4cf3d794a8c468c327df8a300f3bc12d3f9e77b46f83e33f30821fe4dbe0a8340ef169683184cce18160f53541003d06db32542bdde4fff0582436eaeb1085e95b13fe8a9d9977ac8b638a2d8db720e509e0806e4506a35e9124ea60da428b3d4e73046007232ed9003b75b924c82fa5347a54338066cf233287b90ae0f62c397eb21f58d60c2a0f0e5e361c877fbd31102e6b3a5ef38df77d57d06e1cf8dc227c2bd29625f1f08470a718638d1f3e4b342f305d2ea093adb31ace2b10c71b912a1f064c841a2827397fce32a013adfd3e2581968416338b3f2e4a87a7cd8dc1fadfce4ca5581b881082c967713817d7e190a3f6b04392298bff3ee7cdf8e8783d5def9b843c16e0c42ed092f0712c7738d4f0bbaabc72342fe2b73e3157e815f82cfe8d318941f0ba5582ea4463285f013dd24992a77c3a5f6e12fb0a86f80e12e1fa7788bef9c2f595a887bc9fc7b4d2e82f3d20c56ee96e86c5c6cff307f0eb7e24959a1d846e028bcb9c35cf4053a891a55eb5b69447a89ad5bf55c19ca8f2e4d8f2a251b0495f5fbcf36dea5a6bad1eadad021bfeaef72b02042b9681f8ce70f145b9ecedbb013bb4fa0d25ba720e3c3ea4e00252f247d450e61a438e9fb0d4820ee6b3c69a3254ad3d585a011c8363513f0a6a50f47bd8ab83227a767b77763f28e53402e2c721d7f96a407b9c351aae882669a432eaea019e7ffbe951cec70939bf12e66e1d190c8ae9782e1790ee2d98aa17052bffb36ca60487827396d7f3b2e8958b2cbba5025fa39ca3063b164d5e905ad71e586001b809021433a355496f3dce025865422c74cece157b0edff9a3f3b2c547924262e4430aef6334350aa8308b4a9cdf03ec29e44fc9bdc4102f0fad456eac12795eb527d311467fe1fdf15190fedb63ad6c2b534a5e03577f7072d455981e8eadce0fa3259b2d8f7c4e53d7e8e4f9be3c15a25c005e913d91ceabdc081343e9a43aa31310d91a27334385c95787d168fa76a0376bc5894b96e0079ee39e0cacfbf7aa6d408803ad4a257470cf897fcf3c6de99e32d3fa09fd5f3d1dd37eeb2e37cf59299d4578d7b094380bd7903a076e6e68825cfade1f0988b710698abcd45d4bbee2e5141801e71f90aae26afc9fea304444551a7ff8751f415127da51dba9e7a27f58abd0f6d9deb190bd2ccee337c08e09718cac65d9540becc688e4d477a3bff32090fe12a0f3446670727db0ba056cfeaa0df805c942f2a2a61a30ba2a2b6e43725e08de2d466f75b86cfbf74c26a93592da67a590bf2cde46ff2645dd1e72e11c988880fdfa1651da9f03fb1b55bfdc87de40fd3f8a5caaf29e6082859e4058c3b74aa5819edd6cc2b67af148e9ad18ffe46d726db21fae2a9c375698ab13d57770303abf555774f4013ac0ce469c9c037f78adddecb1d61cdb1678b840b476db3d07674a811c3b2f4802fe4973da2e1adf57ac68401b92f9baf7e033bbdefcfb2e3d663afe3faf082c050051ec2490e03b0025783d9b74736ef079cd541c6f879f1e6846ff5aca097a8e7ec10589020d64dee5461da3228207d40c67630b316be22b7a815eddefedc9a3d323d6de342123d20fd284351293aa4b33fe9e2dea7c0c63625056e8b8405c1433ce7eeb9a8b40405c642678e82258a507baf0693d518e9c5fc600d5d067f56f4c458aeab253a302bd845ff978a0932746deccf812197fa5525f6ec3388ce6fedff03a4398e452c31434bc24c7bb52eb14f4e878a7f446ea07b367eb30b34cf3f401fbabf3935b3d9b42a46745a1acc5b81d08c3c82fca9373cefa8709bc8f2f1a4f2b540d3ad0ff7ce8c894645c9705e5cdf59057d89aa1a0bd4d0356e1a9c747b7927be1dbabe649ea53d8d7b7d6b7c89c7786d3f12ca996a311717935620d50cfca602be5e1fc55ee55ff46e37a0a4f40cbe916077b1c73c243e2ec3f31c05a62ba75913357b38fd6b15d28a912f7392c4bd41ecd3e69dbc30e8c1defd27b73cfd99e88d817a68fe85666b040671914c7ed16d501219fdd73fd213153f62a660696be3a4b6a66cc5b8faa569bc53cfaf69d645bede6b0d3b139ec225c56d50725a2447017d5822d8dbc5f639adcb61ed4ee080c7fb4cc24d53fe9826faddd73747a537937830d4c491b22f4baf9ece9b4463ae561ab2420f16ee8bd8a3c1c28bffd7b6d086fa997e0331f9bc5904e04f3da301618c8b32d4451ec6ef80f0b6d229343fce1fe55f965154ae787799a4259810abe82153bc717da2d72cb979b5dbd3f65df2ca51c20de24e1605700fc5448ce8fdad2de66583fad3e74d15b3865d84b613020b5c1ceb884bcf05240c4c21c4ee79654211464836afc17154f8aed7ed2aa7e59e91ab6a677b6aa6fa822cedf159b56904e5ee459fc57e40c5cfe3d03e01ba86abf2b03310ae0c88ac9745a7adb6f8db8797cb6a1bb28993c50cacd64e93bae40eb4f4cd50694af0acdfd200db0c6b9bcb04c526c97d6d9a01be3b5922f34ebc58562810ef6359f935173f3b04ddf7a277531194cb00ecf0e3e3f67fee1121988d0e0c5b0e4d87ce547b50968e29d00e51ff4a2c2bf16e9d5e2674a853e39cc08524d0ff88cb50e83722857bf624679659e6e4b9aeeddc56d7a3e768d705c619daaaaa774b1f95325fbfde253c585a56e32473c17b3ff15a7eb52270db9909691b29c4e9b1b5a74f004b160e27bcfaf142592893cfaa0dec97489a6e3260a477939ce1e0be8328758530db30c2a6dcab2640a1014b7280055f3e632c5d54d12ce5a3e14745ae95597411c7ab8ca77384a47aa88f2669f9c00e81d3cfe4d115759e0fb63988c13010044ae4db0e0baa68f8051b56a4c86b8f8178aded501fcdff2a9753ea8bb5ab60526a2ce3399e7ffec1b38b723b35a565fa286b2ca051dbb7174653c52bc406bf32e729a07a639e5c9d2121299b01e6bd1c3705877187bfb78a4fbe41c4f9abae91066051e5c17e9e19cc56458d2d31846dd9aabc3c41cd5d7ec7a5f36c5f8413af89411aabc2e20fccb6a28c673d03eddaf964137b0789a11d4cb47ca817a7760bad0fd5544e6f3c1ee132dfde3f4503c4b6d001c344ee93f38c6d36fdc51dbf4ca7a4412617d70c87baf21d8634e8fbb1ed68d06ece1d9a957f51ceaa365595836b84c2e6adc1b3ab9283339e5053e5a23ce80e9e6bd7db25d03d3e134a40a3b8e4f86758304bd53886331e5bb6b4e336fe48c46149501c6cd4e5468dbefb0a630f3d29c2824ed23830ac863dc0ffab3fb145ed7b023b7fcefd65f5506e91fc3edc8af796cade1b5eef1a646b8e871568f7559a4499b256dc305daefbfb5af9f7614972efd539ad3cf92f57c6d9497f1dac8e501c5c7a42df234a7469171435528f62c718723efa0051769c0fb194aa832b1661e977bd9c23212de05754f083e2d71286e7d3794b0788a4f029564a13dccb6a1adef7138793ff2a37601177f1ceab8e2fed3c284c40ffff568e56acab783de83594837168bb0424386d058cfafbf5e4e97eaeb5ba6bc4b70a441644e9aa640ee82ae6711993dfd68e9cbde257e3c0ca3ef1ee956276aa31e5c39ff7ed5a3bed567cae12ad613c6b278dfb7bcd731ffdf9f855a9bfa46fc25f000f879f1eb85df8395141a6711a073b5a3e655127449e02521e99b39f6f9a4f855d9d4077cc605949033a1f460fd03c99ac86466fe26e0eedd9fe584a455cbbb7bdf30232efbc596bd7027a0c7ababa081792367b559d12bd1c76fdd9355691ce7f11354610051f470a32b54db22c4c454f34df7e4dc0cc8ab173be96d33640ed0c1db782b119f8d2e7ff64024ec96adff435967d64e8493267237590e30e92f92c9e694acffbe58eb3180245895cb0b3f7071c4c5ab4e1798c4ec2f0382443bd04f03c5235163b961b63b6e9505d3be0e8a3fc550e4f8d776f473558d858c6ce6afda44795e04f33551b926cfda1e9b66e2ba5b7ec38b670dd46d34faa0ecab5ed7a47fd5360a64fe9301890b3cefc8a5295f7c30c82571f85679a2ffbefd0442bcf3b7667994b26ea4ac899e301701d16e8de4645e0ea8b8c69a5b197a1fbd44308e5aaa12817e47577273ced3189bc2af84ec4fc7b2ac3201765c747c29d6c896d81cbf72e3b9f1c22ca964374fb70e159ec8dac8dad03bbd49d8b8d4024b3eb5c833d99766edd969743bb7db13489a6a9c0182d25a7975d07ed759a68fd482b2f16dc4e53717279255ea5c3f3e96408ae1140231de00d37eb8c75b019fe8d6574e082e619a681b0757c6a6571c84b1450b8511280617c912992d5a8b238c2f1255cabbce5ddab67d8fb0b023891cb9a3b9a523f393637010bdf3cdda0b0779ef403f6636fb30306592f3e89e07c6999e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
