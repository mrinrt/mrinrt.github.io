<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb956b9747c91794ccf51df074c0bf824ad66992bf03d8ec64bfb77b94ced38ae7852c10a7e2920dca12725ed60d28c1e533cc5dd02499c8aeae701315b65668a5da00e232f34559a798c1756d47f2493e3e2d8536935ff8c6d1d47f47763f3bc4e30861c426c8e3e864d2f7de7f11e353d405155bb281b1868d1b1a0d48d68349cdb0e760adb6bcc003c1f1b346157f459e7ceed10f2ac398446484cf0b16566561df6473a4fdef781b03718cf4574ec7ddf9385618cc9f15913a809a97b2176e39a47c3e4b0f0d75a7b0205bcf5498971846d4d443e2f26567f3d195f7dd4a330cca1a92b1735e81cee2b9b5462fefbcccf859bf4102ba10a14d1c142f78fe1e541992f5f2681971a4f415e0aa72f93d2325a88d0179e20d6f8198abf8e8fa3fbaaa4fc7a5cc29af81fe5ceb3bbd77fa7556e4f342136343d89dc9d004e5d272d558ba2b00e2e646d3a330a539bf49bfde02b94d4b5468ed1163bea9c77276b650585abddbde66b22aa7cdb8125685d4120d7f4690aca6aee169e758dc42ab460035288f7da310628d79c4407ec70addefbe5ddb0c77932b53cf09a062a8ca210fcba1be21a4999a1dbe0d348cbb3f90d783f094875fb19b8ad8cebbae75cc4469f6d8ace45110728157e2a87c72aa344fceb64c502d36cfce41e5d937219747fa8a87200a5a22b9ebd4d03e42c73db6a8088b003fd2b2c2623439f7709d662bb3c827fc6dcb7123e361d424f5322f28d524ca1033166152dd126b3758c8141e9b4bca4668191b109814c59c58842ff454c66dea3b127edaaa141597feeb01b64223f9ab5130de1adb004411a149e484dbde57cbae45f4bc397f64f820c47d0719566b07501cb0ba31812cc1efcdea405e862cecacd32184906f3290721caabec4ea14d8197f0024afd2ea667f68c43ee34b7cdf2fa7762c4ef49bf0f4c186aff48138bd9f20a7267977c4946390d5b23d97fb1a008106a8cbdbd099dc7e950d7ff69333aac56c87ca1555b6266ceaca8bfb735d9508b6f0de0c638128b4de95136d4df5ce40ee732fca1c26e0330016eadbc39e05486394c603b3d93b495b9f78d03092b32d4733e35c62b9a291446efe147f68f140c3c7aad6d8cdf5aff7dc39aeb7f0c3589cec5599ce220972945c2e3b80abecef89554b43e8cfe78b743d2fb51691de2e2407f5169a441cfa34ef567797ac220cd180e4cb17a94cb7c434c602b51202e0645c7266c924fa98c6d634cc74273ae9662213c7cf860caf3fa0ec05a8f1202b353caa8683ba78ed9bdb5d90428d9799a1e2d84f38ad62813433628c3cb96f95664797aa15006be2d93d8c5f5408d53a60e8142aaa095628452c4e6c0f5ec41f612803f76d43b415ab35dd8c55e62160130fc426690264df2178a9b91f1e5c9097e32d083b19be6a7c915ef33e14531e214092a350e25229f4ac5429e74bca8832b1fb7fdc5aae1e3b32e9e22efe8ef88091070d84d9eeb57e192db26810f14cca75b778b68dab11a25f666fb6200d7f9343d25b7bfa4c098a7e66617399f439c31d4c862557aaf04440c08a02dd1b7c3651999bdb77162ac5940d3fbdfca8c7b49fa94942433001444f47ff3188b9debbf06c800a2784abea89f92ec390ae7b0f5c9789825de2a0a2fd7fad6de0fa90de7cd25f5278cb2fee48393aa350d01af34d9e33f9fee301c650557acd725d81eed9fce95a4f30584e28749c7754242d04e81d1e449f0b24cd4f5723ca96322c423c74fc3b388c1011e022b82c7e8ee92832d0fcbe149f4280c0de00dd930ea55e9eeffc1c0f4e58923f5cb73d7980b6c6b574f555a74e0bc9ec6ee4a720d5e4b28469317c774162b7b1714e4d0ff84fff5b85618cef756f64c95163d5d6bbf3e64d4aeae87e5296223e07bd7aaa5261dd419848802655e343b1d335bb713eefe14d27d7b70bfcc385a70b352d0ed5353bb0544e788cfa9fcbb0780ea8aff987583291b3441424c2a38f0129423cc01feb3181b97646b2e735b65075342ffe442999dd9a9ec91cce809e0a7c38d32b62c3957f5ed866d75ae3e984cfbb00a5f5fc85c4b79ce5e068f20df4f49c79db1402334493eb61fd57d8a15086aebb7a5ef5b6e9957bbf0fce6c93a7ae3e4d27ec3e3efcca22e15ec7323613f430a8670bc3d2735dcf2166114af9d7454d0424ff1c7dc05807d99ca56a62098cdded361cf703336450766c39d2109740feb1209d9a05fbfad2af10ea728b571adc807423d28956104165c366c63bb5e955782cf64ec96e6f438becb688e34eeefbb3b10d5e41b9d9cf12261bdb8bd16bb60c02aa33c444ce2843e3a6f7ff472cdc2c59424b407f365fd95033c87432dd607fba8483dbb5208fb2ab82414312c9841e5dda6c03488e0d0a8a1bd01bf4cdb6a8fcf930cd9d8cdf7841724e625aed1f332d07acb91cd55f289b2586fa52057b508bff4987f2bec0d97e1de2663a400b84cfda3ea8392e854353f69920c07737fa8faeaec93ae633a2f55ec514403adb981a92222f880cc051dff58c9de7bd597d6e2056d3ed26df241247ad4bf60e54e45b0fe5b61a72c46f0e0ffaf8f8c039407b7eaa84a6d8e6e4b8983c2c7b93cca0e071d563426e79247cefa88c33041779b361dd811ff74b41bec5e1e8814c41f64d2a1aa7838a986fb0056a6522ca7e21b90ca88186468e47d8421e1494146a328630faaab32fb96a794e1453f1771dfd93ed13b92bc6545d59c9eb9c908e482653b8312b9cb91876b1ba62f3bfd3f49d28b0e5e30765b9d8c34cc6a3dea2dc2669f6409211096f990ed50c934339d14c245a9b6157c1fd93c96bbafc1221d41f741b83d5211bc011fcae617f1ba930c9e422e4c8205029d6325eaca438280d8af0b1c23045374ecc6698f44ccaf0628590c7ccdf20ad12d1b06652855434f66e0bc03ce7cbdac0ab0c0583b380599ecf04bfd7119cac7727fc9ddae4faaa8c3391b80ebe92357a1738bee68b00d5ff12e931aee843e1483dbefb5fb4f36c42d3d75c860793fdf58cce53a2e7b22a8340819b96033a92e7890edfe04f7601817aacb4c9038646f83b02155bcbc284ce9e19a3da9a96e0955fb51fae3f236a32986d1efd44908b3a53f0973e50873fa3e9654cc172e650abea0a6a1a6c24139b27397fb08245fb203ed97d2dd261bb78a89922d3c53e98562d0d468599dff6f39855a2b58a5d6a0bd4aa1c78f34a7e58678895a2f1d560dcae7bcd8fc8b58eccd88be12defb9698e6076cd32d4caf56b23f5756d61fbb3ce00413d27fe6c7dd26111b82bbd392ea0f4c67582acd08070fe3a6b524fba19c7a3f01c090195b119ab206c41779d0848e0cb4ef1391f5380d93fe934bd3d753114fc24fe2a8c0211cabc2a384208745d076c29cd8aa6b13d0770301eb5a17629ec8c28080944279eabd7e3bc7e735c6e0732e8e5577790d013a50c779afecafde7a7349030b96178f9d635a990464640b16daf6bd7b2fb6760231e558bf718a5867050e3fb03657888c49cfde1d3ebd4b24f4c75022916fbfed12dbc483df094c02149176fb8d4206218b55d68661aa1090ca75d4cfe84041fe4cf935c143eac1471618564c39894f138870bc22a4a83999823ac460c3a74abd68b903b95ee43416ed17840c3b689f794cd2d30a040b66d93b7b63bdec2494c57bded0c4f77ea734bfd8f8c4f60412cbd9cfdba82ad04e2df81d6498c3956134b62d4b44f46f55f726d4d4550b914070a3f9814f31f6b068bc53f4f05208f45ea3939a371d1ea7f65eee15348b8be0279c5d45d3af2198720ee3fbbe2ae1f448b70558014c4b1ea5deb2552432d77b11275370a6ff3e7f3fc605932b2b13bc45aa77411317f6e014ad672851ad5e609e5a38fc1dcbc79f626c2606b3b4aa7affbb472dbfe254ef3bf9810f92543e8772b9379b7224c98e03a6d993b78ee6206362730f6c7532c894e6f36e5a9e795a61e8cf7855cf0c73e0fae8bc65f20fca1dbb00093841a888231e6b13aad9e9b5c191d66d88c56bed7d4eef3b64c409d5c352c8b6fdc1e576ca23180fb4c2b7911b2429468b2c45573b6eafa371f7741c03edb1b858fd4f9fffe4ffe91275f4089ca34fa3c49b49f7b9081dbd89f8989fdedfc34df2f47796a23f1c6b318fb014771e05e1d5a2e5371dc183136bea63fa7621f8381c6a97c1bb179649eebd66b97ee5aa6dfc0519cde2bbefd9cee77a057342b2e32b3ad32f9adf24e4167d9972e82b254c51320909ed5d4103ee80b8448eb66627a0ffe7a9f569603395631180eb5b590fbea924e7350714bc5883a4fb6e46c3245a109a705100d38190b18e3ec76e804335af1b0e58a56ee8a998a6cc65c130b3b65b10ca07a6b7b8870bd32bbf5d4ec9d2e1d2a9710db2155d37a9bbf7f8175590cea401b9a72cb07ab4b7ce903128c4fc80b344e1fc6bfef731a028c86ad9cba8f1c72f38a9c464bbe2795d71f3aacdd7f54f1ecec640d77e282512167015b5086ba36fb221f57a87c535c2fe5c67a9a444830569394196de26ad190c7d7af082d770f25fb3d4e79cdbd1f2daece418e184788bb8fbbfecd30d5987a68941bb83e3b8123412fcd1905c54c11ff378cdf468b2302ef1d16a1b6bf03278de17e6c1469e3b34cc0fb14ce4bfdb8a66a54957fe2eb03297446cb9628ef8685a34bebe61f0a51fdb4ae728b6fcead73d75ffe1bc3501bcea0eb1c55b698bcb4aa561e2f3d167a9ea02b294bcc4846c4daabf79ac62ddb46cfd4d53d1337caf5286d1d9a4f9f5a2b993f2ee6a808baf856359a405dc9e2aebec9236b6d867b78cad1ff89b4a4bc7a062e328b80ebbe8cd73b4059f32d22ab5cca57993cb4f8ddd0bcece774833290e2965b00dc8bf78699784e88489496635e60b347667b312b51c94a44f2c9833a8fcd5f0ef702e43387450b4e95b5b14b7c27afbe6cc12c6325a352b66b7411d827250aa6188c28141fd68ffbacfdc5aba5300f46392c268657b0cec36214c8f8e5c15f7edc9475ed56365ec7046f312a6fb16173456c24e9048993a1cf2f2782c61315449cfe78f47614e1fe4041ef67118128864e6aa683e0d23721778a4a8fa8f04f13ccab8f69ab0e23f601610eaad13dea956a2bba75d2d98ac660ca899dc87d87c24f31ba344bc2b088175f0ef326b68561eaecb41a4a149dd8777ee7c6503bb7c1b480b1af23083abe02d6c03d8dd8179e3f14d7931bd621264ece991d2ef80a296f2dcca27fec93f48324ed7462c5054b646dc46ac423e509f3b3163b6a42027a40d6864c87dce04ed743535922c011fe977480e40eb44d7615a7583350adeddbfa887c0bcb5b92db93e352b4019b5dbe0cd706bc3a55d152e0379253e03c1bf343b54c11862e370c0a1c3a5960c7481dc39da2723660100638680a450ad04d072a1255fe082cfc91fee72ef8f15760ff45c296fd4b1214b161096abdb47327e9b1ec71c481c75a2ac9af71990b6e289cd83047f72661529826b11bbf43229313a84a5fe11db0f6364cb6cec6b5597bc733bcf8704394d3d7fe865369e8fa97c50106818cd1e6c051a0048715408e19138d623ef9dbdeb44f4d22ae492460cbc3d21e2ca25e8354301a7af9e60501ddfe68ac7cf4563194960fdff6299731d02c906daab3267e2de7d6fec1244a3f3c30485ab235285c7bac849264d4f9ea284cd0a52f3dadc59a3c42be8442d6fd1cbf0d6a324f1d92fdb7898372d4ea24c6f01030934bc22b0e3f641f1ec7b04cf69c816be24d6356224767d07ba8d35d9e76a236e0a3a3640088662ad9a4221ce98e3f0dfef23659cb75230d690617582a32d3c53d8bfd9504e651b40b8a1d705d2689db111c15a6b63c300d952cf49c0d3ad36e143f16575ed560723ec09df1888e8cd48e735e095e725250a4331dcaeaaad952d91ef34130b4abd49c03bb78187aa398c1fb72332f30c637fb7ee1b50bcdcffc343a9d34378f2085ecdb5dcb8c11425011424f49fbab3c23abb0e7db513c43c1e584784aca67e17feadf5ca54576cbba9553f124a2d8bfff02529615ff0ed787461f10d84a5da68eaebe3cefbbf5a60067c287f441a3b2fa11b18de551eb2e4d472066ff62eea1d8e62cb9a64e71c239c3fe0ce42a12c3bfdb213c0e0a11c2bd67d8511501cdcf67a1e9d2bd1bdd19e3ba362f4271c7f82a6d3af990ceb04a03232e9502bed8a5b9b6c5e9830b98661629e038fc99567c68298c13548d2ede9a0b4b59da54a3f425462d5433631cbc4f3bab1bf812ab6459405b0cb1a996a51d47bedbd8dcadf324e844512b2e7195854a5898b755019a3334093a4f44e2000355d6741cdb70a1d7adeee59bd1c87bbed778eea99e429e45023df7ce6a247633ef4b96bc1a112a03d1e1a9549ff295f5c12237b5c5602f0a7f661c623c2b4fd4cdf58a3f1370d34fb90f4d319bc4d098363a145a22b0de65604caeebecc4bbddbbd1dc206602a9773104e3ef7c552d3173c723f8c013a0fcdbcd8b87f973339a2cb2b598d63133f267d9b68b63519e3a4b818b022b5eb6286b0c91c52e310c9819e2f1025827f86ee7e0c785894ab6d148222dedd0c40ef0118ffc581dc9691330051a2f5cab0898dd98d4a8ebfaafd3602fb4c57e0418fdb237bde107d496a0697bfc7a16056a49115d943c64b66922a8aea8a624ed03b1119293ed784890139fb35ffa2ff960f40113a68ca1f121393e4e8385562703490f0a5b13de811baf7ac40d111f0f7be4e393ae218ab3df88842e8e12e7f180c351d24c43fc7c74c819ffb10737007c5f20167db420324e804d5e68f7ae7d9186e7689bc396e310378a4b88a0eecafcf9531bd354ec319b3ca15d0c73e33434a223e9b92ba07bd92f0705782076097db98094cf1215e6e0d4c975788982ef7ba55c5ef728ccc9e3ce7dd062e51887899af08bd54cefc46d04a2db51f20da622c0ee07558c2838d531210cef66e2742786cdf0c8c95751b1111d7e1446ec82ea23d9bb68f218adc5ca52f67f968e4d1208c5e6bc51e81f1eb856ad776dfe54eb96f1e40057772db9007b32061073bb6e0c867206c2059a0dfee58b42e13f167e6ccc7d4c1dcb58218bc305a512be33d7ddbfcfbf008c68bffa37cfa8d6c7db638bf083a8e2ad6a1005e381f52afcd7ddb3eae70caa39bba2744ccf4249e23666fc853deb3772d6223d925ac482424cdcf3bd96774750ff7d10ea3ea251cdc4f8975674925ee443a7b9c2e2814f33008464759b800dddb25ddc2abfbe142ed17120e9a050e2637c257c106726a6181d2f9960ac13cb6f9f081f176ece335c26680967144a446e4cd33ee73014d262de151eea237fee6f2c4bbe0598120a8227efd503e6bbbff7c651bf07ea643ecf8aa2bf684da47ca5e46855ff0badbd506292d842d02ee3c8c060d78a140018410f2d2c6961362950c25244cf67609e8c2d237ae5332199598a3236f689939de6cd48ced5232b0cc67025365239977471eb5c1e9dc638afd1c61905cbcc8267e89a5cc733c2fa28faca0a1bcc8972f86c96bf53e93c524e1e291b02e05d7a6284aeadc326f018988594ca307b80b3487d5ce53ace0bd3def667988f18becf84eb525494fd12521dd72ca0fcd29dc56a11a07615a55da0faec3e93033d2b3ebd893e769a24ae0218efd62a9532e9553f8105dc9b7dd9aa26e29f481732e6a93d2f897f3d6033ebeb4da71708feec821786d78a5edece5dd8fa44cf1df8921ea23af6b2c92e4dad932719e696271fd0e19bb6eb492b530d86a9b9c4e45762ca3cd370acc9a2147456baec21fc965eec706f2e941e9d02e90b4f06bebfe0b3dc2f119ec23cf4e2740a18b9948796d73e34db2ff002cc3c735e84e85fad168fc358b3ed42bfcae56efd1772eddb6978b8bf7cbdcec6c4612ef2309f8d3d180fa5b1e60ec90f3d9815df47fd3c3c8c89cf2d9de4f8d121e64b750683034be58f033cd015113aea77d9de83e9d15e75165abd4b17582dac7ce76e02f4c0402f1a13f509917e3207e4f12e12ff5a0eea27d2006d728877a51acdd30bd1d76ac0a144538e6244be2522e97a23695bf4699c0fc03d6ed3978d86fc046bd468526a4c37eb77970ac45559a920b056ac874ddb09955873e34df88aa925b6a600dcfa937930af3f5e60cc4efb467005d186826aab06628f4670f0ca960ba240776e5a0b145beb6518a24a110f45d667b3cd1baa291c5298c5c578ea5c99f9e601acfd5788fe7d812cec55d4e071002650be10fdfe3bb69ff0b6ca1d175074ad6b197e8c2a0058b7105af82b79388dc887d3c447ca34a2969856d385b88cfbb178d0945d7c577f96eb87ddeab0fd1789f4e16ed3296b1bb6914795036e7206b82fad93cf3496c50899dd6f55fef2aaabbb9da3460a33c8c931db955516d53a75a44377e5fefd2faecf2f70f502bad507ed403a5c59f7f0ccd9aa8d6647876ca5eace42b2f650be231664adf25aa3a7c0d23ed474b57bb8ba9f6498c9c5b785ed3e152d86ed5d8cc774034dc411e41afe55842e892d42e780e4dd2d4aad061a794072ab1a04ff4904bdad5451a29d7fbed5b0f12a354d28f5cae3f6c2afc4dcc77552d8c1f06650335c6419422e42f9b9de3764742124e1f5895770b5b0b2c9447836e8e96a0663d36a8978079ea4fb68586f0b8f7a08391aeaedbc25a96e8d810d5afbe1364dc045469d1ce50c4caaa1092cd4f7b7edfb512092964224223bd0d198114c0ec193ea291c9c4f82ee036ef89753bcaf1a777db5d52795bd2cdf44c3fdd94459cfff9a060755f3a8c760989babebfaa9c20ccdb8d79647997b32d0a4f5a56ee08402ab335ff32a2ad51fab1a4ae779917fddcadad5062700af6e34333f9370b3ed477b046e6a5763ac9f4588fa9ed757bdc94ad1a4c899eb9bea6a9f72ccb6f67f222e9804c8de36f98b8f8fba5728a0a785773b2a51feb70b89aec55b68982324f6ea9a5bbda5f38c6d27a72938e1817cb05fa519b895f391adaf036233503f617c4d70ca883f3a42170a57cdf3648a080ed35b1bd600d61b4156d7c8abd4b65c496101531808d6057b4a538f843eefff31ae4ecdf7d0d581db60e0375cc0742fe03b0a157a58245072ce474911adc2ed9b4d0d6c6ad991199abc7c4af63c587544cb334384d3ebf1a361dcc0a43aa595dac3507ebea1e570f6716d932c53764a8b836afb3e8f8043541051ba8341a0cac8fc3f7a1b9f6d43077af41fbea2b5a2327579169bba9f5e03c5baa0d20b987d89307193bba1d27c4c40efa323cbc4774bf0c5c502d20dc11a205c4bc617edb6091885ab48e68f2888aed00728e0c886d621a63f8c9c2fa2cd212bf72c06ff8b8d4bdd35665ad4f47e6b85713c40ba9885f8917bf70e54be3e9e062a5c4d39bdcb4f31960c16d351db53521c7e2b6a5445488bf38dc23295da5f416fd28654ec8198242efe6876eeac54af7b8345b08d2e186653cfafc4c32f22320a23e4bdc9ba250368f9ba514f5f4bf402ded73920700c8ac96444baed9f407cc6e4b88cf6b0ccc04e1be7afd38b212a55497e7c13b4bc54d87d68e06d2bbf620d0411dbc1232d5d936912da6859f5f1a239ecaf88a73bc1acd2e8dcadabe156361c412433de9eceeb4064edfee140af87e5ad2a49f635ecd34d8958abf063080d12557acf36b00aaefda45d540a7423f7b6be6ce04f0b4e4ce055bfbe5fe2452b1fb1d525ee9869856acf8af4b4a086b55542e290ce9971e9591fe7df86c2b2c28e2bee147dcf8421bb0ff5c63b203cda6427129dcea081ec66d3519f86fe0038f39143f08b1f286147385cbe0c185ac123002cb24804f2a8c3c5e99eb0777a26dceea2feaf743a5d5281659c3acfcbcca804697e7e58b7d3d5d28059e54412614566fc0a7b6a23d22e03f8e7e9ee0bbc9e050eafebda64b5b2f9744a4eca3bee2710d19298e3aa40bfd47e1a2cd40fea0049e4ca7ee28f71679946ef8a07e2e4d917000d609a4a49a89df260cd57d4153d5d26df0c56ba7ec40cabac30f1b8f75bb14569cd8f41edb17e457669fcfdec3640d943b20a6b9f0a6286a72a57d4cafdb0a4450a8b65be72f21f3569f17cba516a40b2d60e48f45c0ca68b6a322f684741d8dd6a78ca2089cefce9ab233d2ee8f5575fdf9c91fcb7fcd57fe5c889cc226bb9b58deed9dbdc7f5fa5068bda654017d68be97e3792efdd4d37c642044e4bc6fd79038e12a4635b21d319fbb5b57f028d1aad189135e734ee64bec3372c1d938cd4c0d46dbbcbd6840028b9acee9395551f1b9fd16762c010feffb9ee2c8b68c90f5b619dfd8f4275198a343080ab6fbf8167b10bbd64c9a7f919ba6e75172502cf2d80d5f0f093a1b4a004bff0f78e409129605041726517bc8120e86fc14384356d322002920f445d74f4076af21505b94780b0d53ce96552e2afac4329ea2faa060a60f6edec415c5a91fb035ef3e53818b2ab4ded40fd8db2e6ec741e82b65f1c37df580a32c8c68240a25acc37d459e0ada8754e17ab93734ca08d131f81e7a3e9645e9756eb606fc612d01b90e95d32450839329f89945d59137210a23c409b38d3a2fb6df3d3d04347ef2143bc0ee03563b4f67db7cdc89810be5fb800e18828a046d2e82384a357fd4edb9d2c8bc9aa799f6fd64dd8463fea21cfc05fb24d673aabc98b2c1efa116a97b8edd204815563f64aa0e40dc20accff10b8295261ea998a92d2185dc53bb5c3a17bec6c28957a2eab0fab775bcc82319095b4beafb0e84c70e5a4fc5e5cbb26780180e80c4bba003e1050231b5e056a3e78b69049e2f90a5da19a12e21c6811b1bc3aa4c65377d78bdeb5eb45025dc034c71c89ddcf0f5b1f4c40dc06e4cacdd2eeb5a2c11b1c6a7afede75d69b4e2f1d576ce33a4e5d08326abf410cc4597c581ccde865458ab7d9733bb59ad65f4129c9eb62dabcf7c373b10d514cee91310ca37b5199f2064bd1a6729227af89819b24767eb3b07f8d0c028c71308cdb73ae6b36a1cbb0397e0261535b047bf608340dc2bb8714f34d9a4e7d1d579cd5a946f8dafc11924bb9d16b743656dc930f29a6f12823e7ca588a66235ef3fe5b72909c4dd9a993249bb6f0245b21081cd1834d734ec8e93b0d0360d23aa865cbe743bfc7f6c0a17b2dbcc2e0eb19aafa331f5eb10d7ab6541f4fd554fc8b0336c2bd9d7cef4147fb10e076143bac71dfc091d702680f19ed14bd1211155c4b25311a2d786c625df38bcbc395c7f069434d3f750654f4ad7e38041b687a96abe126441a2621e22f4c859998a84870f4cd6ee5777ac82576f6f6740e1ec364a14b8154bf42847414dee8167a4d5d5e312d7e2fcd2c888849b5ae900c1185764fbc3e9acaf7eea5040cb99f0bd7d38f6369da74835d392cea00ed3a2a913be54882edd067923b1eeddb897ce9531fbc19f8fb804c525744b3cf266a3822b728dfe631a82bc420cd4ab98bc88de26ab8395f7305fd8744a24958052a93ba859994765efa2753c4314252f4397dd85639a82c37b1f5ab52e477d86c662b8f79e92cd69c0eb3f6f06560199e8580ea89326d941c1d97190f055a46791223da0b03480a0326221f1d091307217ce9b5dc704ebb369a4782fc742e9b9fab8f1afbc2926a3a33b48ac61c03e963e0396ebec051d763c32b8fc132a7766baf0c2118e3696994551b40916c7e834a9314253662fbe4e3059a6f9d220ac20892485630b6ba58197b4e9f69f38e8ad6d2fb644f9a55dc6b2105a6eb7433b5eba16166f9bc2ae3eaa4950a9017001122e8e8eb2b530dc666137bf207b3bc3316a2c09872caf32f46d5569fbbd834e5f29bd532706e5e144e7e7a027a03fb21458376412462040fa9cfb70a0f4babdeeba20b964c36e4258938c42bf377e6c73e843bc624d912e728c938d6ffa27e0e2d3631872e8e415714ee02f243fab7b6816fbba1d543e409b59a0fa6c9aea899a665661839d1ac409d5e3c83a377952cecf4c9538525989f027be8272580c1ed8e2b7993602af1c9de7f2745c3c8f3455b1c2dade84a9f350758d76cc93ec30ca248fa0a84a0dbbe1c643152c5363a3e6a90784c92c2c4c86f4f9bf5378e9024e87664d2bf814fc635a4f2113d0d2c191719193f2d2f6b09617090902ad9aa89712f884b89023c846ad26d8d3a9ee5157d4bcef8338d5bcc4bdbacd852cb8226ab6cecba6ec78f59e022637cdb3ff8b0d4fbd3f918a991ba895af395284008f9c23d710607693103ffb2ff1f8ac9b76830da58f3b3ed34e5047e1e5b6eac349f8fd0a3143576264faa01a28eeb8c9e109da8d277eb95f154909387bda09f45458418a495ba980b86598e4e6c3fbad1b15a6d47325fed7da6a315f29106b7ab8383e5bfc1cd943a5e5a4f5c1316be64d2d6e8191912a1f39ff4f64d2ad598dbc584043dd4b7267498d541a7d6b6fee23fb63ee1dd8ed70b41ae73f5b0e76ca14aa8109c0e3fd7ba9fa41eb0385ef1b185a78874253df87c412ab70199da2f191c4227c4be3c10fb1525264cdb7a8a2ec615982e610de5504c28b8843eee34fc70d81dc04cb089029f28ddffbc2801804d17023a35fb588cb3af920dad35c8ceff6b332543d4897ab779d7622d346b58b76f53d55c6fe3bafe8cc0f5512ba650bca39862ab16d778ed4e1b3e4f99a4d42219ecc33e7b669b2e9f5bd33d554ab1ea9a34d46ce401a63db52b2d87228743f5c0e101db1510428489cdde60c29b3bfc77fe06e272c3a2afb75ac1dcc7446164b0cc23b1e5db1a5d8d70300cfc70cdb1d90768713c799e130a2fb714a603690fbcfe59fc2b66c4a187bbe6fd42012379b89140d3498dd83c213ceaa170414e9377880bfc17578c8eabefb48c4402011d2b77a1df62ee4bac3b317776da48fe97e6256a3b8be8e6f42e2541bca198de7d98122a5b0cfe2dad4fe367ffc41e4673f1a75f5849b3121e96c32fd5cfb532e167422d069bb148ab30559130a38ce39aa7392cf491f80189a8d85db82672b791c343a4320d0d09dd2696c1e1da0981677db5ed0e82c844479f7021b51c5171b817fe52f3d3b40176534ad46a90e4927655a396d7aad08f6ef63434d915433d0b5614161e38d85e08299292febfe50a6066702a949bb51ebe500b1b48ce3050d81e30386896e22b196747ee5f9bc672d3f672fc9cd3d7466a1cc400e6f11a459d448eb730dc52d38feb7bc2b769c0d55648c6133add6c69aed49f26837c9183e2686e6be2507ac051e29629f7450931fc790baf558c0a09d1aa7a5822d0b6850cf75d3d6664ecc181cceb1641d6d74f972062c72c668289d4fc81fbab8b2d5b909efd31936e43b7c8d9670b27f7df0aa4a3dd49820377f7afc837a399e489812bbf853af5ce41a4bbd90ab7ca502f622a344b09b0b835d92c359c51a58a19baa0a6b46f1469f5672fce8c60736efdb13e2a2507bfe1f636625303fe1a3a6c4bf57e43ebe3108d4ab73aa3489a3a061eb9d6097ca889ebc2cdb80883e70c79df65072565e2ee9f44ad597be16351c60ca73c9fd1d8a64184fd6af9932554997d459a7ba050e37ff284f5ee487fee6c2ebb796ac0cd07ceaa41daf132711b971064c2f8d5cfb10196f0f0a2f27b54285ec50743ff17eec2e502ab6b682f2024f8f8e49bc3f6f4defacf8599cb1aa33e33c51012b9f62cbcf0c03db1a31426880db829ab849e6e1dffbd11bc610419c619bf7008cf85807fee27cbf4ecc7ed10766ffac92fba71868fa6785814670e407d7f36b26385d164fcd8393deac9166ab88a8e46dc7dc67b4e02910c148834ffe20530d1bd45dbaabde27484f4fc91b0d06aad2a7efa1a4de56d3c89e6b3d039fbe4ec234c0c999fbea87d9fcb6b5ed641f0bd43ce816bebce328f6c78b209e129fe70d51873f2663b42ad3180c3318acba1863afa5ed70af35f9f3c397cab8d87b637995ad5f57fed208208244d18432ebc3a73d6d02eb19424b3aa6d3e65e36fc5693e5133b68de6131ca89cf754ed810bce6906f7b413ce52000e9383739054e542549bbb1944f4f6808ce30c72f821cd09ac288cdbdd6097697f2c4781540193bc12bf7f867a5c213aff7249b617c2149574535d5a55afa72be251b482cdb4bcb703f48d73","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
