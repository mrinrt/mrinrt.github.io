<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ee4cb8e528c18e4d05d5b8f40cfb4c0ac27251c1b561b4a201c6842758681fccb51010a900380dedf7acb29842158933f0d2f6d687ff00c6ab3aefefa345ae434a1075983d2e8b8912ddeda5834f421c06b504d42f833553687a16fb382e6ab79146c4707167087ffb890b6d5a3b421d34f1316907f673eb05b1c984818bcc251e276fde307c173c8ecdc4c27c10892170bd26a0cd59fcac4ded39d19d408d088c0625537b280b32cc06567603a81f717c418c6e1e524f8e0faee1267b117df254ca08cd079b75b4fbdad0017895c04093dedd1de584c34fa770fb3d5a24ca0e363a8b117187eb8911b7a974bf0cf49931834591a7806e0b00eb656f4c03971fbe38416a4e79913c24959d8c94064c1456752e86ccd4759a0b9abb0c78791f89a9cebb7d04060378bbf828eece9bdaed4dbcf03624540fd36f0bf90afe8a6611e3370f933eee6097b4ad46c7be101d44ee1967403f54c2c36c474c7bd026a71d1417494716b56f8c7de637ecfb5e93d45bef155badc937d6ee10d2894e9d84f32e1bb6ee8cee26379ad26c4496da96eb2a81a188bd3985b8bccebb66424b0559b741a7bac13976bca22103d82b48aeb4166d67bd4cdd92b2f987c837246ab4820a0904eb57c6422250282199b43af07d8ae29c154ed14a7ae563fa9386f012476eaed522f1d9c0c5e1c25835676aa73702cbf097754862c4c1c173ff34c8ce3c59b25ea5ab255d8a9df63f7ca01a0e41b83cfcc66b6b0c01bbea7b501e1c3b731559d273a108c7f26babeefc3d01b5aa17e8bfdaad1f172a2218114171aad61e13649947ddcccf10f8bc7c7bef82bdf19f0742b9e6fb54b372954323e369c48f578d80b6d9aab7b712605056a0a5eb18e1c5acf6b6caf44f878d5fdf263aa388ae940bf703a26a0970a028aa90bfe2b449bd71fe7d6687d5090fd1b288e73d2da0220a628f6bd69de4a4e35ccaf85dec4a75bd311596fc0c8a83ca12dcbd066f9abf9e4ce67091e77cee6e97191f9141b56b471496e56d5afa318269d8e69020ca8518f0dbc9e1fe0c350830d66fc87a2f6d3791a32e64cbeef158d070de112d51f9cfb169c80b31df1263a3d5d789beccae8d5e71cc83c7c8960cd4e3ccbdf1429beecb7d7017e6c12ff2c386f94642ccd4c9e610fbd79dea2f7229d3b662841f179d2685afea62fcf59289c5db42dd321365b38711cc8b815ce7f3c428cfdba29b753ad7fe2ca6c5348dc6c5662d3cfbba39a1ef1d8c77384befc2109e0e71846195b25ce1dbc10bbe15064eef998c57bcff956fca473416e9bc42fabef6a59939f28db2079b76dec60b5d84bdbba0c407a68de42257112dd40eaba74a50f6ec99afd3f813e62dd7c9ba02b5595e0d8337e1f0b74f22ed63e59b78b3d43da3e159b8e94e9c2d0a6204fdc273e9d906a2d19b19f1ce9e421e64b7591edfa5be5344c8df6647e65627a4cae0a6eaa0b853e6be16becfd4f7b8ca27497f7e607aecdec1cc87b65c17065c20f3b1286fe2c88011e8c6402422f71f01a41f08278e0f18f29e4929d1593d208f129afedb46ee4fe39c0fbf0102277c982df787c5ead4e5f424a958cea2f4720cc07f3a31024152a994c35cb841ec0886d30f6d6d53e09ba554c16dbb84667e1a8d3343c23c5b2beb1e121143b9c95881f81e45d1af24c6f1fda41cb375f924f061e7df5d4f129098ad36580560e8df8042ece20b32331bae5f48540b269f0860c96c5bc148d0cf191e844765eddfbfc2fa073d189b58b3ae29cbbf6a63a9c617aa43aa393ca13d01040b6c042b3248f4f117c5c3c65a0b9b59afeb95b32792833c607b9185e43195cc4912823f77150745b6b797d6a62a486ed8c4f39d3b21626b56bd61f089986307abe7bd0086473ee5ee805afeeb38818ea60d6d8f5e7de14ae2538cda7d3161adcf8790f743458055539212916f730f543bce6a6a9479b4b8456639842b5bbaac99503a27c1b02f824c4bfacf603aa6dd7dae3a6d1daa47307367c1bbc59e098e07be8f75bd35adde70d2d0824c6dd0d9f8fd4b7a98e1ae8a40e1ef0230cdb8eba2dcc648dec5751760b65b799c6cf3d8a6ea0ae52be1140d4b64ddc7dde34410f03b246e45b309afe05d12983d05a1cd53145629c111cd2a1d60c5c93e22f1d3a6d5c0d41973488edc669bd13552821b3bd2beb03d37b1d742ac518ee6324c574e025f76cdd2dcd1fdeac6dd5a2962376836702a773c2fbccb690106742cdc4f35ad0c098cbfeccec56ab320d4acfaf34c33ba20f5d25d2978ad23fd0053cd90b08821ff1b2b286632b64829c7c7a8aaca420ffccd36b24b05f4d18d8effc589229f03c4d093782bf873f02e0457ecf6bf2dc22fce725e4a3abb5446e1ad5c4e9eaeb367bbf658933ab7ff8f9d1dc78797c16e0328e6c524477d391e5bde6dee5ea02598e616996a406fda7b6a539c165a1b6e63a636ae972ab778039f7222a86e2041729024f4568df76d96ca79f88794f200fee72e66ccb9338aee205b59ae36b9c11347b30a304bae5bd6be0135456c92ed3970cf275484789183f3eaff0b14e19ed2d0793af67884515d2a2ce0cc044077ce75bf171cbff3aa5d8292c0c7ce97d610ed351fbcc354b63a4568bf34e7ce073c5fbb42221a9d04c58fefaeae989706a052c2adc8cbae0ed6ae983fa79d593766dbc255c1dda00a3fe56df51732f37bab1631f4f74a849953263e10154e97bb185cf1e2e1d2fba7c43272a5fdade3cb473f947e0887d07afa60a6b0812ef8b4963dd5fa2115206b3b4a3904b99afbd716acccfe1861b7d4045da6e99f4aab6189b9dfddd1e87442d329ea2190953750b99c7389fb9cb9d97d9e0d2cbe34f29bd194b5cab5da845e51a580261f85b5c52d5dd5ce8ce1c3e1eaf6e5eee4de1fe7b26668c2ddb01cb4cfb6e72ceb838ccf8aa35b3bf5b5c98f4417ba68fa0223c2549c6b15b3cd79ecd243695169e9d10976ea82282241704275162295a678e6d6c90a18d9e87d452a0e48fde4d44d7a2de30a5a1c3d6891bf91489606c1c262811f6230159b6d6668170bcdff1186eed487a763ae93ecfe9931fdd66a2c9e56854fac0e939770d8e210ca82f815d288dbd552376b3966bcc4f47c0b838aeeff45e939fa47cb1df1cf699700f0ff146f21b3044c8b8d0371b773ba5ce0ce55d7cb81b70e1ff00b627f288a7aa84d46a95364153701198425759d7ffd5e3e8946cb9efebfb18559995e319fec33531e6f40ab64f4a9cf66bfd5cdbb787c991438ba4f50733afd97ae61676f4de1fcdd5e70b60daa12415ff0648ca038b8ccbaa5c168b39e5f8dec5a29b55a56a1524613f0ebb3488bffff4eab63d798c10ce93c3e6a40110d3e6fcd1ad0181dd1b333955e757a361dedc225cb13139c1d09b2e491981865709dd0ef3dde6a881a5be39cdee7771fed7c45260f870cf81f20f8ff6751f1bc318a6f2e92a55a0dcabbd8c2ae5ab89e22be55f1b750fff777a68fd23d3265a5ade598f1230b713d428136618e1d1ef58d72e775b51acc7c668139c2b4d0556d116217678a342810c94ac4d3a37ec5a387861cff535cdbe06f841ae9d1c8d1ed50628bfff0167274af843c952b213a4924cc854b97a1bbb0032032f5eb6d4b830e11a404cd06c2d8d4653cf9ff484a45616063bfd44287b3e3dfd8c642d6753247522c38895f11b97fe0c305f4229c69fea0328e986a70353af01d4d03c75b9f1e927c19738f91c16e014574a27bcad33783598803ad5547f2bfe8b469de2d4d1d68ccb7bb3a44fd592a3eae2a692037c6975f88028a804e77a661613d63866a332994333de794554a5e229e9a76a4e7a0569366f7595982cf190608c17164369de156c64c905cf5433a9c2a2323b6bddf7600fecaf8700c4b2fc577765bc5248a1693a50f9c1299f62f5e11d8ca5ba14aa7cfa922b66dcce8fecb5d0790c0870647cabae403a7a7215c5f8862e3e75da78280878841dd373595de4476ac9b395e811f1e38a0d8aa57f8b13f8f1e19ff4db9e477e09896eb377780086bc2920755bed500d8cb312685fbf4cee94b14bc8e903953abc8919b6478dc7a2f9aa8d9fa211a27090340265415635c143526fa1444c7456caeaaabcf1b7792d301dfdb8b13e377a183237e639bff2e9e70a374ee4ca9875ed3b5010fc008121dcd603a001f5b2d560af208d6f3366c995be685df0025e3653c7c8f60669860963e6c09b2aa15a110d08ab2f0531d229209b8f0de1415db2dd36b04a933336d047936ec47152a68e2da8e0d06110db32ab46cb2dc3c3311ca849a9ab321b347ac54c8aeff7ced12dcf811a834beb14f8e21284bbbca03e19e1ef40bea7877c7d665f5693aab8497b77c85645c089ff7d9be1813d6407716df7ab7090095cdb6f088f6922bca4f58d8cbefe2ae41f35ce64bd61daa6e16e1054a5ebd8777d917223b7c7771f8410b65d871269ba569c08136fcd470968031ccdba242bc340727164c9dd5ad0c36ef002380a75f5259a2502ab19476aa0e0dc805d90787922be8860f32444507abad45c8129f7fd500668000e9a96d23896fa17eac40db4d67dc07383051855fd820d9b480a1118d5bc6740dcc660a630719ac3fff6eb802453ae8b0225f93c32ec706546fed80d17391e600c6e938908bf1a35e6e8514f5f3c85f6ff1243d0f2c010d318786472cb50629f448c70ca8f05b4459271d19b5cb5ffce33d7ff1ac25e565b66bda66eb2bf8a666bafd4e2c31b3c58b94c598e5c166eae5c9cf6db563e9733a2a3b792504d29b04f593050feb802723683e497603bfc660d9295a3c518ff8ae2105b6da610eb774b07b08cd035804e6a64f8ca45ea5c0696089ee5dcffd3006c3d3a4d419e5585d1bc27d4d59810e3c1478cd45c938538f53cd3ba6e311254de20be9fb33558eea7aa5ba4a384454e35259c8e7864e574a4bc8e13495e0993b718ac3057d439146d9939b574bb04a2affa53dae06c8fe682ec30cb749afaebdadeec597fbee5658f748a216e2ebad212148445186f579d205bd3c3efea76e6a4596762ed1c3986b8583b69bcb05c1b26b97ea9ea48961873cd76d642cca3db8fd5645811da37282bd68be7c3633a215dfc4dcb1ca360e7179a4c354886474cf76460980420749f941478b5e52ae5a10626afeff72cc5ca28385c585d6f0222dfe1acae1bf7e62d9ba54acf63ea2831eb0b04154995bf769f895c0153ba7089c65b353bd9bad19feb18bb339c35a216e42f4c669dee8f3c93d94f1bfe5e3be98f005c77d6b1ece2a8a7ab05da62b9cc8010c7c3cb52fe2c4da1cee2d64e00b39fca6a75189e50e4b582a98bd2acdfb43b92975158ca98d70d7acbf44278fdb31d1d46a85f6a7712455b3c8abc32df9f40a663472a7b9ac87a561f8f65d661b7c9fd9391d02ca797450d47de59f3369c0c2acd75c28315e4200498a6fffdc9bc17f87b79fa2dcd725ebc4811f153fc712745c1e17e181f918597ac7a8a3afcc6414c1d5208d4037b43f0570f98dd4992fd7707806bfe86fa1d2ad48964191fdab6c3e95bdf77791d3f997b69205b137b650e301c2e713bf13374f18d28a865f6b7e01f43c9b8b168d1b6df37d8a25d6156cf38832d5c30270a2cdf41fa4cbe40aa1551f534860fe5a746d122b3949e5a3dc80c81c565b36112b3c3a14147ec4fc6a16a61fd2b2322c1bdea73414eaceff38dc50fe3337d3b2672fdedb23d9628e27c0a3bc9810f3ad4cc16a9e3e0312ee9bfc9ea9e50271f9c65349d2c70d35564ebd3ce9704efd65f133fedc8abe59b1e99ef9089c57024841ce9d1f72cbe7ee597a1d2527327fdc269bbf0f30cd476d7247c0f392872ef2bfe7c80aed93ec24857a2a31ed6db7900afc48e2d7994d3ef2f225610d994c047cc49c8855a9f8a426039b765f853846362059ad7c4036b80322a7585d07e64a2de4b54606b8567b0173a9b0a6ea1bc7b69c6f9541a6a7bb7de86fb6e9f38a8b14f1bf3c349cc6137e912d6b046e5df9506ae3e85d79cc8479063b0e3799a7610fd8259ee8a1015b52d8fc91bd73621ed52cdc33923f935843edef6b4336a4a60eabf4b682d3d7c642d4bbab5c21e9b8e243c646f73479994422c16f1dda497ac9ec19cd47263878cd678e8958d4be1599987ffb1c0f666ac591bf4c85e4bbca6e9ef1e95a89504f29c7d44d8bea7af0d71900fee86a0a55cba82a73c416e701d239680135ed474f367c5b35dca4c0f5a70f4660686af443f7c9520636f8e4ec579d70272693c8df27ba8b2b2f2e1ed028ea05bc57c1cbd8a39fab439afdb3038edb743ca394f45fa1e478162180bfebeb9df1725a222d3501f733809961750d1613af31d526ba83cde6253cc1727b55660b4046893aa15decbd413ebe47ae51e7bdf9e0cd4aa6bb9e7a14cef087bdd2f94507c52597cfcc6494338f12e0ee9a3527796a6115986fda0c84e927b306132d40915bb08e581c126db17227a2d177038f9cadba9a0389ec242933e6a3450d636becfaabc55fe9165919d6b03a92879fb11b255cc497c813f2c910945410e14782748e8206056c00440b4a37679500ac8c3df50d3aba7e3e8f451810781850361fbcc9a397c3d883a70236a5a1e0fac2166f9fdcaf555e5db0eab55546e9331020b08ce39a4cdba37975f0dc60babaddcd8863b381598de04b4cc6cb379537a1498f90c59f58e9f8f57bab941a7d10ce2b9b8ecaeb60818f02bf983c99196eed1320a2b7a681d3d3dd71d61e230de3cacb2e62d9335d42d852c02077744946d2db2486f3ada70c27d62670705ef3f208a6bbaa204aa2e7b38e0169c8dece6a94f6b7040854d33b2462b4cd7b312ba491690585defc3d93ff783e4e66b85c2399317c6dd339f2be78f5cf3455adb4066b0e4a1c48aa80eac435c9a01ce1ec517f97fea05f50c30279fb1d68f6f7f420cc2007fdeeae8f4d7696254ac3a65677b807d1ca6d4a948297bf74b82cd6806931ef0b8abf4ccc6e782e4eb6b1f406ade1785a9c4054b28ceda338db99ffb9f01d7abb6576ebd2e3ccbbbe61be33ca35112909517d781739f19cb4ab945a99a4f600c80ec90f1af3ec0297a6f4d331736aebf4bf02a91907f3906bd89ff009231a1b1025234b863da8a0a23c93795543ec0242df5129b06da7ac30b8a1077433d45aff202082b9c298f681096919f6b0383e61f1ea31772d2f6ca3daa8859781d0ecf3767071805329d62b73e0b3d7c6b7edfec7ace227e1e5b7fc100bfdeab399cc57716916e521e63f2370a84e94e09d42338684f92d14348a6c977260569adf0b155cc227c094ff2b99430677cd7b52a72049b7f5f82cf2a01f42217d64284abe3a3e073a9de6b1d0699c1299c9b9ce7e64b7b2f929a5a1d5c1e8d1504aed7f1569e84028dbbbeafc2309408a18d871047d740d8e87c2ce13276fe03db8bb9d9f72fe65910e12a8c7e85a7b338f7e9440c23b1e46c790d5043f9eece0aeff3aacc9848584a50454a72abf594e4dd6fc489b51651078a664b1aefcc2b391c07dc1fd3e17cce8f5114b5019ad3defc6fa77f18c4588c19d0f4b2c1ae038d11ae5a14faac36b9e06b5722ba5efdda0ce56b6770fa1ee4d73fc14c08036791d1ed5bc5a4107d56c8163c6d0bf78e29070ae1ee7d86cfa1b3f009f9879cbcff80c65cbaee535ef1c39282745e738c004f6577e89ca5a1cf6a3cfbec6d322b4c0526e2b0f52754ddb00c2ac8ef0dd8f54727840f6a78918ec5791dcfbdde17b91a9037e3cf3097d384548389b6e5147f17faaddda8c6f44c4cc0a2758bedc14559a0b2e67f4c551f2dd977bcec4e8e592bc73602e42cb169c0293244b88122cf5a9538d4de99908d6c1c2df2c174283bdf8dcf046e76e890ef0c5ec947dec041a2d593fd45b3a8f9e521327bbbe356336da0e04b6fad686b7faf3690304c14ada69721f6202fd7af3b9ad5b1ebf47039719a8e4146965f064d19d31205f71827ae97024b09b539b6a7eae3aec29914e00d305ac86c76dee294be09239fd2a463c1cbad07d1e37bdd806d2ff84d6bf1d0701ad1f7a451f5c358b2af308f07ac8a1ff106f49a07d5e3275483fb5a00c1d20c1f4ce0d57e3587271aefc36b58986e68d9c36b4cbdafec34cb69c08c89cd56184f275ad174411d43999f09f8a33de4485e03f7be2fba2a19418c9574a0db84974b801f2e34b5c2f5a81f363d07282b48a7fea1adb2b27387e891dc47c6735ab0a59f10f82637b79a61360d34238c1ac968da31c8efff8c2acf1f54f3934758ec449a3fd4ee92353ed08b63f626af66f9e6462f752c904f0c55b92ccd570fb2fa14916e6773903e316027d57f920f10699fbc39b4b792cf201eb5a7cec643b903ad0afc49cd9971a2323a32b36b8a5f8df177af2031fec5331ef18273746c7f22914c444111c216a9ae988afe8900becf2ff2f659c442859eaaf3fc2b0716d703408dfa5bea4a2504a59af098d6ce91eeccb8dbf537bd05546cb5029fd374a68b3786059055be779c498d9e0f78cee9f391d59f4d4132b4c1b520c2069ba340b187c01e02271f4e33b717007bc4c855110298fddd9ad982fb00a8e92fbdfdb680a37378ac5620288a485d914f30968bb6094fc6190531b573f689132be782f28872de7cc75ae984cdd3808066619c1363008211f8ca82ac3c54ffd2e669401e5b8232cd88922db8b226687120b962bed2ed66f31fbe113c38b050427a5fb63fe4476c4ab1e3f4c99a30c285392a066508b020f08520deaaf61fac5a980e3938f28fe5bff46f8d1ac035b1d209562a75ccec5c0c689f6e89fa814adcf8c1b83e5fec06090fbeee9aa0b6ff2fa026bb895c2612338f810c594dbd408b3b80722e4fe673ad170667109f24ff396ef593b6e1683a4ebe8aa8d01daad1991c74c03399a22116a63780eb4290787d12424478dee56f152f6559d380e0dfef2c24216ead613598900ad5d4fd6ca78b36d4c7c7f241d7d86cf762c5213fc0bc95c45d61675c08c1f280f4ef0f71b1bf5d32e4571a9df2241f6019714f4f7385431f19a2b2e2fcb3b9f0da6e91a07d0c38c572c78d56435aabcac6155fb165e9afb3bb1d08b511cfdd02e48f9c7ef1f34b3feac46432f7b39025f9655433aa9bfd2e99768032fd60693029e5302b3ccd72bd1cce5901b122b6042b48f8e786e9b093f2d1142cf1c7db10bb42b4c80c4ce5b32b872c351ff34d05b4abf8bc657d2204db7f020ac808bc0758a2667e1a2b400c34a88b197a567e9155f3355243daeac035bf05a351de55eb46823d918c63ce9059be29571bf9a17a672fcff3f836e97dc0f9004d29e4ae2d12f314eb2657aa13ef90a69f6c0e32c603f3592a174b331032ac32a48a4283cf1467057f83a4ef27b0f0a52af93884c4c3726e024fda6c2d2660f6013d1eb2106751c1f1ebaf914465524b0ad913e748a2533ab2c8e85772613b62e1eabb39fc6b1ab6d5f578bf307f3e2646fd9aa19953db9713145689219f7d67e39cd87470c59e72051c6ae06f8883b745455393997ef579e25281dd0aa67657ad7dcba442714de290b974ae60494ebd845d98418ea52acafba46eff08bd640270c0120039c40f25900f170bb6da8d3410f477d171b1f8b2ab56fa44bdad2f588cd0bcfaed859ab952d6d7423ef67b80d87184725180232c99ee304d6080fde7565b0c8e2cca9d0d7828b48c6d4228c71276d15c03b6238f5b366ce7f8e400b28f364747e0ac3eab4ce68a95bb69fed3c12ee36d1b41f677cde19c9863ff7bda7bc06be276738f5ec921796d0c3437f46dc7e589c8e6ca06d5a130cbd2a7cdf4bf26a08eed65bf618fd1bfe179e6bd85d389156bf130e14db1374478238ed8b020bd7fa01b62abfbaf7f067435be89ebdd4c68e0995b8674824fcf188cd4fd10d8be957bb12c1b41768e59bdab9b0b3732a6f3455b338e32f959742ab98cc22453529cfd53b148a5e923d953e2515b36d4af6ef35fb17dd7827c4d6f88dc37b3c5aa23fd999f6237f748235d1b2332a152004a05ca85c5e702e2704f1e452f7d9add3c65492ced8460404dcbf34d06e74a2b1f219ed3a7041b7fef23f9f488950b412349e6ab1c8a592a4dad53c8c18a6a3fffe2d90e89f04bb15819e7580ac3b1b2a0c5b100653b6902344141974598549a9901590aa72492cf3f598baff864bc00f3843f446e90d79d72ea046803e512118d7e57b3490dc04c9b184c527b9cacded6e7f0af7ec6e4e64fbf42de882a221399acb44a08a976a4628e652d93c0c7078faef19df46031d9a28add87aafae359655c64f6121c1ed1fe8d70b4785fce8c8da9f861a0033256f6fd4ab3017b56af9bb47121f2f8fa532db3acc6907a29afa0f07fd981bfaa2256027cca8237b6c661e9cdc3ad634fe5c518a4d2b9165fb88524a2a0368188d62173e4b27bb4bd6ad768f4845c081bf40b5e008b355ffea7368448c945fea74d4e31296e157853ab124b12d415d1bb7b4001538b81cd7fdad4f34662e8c38ababc196a2c5ee188bd3a325a3340008af63df50887b0014cfe07fb129d5102dd3531f80523e21d945d088389dc575a04af25d9e18da59b43639f9a2545742204382dad6aca08b9481228fb85cbf0807caf1929323ae4d1f246a1b143f653af320693d4cb4e3f5331873f089b6ef924e1657a3ab3989886e6691f6f852c8aca049ae56e396f0bd9c2c5edc411e2badb71e354298b16e05c736ceca18f7c92f94c9477c34f20fd01a942c384620609a3a77adb2411da5abd0abec64f7534abf8874a19c2498a05d7ab38ee1e880c5341bfbdce472eddec169f37840cfd2f4dd29436c68ae5ac3b03c78d75e715f930133dc22d4be6056fd5e27d5c694f20801ab08a504cbe2e23402bb756eda285abbe8b09005528d7aba346ca65a19edbfa713b99e087d266a8082e19a05e6131c71baabfbdc62d14d9d04a17db016463a10e71a4a4c2fc319eada52a076ffc2d050be1a8114c207eb1f7e8acc658781d97521a478e3d162f8cb73378061bb81a46bb6ade6d463552b4b1154d6590ae29a1dfdc43ca2d16a113d9a1108226c3e30c38095eba3cb508d446e73692bd65bbb79e6c80fd1f5f837975b14afc333f1955d7af2a33213b293992d5b57a9a75d0568a0f27217beb6109f5469d3cf8455a4eb322c5c5cbcd6cc9d712691ff5a6a72044502c61fa6cc415214badfecfd133a37ed8ce6d91835135bc6bd1db80ed89c03eaad1d74e792ef3671e2ffd7d2efb440a6111e4c6cd79cc7c813032fa73186e4e3ab5335561c1cf27ade36316d905c9700921f9dc77949f628356854ab25cf53ce0517cbf6a4af4c17591f8d4714a0a2d951555164df2e440e6b36f1971ef8b86d188dae3916733c9305fc73052e893f2449eed25a8f8c04ebfb27019486d926d0dc8a4159f01923788e9cb91d1e4f3aa93728f131d616884e56c479824b9d78f518cc00cacfcdc2235eec1bd21af116fa3a8c8cc2639491f17bebf29263b5be756caf880346925b528237b97d2e48ee59f21f61dc1fe95d1d9cd4c2ce7bd9b84271663bd13b16329f00994fdbda48828a1a726dc4f5f43a31051f20636aed4c441a025654a70c01bd68da8e6b3d831d689ed9c0ca072624e880d3674f16856f708c76eef31e2232ff035468f8bba4cb94f5f48479592fbdc46d326fb06504c4a40e532660e0b3b2c422ccb7d0b8ed47296e195bf5f261b2b7132f9f572c5dd1ca5c6b2d0e2e27f65615e7f5c200517d4abfc62898f2f1ba2741742a1cc4fc91dd9b61c328bf321617960b2ccdb87a7a7c854cda678641edd18c845a7e1df1d829171e1577400b08c971cb4d56da14811dbec31e2fe881c995e3990c91cb66f37b078870f84daf3d6ec9a2f8dd6754366559fb711f3a562ed89544de8f20871e744890803bb96e0e08357bc72752ddff3f393a5adfecc5cbd630f35d274106bd955cefe712ddb31a5456a545976e7c905e41c170e7de2147cac43e5fc201879b09d52d3625d3480690fc55dec71d8768974df3c279b67483fa032903c4e56ac2042c2307ff7ebe5b596ec6d577b56bfe6f39fd35d47d77e374234fb921a1ed59058e48fe5812258127ed399e871b00925d1ea5a6fe31f7908eebf4f0b876534297704683aa511594a83112d0e6f70303d1e57bd7db5cc54f8e326a1e9ee98b78af626297e8a702bbbfe64412015001067ce5e194d8ba0e59fa41316aef0708feb83e9bfc5a6c6abafa453c4a07475736c48b45a530d13f6900fce941cdf7f2808cf2c5b41803acd4e07da9c49f2ea9b8558267887b34135bb8dbd35fd6be03dbf39df0bb2e6b642ab6546ec7c069a9469576bbabed31bb1d74946b8ec2f8248644a938871c4bd23d39c051834996a2bf8f25644522e3ae6a9fa74dfcda371baf0703e100ca414f05eec9302db91ac603fd7581673a781557004d5caa15e098cedb4e21b5596aca306dadaf7625e741ea238018dd48e475b1c32968f6047442bed4962fad06b7522b026ad9c114446d4c8f3abbe8a295ee1446371c5a98596fea16d867b66281e78435b64f867c53be19c94c91c494a1ab61059171e7dd299b52999bf188374c840b6239b78b273b935d93ae567a91c71c6326af63869a663f91d11380dc2e54415aa65d12e93230078047a41a11123b600638c34ed5e5348461401a019414abdf14266a610112f99daed29dfeec2d383b69e08ca8bd42e80f11fb761a6ffea218130402c0ba867b3912a30ee34e7f21e859fc2f064333be81f7ade1bcbe2291e996eaf258c6dd814bb7af01e662ef2fa62ff5a573df28bc0de95e716f44f4ea7bedba00ec89b504a5de61744d6d1d78475510bc4987a31d3b6f8ee9012dbfef943cf433824357a849fe1650392a965077cb12154cacb5e0cdc6774add694be79d96485f852e9dafa7e173144c449c6ae351467bf5789832fab8b8cce1297865b7ff040adf559814927854f8b88d38044e35a5acf0da7951da5043fe80e413ecae4f4fbd0e1b90634c8f05a1575cd7ed1fe6d0c123c61e4e840f17b3bb28c1fba68db0b9f719d5566f58fc2ae5759b2193acdeed61b22e81188574a100537801e8738d2ed41ff77070e8c0903ecae495953845e120ee67e7100dbdfaac261f641ddb7679e9cd5d50da205720b8d03f3d416f2f2ca5fe423a1e607931871ad29a50dd66140013ba3b87607c3438de317445d8de46ef3cca7d454e76d2fceba6219e89af1ada67a51b03413d0dcdf685db3534be239f824245e847ba2cf6f0d7f172d621daa2f4aa5a9cba6e491075c5c215eeedd3e8c8f7110c438c948eaa3b92fec4fb0b70b8e699e65560351cc0c15ecbc7f80c6ca5cfb2f40b4ee5a8ef09864db3d39b1496bb1c9e25f173d79e13c0908f750685d405da864cecf8627f4e817a24e1c7c0641d8d160e4ddc92f6936d0cc8b51790631b09b6de6fd37a23995f324c175091ba96d6c36016e5e68c0534edf84ceca088361d748e1df914c177350e7df40a08d21ca8b8cd187321533539355a8ba14e61ebdcc9b6e4e14feaaf2ad11cfad875bf45e5cd42b75cc0c322efb46288e587e07cf43d4fe1a2c721a52326653f23d0de5ed63ccc2929deab39b873d0b790df10036cad62a2c6cedc8f10bb47a4d722cf9fef11dab4ead53039d0a5d1fa3348a42a87a2d1183bd88c3f6385e36a91c41e6e7c18421d28955198c921b6aecc1344a7394cc665c758d4ae6ecd1636928f42ebda6ffb1cc55583cb559d0749ac2d0b365c5da3faafba94f77e2335de03a90690f32621d7d5bbec347972da2e1a060c0f59336d4c0ca68d0156884d78373c3a9d18a99f2dfc8e2a43c33c26413ab3b2349af0812","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
