<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"241d87ae57b3bcce1c7973f6bb1f5df071d516d3317a03728e63415aa886248bab585928ccc85670488dcb1aff3bdc064d4b148b3d5d2d1d18139182214fd2d2e87d4de56dce2fb53cc215f3391df1ffb31009da7b948aac3029aec1c28e2bdf4617281384539aea02486018ee5263977cc418f2f8a511c13921032e254907292aa54cc53602e0b2e18813c3a4873dc23d6890706ac1f15805c5332606ac5a71b5de5c78e22b4a7898973c88f180c0cc1614b4721db2e8df0e01a333e6adbb4922372cfb1a5f8817038d73f707b1ca90bc172e5e19c3a49b9b2b9d571dbde61576e6c9cd8882c5e3b20dfa0733753c9dbd465f5bc2525e067e5078221bb0e3f1a3af37bc66b3b13bdf662c080ee86818353cc3f509486d57a1906b652c361530dcb1258e875b79e27b73817ee2f483470222eb7a9a9b1b51e38bb77b487663e256bd2255e9405f3d68311a5fa037984f3411f9f6bc32d7645ed677a9e6a47a594689e10449b07cd78ab757e410b5ffa9837372025d0eb62287222a7df8f7f7ce825043fb7a6b3698e3edfa730348912915901fe0135e2da876fee78fa0ee808928974a8601a3ef3177d4607ce085ab3282941cc1ca9a7daed229c71f9efaa042810127e54f1524f3d4740590055165b623781f317ae7f2e62b9e81c8e6494384d34f0cf3073b79b57f4676be091b6f90aa188eef9363a94d5d7f8cb2a6752ce176bfdd6cef626a9cc0e89fb43869da12f640fda646289ed487277ed0a52440eb3c8591d8a6391ee84a3e207c61ca3714157759c27e44a6526bc929b6f02617cfe0b83288255994923e8b1325eba9a8ef88d0e4db625016787181ba41d6930a0777e846fe55bd46a208dc258f1599d3feb183a3307b1d3f90d6738510e69b75161050f4b541996d9183fb56e639a5f3ef8a0dfa1e45e315f9618bf70e5b8908141f04a0ca9654dbb480b72a0f51b24eb434cc66b1ae60d896052a2eb61600ecace344bb2df68820dfdbb8c64f9e5dfeda7e84cbf449ceffc396cc455f7a9d8230c813db6fe245c37f02d0722bb239c97ce721e213a98cfa8ee037ef4666a8544ea2f58cb031b5edb1444e9bbbbf77eeb26285798f3ca2f853e22b6ae536f77da63b888a956d54e3aff7e906961132e8ab1e65fe6b5c372dc8feeebe52e88449a4df0b6b14b3b6eea6de6a5a025c42c6223e3a8b8454447459e84b77410a93e75d642eab64d3260835a9c39f82fccbce08dc99a4781bfdf66433e6630d8d698e68e0ff8cf50d442fba77d028066cfdfc37dd21d7f045f289bcb25da7d5e50bca6b1f0aa466efa6e0e1166afd520894a248ea3d10fe7037f13a0654d8e716863ea7161cd88ef0989e2faa2e2732feaa96ab26f54dd5fe41df66bb34d8069d713e052cb393904d89f99d9e9842fc7eccaf82f2ae2d357aeaef7bbcbda93486982ce326991fad70849d772770f2e4c8dbb45d577288ac1c7399c4cbe99fe4a2a2a42dbda0ac8ea5ceafc970ef7c8baebb8a38aaa1c02d1d728ad29543996bed88a5721afb94faa62b6f994ae2d18ff61079e9581a17155f5fe50e9a3292b2cf0f37e8bb8b0096ad769965b8b8780f2456b8fa977e5466d9e4d47df85cc6d2c034892aef51e3faefc171323cdad61910b8e83df2bcc811e906284f7e1fa2246e5cc88b8a9169bfbfe50d218e941aaab761cb4d3a0ec377489b26b3a1eed12f394b7d8b0decde225e0728d2fa719497cf2c1c08eebab8c04a54fdb8051c0bc25c33b46d96b3f3c61b40ccbd4efe4e505f3306d75ec860267b334415db8e1be7f3b894be28dc7e4b3893c504fdf1938f5085c23853d5e4bafcea526126a9a206f4e400e909b2b38487c7251dd6851a153cea3a3acc1dc54950e26809e8162eef7225f96036f872edb92522468c1e3243802abfe2544532882d8a045adfb9885c50e0408cac8c68233bf5e05887a8895e7e79423651d771ac44fde13d53cfcd23ac80fa5f9c900308961d813d1ed224a86b630b821baf0839714ee79cd3e7e4f0bd81b7cbc5b069ec8e7851b3044449a5934bf265f2a842dcc49dc3537d913da87e5b7975f1d4ce8e95d662566239fd440fb9e90cb0c130d0248304fd2d56ddc21eddeddf4f692d3746c6a64472b41e15eac645eb84d5ed2df28d39406b26f58f3b461c6185cdd489cfc5ee40d015a9ecab453528b2c46f2eda05e1b0c9904818f1d0cec57f99a0a21622ad057d154b24a3fb3f0b884c0fe8b673c574aa21e3f685c3a9eaede6258d0caccbb26ea01d4a3e807dd44c262e58f0915675861d1a9b401fe7c17c77206508418e6ef448ffcb3cb2a9daec88a986ccb1b62cacdcaf7e12a014d2a566236415feab20ddfd68ab76b5aff21aad4bd72e65aac9de95b61bb2acc22272430d7fc2d9dad4facfe781ad8900895811bc6762059e6d9b23f236ad60474016c09438319db8a67e5db0ba7fdd3c5e9836b62975ec1b55684833eb7c57b427a0073fbc2d243a9f5cdd898b82bc169f74e7098a9ea9a41fa095d79685e17e2f8c44617d9ac62152aefdbed78594b4e62b548f3e2d9b4125cae976040a491a7c3c7c5bba06760c51014c0111b6f1104d4cfe24dde7c67d39daa3747b1ee738df2ebae358c30f1bc2deace28673b654869cd237646653438b82b9029730e7137001cb8374dc957478fb93b0874a5089348c531d01f51cf4e643415de84420632fb71560054eff2f081a9ff615adfae8501ebfa6034f934d660fb18d81def4e5d8a1caa5d57d157ba02a97d842d99cc4aa010c48fafaaba3713b762e9bd615bd2fd4594d66a8ba4bfe758e400576b0ccf78a85754992f3f6feab5d506415e11496811b113e1baef98396245e9f5da3b43cf33fc4ad67dd616eb09a36370d9e8ad3b9d244c851d2e8a4e14a8182966ec0b57d94dafad8406cafe09e7f033f8b1e937865f37f3c4c25a1e5522fbeef54fea4d61df0144052775c5c9ee3329dce65a17d87f7d4b66b8b3c92f08aac6595d6367f56561fb7f87925574a4487949b93c3a1507b9d87d45bbd1b50e22d5b570c53ac69902745e0ed863f990dbbc5db1f611c229d2f6a7837b1668432457d20a401a421674b82ec15340eeaeb4f022343ea9dfc92a59a95e775904e5465832d6740c4cc3a7d2415a3a5a218cea56eb742ae44d8fc290d226d88ff14353ee03015e4e5b49ba42418f60cd059c98f15a6e99c660117559b8c5009dcc43eecd9fed5a3557f3a743eabbc435fdd6ca0ca74ea91d52a3c98587f549b4d8087952b04b8c9b599870bf27affe34e2358c01a55a5f0020e75b7f39910818800917c3269a6b0c6dd2c131d9387032b2d608c0261450cac77b5f443960fe2ff730e468c996f2a1d3c86da1c3918ce0cbafb8aa3f9416525bcd85426cf376b5425dd66126083e8cb70efa3a4103a55c0684f85f85da1e756d202834486878f4aa5873fab006c44564797e0b2b4dc0dac53fc7bda0cc6e0e7ed9c8fc6d407a198a40c79b92be8a7fcb51042bbbcdb506edd7a86b8640cdf65df32c7ff7d367da1cc4fc242e52c5bb8e3e3ddbac57dbaea78c71c0270141d2a1a69dea99b94ed354e1bc59aada7ab0d29e426fc60cb2713ef89d9a3d58f0ac42280b031d9e712c1980a0c2a2ada29cf433ae2157e869b3af08e73d135ab9bcde6735d08bdfccf215c958a4ed4d5125c36650020d0a7d838dd7ae3a304992da7cab0446b4b6a1046d50edb782c34e0c0d994c096ac142ea7e34ff6fba5ebd57080536f70ba440cf78ab77b99250e4b35582a71d6ee6f85543478d337b56035925a36b28429a7c643b916374de75dc8a76852f57c2c50151895354e4a28416ca40fcc97356cd451a95e320baa877a05d9295f96ccc55f161ff097be71f188d617edb74d02101047ac65f77bc93cfb29bc058648b4a59ed9f24917c06106002deb3d0cadc1aecf9b8a203dca3019661cc1253ba0616dcc436ea3b3f0d3b5ad300c2c55977d81ca54bfcd91074bddb528829ff6c0c275eba6076499e43e6595352d115866f71f172b5d40e5248a0eec3d939a4b00bdb411c16c10cde76623b7eb0f73ec87c15b34a18aff86e116d838ff4b34f6ad20c3c3ae75092b1f7081ef6af04cbe85c2fc31940c959e389f1acdb45a54026effcf1b73378ff65956deb2c0f2fbb0e93010d42676d58328273abbdcab24940fc4d25ea7b2f24c3d3cd843f83f70f8deadaff5b62f378fe88a7cab083f60e0590eb6b1586c2ad9f0e4e116940ceba9524963722b65db65aecfe7fc9dfb6d992e4f7d58242e55ca4bfb9a5692c0b819bfba3d3a4080512bae869d78d1d633451d78d6cb671e38a9129927e2600fd1d28a4afd0a4974b4168cc57b75a8a0979587d7766f7231d58fc153bf81e7d41d94b876d82044644a295b05705b7a0c99ee9ee1e61b9ec74ffb7533d2164a66cbb73e29154b689708bfe91278fb7dadbd491647681aa4187d670ffeba6d16a86225f93963e48b2fb2ad9db104de813d7cd084effaf91f9e815e64b33c5bacaa308b8fd611659e4808489696b82750a9e36b8a9b66dab6e21281a69a947c46ff8de953564e318157e8d1cb8df13038176eb566dd92b18b289152a7d373325f005808a310791866d32f0ba2c267ba209281f136b3eeb9cb75849558da0c67be9b6e040d3d001549d0a7ad8d9399e4a20a4b8ec2b6bcae3089f68c590714cbf41dbd39c2c5ddc6acd27707aa70cf2bcda8e036bdc4b06bff51fcfe52ea65ce6080a92a475b32db6ad1f3d4d47f6a1a0c98a8e8eabd158dcf557f8fbcf66e333286a43930830909b97dc06aa13e6f38705573554b70dac46f2e56b283552da07fbde9b9307ee35ab9e087c8da53078c91e175e9459a055b13fc373eea040439c7388841eeef11f6e4bcf26e38d4abf287f337f0b50ae7f279d0837448dbe8a64e5bc58a902bdb765a39b4e9403cc3d4c720940f17e28b2353e36a387d7d5a0d4e46e592bfdc47f45cece40db6db5156a42a8b1ccc40e10b21b2a73f17566347ce2f237341d94186fc1c0c4245d7090e97da220f8063029655f3cc85a1ff81918f9d18585786adb297d86a27aebf9630a98aa158cf06aa6e4b64552606fbb4b3527293d71142a92623616aec88871f791c7ca7cc95bf44d54925a55cda81a5c599498ef35ecabe11ac4e6c86da224865902e0680e0a88b495c2dabc83c0ace51dfc03038e4594ceaa95848503ef6bbb6f62342aeff55754610cd1523b4ce27960a6da0b83235b786971ec3708a49803d9eea020f1f8b4c4a8f6784a833b746c1e73f377daa0eb1c60fd66def39d613fe73f3c0681b4ee0e896efc5002aa951fe0868691296960540791b2a0baf94f0f55c2ad93828e2b0fa7c6646bd5eee45fc2bdce4e65ba1d265a83ec590b4b47ffa62f4594b8bcffeebcbb941ca139dcc29a1ec0a1444dac16e2109e2bb67a5ef1b8719cb2bba83316df9a582fc4f581bd77558144dfe6d4c7df98d9bc0d1a9f9401f32bfc0564d3582f972e632080bced45f79025beba7ab25475c2c0382990a89773a6a015968b8c3df2053e80eaab1078ffdce90f18580f9e2ae2daa5546709786e6a097227df067a5ad377dff6264fb5ae7ca24e75afc90ea4751dad7b720cc7891636266d3122750e1981abb1d7cbc7d69ba748700dbdf1800c2a82d3f9bb624c7a44dfe5446a278741e5ba398a91a444eaf2b8846096b0c18b812bd9685a5f230732f19e37a9933346d4d0ff6280908c48821f8cf2f4285f43e1073c364f65d095b7746abfc0f7be735c03dd232f05eb615d93ce46538ac6a0825445d33c7444ef36541c338c244c72a2d3a6913772670460585476fc7494269bb25b1cf81d74644e89f2e2ac99141bba66401d8e7718d3b1bc2b23f35f58263b483511e5b263489329af3ae96d023b0949244487dba68b0d854057cbca2a6f46862206b986db1a64ac95a9b0bae91c8cd208570b20f7d692509a27d6d14505d85641c27f9e780af61075578e00cc4e35d302c61797a9e8e7dee7e677ce94cb3a077ed5cff923b204c095339a1db6c4bb79b0288d76d7ad0b4f133624316eb01e8a0a8813de8155daa8be4bd8ce255ba7d6e2fe983816f697b4954ea55f1320a7ae263b5e27e86247d499562af0558c487d3b8608510f0b780372429eab386a4ff052837f15e5771ba280eea5c8f86d7dbb1d503ed6285e6ee35094dc808fb355a7210cdcf628fcd226394e94f3badd6ac640edbaa668f6d1f7948dd65d2f955948422b5d7b517d76f54db5fbd3fb43185f4d464a16d05595f36c04e054c0d5c732cf7f821bf6a3a53f0ea5fc75735215f7b072fd731a26f923458980fe35533b006c5f1abf552ea9975b93a40c42a31232e115f56bc48b3a7a9b73c6029e1ae8674aeb572e4727aa60ec94e4b3005444607916aabf327ccf6819b94fe1a4ac1062a6465b01b9d9f5ab017da8ebea0a9020a5d3f3d058cd5f0e097f0a6544638d1d0ebd95e9e70a4470953ad5528a383e9e7f881ee4bf257859600a2da869c0a0ef0bc663a31ead580f31b67fe0b044b032f4c2ff45d09734821d83c2946aadd92441e2363ca6ebec194bec26d5d96f2cd5f46263397891db7799cdf76337eee208a2eb00deaa35cef258877fea9b31d7f73bc933703bbc381453582a2ea176a3c3489d55205a8ee3fce0d8df0597e3c7439a15ec41c9120c8bee7d99f596bbdbef8a96848dee13f623e9b4e5b908b08b8efdb8cbde3cf5428961e6269a8876edb5ad5053b5636a3806428d167e43332df302a1f5d82bd5d614b2db8ab779aa48306d287f0713878b0ac457a3c4b0a3cc58479654c66c1e681eff5a329ba620ff514bccdc76471e9f33ca026c58651bd694b46bd2284301f463048abe3b6b90afae48fa2e0b848327bd5f40add117eb4f77b4145a211f7c971a176e081d465d8268f7f279d94dd3f0b31ceaf2505fa72024b6a7e23e4e55e332ad6f9b77c2e0b885229893c4771f8b20ae97f7b5b40f5dd448b647777c72dc638ecb3e7931441ec44bbc23c853cdc27b600692a216439d35b344e5c73e860afbb03a08d54fcc9904de757c132c6bd3983eeaced7bcf7d40708afb6c3129d2be31dbfb3af8742fa58e3cfbd58a4daa3927ac48331dc7e13bc2cf3a69650de183129bf66aee63a5413d383b9a19363240adc614a2cc58d1afcd3faae96d0482abb556a3d160d1041769c63fa20b4ea66ea2e8c455b8572f6562ebe342d90e5333795d9f51cd558f3350ba5006628b4023aa883a0fcc030f3245b1bd98096349119895995116cbdde8a10ba5d866510f75362ed3aa49d76cf1dd71f0c0c6a38b1a83d123412e66fb667c62851696872317d87ad4e30b2663727f703ab4ced1cca15100e839c4ef43ba663e90e061b348441e4acd40b28c978ef6ea16d48197eb3b5d13a87c9199496b9bcbd56b094515c8e6bf6c6b53680761f381d72140d2ad46a078fec1c02031b5f03e66476435b0f6a1c5061ba8c616a787c742813d412a2ec7de8262d1869450ec62d9f62253ac9e7d0655d9f25e4b98b2660f73713f690060839544c9af33b0372b00d02cec8a9da2cf909fdbdf5b95f21c6ef66f346d1600fa3a452a4b56d15dd7d6698a1610871d68160e34cdd8278cd008edf44a2bd932c650a80a94ac15eabd039ad54b067b08b6fe5da54ec6e27d1fca15ecc6ad618fdee3235ebf38c4dc3532eda0356da3c97220d0ff0b5d5162ba1037bcd0a1cd35c24b04d19ad141ca1806206bf85026b78a4fdfff688b02e83c3aa015f58e5045c28af4ff2a49df2b10dcfd9846282de14b29bf27b95d78a164a2a7ea0ba7b27ad5e2c1b63cdcb6adae786f3f02eb22970d478d20f85195a14d67bd096383367f4c36eef6bab7e39032bc0413a4a9785f838df50eed285072dc4989307fb70e4bc2e95228e46c4f4c33d739455ef13657347aa01480444f36c59bf7fc3b3aa796f1597462c2a17634b01ceada007d43a58ab0c0b48d8582d20e556dcfffbc7b3955578d40088fd7402c145e701c5c5995dd5c231960d788ce65dc0958931f0a3efbc6feaa1bac2a3d5cd073e76e192da39206aa67087865bd33406b410654f2b0739072eff1fac4c71ff3adb56b0db3cc54a021a4f3a12de07c74dc167e7f2929f5d2033fae73be4ceaaf7eb84d7847b0fac8392346b96146f409a53635ebe2ccff21ec5dfbf85ca3b2182e45f4add9f195784dce1d46cdef1e2e6cdd16f9bd64e4fb2b65593bb70b695e499f9fbff7cfe7280fda196e283852c4e7ef01fa81ae77cee666b152ff643862f40f63e5f8f03aa8455cc4c6cfe516b94dddf892e35f82207c83c7226b87aeb6ca0c75ebf7e7db6e5d9921ee53de52092b099134c709bc11faa6fcb594935f9deb8ae34232a060570b617a47bbfd42dd2aab9984a965eba1f56627db9cca7c2f52a8dfbfde0fa08bae550dc044c65f10cfb96a45b18303d8efba41e5d8d308e421d89f7027fa00ddbfc48c67927d41a23b388500b8c9e44780dd936e0fcaaff3296419b02b8cf724f234f5847ee195ecf56ed5beb9e49877ce7be417c11b781e80a1587828f7c40198a4f8baeaeb3250a6365bdfd0e726c15120d0eddc215aa975a7474b359a2e4f65d77c3e7cce614b69cbb15e752314691ce307ef45b09fb384ebfc915cbbf0d81d165385121ea52e055e5243c89575bdd07c0cbfd608f06bb0529b300937427f1c1e8f1e48b00d4f95f237ae38510bd7f4bd49cae5eec3fffbd9b18442ef8555c0af0459562aed80e5ec7695bcb61100db37d491612f3e1c12ef246784c849b3bc6a363897dbfddacd12271e743024a0afe0259669f164bf9d7c1f471aa806e9c736ceaa5a6735b136ad5b7dd0c63987bcc4783305a30e45cc5589bb69526df93c50d84207943a3ef83c1e3e7359b18a78b733445141b60b8ab4927431d03720bd49300e3bfe8ed3fcd151774e5331d2bf7ed117dd15241e6c89ec918d2bb4cc81a31858be6124d0c683deb1299b728d415c78b7991349b5f1e12dcb99aa0eb3ab45a6d7b83c83fc0165735c3a7a6953f938cac37ffe8496b03b9ed4fa4fe52b6fa4a5516f6462392ee8d663cfadd748abb3be3fa9e848cc1901bb3ef6805eac19402849ed919783884bdb42281133443fb081c49840aebcb04e787720bbbd2449a4d546eb5a305c030095052cda395715832d4626d4e4abfa9a3e1635c2f70b01aae434e648be5707a3e7e45672d817e16642b472c837388a87e4930c2ae5fc7bb694cd30e3e64e79a69617301562ac30e65873bc46cca5fa0a3552be04fdf3f15e32576f3954a7664c29f2e727f8dc9d4fdfde9dc1e5001bfbef6ccd22c296b9eee0e3b288639a08b7d033b33fdd5811c2ef4e03ddb5dea504ceac28475cfc2b5487403397f76f23544a1fd5728ed637216019da424dbba81509143bd19ac6e6dd4193a74a81c964f3ad5872e71c60dc004c38c6728dad6551e970cad216880450c7515a75fe67adabaf7ce896b513b54e7f6fa2501c6589b1025a3432fa438c4c3fac37e5aba9dfbd6e4a123acf5caaddb7f59456422cffcd6326ad1e701beaf4471c95f40de48a1e8b9ec6276f2551a190c2491839a7df530ee22768d353e493840a51d3d6ad6d6c78f96bcdd75fb52b6c0999798c9904989d0c1734cc0febade8e98ab3e29e82a162a970291702947dd51f9e76c5814f2820405f0e57177c5d8cc2ef411b0d0d59de5f635fac2e03c36c4afa2f77b1b330a08c4bd86b38dc7765f2cba3c4b78ed72944db6eae0a27d6ead41beee069d9a8eb850096f6eb66a490f2234302d140c10e54b9d150bb7fcc1702c3ef2cea1333f03d90bd27bdf3fd4fb25bcae9adf73f57b6223639a670005d184edd38ca147113a1cedb73a29388d81685f31753a6d48591dc33605f25548377b376ffe5ff459749b6ef42ae04f8910fc5d934470a47b81e8a5cc6aa7802041696f1034b91d37d3bbe3a211dd7305053429fd7a6c5416888a0b727230e1a891e168bfb204401e5f6c328dce1434d550d44dd9f453b37a011a87ffda98bd0150e2daac15c7eeb91df6ed43f647984dac35cd1058a20611d95c7966347830f8ad575edfb387d43a7f37144b7935641a4cefb687986c9853e6b226877e1707905f325b0c346e8d80fbe878e838a22aa92ba98571fbd4d4c8e2481ff71f3305dc48c55623780acb4385cfaf83e32a82c7e11236f439e159633992b30f5189bd7d6172103ee92150c17ddc3a0fb1a3d70a4f2ba1b07385fcd114148d7aeddae09b53e860219bac17dc881b2aa13e5c45a0f7f976a679aaf2757154f7d12288d59cee8c1a61387b364fa84c0a573a9cdccfbc53b2190fd3a2adb61b992d34e6a21308746ea67bd626fc9da1a93b8e04ff589abf919179a1577b80670563f1fae4c27740f05df8ab1f906cf30ab6c2f5a4d71d5320e2f5a722f46342a7363c80bc39462d8333e40214bf729e36cb8d45a294f1ed3a315b97f28db76ad9c7c7639c15a6995eff8847c4f774da69601c8a96a27d90bf40d47cb9a048dbcd8c2b578976d127f3a2124978d78ac05cd65321d9004c7b28260973748d5c52ff410d86aee6fdd035864195a2f9bb23e3598fd93a56e5e1bf1b012e77ddeaa71340db547f13382261a788db083595336148a1a5694d488c641a892bbb16e763c84b96613f5798157893db835c66606225e8f7bf40162a268d2f8f724fdb3627abb5ef6003e2337ecec65834e0c2639ba26b0e1a18f89c25323dc3b39e60ac1444f6f54e3a176e7f3b576c9f028d123546c8b1688370c1383e8644b0746bed0a1745751b72b3fc640f85a8faa0d9a2491a7e594580bcebae6fc7d28ab526fc3498b5671d41b373f94df048909d33684511cd10d09ec6df5bee2fe7183a1f0715ce2a312d9127788bd750fa919afdb8e8680b228528c46c5297da6dbed3db7dad84f8fa2a6ab58cc10519a9d4a717a96d1595ca041b3b83d03a673c254fe637051083b55e4d3bb50b9f0f59ad6f34ce7a8fef2a5d78195ee0a0d57e9dd500b1effba8373e733f7c4eb48d56649e8046f205c35069aab0d89f962428f1f0d2283c474c95279ea53fe881ca4cae9c7ea4b2bde705de53ae83c0841af0a35288073300c03d142a5453d1f47979c449b792ee6c3827e72043866f379e51e0fbb1b5f768927aa4e251051da55946f624e85445999de080ed635b1ecaa88400a0ae83b096fd46687219a384e9bce512e30bb79f0679ccbf34d3d6234580e9b7183cbfa3c9794dcebbaaaef599120ebfa079085dd9eeb26192701a614b37dec54de009022633b7b19e6e756ee8245d4a18e69f9bac97e4cc33e0d96292397d2ab17fd16f6cf7af42739bafa427607df240511e960cad861a7b6afb08888eae66a16a3a4c98650c612a05267389ecdffa88437f56ca8c60b842a64d43ecdf22ea2e7bbd7d3f122d8e78a39d339afe94125fec49cfefa4d759ed0fe7ca104fd58fdbf812fa9b0218150c55d0d6e0266b8bf517b858245678dd42409a6ff583c2791c81d7dc6f9d34b7baa9989c3513ef7bbed598047195928bb5941ae2555f18c0da4b28ccfd068337e18abd00130583e633f7000a5586da5ad49c0a381cf84ebc3d3de73b78efd8d6ba8af8c4ddc12d950cabdc485d4dfba82ecbcdf62602cc770776ca0dbc43b024bb1b7bfe13ba81cd49053c63734a9dd7728d33e165555ce899bd4894cef55835b684561ea7e178b4b2b2b539709a8dc2875c9969f67d00f8cce14d3fbc2993c6d9275d94e575bd1bfc20eda9f8e622dc90f676947338e814cefd7f828317a387e25cbea67cf11f41f676e5c19e43239b524d5c2d86e900f3a840d6da6a2b03aa9d32eb0efa340a1b7c5fa508800d546b4cadad23b85a05598603f67e50b50ae5c460ec07c9f07a2a35bb3c2220459ee908d7782c7a963f43bf28878e627b2f5da60fa0e81504d68812558f5e8f5b5c8bcb228624d4e42e571bad5e0890cad3fbe2145bb4fd062a02385a0d1729f8da628471819bd475d9620278619473a98b76941442de9b943d21c742718cf09cba1e749d5982f7532eec22899d736a58cd261d80c9fc923f50f3978090fb4e19c573541502f65c8c0382eca477a24d46b53b4a8f44fa6ab9eca02c6f4310fbdaf22d19aa453660d755fa72596cb530ed90d73012f46211c2bff7084e4cb8633d172c541a07207d31c752e595b4c4c738910a612753ec2c6c35f0d520564fb10c662e7d287726ad099f788be55fa671df5ce450766ed541dc4f8c364e4e5578fb07ee0b3a79ab6a7a22f4c2b5b3dfe8ea53f4482c4419f338fc93e7df0d844ac5414e982260d14772944cd96d0ec4c7b0d7164af0e51c7d8b400fa8538c143e6a10af4d20eebb3f45faea25d3253f34a04eb3525c6747bdbcb60c10d63828389d3644b6b60aa1a9beaa1a40f2bfa25c8c6c6b2107f26af34bce67dd872d7d6b9d9b6500df6812313d423eab05dde2010663f6af2127b0742f76b7606373b825d9eb1f1ff17a97255336c0a3eee011bdd32c58d65687621131a2cb95add333da59800a6a3cdaad356ae8e02b2546dc97eead6980c3e3a59bc4b61ea78989df01957d5d4d35610b9c04599aeddc986a32c49ae641e5c5aecff7f41ac55e51aef6d777061fe185558cc4ef1bdb7bfffbe635bddcbf40c3176ad047d6d373826d6f81f27cb71c3e70cae7ee2b7f891c536a891b29cc3f87a9a43b41dd4b6a850b67e960fa95bd5df60296932931e13fcc9a22b536cabfb591d162016058505d8ce951147b8129360cf4a2af2b4b7c8f31fea8db0668ddc55c3c8829b94be4f6952adc5dacb1d506e0c02fcf241271567fef915c75959168d21230ceff5d0d8e4ccf0e03b70f9940fe283924256bc99c7c45a23466675b603ba3100b3caae61d73842a885cebd5b694c10d4f61c67d8dd0b41e4a9b079dbb6cb50badbfdb27753f8765abbbe0bf44b8f97355c2b319bf7e112bcf4e1b81d6c7847f1dde8d4b94f6000ce5774f8379e46e6ebfb723d4439717237fa97a38cbb9694623382739c2c6d5e2cca04bdc94763ed8a725541","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
