<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8c930fecdd83e233ff0156a84cffec62239344c4dd122a453e26a823c67d0590038789b3a4c586c1b8aa85700c6518a7f7bbcc6df8e444947b4792dc6b8fa224a77b2c8d3dc87e3d3664fc9c0eb10c2fbfe690f7d3029ea8ff4afcb170fe8ff7c7179b0570072ce9c22bb58239d9d17b0f156f8082bf0f2482ce8b11aaa4a2cea05ccbbb9cd95c9c6c1036cecce762173b0a61227db8740615ddd230301f781038657bdb9acd00934956d813cb95c10be2afdf85b32a90c03ce395885e0ef8527a6c952b1d8bfd75a6cee272f3cbde11586b1772e5fd3791022978c32f883c98eedd5603744e3e42d309df5ffbb76c5764b1505e34116b86dbcbdc151c08f2fd264d714492a82f67085ef92bbbfa6e3723d1c6edfee91662c7bfd638ca4b18f0bffd55bde94954606951877fd6b79a5dbe7db7485181c5be648f68dd7b5a4e2776c07450777e3452a83eac928c5dc9ea70f0deaee3465cfc395ce5956c62eb5e9457f23c76dcb65edd1f3afbf8ebc8a3d564283d1252af01ebc4cf4ce374a74015c86c474c121ba14afbc523e595606a6bb2bd43d0138459a4c04d58de9e286555e892960a8f0d4e3ba5313f4f46158cbdc77f314d4cf93c9c13ca6a2d1a2858678b5aa119f17be97bc68dfeffab4cba1de4010cf798226d5c0648bad1f4e5baeefa0cea84f34069d4ff80fc3e83c038738ef436357eb2e06616df928a8977f90776f8e8ba68e1fdc5e821748c4aea90d596abda5a6737b438486bb449984d0a6183fe1b8aaa61e09776ddce62584753b87bde428e73bc1e0d5202b230891b391e7c2246fe3be6f660aa0b22f5b960a670fcffb3bf15209ed5088158772c9d9d3c28ab88c64cd34e0852eb4ae00b34f8e1a4285736aaf9dc3dcb3bf9258a5979aa555ede72862b50246fa3116544dbdd757178b31f8332751d9e3528104a5ecb1b437586ce00c19336bd8b8fffe306207c384403a8bb14ec6d16f44f445874e50d50d2581e4fb7e8afa7f83d3729db3a2b5864d8caa662c38746a7f8fa55c13b9db0003c90835fed193c33575b28ca5803b234a9c5e25ef4f41ebb046544fee462677bff991d4d9777fa2f514b0d1e7165734954c79c188c42c5b0bce10cd94885e2bc5b3e82af0b2a16c51ad2d333319e1927f9171596ebab97561330c49c6f76e0dc6f3064328ea15f1e525e954924c6386eab0c2606af3c813ccb6cc2d336ddca26b097dea093b52233da8d948507dfbbc67c3f58d509b1fe028ceb08f458a13381dcc59815207513c7ed24a26ff30973d2db55d5448b58f20fa146942132c07e27f600c23777818c457944c61b432fbc37572359b5ffacfaade21dcad6d55b31f2dc0d9ee1346af26d675fcdab2fd55e86285ca1694d9e7a49271c2dbbaf7854865219d285b168e6f5e4d1bd8917c6ea3b831d392f36e2cdd85e2b39da97e26f24816024b399b919e5fd19423a027b82c2afb24a78575cd742d775c9149100519c177481b9e4a48086c8c42e71324e1e16d5ffadd33ecb95cb0da9a5b76bc036d1c23f945b73ac81294b9a54663c6c095b46e6200dbadd487a8f847e7ce86398a0024a0c3d6406b8a83998392c262dea0070427a635fff1a6b472456c66efac7255e3214caad4da70d142232ac9d72eb08322fce3b28559071e2a74283fdfa11b3d41c895a1b6c225e27ff42397339e6ea71168a493fcab4c16cb26b3abd36900bdc0f83253364127a3914e22428c223ea2e5ce60b9e9c83cf6e2fac1ef399fba142e384bba4aaffcb2a3d436b7c749511d8db6d777ead098c857cbaea2038251cc044bcf4b69ab6b137448ca3710d2e31cb9a96051ff9a1163f40b160be16a1ab1248b67fc569ccfc2d679a287070e3b154145678b184880790d92704c63f6c8c4b248321e7837af3b6ce8fe81b653cd4a386b8518cd19714d61cb86c2633d60e5298758626a85f93bd581b61bb73947316ca353d4f7b98be474d4ff079e3cb4f5e0849ca82aea716a5a9854fd016d1a5f379a848da52c894ddd9e725d9d8d84060ecea74bd1e7ce5b48de71e7629b75d701dd04b2845e75d9c8e97cfd47f4b7aaedc0fe650be8272fd20d3493729d5b03214fd14d142df253f6461ae0ea9067adf12f7ebd659f89c2bdb7771eab1d9c4f5e9e597e2795300403d528be3399a75842c903a5aa65216852b8a79c6aadb937b5bfa5c9e9b076b7b6a19351842dbea353b15770cbdf2cfb532c5f122bf7c74e3d5adfe341ede905b560a913924bab9015fb62e8e71b7e21faa05a0a7c2fff7da7c25a9e5e9357022a31c2822c88d3ac53d2ebc5e97c18f6b73b1ae2c1d5117ec3fcf527f6e37213bcc3e648ce3ec96517ac770d59fdcb0b12fb359f0f0f8491fc8a9ebec9a9390964818cd302f903ddb101a7ab3cd1e80eccf1720b759d57394b726372cb5a87ccc314b69793c8c44b4aca6b5f68f93e3afbf7867294f173cbb9332db4add70ff471cea16cc17c4b86a61f9281f802bf5ff332a057b95a95bda2d490831f29a9e734c37ee0b13f92873a3bed6708ed83fc0e9dbf7bf9ee6b74adbe2fda65f58849ba0bc4851539ee6c53fc886d2beace887fa81208ca7ab07f26cc6d5cbd8842ef1291fad651206218e094602104c646aff494dfff29bc9c0c9e2fa3156d9b117feec6d599499dcaa6b9eb21a8c4592ef4464a80cc838c3690ac3d2b6f29878a18adc16d4b47c22cc1e6f76c2261f2b2b5a19a72f2fceca19d311fc540080f9acc77e7751db043b42112415245a3611788bc96941fc67b019b810de11746f3e443edded8b34568087ea8c54fad763f4ba97053e986c05d8f90852511f74fcb3246dd6e14e973bde198a9d54544f6de6ca9ea91884d1e2d17ee48467a0aed09b1b24519ffa7d2e4b8b45b05a002c486c4b1f4035ac42cb8ba93fe260f87d8dd4571e379d28d1f76d898c7d74ead1e829087df369ffc36c9c4ac42ed149ebd924dd336d14642d4ba5348f58f715e0d8af3bf7287929d1c6a05a01c9e888b6955da07b3c5633c1ca4159aee86d7910c577ff6b6d2ff19e46720a15e8c2befd61ce47943192e3a6b4481b80fb4ffa3b4bf60e16d1403a3a3c985ccac0e1b7ced96dce95aeeff00f0f64b8f583edd3e3305f1bb19133eff67f03356f8260f98ce74e5ae1d032dcdf80d33e669255bcc288e4a2c78fdad4019d0345af4123b8c100d99f1401766573faa345b4b1c88dde265493ba2bade9b51ec0b851575bc1d48f739466e538be45cb5a90c1c5593dd642e74c964493e90e0d83aabd0d9d093a0af8158fe13106c3047b635543b09a45d52c615dd5ff9ab2ab48b1faaf5f9e5229d776d7524990451c5faa0f29d42fe54d37733a3d5c7ce0a6af32e4b6a53856124854c33e3c12cc67dfe377709d62ddcbfede0da1c80316625ed8bdb97bc9f1bc61415d8e352be08c24b966e58b534a6d2156cf0ab2c92de75f8a0cc9695f17f374d4cc0b95bf0d7f3ced612903cf75274bcf1ccc452c5d2950f9b0353e1a9708b0c7894139c9cb5dd3cbd01a3f45f6cc5eb28d8b6101c6a99e9abe71a706c3f8f266cb9612008219d28416ae97f7ba8409a2c5ea2c093605c4f0c5805a8b746721361c6b27740848dc8c5a05225d401665575086292c13bd09444f8d375a0f90de5301e1c2ca84d3bdf297f833eea4a0e4280f2a1c1c3e6ced23a103f3e60cdbfdf101f9df283d7b7646dac73147404143c247264825d2306beab06e05361b8b2c84f4d5e7021f326b376fb898fa25e975cf4de465f492bad991db9acfdeb2b0c5554ed2adf8914c90e71226dbdde9276f9ac88f4f443a4082334ce7c62a6338bc57635ccfbc0cdfd1fdb22c39eb69a573afc307aacb443e1dd5971e7625c8c238862ef42d0cac0c33ebb856f497405a569c8337205fcda5d33779fa606eed7a07471441b59cf5704c079049e9ab20ea2dc98d30c8311c8753eeddc7724441b9e775c3e9e38736ad12150836816c7115b01f2f4802be6c1e6c85d1a11d26b9fc6855f7015c750d8de184ffc809ab2f4acba74071cafe8e9150917f2ffaca0e14eccd6d2651c2c973b4cd1c5081c1537d447f139509d3a7697eff853f4091f072858b97426b111544fde16028dace4e53c524ab3c860f7b816a260a8cfca68c48bb0fcb66d4ef715774f8f1b466838c5649f09c974c2b48080589f8f194d4da93c58e0cdc38129d0d6ef8b5e3d986957571dd5c2d5ec0d51fededd6f5a0520fefa89b3eb7c58f9b0f995701352de4008a5639559a1e30a1c32244aff31fd738d3ff3e403df7362398d353d61166a615e8bbed4eff5df94dd3bbd0cb03defc1f614b3755c399f65e8cb7fbd0297d6a8cca439fe37696a34d867175e86f70ab4309bc573676549ed3559a346c7c0521621b1ca95f889c3a904bf6fd2b10eac5163ed6ac56c1f18bade5e7c7ed578fcd4ca27dbfed3d951f61338b49357e3dc9f25930e5d965c2368098ad3fc7386dec09bc441aa3ecb09376e2bc1343aa53a3629f0b83034c6ee48ae01e283cd66d1c431c733d39ea6d9e8298bbaddec54c54b7f488914d79c4459c571d1d611822ac7cdad722c7c634dc89ec4e862ba18866f7faf9ba3971357ff1ea6dd7e428364c7d3ee5a3df053f8e0e89d9fefc6c16fdf6ed0257aaacefca56ca7c647bdd8fbfee704479a1e579f70f71bdc985533e495f346d1396bed0a3b8aa6a433e121844a64f5be53ffd8361e6a8389778b031f59267d9c8907c8fcd5f2705c0d7364b0eaee190135fb46b27d37b4b47ac38ec104a93ec5be350e58e343be977217ef4b6022de79ce3c4bf15044efe3fb8677b1af7b7a8be1ebb6b885934fed855dc217ba19b492c1504bae1ecd125931c5fc3e41a88743b3f0c968b4dd577c8b81dc9e21226737331dee5b1289b45f01ca1cfa6cca365e1b1755e8a82e1aa6ef2f17f30bf183db5339d1f0e7de3781478c212dcfd36724b14b7aa374074f03760def7344ddd7f14c98f968a77c50811f03f70f8b356ce89126a5d85fbeaf1378bc0de8723b724ea91970c00a2228d14b5ca6123532bdaf84f70c225419d0e6ee38cece505197a0c4944a152f8ac31b3f95cb2d669bfe7ac6eb31bd9e61390b7aee39840bbf9346a5294dc0e64884ffe909df5213804833e74f4072580fce2f7414b1e42b5038c998cb546a1f566c44e36a7009120c9906db0d15ab4dc1ceca5cfc02a4bef67d10d95c1e00fab72a818e73d9bae2ce9a667e95013dc6de4dd3fbddbbbfa7beb17973edda0b50a50e7e3ef119aa7e19dc9f17030f7c5fb62380cc2fc272bc98d901c6d77506e354e81965b1207fdfcf1def462907b0b2d80d48ed468d70a75ba976f80a8b31c41a54c857e9fec3d05101901b35f3703532c0342437db6ed123d60d3270614e3a9c6ff37d317417ffcc915d1b561a9b8873f10b008a83a1c954a1e98f851bfe337c4716031745ad3689d84c507747529259746b584c35430730abfcd9955ac8e08049a32b1a14f661087f0b1ca80e5d0de47de0735076f60fe5164bb6c82005568cac638a95df83347843387ca36b0a47849b1069fec0026f2f1cb555a5c403b1924440b292dd91109973ef245cfe677bc21d09899fe222c161734af324b69fc00b3a76247f3c8121a64c35b089f845c0b0dc15fa6e3a108183427cbadbf8d94fe24ab68d284cd886321979a10881c1f488d4771ee6cdd8abee243c1019a25181c997d86b4dd0b455037edcd2d8523e702f8be2cc2a521e2ceafbf6984a3380f1a5df149d59ccabe67b8af9a35b5a0bddce481861d511154bc3848924cc0a89797fd58fc51db9114f26983ff84d00daa6f2038eb52055840b0d599e7f668664e213e5733573cd3183c196562bde38821ee1b4140547999f66f0b19c89c3ba072f9853c389fac41974b478f1f0c987eef173d9b16962966702ae9809506bf24e78ad66be9848af49a1c9443ab1f1b9657a7fbf76ca53f63b1675b885b3eecf5b31641ce00f1c67a3f6ffb1478015251ca9b3c7ab35585154ed83602b65378339b458a1913a820de0b2a1cfb0be068f0d8c04204305e65ea57213a45697c462882cbfa542a0074898c573571213ccf51a7c4727bed6c50be3dfa16606f48d94991a8d2ae99f08ad902d1fcb6a7721307ba9f524bc652172e54879c0d02729a656f6eef51709648bc6cf61d67adeee6748c64186f7efe32ed3a141fbec4ddb8faa081fabd43e7cb7afb0c091fe9c0ce94fe905f3227ad6edc21fe85b31663461d13c36d2572fdbceb1b9e9a612af58a2b346456f2776e17743a340d35ba3e13737038b496d47545e0daa57c27c21164d97c5d2bedc2c1386736202dd082fb11a815f1e519d4332489343fb01f8134d511227820948c8355911d039552ff377f7ff607ea4d9d2838842f8faaff7f5fbd11626d07e7df8997e76fcadfd339053bd607ca1697ab1cff80a8d724edeaa22c89bc1019d830585ba9402419606cb9f1729124a1387eb212d6861e71d27f7a7d8797a3d8412ca23fd617b410ad6fe30277848652520c53830d8b8f3a0e567b4f0b2fa97e16ea133b4c7fb7ea501f11d40f25ec830fdf30f7693056830524fc215b25f870fe64bf64a472db07fde298fddc464fe2d5be78b638403e1b1a00cb2b60e69340a579f7fcaa40432181ef437edeeb34184d2e962dc02a7d8e4a853f1a7d2c05f97a8a77d5e27b02c83123f1feea8c5ac409713fe008b3796024eaf7aee8d50904f039f08ec6bd2914a2add0d2e4ea66657a5e5ec2f0aae119034747a4bc01eaf5fe0a8ebc47d24f2c268f0e768c1f19e82b9ea97f15e7cb52e8c74d1e721442e414eed46af04c2a2f6cc8d698ffa1e105ed274e43b59fa1baab97262e8b60eb28947aac764bf8972bf9e061f8f366404ac010b4ef9a206227185ce27e242ea7398942adcfe0c35f2941aa084fa55064db846ab594e39f892d3ff32cc507a0219b6ea7dba4c6fd20eaf4885f638c7f667470bde88995a2277549a48d574def878b38c5eb80515fa878f48a72497469934264137c28ecd4666f322a06f9fd31e06f757f302e9049107e21514d0c3fe7f9435c507078ef189e5230477efc63ca1e1758e6ac345d7b7a9e6b1048199c1e141be97a6f481d29b725495a3dc26e5061aaee37312be764b66347f1391382b38536def5d553a8fab1f7bd0f6c8d5c9620a3d5ddda16917a560bf5ee4b05ca7425d2e8bb0f4b0f12f8c4678bba0039c8d0ddac08c9ac70f2989a2aa03c194d6bf8b0b022e5708e1cb653046e37de3d002a3af3dcfa5a44591e16497c4e5f8820a5a7067c1320678e0c3b6165ee698b870261ce24f7ba8afe7e9f4d7b223c7cfe3f4d092ea352439a465622836192f2c396d45c4ae8da516cae236fb2792f67d5dbad955d6dbc46bb2398d34af4f4e20a772c9685a34733644163c20114bd802a1b3ac1ca76883d48b98e6e7a2171e52931af44529c365a1c8eb1a45e73ac4c6117ef00c8ebbc4fef4df2eb5959437138e7ca295c2ddee4c0599c6c27c8c8426e37937376e72ab784f82d4cc42532750626eddf8ddc1697aaf45b6a44db78313e599801277f50bca9d61878ba5f986d65ba5736fa8fdcf37341a00bab445129f1ffcbebb44300c67ac70fc07784c93466ca9e3f4e52818acd8c5cbc96fe1ec415902bb7099e7c92c0d44c460ec60131a1e39d6e71ab611ffc997e0e7476fdaeea8159d09f77291843b6c211527ed909624ced824aef9d3b0ad415249592f8daf024ade82b63898b05484edd8b0a8024832ffa57e6135f8578dd3565de10e7a022f7e22a6f062867d9d2e17701bfbc2a1586e2f79e767f01c20ec04e5bba6a4c9d74a81a587b1df10b32a0ee10e3f1bf46921bec20fafadd25ee5e4a652cf9de61f0ff613f50c04ba87a5de51917bc3671a4a331fb1c41bb64483e307ab627e52e3687cdc5da0d45210aa5de153413364027089cdd719bdeb2c77372002041f490838e906f0e47936e923afb2cd1ef80a28804c70958806198aa559dcebbd925ab78bd2ec370dec6b3e1492e7ebf6b74a1279aa5c08cb93c851015bf36379b334a5f6fd115ed585bde4b2e24a22ed95033c0005a097bdb2fa6effa83035d911b2046386aeb9ab44db4082e079daae02796d58b92e78fad2fb27574428cdf75e7277f5eb82e78d4c1b9aecd25997bb50bba318d71c7d45821be592ac88d866d9c7c6f0cdea9378710e2f14f3ea4992ae6e20f89277eda81ffd56777712e5b03142293480129b709bede9ed0a364405a5e62d4d79ac66ce61fd84f9be6e4e012b3c729ddb389f5e587849456bf02a18f0759dbe11740f27338e13f0f56ec599d1c019b2e038f56fa926b4fbac02afd2403b72893d035904aef3c1c5b4f593d5b36bc0c25483bda83868a25f711c38143cec18b644f4a4c57961026ab8028bed266f17350f5d6c6705a435179b7e95f256b3642112ad811500ff0c3df9a62e4bfe732131088b2b22702d71651ac7c246ff57f079a0074bbca601121774955fd86f74d5b59d4705718743555adc363247778cc574bc2bf6621c1c295717e055f00197f3436316ac9a3b623db4f32f68493cd446ef41c7806b1398f756daa8e168b0e42d008dd501d4b3608428da370568dd0b539593f83c07a8606b44729742ac7b63e3070ffe1178ed8778f630b273ecbd6a8141970ab97a91173b5bf4425fad4b2e4873efabe8761841332eb132e2808f349effab75713548a71bbb8169baf0e94f5a2c5cf6089b8837ab249b8eba46cf6055ad5ea55391d1e995ef83354cc0a3a5516d9c67ce50837b5df3bcdfbdeacd9c5c812b2417a40d27d6c7b541624606593deb842aa608b6de5fa46533d79239c838b0dbefb880a1a4e4bbcce1ba606352568081321ed68668884925d3a4381fa624d848b04e9c24af679744752dddefb9330599166ecc011ac232fc79e6cf43271f2bb2e9dd6a962d3769b07ed62133cd0f1a9eb1a276ff3440b521b84cc414646002bd87d1bc7237d79ef889bfacfd0c00584f81d68c50522c70a77ba26b465a33f30a2be574d27409f7de7c3ff9f0ad20cd7a06bf7da18c4ee0f09f0e478433cfc5df4d8850fcac0ad50e45efe26b9eb62aa2d390a7aa850fe3450f2f3247f20ba0228525289916cc806ac3d29c65b252f1fa37c57e646fe5f47c03cfaebcadff5d42c2ead6621e223399c4603487eb5c1e15b50e6188869b7835a0a57124d1803a9aa562706e680aaa709a778e06f653e4627594475a73411a5f72604fd3d3035d9d50505a368ed2ecede0e3c4f09594a5430ddf3f0799cf9cef92c2b822de3bdbde0fd988ebf1d0fd86f907798244a6339c1b00dee67d00fcb7e2841c334c1ce6b1fba5f0494ba4eeeb452f24c99829996c39e3eb6b5f89b7dd6228e2375912af7d9f286200ab59c2449bae9941cca79a96ee1bc9c12b64adf7f607b97f0172ad35b1de3f900653db26338225c3e65bc4991977fa98485a03e12b2b40b0da6967c64594e47de0f10b134b9c8086c919f4bfa17a3b124b17b193cae3d6144abe74cc5959824f02005e5e3e7a053c9026c03ea2cc09a5e692d00ea5db9fd7d85aca3b91ce2ff5eb5860fb28336f8ab4bc76486c09c9a5d123b486b0e6321a2325ab83bd0d99bea41ace73bcc5fbb32d12537a3b22f9265b634eb563c964dacc350a5d4c19f8157c513b1032ea5634c1cb1948474eeda0b5aea52cf9943fdaaf790521af1978cbc95c7667050e072ba0f765676f6839831dc42dacdb0147804334111b81c95b0027b8e712949830cb76944aeacf118187a629352fc41a9c57ca504f103d61160e687cfbdbee1c1fe23bcc55620da3d088e885cb11eaec439616ce7964cb8ce3b77aa6341c2885398550402742cd72854a2d89b606aa55366584fc73ed5aef88b6ad139414528d807d8134205e209a01136506220245a5f06c6abe3e1734dba8a3de3ef78eb4cecfead4ef99d9cc49866114ab1a6357c5944c4d53104823b4de211f3085bcc068ae43174b3f225fbe7b4c975b2b09b11d160beaaa574d503b3838e51de0f63c4936efdd18a4a53c0682cb82695a38eec4e7e603f250f0b212a702795c5bf10b89e632eb647444f53f7b3b71a956b86d6872659671a72602dd7230b607985ec406c9a8911975ee2fe808261b804bfd5cbb5ed9bdacb2bff501d7b4a4297105fc01078754e000a056877e890d3fd952d425ab930a7271aa9c1617eed13fa980e737e1834abc0c27188122c69bd03e82fed6e81a5ec1667cd904f2bd30a30521781e77fe27867f03f3b5864a032a645c24b375079c9f2fbd66b7a85f347f3ebed26f2944411c410a60c5d43895dd0628d749401ffb48f2d22871d92e8faf63766212321dc9d5771eaf299db2cbfd366a622ca5aa590901cad058afe2f6fc4ab90de42ef90703493bda35105ffc98f91e3db386387f8c4a9577d0582a94f9761a95196ceb26cb42a02e0efb47e9ece6a859233749ac868248a1ecec9ba96a86c1292659d4c6e0303a882d295fed134905ff08ad8187af8ec34de11f928a0e5d151675c1752a97f303bf68511f8e49016459981a6c01686a5f83c0ef1e97110648c5f8e3d51e5875f2b793238424e98f57376386f6c811a38e479dbc9e792872910971cbcc577bfcdaf5395f21549d30486e96e043af07ad084df2236d23250dbedcf20dd19eac631301a5645a419fcd9adbf1daaec397b72f37d032ec78ff3daa7c910ee68518446e567512bf3104536d07515df3f06e1d8a95cd4df89d0fc2763ddcf05c9fc6edcf01f753dd6d36b23909931ffd68422aa4288125c7e713dbfb7bdf2390657fba2a1e0b96333b4b08165bf29ca74d7af80418c8b0efbff08af0584a5016bf19391dcd815595756a2e5ad33f2f3346635031c5550c5cd34f75cef738b9552e40a1561ce7943589f25649a67534e4f444109d1fce4f39369105952d8f15d848dcf5bbff40383b05c1683b1a4e99eb664afc9cd28d56a289a855eace14760d4e0348c4fc94394c74ab1171922a5b094c34d7494a9f298f83ec2b5e7129643ba74c2f99b206029528e817ea06ef821037c942259c8de6f238bf3b9f8e782bbcbb0efe53b85f217fb89057ac37c4b9b665e010c22c4b5eb7a803cefcaefa5fcb02159f30923d9308cd9c92103661949242089ec5e17930017030c310872d02a9fb624152bcbce263fdae6b9cf5a1521b94495d14bf8b045ff3d4e28d3e8be6adeab5237b7a35255b4f968e994573999d9bc1c3980c6c636b05ed3309f1d251cb940912cf113353915e70883cae6d3b7c393e0e817fa6b75c481a9016d9c68efeaea9864aba0f2be9b1c707c3a915611c389cdbd6ff5a41362981e78fb2ee538276660d3231200d564575e96069ce0e9b928134c474b5ff0190cf2c65aa1ae17ab06253f0765c9921324088c7a0367551f0a284ee7104479deb35f9353af76efdf00f995edecb78c02da5492c04cb0969496d8ce9043883a651c6dec02bac933df95591c419a3b1c81ed5ac1d537199a8e1a08760f32fe6c2c180876df9f5a3cecb3f7f63fb8936a38e5f2ce328b09e801fedfc9b185223be56fbe77bc7ff90385b177fb8f477eebe6d9932b8495effa622b3c56abfe5cdd383bc1515a4324468dded419bac02aa923cc104f370bba812e76c83d3f3a954302a19c232e4016a9abfbbbe31522b16c4a7024e1158ca75508396d980672cb9040d996535f7f540e0bc4a8cbc8147c565f2fb2a4b7adf99fc3e4564be21c36e828dfbaefecd7b01f34084c2eabcc1c1de7719a26f0959bf6fd9837364eae6576b28e60211e70f607278003930bf2487698837cf93ec2625ac859bfb2e74aca55e256ca65da3225d0f55220d8e66ec58b0cefe4639603b4244267da9027b6cd3f181f579e5cac1306e4469fc3fe8121314ce4b73328b926e3f0dd49f5141b6a71bed4cbda6abe16185a0903b055ad548924420ecec5e3d1aa068328374351bfd47d0e1300592ce38cc614ec58cdc506bd5239b10747177b0f9d74498e62de35576cdc57270dd275fb9b1097df7cc9be0f7637c920bdce57ba185745bdc5c2b8a7c28605d760e2bcf783d570324433978a1c1d91eefc438e8723bff6e52b60b1c7e30bd4f68dbf5568fcb65ac3d84ef9f18318e9580f89497eecf8bbf6544a4d83c77dbb00389a33cf76f50575fa2e110ebcc032149ba7dc2e567083cb6d33260e2032df63954256226721cd474c64820bd0234a725c00b68a0f488c012f6ea64de75dabd38549da740967f9f704171d2d1c4912abd309434e779a25f0992bebbd3ab1fb04a15d7bf8853b6f0f1941261fa4f57252077e8523b41ca4306ea0c9f577562b115af5b365408e0e09f1ee9974edd08adf8f8de4b5811984ed5a5da93181c01c0fcceb2f9f324905dae7dca1739564f16fd8956211ad2b5fcaeb16acce226d37d1786a2b8fdae3ec3d7f7429432d2be42abac8b48c519d54731b3e66104cfc9d17223554ecbb62957f57d4fa5803fc0d6787282864e1a13bc76a567c2b6c370d91ba1d4127d4393f3f465642ed9f92341bc4e4b57089e2d60c22b6fbb8c0da283aa48bc990b08e6fa981a964da8db293b5bf5d59ebaf943ab47b78169c25728bf164dd3217e231c23844946fb21fa3b774effc4a0ddea0832eecd8a0c9ab8a9c0a2f9b88a20f5582d85e467be731a2dd34ac3d72eb78391ffdfce71b893f36e99b7e3368b563ae79b1dbb072d4c74665fb744d75a690c24a2be3ad6c57c7ee0037e6b4fe64e798b0e1638f82a45e47535bb0c5807b8e1eec359d1602c0139d21be3ebe295966caeb6a8d7a0b73d61e08d47bec1f236cd6cf65c656f838563a56b9c41fac0d5432150bfde7bb6a1ffd8b76777102e28a02c6e7a610e0335508e56385912413013ac14b0f2369d60a632a607dceb02c1320596f62764f0dd55787944f130670f66d43a830974d683aee8c77822175e1a7a9170d0690f8700cc2d5ad0943f0e27dd6eaf144b427fb298357d5eb50d9374b2f3e527147fd19c35af2a8d0a46aa747dba5d88ba605d7c1cca8243c5fe96c82d29104d103dd461e51b194f43942e3ad0fbbe2004fba8cd6061965a1e05e8d11ee874f267c822dd8f43876da40bee986be5c98a709293638b7c8a73a69249425544363183229abefe7132d6361a01c2f45c9ff873515bb5ac354620aa7e1ddfa930b0e954295dec9ad35860fea25ea5aba4011c07931a80ecf64ffd47ff43753f5a952b9d03512e75a7e313f5ca11e227b2543ed16ebca7bda37109952a83b28f928a4faa142c230299c7e8d458ba64fa93c97694e51832ffcfef4933f7ad7414a13f14beefedfec69c73c212be1ad16f02d21f4b95e7c87d4a0473ebeb02e221b0394708fa0ba4ef24c67135a4d356c505d21e1e2f4516e86c5b87e72d9222b65298038152c149280cd95e0aa6725199efa910927496f4fc713e7aa1f1815db140d41306bd8ce88207e5169fccfdc7eb282a91c3c9bc7f6a1463811de5e054f3b920804f0ce7f9b6277a026e137fa4c864a6fa01ffa89ebcd8668e7de0eb74a448cdc26ae45c1e097cd176ccfd8b758f89","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
