<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d31d7eb5cfdc8bbb8614c063de7001ae513b9dc55260449cc9c36d5a9bd01d06d66306679e937dfc2186cf99cd50bda550f6a957ae269c46d02d144c56c4515b8f3958bcb29ac853135681912280d52dbda2b3f6446c4f83fe8324f696be2a3aa9041b955ae59aad8027842a0cdf24a06c99e1e2008fa5894265deea73dfe498060f124a77e387c739587a2bbe11dbc0759adfc0fefefc8a97792327062d36bb003d107c4482ed72c63c5bc2e1294047e82bf5d606955b616845af19d00751e584bf125c9600c0a4e6be6deeb0281254bbf9d64383a99e2794b7ce08e6f93441a6423eae5f2fd7d509f1a8b0b047b99c5e7826978c364cc6f722df8ca5aa14aa2073f7b0252be6b8fd47fe0f172df41d5b91ad386660fb22ec11a12edb720555c102b3e75546305973c8ece10603a829a96ca4a8c16a1cbe605a20bdcf649ddd2cdd098435db34b8cfa1dcf25412aab25d6ebf2e2eadac281cbf706cd979a1bb5af906250a5d4fef8475d65726955fd3563719343775733b64873ee698a85bf34e14d382c7aa13aefff49dee3f8a94efdd7e2183901cf15ed279cb17ff7fe9068ee52dfd3b31951d48c9d0b8d9f0a072b838cd78723800f1a760c84dd79963f2227a922df364e3f76133855cd66c2c8fc82e0f3bb605aa3208dc135d61e3be59d98efa886f98f78d74da5e94bff0d8e9d4635494bbe5ca80c0d5c658c536f59ae4d0aa9aab218557b26a72a749f779d96b8de4ba36ed7b634bd9e6eef8f10be25ee5ba3a749bd2a2866add830470fd0d93dac0f2586afb25bd33712844d14d4e10b3a17e90d630e901acd254846ccfc0d9fc031cf072dd5387bacaa99c5ec2e50455930507aabe9cd96303707a4eeef1ba64175ee30cd6f7fe9ff4d1139df8c253da27d55b418dcfc9ac6965f3473b5fd82921bb4511e8013f05b3377ffc1529b3a3e9a000997275a6a8ba44b25192e7e6f86a9de1c98e0373768f95312f4f3e490f6168eef2665910a8f1c53d4b23adbc6241f263d6d9459e4c799485018bf8049bb0ef36d32a0b89dbb89d058a61874ef9bc6939d9602453569014c57b354c2a285b8b2ee24cb5935e257927aa2d20925a08c62d0f0640c68734b6ef2510bbc73c0c663212b4b4228284ae3ff7fd2ca11b0ae481c07c0d0af560eb576b00558e60c7c7187eb1e6a6d0bed05d9b9e2b59274041ce6248c2082425d8a60133f475cada6275425c316270e4186d2ce48ec49e99cce7cd9cd10b9f4d8249ecc9b6a92f3b2432e0b34def0c689f285beea3ae803f15ed69a568fd0a6e59e75cef2c0ef21864c281d0a7a76260b927484c22f4bb07bb08604990f72317781df06e009875264fa5d3484cf3782edf6f53fe6cef56c17f386edfcf00b0e83413172217f31f1e094a2ea468f09a8fbcc33fc7920ca5871d69b6bd32888da845d6ee333163131be3d3d538133f7aa94859d17ae0bfa3394262b3e060311a4f7f6e49d1c6eb9fe5de2977aff6c4578c46fe03b2ffa52c74fb16897c14a4b703539032d50607a9e9c269c9532730ac67700f0cff723ef0fc768d0c654e8edf8761bc0402b39302b463ad94b2a2ebfe2b493d2150c1305433f68d341e41f57e1d1c8a50c1ab394e957d3199c00d7e2e695c67992828225cbcaef97c78fd6ef569a8c53da56a8bc9e127e0011988b7418ae0cb1d63b6e375ac751b0c8c923c61bec20bd83fd86bc3cee3906be34e5ecaad1d801e8352c291121e5871e1c8936424032dddee88d999989ebdf5f20180ed434b79751249c3ff42c38a82b62af6173dac061a726ee818cfc8dcd52f87ec00ca2e4381221b6b9798114225c200762d7d87ee4deced515c361600737ed528448eacf20fd1de1d1ccf023e317f73e52ca7b8ee825cdfb11aa683caeddc2917da581cbb59808b358e5e72514ae872c0a87035270cedb731f35e9d75dd14ff77d722aff3110eb095709a8c07c1d45541ab7f39433f0a597fdba786b83dde34bbb39f4eb72527c8fce6719e60936f33c804e0532a80f1a45de3b4d8cd3976a272447944d6b9e8ef52509f23f986ef04f86c652b523aa0b0690cb20d898ae25f42b5af35ac626b7f79d091f0aed6cf11be47cb72418f0b00633f53619089ac28de3394c280abb5e5b74025d30e3452b16084d89488855ec7a82d50c6f05edffe18f8692ad6e91d9137fe1bc3ac8b76099a3711f2d3210b005a0fc2b04bd53ca3529556185ad9448963ad40c6a97f5c8d73d4c2722734fa63ca038ae2fa31278b2ec571703fa22268a4c98d04544c64c9922e6959a957f4c71c04cdd8c524c99cf89f72ffc00d62637938915c425b671782446a8fa70df138b3a8a85c58b65ee39c14a88a54e4525ac7f2f779783e2908eee0e3e926839fbf67e7145ae70ec258b71b9413b78d8a2103f7cdb7f51a2695bd424fe9fdee7d0cd49dc9e6f1e6aae57ff4dfd8d5323677d2dd382ab7faba356a5f369999e3cdce57ebfa1951bdb2b76bc34bc9687d8264dc90a4852a3021b408fd31a1ff53068cd289aa92da082191d855f94b15765d47d88b36839708a07ecf1efe8781eff5e101c865363a6b4ef7acf2fc08db16508c6b2f3149a859019e6fcbea9e8b3de0a4296888c482dff2b1d41cf71dc8c2ec5ed21c06a8f706aa8c6ef69fcd9a4ac63a9627fcffb7a7f29ff6d97bf40767909040c4ce075e8b76924d696e995e5e44c9953dd4e02ee4e82a710c567b54a78221e1c46e55175e08033a3c9f0df6485d8332a6bc9563ea90e6896faac0086a317f1ca8581031aa86be5ef616c61e6311bb9b61c81a8ac59d1a56fa70410303a0b9f430da4953b506921138b0012dcc2c4c371ccc25589efbef14484f2b2c8a8c1590cd5c0f0f1e67b2562d5807fa0811a4db25bbc4e8912b666971249b186f7c4b0416eed85bebc64287366717c0d04b0518dd658a5cffdf9d26187254fdc302da484f8b618005a8bdc41d0aa4e69847eeff85d8b39017d47979f4818ebc4850c62c9ccfedc3716281d6517f148adc50c99ac69c6be44833a509614982ddfcd8b0ce252b42ef9241f265d92d5541ea0f6cccb987b22d472b703c8715e680834842ea291004363cd3685782772985078b8be7daaf19dd90122657e287d7afb5f0e480f536b74d780e858b312b9804466a541db4e13a758914bf840699caf35fab9d6992e09dfc554c2b5b5794af5f054eb2014857ea5c626840d6e4bd91625787ed5c8f8ba949af4b468e2ae5b7b01a04b90fd1b4dce31b42ac3622356c6abe8ad091e9c2cae45f2ed9bed0523dba4310a9d84ef3b6efdcfd9a74d0b8c91cfb29318f2c5977d8f6329625fc9c893e6e97121f49fdd2c34c11ac71318bfc94ad7406fe751dcbbdf9b663516b097b404c6737bf061c34cb5aa9ff419139565000889f11354dd6adb64d8aefa830898ea85f73ab26c76ac0e84af81b03e45caf3170bf2599168035fbac4febd29439a57917000259b3b175b39490367ed7f8f9b01e9826acf14817fad21e11ec2003298fca9a0b4f65ebd3ad86d30b2e06bef170d711b22c25dacd7b70815e8151830cd48ab9742858061f202ab1deb6fc04485cb8f120500da7d9910095479e0e828712a8affa1083b2afbeee57dbf035fb05ea52425f70fb99c9684155f15e1fcfc73996db5d9990ea9013c0b0bd074f29cb0eaf4d0ed318c473d8c473ffb35f22e299a62fc895f9c92ea717f821fe4f9b06ef9652ba221857d86c8813c84f1c36dc8051c5a31ad16989573b9dc592ef0d631811e613fe9c16bcdb29623f4c18f57c06546882ae5440dd2cb1256bdf9c8fdcb1f916c5c602375cfb64d659a7db1818890c5ee556d3d5d17b40cfabe99db8d7ef5f5d4b42a30ce49319bd572e01ba02b2a90310e5f2b32d6d8d1e0ba93730400a15432135aa8b45e7482f763dc874eacb33b988e9addaf55a2c7cf76e4a04bc78ded2a84d66f75abb1dd6ece03840e9ce66327ceaa94c460b7e6a800d33de2a5ecddc1932d06627d3c0d25edbe19fb3bf90b7ebe27d980f6a318c6cf4faa897843ecb6aba9ae0db5e94186656395a20249d8d47c65b5fe20bf0882f06013aedf826c36eeeb948127da0971a5455d75629f3da92d92ad3a20cddcd262d3d926000f7a0ffb960a1c4b885f167803a98005e09facfa38fcaf65fc403923924de281aa99e7313d7282a2ab419df404a5e9db850beee29b5353dd4cd6dba4bb0ccc8c5e7fbdc4e62416f5745176b123649b68deaec8b01014867797cd6a6baf41661d3e3598f6b9991d8bc5efc9d4f79e46cb0940924fab7906321ecb5b4f833981c74f8349e2c91370cce1fd81f859307abe942fce8d29dbe25cf305e12d7b199f1d1fc43b8526eab374bf51684bc23c60585d66bcfc0fd5e1a94f6885e40b0129eaf730042b3afb8bd09145a0e4280bd672f24420c34d5b9f4eb6dfa0bd718e49edeff2073ad2a26739abcfc5a96b67cc915b8c96e325fbaae75c7420c354db132d02d572189d77c2ffa59ad37f7996a6dad811441450461a1614533da1c549f4d7d437b31922a2a091aa5b780b804515c522338b3ac607a93ae0f6ebde8645518f0c957e4406108ee3422c6213db5015f780f187bd9d6dc30271eaaf930bbe4508dd9def3f0dded0bdab7814d0a0d19dbdff4b48813939a5b7feca9c2b09ca1c0785dbc0bb09bdce49434dc88741063df079ddabe4dd8f0197158dee75619b0c802f5313367fcb7552772b2fcd68a58ecf9cfba5b195d0db83ff125a6702442769638a9d3cde11005f5e8bd9248bc4252ba4d0de2b22874bba07e5a07c7b552602c7d845f50642a8a8c041911296937fb1ddbcca85647a3b2b11a304ba729325fd46629356f9153e9ca5cd8cbd0fb9d19cd71f9b742dd2310104138fc7b916257cc6ecdfe65ef12dd08f9c62e3aa40b5f6cb011bc64186748e224aa878d9b7b386cbd30930a1ec054147bd697ac8896b5e134e45ab7cfcfb15c4d09d703bb9f8a5279a531e63ccdbdfdf780e02accace3799326dbdc51845b6a3e249011d0e59a23ee228a655a6e19929e81ad57415c78eb14feff33cc18aedb392c907254d58ae3970f0185be967f2ae3e728633cf127f42e909fe1157cce0f769f11a047233287676a20bb194170608e208e61946a43d18de2e0587412f8a292468ac9dfe19b36679715ba5456516ec646d3ed986e658f293e9e598cdf6b7fbaa0026a426c221ca1ab3166635f24493225bd4d4e99d38f5323e616448e508f9de12332d63232e33477cbf1b24aef0cf62a3c22827d1137313f52c189aede0adb9a4448ec2ee5506c068f4094c5a9dddf88cfa27f6550bc7f2010331f181827facf1ae3d4e635613f32eed00717e5dda333008b3cd8728c7329e7b22618cf33aa332ce2a37b79c7168dc6bd43ffd56b8fa5b876fe2f6fb4de66a679d1d9e6014066218ec7df47527f6048a68bd8fec65a21c4e457e6f2a9650255940738b988ec787a0396e3ed4950bb02d973f1074e055ac721065429c3213c3902410d47ab64f3940a4311dfd4c81ab144e526e20fab6029c6794e481dad1afbd9bd33d44f745cf37831606e8956b743d2e6304e021a15e8a95cddb791a5a20c792a94ceaf6a9f9e7cb269207519bcd0f9a6e0d9446eb168b6947d2501ddf7c2fdeb1353290fbfef6c08ad1722e319c6d0d64a8c45dd1a22fe7a3b11d377850d7d2c886a01081d79eb5402b6d3ae4d75553dbb5d0095c2d189fee8d6ed3aa18945179d9382ac6f5d18baa4715297c89e90aaeadfca42ce11687a0693685686d632c51610621abb78c4f78b7b34d64da9bebe119339b67e41ae8bc4aadc6a519faafb24635f845771434f50b1560bf6b9b51fb73e8eb32f54b8c363d5972445a20b50c09dbf5fdcd89a6ccf15011aadf88dac2fba346bbf8f52a4ac093812f89fc13abb61a37bd318cc12988374fd74ac086c729fd6e817a0b034b1b11a486902d6c0706414fa9c6c1c567f6306e6fdb23d8ccde6bf6dd13d580d515cd0d73c20c6f3bd1a951fc05772e048479bc84411c18fef345d205efff758f739e7c67294312a1b560228f9aa93e8bf4a2fdce3ebb4d729098e61927a8146f0b6faaac5bb1de1d88428795655b2d708cc596788180fc352578d659939f480d50608edf892e0584c134c0f1656384f00c985bf2c8ae4e8288c87a42de007423f723b708e2b36ed53dd583e78bef6537c5945f49610c5052f3c57eb70d5e176cb9225c051259dfdcdefe53f1793f031145d4b2eab056c4070f0b583d95ce5cd7d537fae3507b95eb8506b516cc6e1278b1e6dbe848071a05a892694b4d6a93701aa52179fb496f4b1693053263ab3239a96d3ebc2391eb40b7d3e743406cc54d496401de317fdad25c6f1e7fd09523a87be12f2b0af40c29fa3ca5a53a94e91b57d2600e4126e5a0706a602e799078132dcbb90cc2cab7a84bd1ed818310f688a66fbd3017996c9ae94108095fb3595cfb96de1bd8a17a15f72e89c48c9872384cad324ab5d2c37a01ddf0d2448c70d74f1cfae9199a0bf7195a5f13376643d607ba57ec359964320de5ee046b61b8997f3d7f28fcf9aa7bd96cb1fe675f0e52ece27559c42a4250fd8f701d380276f244d293f058396cea3b58af885969f79d7cfc49d8f90cafba6923bc2d48ffba09c96f0cce537fc2f198eff4d8533de40fe0c593e5d34eca6280c78bbd4f96e234d6d1fc4197471ecd7ef687fae7bb6c3d8e731d569eb5a50a7f6d9e1f796a4c618755bee5f6e3e9923d36ae892740bbe4a828189b351104e54fbfacbfffabbfdd8840ac98877b9ad79de238ffe25355572740fad4a1fa7158cb260534cc9b4ea50a6eef6efd7065f58dc078b101fd2152dd13568325800a298b2f958d3030f6f8ee74a8e3b0520c0aba764eb00a6f03a4d9a0f4aaa50f8d564e0c05f02473971730304f824556a7d0b2c906719b4c34aaa4ed5029bfd348cc9d4ac16844d7dbcd8708885b765d64b23f8fe891b2d0cbcefa4fbd644d37978af5147aba628f50a4beff76129eac1ddb7904be585efc11abea94437764c412028f0f32d8ba999f32b0daa68625a9716bbba75357c5773c274bb80ad7ddf5a72225452dfe113b604214a8af3000ad0315adbc84dc149695bd0d21b2fed8f806c43449da32d2947e6a0cf0c3da0b99546449ed88e8faa3aa782677c44ccc931af12f8e45e92b90a27ff34e716f4034e87dffe4cf8518e1c0326b96dac20ed617b7710854767d9028e521192214ca8c7d13ce4a8bfe3d3daa90f9c7bbd8a8ff934d4e4b0f2b80ba6e00ae31b9e9a8c2db6b80e66ea9c6078271a2349a21c7dea5e7716252049e55efcbe838b1e39c71e127153362763822bccf81380ba66ea8273bc8a38be861db2c15afe2045ee307634a033a4341eb3871dc59a3c4e337d46c6b1252454db2d9ef20cc23ea9fde4118ac5790fc99c655b54cd5153011380738b566f5a880fa6b8836b0bbe24b9f52dac83f9a61eb929bf6457f1dd5c5bb700f6cda1492fc56a00d75a200f2380a605f5b0767f7c07ada9fa44abaeecd998d985c0606a7cb120c0a6db2084d93c92a57d2d253048cb82af208f5dcd9d545728c6edc6411d85345f5932dd73aafa5bcefe121b2d59a4c98c1887f2f4859db644a9a81a85ff7b209d334e544e3af4442ed8ba19567054c382d2996bdd15df423a795fb41ba2af771c90c3deb41a1d341aff9730a761bfb083dcb150946a25921335500642dfdc68518f3fce71503484dad99c9a51dc31cbf766f78d746c10ca027580cb0990ac795f4ecb65637782cd4907f2571962a36cbc8901e549284f318b6dbdbc1bb1703557ab0459193dfa731e4edf9bba1ba14904704727e975a35ad091c271e7e6a4581ba64487c35d02ffa6e25a1c7c3e2c65f41f863fb7ede512e7979940a8a7718feca4b7d8f2923bedc97977f629b0e15ae3ab6420aa46e7f5ea8c9ed84bd3f56cf1d8ca44ef3475ed5b78dd5851546895215cbc7c5b3f96436aff388958e3a5470ff4a41d295df64c01ddc84602f942a8fa0e8939cd0cd48cbbd293763d593b95a1d12ac30022d6ffddd280f08645aca2a0f2d76aceee2e62200c76a927b24d2b8ba64754087cf1bca8260e8fb5035a5392627fa0fe7d31a149bfa7a612267474bad262046c52bae1ff94827a1194736171c33ac065c8cbd424033b2cfe948b81413d03f9e2243b55b2e5e0c4203ec32e6acf699b07231dbe6bde2d79f62921420abd0ffd8e232e303918e5672b0889edde5827e08cccfaecee5f6c511f788b388ccccabc963ce9279d4ff708f7e766602e15f0f3dee1ffb3cc9ffb8ced89f4529bc21512fc9b4af2d11566c2462baecbab76072f04e60f966f9672066379c1d3698ee7554029e71eb8fad6bf073e1098d313c25866de7523b3a009192ca5649d6db8e5ef2baf49d3bd6bb54269bab7753714dbdce0eb8adfcd4ca30fe78958512f9beb09c3b9946c63248d8f84808c9c5afba5f032deb7a5b72012d73ad551a7582f2c5b59d7938da93dea13cc6bdfada10c214b6a01bc8d30a73d53952a9ea1780e960291f29dbb892bbeed6f83f1f16bee46439ec755805a3d707eb6f1b3df291b4e49c29fc762cac8a2fe2412eed2fbb519389370eafa9b31f40e791c3f3c7a146df22bbcd4610999b5ebf4111d1f14f660698f5188df9f3b4e4f3a6d6bb39d01a3777f8ff1d7894eb9d482ae6d2253ca2a8303a46728bedbca1c7d254a3bc566e8966d7a9ebd40bc7819d8dc4f0281c7ca194b3900f60991c2c3415c78107bd76d902639ecb549de9b915d95f55eaf1a1a1d201a106579bcdc9bf6d00dff6b6d74a9b5810cb90c02a9cb156821bfbf85fb3b8fd79e5fb0e342e7e206e6e9680f9d8715705ad856e424811882b7a61025102fa995dba37024890ebef03651fcb3282354f48cdb3ee9c3ca8c9aabbde6d6480f0b53b143a1c906dfd9c742f4fb62151eedb8b9b47f1216095ccbd5a48d1cfc8008e20a709886a1e7ff60d1a51839de0538500c616274c15e98ee7ed1983e4007ec5a30df9c3c916d57007cddf20e1d1f651607939640a364fbe9d3a3ddec0f381df685d6486e62e96f105c87fb1a78c216ca79eeb8b3cb790b6e1adfa2e8a5f9d5b72e44b7c6c85a07ac5d633a2ad74e2de15d0213fba2c98cc40c365bb9ca16499deb7b4e1497511589e1500f27431be2a253d7f934bd56b32715c78588ab304b8805f936166816883408d43f1df1cbfb5f9b7d1db74f26c2040f289fae716e7500eaaa710ba22c371af9eb4b589dba99ed42715748bb760ceff9cbdf6a403e99ab8c03ce81d58336069d6b2223e065024ac8eb66fcf979842b3095490f718cb26ae2ff8719a29b4d14ee5d462109305ccd251cdccfcd74e628b94190a4746f90880422f790dc2a5efc85bfa4614d2ab79a222f3d4ead649ce93cd8b7c27bda333b62b92897540fe345ab699c69940344e835f2c3344cc8672a891fbf37f802574eea5176cdcd148073027e517a50a4290b8df3368d382d67ff0bd3edbb1b523463fe3604365fed9e9e20831f661489e6eaa55a6ddab133faa211b1c56d5b6ffbcc79b08cc17e94d89728a592d742f39461de393759f94fdb3fa3f7096498ecb3f8f8f483d868ea9adfc5c3737f8377988291f5aff7be64844f260dfcf11054a3316d3d4ae8a60ed8b64d1bffc587966fd1ac9659e5a00fbd71ecbc364f89b7e2b0ec9fe0fc7276ca8681fd0d5c83d0508bbe51eb6c4fdcef40c70cde1a60d14b188ca601576a45bc199e7a38554f2d4418ad36dcc5f25ad022a1590f0539bf804841c746eda275ba302616b12a7c53dcfd7c9178055a1e7dfc9d32c5fa19cf2fbd118ea49acb5e7397eec4342abbbfa9553df21e59f4d7717e0010d30234aff16a06dc907d8d23154d449a2603932da32f9a441b82cf2b73d5d35ae7881c02da3035097d548765c007f7950a69668cd9d9e65e3d036e88f762e06f6e09a217847a478fcbc1fb3049f759a4af15dec5542fb41e1ce5958a4898af8ec3843ae882dca7c78b071cde0d6020881bf04d7f1f0604e41eb2840f02c94e79d1928fbde6160ce08c2783f816af3f87c1d27c576612007d9666bbfe8011eaf4985c3344f3f21fd76d3909c9c40471706490bbe2fb9a454fd7e7b950f58824e902e20ca8d381ea155924d4b6644673f19416597958646f1112cac8c2d7dd8964cc3a09fdb3ef698636eef26c37fa51c69739fe52ef736dde74d7adb71546edc9076371d93ae9c570d273695f797f9b1bdd0063d13881e9ee18f96c8312edde3e4257ec31a2cba513657a06404af4a7c87650bb409f545603e3836634157e543d61c43f338068a90d843c8ad9bfc59ae95b71e1c8a7f3bca173540446796a681e65fb0dc0184c053740df4a515e7affdd52824aae02fc957e2197274403e77781b6a0e5a66a7e4a3cb24e619622105b3cfc7672f52c3f4a92c5a933d79eab825628488969c805617e0a4529d60987354ff44b933303907aa62d937dc5bfc892e6ac830c7b8b091a611c99604a4ce36212c6f6a81582431af1d07aa3f9b3c2916346c41522e010cf79bac9a6c359bb79532bc0bc72b21f999265edb8296c0ac3d78a1c37cad64c98b0eaa0db7c7477d86affd0eb7a1997db7cce97258037729f1891ed3c6baedcaeef8211496330c7e2917b2ad66222045c06d8e22409c7db88a23f2bd8bb73a1213d980beabd6095ece0fd505ddabd5303c3149755bd7df18a87ced1cc4e223fc89733a2b78dd87135bee7881e20537a18e41525ec6572ee6ba801a2bd826edd42049357782c2d36d51bd8551e1227b02a2677395d638540db3431eb4a51865f1a694dff926284fb59b231a4a303900db4adfd33c46750afddd8dca141a9e349052e2f6a7a1524ca0e05756a5adaeb01965ce78f18ff80e47a6b5820321f1140536bc39abd78d956f7e4323ff6e7ed29fd5587937b3f96187397a5bb2334ade37d0255863e07e29eea70feeb177c3dec502b12f11dde874f2ce3fd2b9b0d362088c2b17c0e00b4757137e4fdf62365b288eb7d9100d69fbd813b46a972e391e51a7d91ae93a9691d31f66d30dfad6d5f7a2df75f43d1b6bf64b2035f877aec5cefcf03eec3498bc05810632d2d14aa6d77294548d29bdf7a8cf1636dbcbfa410453f585a015c7530a1173b09cb193645decdd00316212b3045f7999cd8fce0c66d195ae6c20990f7146251ad45769fa71fba64d1e895e053bd496c1e9a797c95ffe5fcafe3ba90a3489fafcc06692d032a2179cbb611ab14d11792ec2fb90c229e3074efc07c3cb62dd64c8dcac9713b1c7a7541d0bfb51fe895225119ea1ad7e6ee2bcd6363c84d02f46b189837106f4b21e63ba9860d886eb2a109aeb7a9abb73f66c2aeee66eb80bfab10ece54ad7ca499270e80e51671dffacfa078b433e48c919732c20263519c3be2b5213d942c28f6e1a6a841fe7eb8f486984606b022e671dddc70f057bd4b7cb4bc737414e977289452656bed89d19a3822b80eeed0bcfdcdd3b4206d4c77d7529c2d48a1d92575117b94ca06d421ff3bc342b81c3e0d380712cc105f829ac7df7931a070cc2de57f4430421654be67f26383b3569467946df872a5804ab3eb8a2df1b4e26aebb23609be6dc509bf8a26f3f7be0f04243af29b9ff607a79bfaf2fef0a694e1684182c4dd8dc632623f6e48eab6bc3703edca244c7822a0684a71ea1c83ee6493a8213babdf8d974ce68f62ea291a7cdc1b771c43f6639bb0d35644c14a7ef1b7c4e7288c136ffecfa01d9dff7e33f7a56ffbbcb3c60a4c07349d8ccfd2f8cde1433a13d954e8da4c75b02904f7662b144d1e1128c0ea169f3d0d1c40ee8619c065fde20d5cd89ff72c924711dc477bfacbaf18c02978a9ebb03cbb9d43252380f62735cb89b854ee315931b5a942f2f292ad8b7e511298ec34bd768d361f9e0b0d243fc6ae6c220bb37b5282460f446bf98f6eda1225d0422db02e2ba0cf30f830b762f53e4f7a62dc48af883f97e67647f56a62d9406f5da9d2c440dfe9bed8755d59b9e3d11a8f15f51b10f36d97f80c7747657a87e7e1903abc01c69409ee4253e9fa82bc9851cc50658af6abea7617754b1aa4b38dea4d88099ca05316f0d99917ebb3ade104c2ef5d08681f8d548f30cd3a2f53484cfbb155f4d780265649a3158da178115a4ccf65933b7f0f95e219120b97a0795b42f2597daf4dcfaaf3bdeaea7beec0f1b48560dc61a44a9c3b9b99c34a3eb9a2c4e90236ab615ad6b57f2b9b311dd6fd050688e0ac40ef44e5d01e01bc35f1809235b1fee345939826e9a2dfd0348cff2482173559c7fe2666c9e4446fe1815acb35f3413ef335893d454fd4496c2998b64f34fb3b76212936cae53af218154ffac7baed0fbed9c53f84513e37edb40537968a958164e22e0fae7434be8b435ed729a8b5afe598107b915d07986afe61b8039ef63ef7c3bf9d5a25957d12422afceeefd207e32b68088120c44cd31b69e51421ad25147d3641b8970420693c075af54d11c4220dc673d32c8e059b0434a6a7d7ce7bf08e9276f645b15867347f767fc6db4d04fb30931eeea17b7ea75b8557f939afca81c203501d0194ba5a36ba269322c6f567b4ac4042afe72e7438431b59dbba9ac421f05b4b0b6655912265935dd0e897624093ba6ea83eea0a8860f5ac51a8d1e84faabcf92baa36831f155e861e8d1612c9b005cdac2c188cad4ec990a4a01ab7fe64ceab9723a374d2efd75f638aef0f33d658cb465b9c8f57b399b7f8dd9e01479c471d6e5d5259a0a89f0ed5b0ac084b8fc3a8fb457c217111b93ee35ac20edd3cf82e15773d1b601b1882737eadbb5fa01f45de330a13afdc8e9e02f833fe82c2698d04f33923242c339d2087101b5cb031fe6a1afbe29b7c73b41ceacdab2c58a453ded63090ae00fb26f724da491dc54b7ac89af57bfa8919e7248c274b8fafc61e9abd5f76603ae8ac2cba0ccd44b200e7d0cc907cc1a95226cbc54b761f71256e614ebf572b007395b9ed94abbadff46283e9401526c64722498f550d81f4594ab0733e74764e482952961676dbf46c6cc43c10a484c91618c6a4f53094b3a500ec07e1b2018489602f4ca6626a1e03d714b0b4bddf929bc55d09d9a7e1c7d79ff63be5b82dd41a516692501c51a28df74e3c1785a59e9bfa41bafaa450a0f52a11b20701fbca4469ca35cd5df88eec48855a9159e351d980da47263d9fe1c607179b015bf80eac62aba3c864e03f7581a432b37381940648e1cf0cce69075371f51451718dbbe6b0447e283abccefa2670aef130a62ef292f52faeb4aec97244a77d85131a8eb7fd6e7182e4e5a33709063c9c652911d25a82382a737167b22092f7512139e079918895f06ac80d44f036a374a30ee87c40c7692706190119dc4f8a7934e21a9e759d13cdc8ea9d4b6bf226d26d5720bca512d7862a8d37a612ac6bb80be31dd882bb05fbea262f32b50e3948e9d25e994750399b7e6e184b93213efedf5a9d2d0ae60eb29aea89fe42ab619237be602a89ebdc8777419b23720b310c75daeede3d2ccea75435101bc36517b36d93f9abd8afdff5e769c4e97606489c1e980cc12a8cc8b4179f26cbddd749799b18e27a8766a356b959c500d9265f04ba0f012d346a3fc79ffaddcdffde7f5a831512505b75e8b5af395f718de2f294f3a5cdc497b86431debc3a2f4fa755a282b13b8d552fb45765c00fc71e6f5f450408794e67c3b92ad351c3dae2879bd1b6ac7422ce5e2557cb73b191baca874c322a7cc37188e4d39dadf2ed098916787b5fd132ed7d9c8012809350981e8881976c75d8154e7db9829a4b6cee310eddb7c8c9a1f6a7dbea5bd221c68b39f91716f6f4a7d0bff0105f39d05c042fef3a4d31382376e4edc4e4bab22d3544bb6838ec951674e14925cdb1ce408453b4af4a03d96fcc504cc2d3c1e78963e7efe8d047f8c08a75ba23586d4710bac82bfacda3e6b908243d501300f62239a3b35eee3e08efea37cf691f7821c071de4ca3c568061a296c3660727284820fafa4527956d274cd761cb6f8be20e2ba076d438b9ee1da857a96bd7d865b05b54b131fce6eb4cfea92d4196b8baee905b612c9e86958950151f1ba7641f0bb6a722f53134f17ba3aeaceb11f6df470a532ed9ebdcf7c37a8ceb4dd6a20c8e2326c3865f8075b77a2e199a948b9d84867ba4855c58c67ff63046bfaff73f01694f7ca8eda93e04954cfc8743485a78fe00752843188158c7e61df7a30bcb779b779eebd9939bfbe53545cea8cea8fc7228115fbe1022253c1c2e6a93c0549f78ffd51eb4e90579d307268e9509d8703c34c80d1d7666dc11fb9cd53c02f68bdc37f2d02d52bf3858eacadcab750676be830ead7e81fa6c6a078ce1c0fd7dcb6a7c9a02a637bc4c706fc87f3e245e0cf0e4555ec4a989d8b5375327a927c4aa41b2a5862e14bae882fbe2d8aa0fc8e8268759faf767e248c659f3fab874ed153580a2d1a2de70c3e957d721ca3e73dc529bbc7588373ddd38ddfbda3bd7c0878e5bb7d1e2a0e3a605bd2ab6ef74756380962d6dd1aa709ed35b027ac0338f26d78b623545972a69ada02d7f6f4a664ef2ee5aea00f40b85e25a8e1940f7b47152d1aa3c32067a77b076795e9e35d3827747a2da1d905523ca15846a2ef156970e53634743b8938c60afbb6782491dc5926c73d10b0a3a67e2b5ccdb3858a9b3b22f637fca1364fcf2fe5e1fc2d0e6251585790337f8face5cd7f208ca27ae58086a2270586db621700b24785accf1bc810de917216b03c04b3f5ce9a8523c905092c5ac2c25cd8359b6a7d2f73e59952b0c14d6c16cba62930a3c25c0d87b526b88e53340b382771bbe2fa968aedbf9cce8972cf6efc4a0176988714077b1432ac780a64beeca7106a059b5f1a59d76aaa3ac7880c513fe7fd2ca0e006e1653ac8519a7fb4969d1f91d494eded3bcce891d25a9ab5ef95b18ea6fd7df086ba1fe645ec443d4aea3fee04ed8026591ed2f1b91f7a7a22091c32729b9971f479ba5ce7894b59a61f8c6b10eac6c8fe97feaa1ee921f8eabc94d9546255d08d371a46692c6426371a6c1caa6bfaae46b8381d666fc47328dae812aa3d69b7ed1656bb09e6e0194c93e93d89c7ea4ba9dfcdbbf5708f14ae0732d9e6993d63d4be5f63d88c4f89d278ce83d64b8411a4e4e99151b54add55e35808f8f18c14cd7ed8edd9d4059a8211fe62e2c9ac2c02efc1abe9f8292a9eb2d4fad690fdd2dae279e69e076119db4716260e071d5267f98d4f407b4f9cefd3ebc7c1af0cc18001a4123b135a6b31284f08797fd66e795f1f0d4edce738aaf6a6d0d9963d738a6aa30498a78e83429e3396b46b252dde49d4e02cc88d53bfaea9294d6bdfb93f5de94100ac8bb86e8a97d3889ea729a0116611be48862cb386793a4163669d1132852acb9eacedbbf5a3d9233cad686e9df03474d0c474a4bd77114365a4b4760bb77889cbd49383e231b297435b9dfc9ea9adcd6a22b1a409e0e6db49b0bcb1a4e43fc583898412e28ce86ba000d07f7e65d1c9b99ba05ec8b900326df1c9419b002d12e7bb957f7ba03d943b782841a7bfe6009d4b9af395c04d352de4deb3016a160f69ba2f2ca77e61833253c02262513802bfbb62dab1caedaf8891534143ceeba594f52c3e04345a65d2722e1e6abb8132cfb230dec5a22ebe8548f8548864e9ff6630d01068a85440bd02f1f077923c148791d89ce6ae52a0e8d804e0066fc00d70a56c90dccec5e67811a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
