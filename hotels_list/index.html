<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63a8556c49ba1cb06af08809c51d551cda66d1578176c424c7aa8a0dcdad6f81330024dc076d2e1bedf1984a7835efec8fa84f9b2e5df0e70b058542de71fbd858b8c3dd103ed6e7ee187aa831549cbd06a730012d3b37069efbf0e3b12ccd027ac68ebbb81763976b9e5f6367f6b7206722d7c365410275c302d56044dae2a7b858c27f5a74bb3ff457d5c400c559fa97eb07014014d0406dd6f4a7abb33b75c7fdb4af667d1998b7af1f2f54db1b8f169898fead9e1660e0c7cbbc2d77d93316038ca6b2d41acf6fe1958dfe90c40f8ec530a88254235ce3c84fc6166113b41ac6c18a9d395f4182358e07c93202a97daef3c097923988925edcac4cf4ba73b1934f5538afa7d90aaaaf5940c428ea5d893741b8fae0ba1b78420f10f04bbdec1fdb7bd39d91319879faca55a9c3df24a8774cad8a1061ed1bfae8168f43192b7bb73f925087a2231c014cbf6c15fb1551e2df9715c6966a3195fb4498957487dc22e48f0325207af5673a8526a3bae3825b5ec3d1ba54b298ce7c3f9b43890240f94fff651b89f2e7fcc540ffaaf5634612d0c6d6310cee881b88a23f3da0be6f4e2bd4ce9e666f9dbfa97d41b1dcc4122c30c80a899abcc878aaeeb958c8e73d8a4da8cee5592867c565c67cc8af120d515b052805a43e41e2bdec72cfad6229aa466b695972629155f5fa04d6240544754f6bf6031c07c11423dec7e6c1b4040ced61110533c03e6696d4461535be96ffbb57363a8ddbb88063bce2b398ed5bc15a3c772ccde49be12440c88845deede0a7bdfdc3da5c2d61de72a9068e01a29c6224bda0e34e1293be6a2ca6d0a2abc9be233232ab45b070ded5c1e2c04009f889c33a017afd38c9d952c26acd7233385c645c56b03052c57163380fef5a002e145bc14b4e57ebeccf888f6f452c899e7ac78bb7057378ddff1fcfd8581679a27d7a2676fd72c0e3b00091d713d3ebf42a7421d5b21cd72f0079d2b761e57a1f8cbbe2d9d1825244802d0ee0d5d856f6032ca499ffcaf9640cebcd3aa7164fbe76dd3b2015466e362127c88bad5f1a4a904e7e4bb1acd20e07c4dc1a33c69d93954218e34678e211025dd0cd5f9dc7e5ee8b372df8fb2380d1201c584aa04d605ec6f01c19903b8b01f55f59080dacfed7f0c8715341004f6f7d268353170aa15f0a10c2030a92832a99d61e8d2c207a1fbc6fd6612f00d2229d26907aa1ee840e7565105b009ed7b7841c9dcbda9617f5ca98b626d2c783ddc8a036da2c87e854bc0657d4fcd6d2b8022024c075befc63b5dfb2585cb3193e8ca215d140f1ac0ae7638965a94d5fdedca3d7e14cac3d4182c870e973dc5c155d7b711b702f2f144a27cc1abe64d65243dabbc66509af140a050f1a1e7caaf7f3da6a4586e6490459adfecc35fdee5b555dc921827a9ea3e20d8df111a6271b359776badd73159373e3b56328d21f8089753a1c0c03153b46807ac0247dd48a93ee173444ac3e5d20da5fee7e9c7ad09354105505bc08052a4b29491c38a77fa842a9ee70bfaa82c3e1c2d156a9941ab625934a4eeff4f314c3adb3b7ea97769f1cab90d515404eae265cd344eca262d63a4ea49fa16bd9bb99c94c87372befdf251240abd0ce5687eb66c181651ac216c25e7d3739c09fd43ff919deef401543603d9399b780e0649719905e2c733dcc41f68e2738e7723686a0350ec3af6467e20873786c70da2d2f9ee0762b0b53206a5f77c71b4acfc9e4012ef906d7df252288fc0bf298fc3ad98edecb3fb426b405c0512cbaa5f51a01a941b578114c2e8974ff04b269e8f419c5866bcf29f1c6057188e8cf95c0642b0e7c0fea8fa4cf36737113922e0f0d113cd381fba6017e91b38596bd869bdab7e49cb523f6f8b27be24fbdf839d8177eab21997be5c060b6c57efae55a0475ae0562662c8527a96b533e481ee032b25557ceef3677cae1bb62f09da08ee38d9b297755d87496083213f38ae70303282db439a43f0d97d7a87daeabb55e42caf2260bcc188d298a09f14a83fc660ae123ad42d2d64d6d29335471aa49719f2fea455de2c4ac0449b6309dcd06ba102ef9f4c15e56d7ec78f0eec0d3f81a3990b38f944c009714fe48c14b110ac160459a0611a854ca63397a7edb6c1ae5fbb1fd91701bd0abe7c27050364c36c02bf85d26c3205feac6881c3481e600fdd056bf6d12fcf312b4a14e51c5e5168777387a59f895ceb8e6fcd8ace6c1625f2613687d1827937073cb5bb68153f17b8e5f67f86d1af375193c15758fcdf6d1fbabbd1ed44d7f0741acf88430684e62ef83c3cae2cd9e5af2fd923edeeab7f8a1b28dd97a1965f947471bcbb3d034e738934fb40305d262505e28a4810aa6466008ca19d1cecaa0c1419c35194b7d4c070642c06b7ae288ee730fecd0039687f9138d4673897754ee0a6a46107e2c2fe1c0d01d04ff04433a69cb07fff9fb5190aed9217bc1d63b4f21845afcbb53a3f67613004bfc65f0e243cfce0c08c3070cf6831581316dba4a184f15029119376f643ebb471515dd88a26f94cb98108ead685caea3f096843c0e933f4242b9e09cc984b148595c1d27b9a6de4bfc30a618cee756eb8b8c82ac1de30a1648740c3d54058472c63d2a77f3093c785524f775b12c9c7dc57df193c5fdcf7b85b8a6985d1d993f1e24d53d342557a7ce5a63be4fa0adecdcda17d40faad7195ba5af3728f82fc3a93068aac69f79ada0736613d062ccf972dbd81a932fed06c21d675c2710050086bef7fb127d7ddc6a11182b0dddcc2656dfaedfcb6c2e0519c9838dc2ef0b830b03b1c0f2691322387664f8fcdbab2f3eb1429c260525854ff727a029e5bf6728158365450d5a1a95a95af1bc8eab6fa7f833a6590c12e68fc19e98444b392edf1ee3513683b6ab96aee63a7305bf4aaeb373e60b6025ff0f9b9d3baaa3d026fd3329c81503f6054c0d376e3f6192ea5dc0e8713e9d2b8b1ca8e860946981667cbcde9d4c90d29f902d7361320e2be5e1b3f24c08157abb039b68ba7aab7f8d9d66fe57a453dac36d1c4e45a6923e1a48d8b563485c86ce6047002c49184ee1fe5ffcf64d3e1c252a85e24b7adadd3e5f2faffa891f48c791ef81d8f4531fe46e69bcf8cabcfffcbfa98968aac6c64b76827c357c2475b84dd843b8bb1e4a523a4b25f6fd85236240c373ad9061e6353af2f6f692f6378bf5ff7bbb830deedc0b34abf8d22bc8a95f3b8932b5db6b8082c8e5c344cf7e0fbd190a00ccd25370d4e0484abff2471b840e2236fe6acc928fc18f5c23c950b3c3c95728bd4b84dcbe455846b5ebc6cce44d69b9e53b9dcb0ebd2d38c37e3f40f6f7e0ae531bc8d8a891e67a3d75cff410f142625353bb6cf522d07d2529f1fa303351bb2343e2711f5ebe30794568386750b2b9d629f6417d9003270e6312abcda1039b7ada992bcda300112beb39ac5bd15a4891830b6bdec2cdc3c3071ea663cb7b5ae79e3dc0ed7e8d0a75ef1e100fca2fce60f23c4c1204e8274b01a55b2d95489331f96dc893b0452660b6aaefb72cb8be8963a0d993da1beb3fffde6bfa0714e3b67f80a18ad99e2da63b3e9c5912f165c045a3bbde28728ecb6140ca3c1cbf0ef2dd91c513fc525836907eee2b41f919050124b5c0ee757e671d413f199df88c3a1ba17655d04957b00254f0b7e76fb3f6830bb8d3533ad3d4977a9da7646d5dd39c6e88b4e093d84e3750a641fb7bad2413c57142b35cb99074d95af3f7ebfc84573bfbb0d6f0ca9793f36e950da9406ec98ef17c38d5c6fae47542c55674b69078cd16c105b9c44bd42b6bed14d58c0992e4fdb38e60984c93d5a72e5e66c984caeb9cf49eef14abba2e01fbe8d8213ae15c1493f5ddcc4e838e39131edde72c96a35e36bab4847bd55ea137844c70f475bbbd97277720596bab1722c6b0d24f35aa88488d34e4e8a6fa8de6821f72847b2b426374a1319c69ef978ff206784eca89347b105c1712e9914e8e3683718929164fa0f2b7db513c7d28d7d6157a58341c00a05f851b2f50b7583c4f8bc79623b638a6fb30f936b942399430938fbf86ca946860ae77f185ea0ac24afe856cc02df1a0ff0bcbf37ce5f320e289d87afc42f7d1f6734d90da967e274eab7bc66dffcb38a72479cb9de8613ebf34dbaeccde66df4a57aeea57bb72e22d4f435d54e4b6e10da221c88772fb8ce4fe94f62a6bd0240e1c4bfb442f4b1eff798488095670f086421fabdd640f70175c39e687863a4cc2a79be4a6fc7c2c192c00330f193db36f9f7ff26994f07396e433d8b4945bfd13daa061a217400be68334b32d2cc19a6831d93c905e47fe0d249dab81bb671d9f88da77a4c6f1d94e604f77e554dae8f88f1ba2e22af5d7f196817e007f7102ddc80e4d7fa8925946fc03edd73c490c3f64154c498ca4d3e012cdd4b23ab288bdd91686a83eed083d0d75a5e126503c8006a869c9d79f834c80a5f35bd321f599327b7867fb6d3f04c7b45dd8ef624c710f97b6539659b2087c93cba9cbc6acdd43c669a450b25325c2699609e62ece1dce183b0515d1d73d7de1b43444326b2285a868bcf73e818645d98eb5310bee88f4f353546623d44c04513dc4d38afe85a4d7e8ac7c88f8414a683f8146a83ce506a922f11ce26c7f1c2dfe257d5d2c4f4fa01702e7cfc37f8feece7d5e9a985ced12f0e9b11f071da7568d1e38e672c0f50864739e4b15bbadd30adc6ad1587472a33ba601718b610d90f00cc4aba07dc556b85a1d2774a31defa1d411c6901e0605d67bcc8165b5408ed90feaa3ccbdc70172bcbeeecb46de13863aacb979306e736c819ce89de76cc03a1adf88f1a8511d0c38471162183eec80a79218d5a69f9c40675591756a5bf4e993353aa5b2a9f4401b5f1253302aa895611f97daa24e8fb88ea28be2e65fad2d8e7d828b1760dd1617c560ad359be6eab6cb55fe1e2690225609f1d573ea9883e03545da1dcfac5a4e4a5c3abdfe08a77d5d8e7b72c7bcf64fc68191774a31b3b969332fb5b23786a1c84f7f941d2b9a6f1f46cde21a03ee3183fcd64843fa32a99a9486692ba237235b4e60be94975cb5c5b89ffaa997e49fa723ce2862417728dad2d15e452c96a14af5b092fa5b3994f6f1d854da40f33030a3eca5578d36bb13884278a7322d8ca727a2e872d704c5853cfd574f96dd34b82ec1b47c75437de448aa371e98fa0d66062ce3a01556ca04f1eb9751e2d4a14268bba80e7d27eee78fbc3ca74068fe584104949d207f28215e27d5854d29e002197e8cd556ba54278fb4b5e217aa8b38ef86072a45c7a7cf723c727c9f2695286eb36e966e54c0ad5a6dc043d87264b6376a3b6172de7a40b12d6c12109d7a8b5de20db9699d7abfee30cd0083a2cc9977e49bb27c75f99958edcc4a1bb05ce565930fa35907452896c16984c3d0170d3263e050256b326cae3662f122af1ca118792b33d8ea35cc057c9d6e680f6498e3770838c5f381695118837c9873340877134db73e90964523e085f9d2f4e02c97bc3bd96b94a654a12fed0e8e75569f6b06fa115fb9fa20c66013a38d570bda2ab853b8c3571bd42e5cc86b69692b44dea196e4abcb4fa66b5eef10f338076fa2b4801db4ec87eebf6586432cf15bae12fc80640e26fc4e95768cba79744090048674f462ef4ac5d74693f9c2342a6cab03f5b0c793cda88000f94c735338086f50e1733b5a6345f42a1f2521ec99b30d356d192abdecc704ffd3651d146e2c6fa7f700f6fd8ac239a262e14381edd055e7c13e0620d5a81b9cbd02935f6795e58e26ca3384ce9c8135eb276eaf9c4207db4174d087f386351c0b7915a9d6af9dfc5d7f465ba3846a67ad741065963643ce5bb2667bae0bd0fb80b077813bf11f83b42d7b1181937c75e5a916886ba7a303b3735dbba19eba3c4aef8ec1a7bd93bc4dc3c9c3f626c30e6cf2c1dc272fa343c3971617f0631a1983a982dc98169cd6578505781bcb8b8389a83ee43a36d17604a59603e615f8312c5dd90ff5afa958c6ec264c1af2d6f6d3784ade5cc5ff19730308bdeda89149b469291dc66a24ed4eef665b4343189e5ce0fbf21e178dcf2fe7d0735cadf7ab9de15fdafb57b7a8e73b56f0d6091bcbf42d193e2e2722075de0b967239b47250e0155098c7d493dc56e7b07984f8b6d4c659f8d839db03636f8e7ba55c6fde3cc674b3fd45c3505a3accb49230d0559ce7b2e51415a022814c9d65a93a7b9a16d45d0607c782681c3f00bf82d3171ed9e73ae2cf6d686ab7bc235b3b3e384c5dffc7f75cb97f16b7c9e6265a83b24a3e9dd8aa357eebb7867c147c919ee8e98ac90efde8d6891cc7b196b8963dedfe703a73ded7daeed96a798b767d9476724ab58f7199603b73b87597e1d094d15b5a9537a0772b1c4bd127320ac0457b7ca01b2e0658117ed9c1372173cdf4d4345819aa9551d66c1a15baf2a32b47abfc6d482659f6c15bfb57687f7cf9a515dea0fbd630a1101e7cccd6d47ae2c70172011dc5cd4504c95416a1ec9db7b9a73e5727cd5ff9175fa981f3341605b18c4e0a1ea52eb102e6ec0228d893729744db9068f4770ad2b8d13cd6941c0255d17de5fcecd1bfa92121493d0ebace75972670babe810edbe1fe19c64da28adde8af8b64cde297b632d2750640b641bde097172d19e4d343a60ec32ace8811d481beb640541782313495bb2d3182bd41d15c4dfa04e23bcbdd83be34abca08fe877add0494e5944f5ccca572d994ffb3ee0363053bce83cb49d00511db62909b5c6936b63a3aebb15e623d5b9dd3159abde6155f1ae1cbe6ebf5fbc3ab48d260b4b5738e6c55e48ee796bd34252057f1ab01f226ec18ef45756c49f4e54b16127265f87867e639d1a5f5f913109aae50521917a2a765b2f877c9d158f925f04cff0b414224e8f63d7f2b2523e04ed79cbd5ab9e2e65845859f64edc9d79bb928416fffed0660ae79e9d2d460f6a8e5f0d206f064cc329def925f1ee2298089d0fe023f07b437e85ff3f59f4806c2a0f571f9605ceee66d481f6c5036171627fad0355a88ff374b57b83e8972f4ec159f8d06e21734e194dd0b85c0147869ba8d79b3938ddb13fb300f85233e29f14d1acf716d8f5eff3e878d05527931d9ea491335d1700971573c3eab91cbf88cbe45cd910cb0aa4b214644b710f69745e9f150a88f32ea7205776508f55066c344da8a3833333e92fddf803581a896044fb4d777d806181f077c7a99e0f4c0adea58ce76c7fd1d8a7f8cc91a450fc87f80202b4c1e16328963bf5ca2da9216a78853885442c3046cda00b79eca9349b50500b208c8e28a5bde8c7eeae21b2026012e51c3cb6bb8d8448bd46f6b66e4bc943412bbef08946441e92b6fd5253c915ab4176763a6a005d57cfbc39fb3b9ffb55b4a28ede540a78ba867a917a501b17b8a9ea8fc7ff38df4b9cdf7d640f710c3d21c8e62e1628d2d762919866658a62c52fdb23c8d51d47303485ebcdb211b315ee1fe4a482586891b7c7c2bb55f65a0da008ea9011df788ca99a77f0740c85ac45b6fce884893100feee20c43fb01b64175ec3ca83870ff6a98d74e2f707693b9ed11bb5c31fd12f6d680c42ebaf613a2e227d071c48f866cbfe55ab9b7748a07e378c26031310aa104d33d255d2f79ac11dd222a2510a6832f5b601e8f0be120e34c7222a933028a06381ad9b639100c7f23c4df276e7e3df55360d6b684e29bef4aa9d9d85abb3d3d878c4f3f9e7bb87ae72904c4bdb22f078279f8779f72bcc4cc6573c2e70f8c18f8624a54a31a264e5a080df45e52474e4456eb7be1a4100ae71c2ec62f376afc291fb8006e8292c2469d49d0d946b92029f72a9b811c74bb67f6596184ecd46271e17e2725be19b4ea277041560f8355ec240ea43e1ff601544b738ef13e31dc8bfa188ab87e00ef0c008a58c63481d4debf07d5d6d67c1c58954af389fe35175d5d4e638651c35c0a6e29381dec79b1213b5c630977ec0730a89228c6d4cbacd051dcaef50ac3439e9deb7e7f25aa39373b9167f4f52c18748018eb2e8a17122dd183364f613c33cbf0ddbd71a529721e755305292aaa2e844ebccaffbd24adf6e01970f4b707c387781a4fe87ec54a8cbcb33b116e1dcdb862abeac49fd05b119a7ca2b21296e974122658443ebe0f50aec6ccb6093c3535a13ced4d22d88b885f8141f34c5d08c997b07571e7101ef9c9d4009353913b39d4ca873e89dae87ee17b4c4841ffd1c792107874ade56873be58aba58bcad7d6c966531d331114cbded15c9dbe161167f69d26369995ea047260765b1192a26b6066f195da79eb08869c83321f0d46df04c958054d7787098da9835fb347191f64c8742712bfbe9d3477420c8bd5dda903bdbf106111cc50d71eaac721bc663ef4684b14ddc157cfa604c54c7ddd8ba0b3ee71e3dd3b3a8bb5683bbb4eefd3bd13a9747347cdfc2becb0b1553e3bd12e7634966d2198638706299bcf7d2fc1482e842611cc018c8386c17e10da5839e3696d9030a8c8111f121b72f5450a75ab67f16687527dad2573bc9ee2c25564d9efc170aa0e0c0f0cc9c49b8fdbfa087e23111216b242bdd99ea8baee2a1e1673735df27f593e8abaf1b9234667cd0b42d38930b81bf4bca82ec40c4193e512270c679f732d31e880e326786a0125c35676ddedf35c9f2b4dbed2d4a26e7808388d1b12bd8ae82f36f0027097f21a0e92af4f913aa1a30ecb78fd0640d13bfa71156220c60fd46cc176b01e0b7c630b71d164a77d6bfbd6f7fd5f456df5cc291c3e006cf5ab61b87d461d78f34e0be67020b11d49d5b91c03b414130aadb2e25eebf9ad7ed5702164db5355dcea2ad5d69edc8af12a49072fbfa28f6ff985ef178d619bfd7d2ec75527625696e98c9abdbbef6185abf180c1b4ee85a78246d3cf5226c802ac9520c8cc82b526e79dbbf367cd31e0a1ac928d37caa8c034f9b76e70c3f8ff4083d60abc8737c5beb18edef42ae5f1c9fabe26a593cda630d356c3babdb162917b562385bcfc73783e2ae47d3cbdb20b3713968384a2596ab99a9abe5f86431af93cca0b5df0e24215cfae4f53cfe3d7cc60ec8ce776d0533f54451158395cb0ee2e75979e329f492fb22823a6ab3305b85bc16f899b3abec6a6fa6f96c53c61474c21b68388287bc1b5683c7bd2d0ec40cd937d51d308e8c9b1170d5b840021e62e1ffb0808f762826d5e7e94fff3c220175552cb91fce1a443c8c8303e2c586f6e805a5d36f15f484d03a8f7a6c0f18b125373076f7c3ffe58e431a6f6f9452d13fc4db0940411fa3bb8ea0c2e95c7536517ee95b7caa233a5a90717e35d242f55cf39f306ec7a96797395537b489a95580e6557d470f677cdad8675a236502fafbfab2c005ddb93da751e16e601f69ce3d535a0bf15892fd4b3086920d63cd60ad87cf11751b4586af7539dc6818930e05704f6361d678917bf87ad42ab3741d00a9fae8f86d0787d26ecd604fc7ea548f0ada09240a01381ca2c6be75690ff7748ef7595bcce71dd3c0660167165462e1856a282f8a3b15d061a75d23771b8bd9b2ca9d73f3dd2fb36a491359a7c200ffa03da6a2d79216405716f7e899a52c0701232728e1923778371457c4d3f30bed2cd7987b171c0ce01be4ceda850891a7019651d973118dbd291660f92858cdf429e724980efa0127dba21a4e76277730b586d8bd1a0d42566153c1aeebe117a10be5cc190adb728dbdc5a49b921c09d96882b7c8335559ec229f9b574705ec78014f7cf458df063cd9c421440ecc2a3726da15fa917b40282ee8574f9d6a5175774ce94d04d4abf9460b99514f3f7e26e9cca13c13880ca6de513e2fc27217d3404e1e41c45ac40527bfd6e0f2b645986f099f0b89b31effd46ff57624bf8add6ee649f18228f600f16731e784971239e5d515f8eb9228cd954c55bd94862aa9f8f692d25358bd6d5239bf197ca62b63b4a96ed86fe86f62c23d1c9a259d3b65cbfbb22a1263735e346375ee10d263a0cc4b1af1eff1ce409a7fb5457631e99cd53e55a53c1846ddb093f5d2db83729e380ab0fd0210bc01ba70d7f5e2ddbf081d4060d49523eb21f32ba396a68c7d134b9f31c4cad8c223a06cbf2425f79dbed79c235fd730c7952c965e5c0c3d1b9cc504d318f82e1229fdbfa296edab100e526ab9819a115daf8b6d2b9effce14ce2ea35479b3ec28466e7258c2d8da670f222e36f463580c1969363666cf46da343e1b4376f4313f2593fed83a0e6f0f1ef9bcf819072443118c745f2cc257fbbacf986555d6e9eef425eb1688f5550914ac26e742b6825d3f604755b45d45d9b708507a9d64c7ecc0c6aae4c7e4d166263170f95f96d05df4f1274bf355351c602cf12ddbf7bfadaf80bc916ae97253690938933152fa90389ce7e42329249a6b5c0696eafea1fdc7add8e8b0c5af162c669f8728dfaf71ec85957265c04033f79e4e7d4e482761f40f69eade94c15a20693632c13122b56785ce498dcd72d0836289789c123301ff15710121848889320d6b69255bb64ea37ae6ac4609c256ad6f181a928c469d3f87a479141fb9ea68a35209d429831c609974c55d2dd5542823d967d7b96e24f0622ea4d74af32b7d9f38c3277ae81beb1d549c06a7d183472fe3e149402e62430b183dab5852312f0215eac9111cf9fae2abf04ef7d86939d3e0ae49dde32fa44f258bcbf0884854b2a01567a53099a544a4b79d2c22793b57f65851d584fca0dd1997ac2ef0fc4470b79e16eef5a8f7bd5425529411f4d9480ed53e9f80cf9daa5ded21a13b4dd46fdbe4e705345b76271c8e9211b502a108ed58c98416f54d2a58efbdc22c86d6afd16b59c150faf215c0cfb08e7a0fe1b430b1e03a855a728072679aeee18ded8f261ff441e06571f6d5d9916bb11ba09c7104a2f02a4393021a4f2fd8e04bf4e35e69594c2934e2158e97cf709f870b8426d11c3814d1fc63dc073603bf8fb571736880bc231453b2841330af54343001105c91fc0d9f458656f0cd25a8af6b769c5b9f062211cd015e44c9c0de4d4092783d7a08c6d9628150da2c6472ad8ffc8c4d0210f547b17bb9f61b104320a1de9cc7718a29b757ec10e359475e1e6096f75a2d432b22ba40d1fa33e273be869df1e5caa035300e95a03b6ddcfef4c1998a3ddb7e6aae1e19fd9e0c73d62be462e542d32bdff4a935df8db440d8ebcc90b63bc66ed09748f6d9210ff05a5b453138f6fa81e9f4e22d90ae73d2b1ebdcb754063510a604ad4b07d7c995b12a9012d34562216ac5861a83b1cec4a72920af26f2a7a02cd2c8528f74eec445e0fef9bc2a11163513e6b29e8a0ce739c47da98727d0e0408d74dd20717d7bfa6f387990b0e3210c47abded98a97d92308def5841074d54719f1d2691ef38e749172ae34829a726dba00a8eb676b824065b421145aafe669bd3868df9880f6650d076270521a3711453aacb60f07cdacf31b1c3cf71f60b9b7246f46168e13888d84a27afab1a3a294c116775f3c13e94c22ec857f97c5cdeb9fe6ce76974266c9689ad5f8eccd586e676a73df72a53ffdbe49407bfe7977a1e7d2f9edb3db9e3ceddecc8eaa3d952629bb845524d4ba8e1dac729b65788efedd911ecd9237f943d2a35fbc984066eaf9fb9013ded9a8e3f01065796c3553636579faa2825ed9cceba8197d14940f461f9fe59f4466cbfa38cdfa51dd4e8806dba46c40ba1c4633537af09f5126f46843c11793bbd10a466c9061c7483e5a5487ce82aa9fe8e029bf3bb2680bfb2d1ca203beb4fc938f8cb1d8dabb773b4f622e09dae922438cce8237e91f09f3ba1671bdc173326557d311f033eaf3ff3fb452add926d9228b44e831d1ee8cfb3d7620c7d63c344f763d68cbaf5a7e01685c0e639c30ee37ba85f4649e8a616de07c6c6627bf077a080720909a66b81b74ac52e1808bb566d667d186993c99db3b62a4252019f37cc53fe6bb274513032c1182c58ce4ac8b6974e1252015ae66f10cfc6659c2aacb8ba34d35aa77345ff6c3d64ae4b44a1952301d3c86ef71805f5afee713d2e0f3400c09f416d7807aa3cc748d9f43b6f3117d37b099061e7a0152d2f30bfb9e956d87733123bd1ddda86562b5fbfdc42272c638d885d8fe9f499e69ddef94223531bde3ea23be09b289e998a0f01ed685c43aacd31e340536d8cf7c25693c9a2c680c3f95d7b6358cad64fe215f89b21353db015a1bd1a8bcf0bd3d220d096779aea3944d9fc0bbf9145ae967fa1d0fe62a2851a0de0e7de311694d15c79b052d1cfe91c328cecb8164d61bf784b0c1ca48ea62dad881f4424556c3c40e44926479d09c80276492fde03cfb840d8a9423b0887a0582acbd216e0ce694afa7f3ce107fc0259fe041e8d1a606068f58ba2ec428597625d4c9daf933261d07f4a4a02545bdf1288b561d50f26b82042e25b904edb77cc7a1f49fb41fa3a7d32e6cd9521208901d72426edb687f50637b1302dce6404f2d66bdff27c14eeab18e4585a067f51cec263759b5b610f618449ed1aa849545abb94649614863f424f6296536319ff1141109801d52bf8466e27f4f2623ea393257f212066567c49a023dfa41f9bc031e6807bdc06364f38efb38ffb0bd020e98c4e5b87e25c549c3aa20fde5c89b0c812c3a3e21bbe68984e1e401b2e23549984f8a54a45fb672f9bf52241fb9a13fed7d21bf7e27ae0debf95029f25277e7f1b051194edc443ed3135593dba147cbcd923d4ec9142bbc949f3d3c2ba71b2a23fd886c1b5bf85bb109d76a26d89f01e155d2f03adbdb1e3a4edf06561b878b3db3b6ad1b9d97f76a2de745879b88f2fb00d5e145ebcf7be6c6c4a4ae8df2af9000423c5aa8d5e2dd4d44bca0dd43ebfdfb668c09b45ceb3a570b10b2a7d19a1eb7f8d867e1e203775fda8dd61c5a6f2b7bafb8626f6b06887e8ba700ef10e5517aa617d287d4f38a1fade4f0477b5e96fe85889533a7f7b0c0adea2cf6459ba9af6be8e6663424c5734f8cadf6a91382b8ebb376d99b8ce6446cfa7aa42f40c6dfee7cb927118b15fcf4f2c976cd34512910ef1ea6d14a87ba27ea66f44456c669c1ef2eb7871d7fd5d7bd5a772a76adc6eb45abf2b0fbe68262fbb6009001ab3ae8d768d35b93d47f0fb0d2451d89725098386bf8646317e7b5cf34b70642a251624910bebc3babf4eefc66df152a6706f3c3a61409e071ad3ffa201c53670f5c3e12b6ee23d899b33917bb611f5625599caeb02e6d62e2558fab488c4068eb89dd8f2e27c78b39392e82835c72953a25468fc15c9b09a4b8aaf8ba9fe7c7e4b3daac878c556c43e8442a6042b6fd3e0a03360b2d88ec91f55a7ef3c3e8991f9fc64c36126a39f28219943caaaae5a28579f67f44b765311be8f006f3a03c482b0b507dc90449736d3407c50e1cd3bd99e67a4e13e9881ac8916ea27ad3a2161ec527fa6c98bfda181756bfa7dcb1f1772f3af62eb6782ab45795e5d7d19756d525a7d2c4e60fe19fb0eae042de27c891e25702a4a238ece6a319d6ce7cd462b2c6b1157aa4374c404b88f563fcfb383b9d99b60ba3d47c2baf018ee6627018d1cbf44040fde03ca6ec2eda9f9b3805330207d0d476177956fb9b3049e244664a3cca7d10d817f0916121dcaa47fb486c3ab43b32c86f465775976f40a6f4d2088aab20c230f1fa5c1769c404aafbb4488428f09eb82403428efb09a0b23a568838693ba505d3edc7da473fdc750309c028acfc8f740e3d8b7f5da979f8a5f42a135939752e500569a0d11655f61ba5f9b8d045a331b3c01870626d5922736b06797a3e499b080a1ca3e9a70a099d94734d4385da3f2cadda894ea08e1add2035a508e76a06be121abca13da4f8fa2985046be16792e3c37adf89821cabbf9218be5c120dfa37b69c3e65369d8cb7d434cb2edf3a9b23f7fc223d052e17ae36585c83aa6241f55fe219d7a39e42eaff2863a80f131eec95e468fa525c1c19340458d4374d66bad3cfc8fe9b04f9d838f4364eb0965b6b31cb62bf45a496a3192d24de2504bdd2755ef40a99205cf201aa31fa60f20bb14c451c1e38a8f67f1ff74cac8c54edc3f743eed36ad9807ac0246d278eadfcaba3cee07377d1f0008cacd7d38754617808eb8323a669c666d72ef1c260908fa56464ed69cbb4aecfdd7c203fe53923a44c3746799855a7e0222eca03494ccf4b53ce24f67aeebafa125bf4013e59da97a205404359463c4bd617e54b40636715401423a59a5bdc22ba2ccf08c141fc7f8fbbb605dadbb8c41a1d5efb4c260bc567a5114a7b73bada72a05c5eabfe1f3c5f3784846bdff5314ce1523fc2d3f179225031e4b972dc9a30486e7d021e08f2e65a6f9a2780bb68321366389cd540250c6dcdd3fa72cf3bf0c4b34b9b5557596a11ce11a8827dfcd1b4ecb67262336fedd05157379c155e8e93a3c5b21b9eca3ccee5985e8f898ce7ab337b9bb78725b5ebd28358077ad1f5cd64a6f9c7acaba72bdc061c6003b3330dbcddee9c1a00bbfc0823f3aa1e805808df2918ba068fae8a2ae5abe04ad64e34dfc1ef565534c96fc1895f522ebfceb1c0984ea26febe0c03d121ad0cd07ee65dbc48898a0af3945211eda05965c4499a54c0f275c2b645f025e661bf39a1b03102f0d1ea3fa5be83dfa30bc2a39f67bdd2eb1d2b351e817bf33d67cc1a6c5ee24c3b8a99242f9fab13c934fa6343ad32c4f7e469dd29d789f9f09dd45e7d0527789ba324473af1dd46d6bbe34745b27561628e234f0e3f384a8eeea1f0309107b1a4a1f200b66a99acdfa4fbb49293d77b03944dcd73af3111d17ebeae48ed26fb9617c526e50c77ddbf443f4bd755d49225d44ff43c6c3a2a1a5d1658e623b1a8c0ac401f91769ad6340fa864fcc3ca535f74c3380c12954edd6f0b7b2036ab28464232ad1edc5c1884265205befa6d26f7091929281e2d30b804a841055a405dbdce4fde0cb50802c6994a7dd1d59e2cfbcab1681832782a7c022d20102c57e26ca4e22cb7913e4255be0db1ea092c57eb5df300a743a052ed7896a4521db704cda9b071dfa4dd7064383f1b8212f789163b70c76b6e7d380ce079396e10d576797e7fc980f0e7dde133974a0e76b4259e62c418380081753002d5420d2079411f6f643bc62118c064d4b140a2fd36fde035912e8c44706ffdc69b79732a96364ef904fbef9484bbed1aa658da5cd9881341de9f90c17385b33071769db847b95bf675c1b523634ceaf30cf62a1f6740e312e6ef48291ba7e6d476f4cddeba8c93450a223e571bc18a22f463bbc270b78e02b78c64973a701c68ac01ba8fdfc50509c2c6b92b95f0515e42e9fa0678f72677f32460b9ddff892ef1fc7be9fc16a642afbff33c61cea9e31d3f390da8eee4a3d0569b06feb92cb722dc26ca73867121586ddbdfa15d95494ca6e9880215a8046c865e3e73664db6de26a625df71e8895673300fdd3dd2a7890c4cf871150210c610504ae8e7c76cda5fd5ff75a91ba88567986b03ff79f116d30eb3a542d1317be706af15feeacb784a4188299ad50f1a7aa4d1af62c971f10ab3e2dc3fdc6cbb56d219ed1156e71d490b4d835a7a409cb39155c5b8ae34b492f9f7e473d1f68a075975a9e09962ec19a975149d08dd033ddb5cddb842a435f81479878ec8ab568e917141d9bd1eb2ceba446e9d53b9a74c48789164728f5194addba1f87f0e4cf287b20ccc9d9a824b195a7166fe6709382b620b4b6f5b9724bfacb82582195ea1385d7d59000b731","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
