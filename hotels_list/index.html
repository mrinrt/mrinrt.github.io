<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9b4bfc76ad3c4017f3d75eaa530c1345ba35ae7159a28e31bd1e081f0cec8f4804d7a1d6ad1810a01436f6130f1da55dc999f18950a4096aff0ee7b3fa396cb8394efa6a8d5f648a2ea3ef80b6d9acd6ee65acf26688cbda2b1b98db97f4f687ec598707edab35f47e400455ab2293ca3d507847f09eeb3b2c0cf2b6c120c8452ff1e7efbf105dbc00f6a53c33787a5fa00b587108f4fa4c6a9b2c422d3d3b9df517284a96b358ce7777ddfdaa1ecbc63f9b38e82727858ed219e5b9fe8c82b3302f3cb7784e4d09964c6f42d37563abbdc61e5a7ecfa9b526fac7c966b125cdf7ead2407e80fdbd389dde0128e9091bff397ab65f7d4d8cdffb3b23684941ddd8c82463b4df6d23cfe22a1e99a66fe5f747392f58fa17d67979555f90f653f231c28ff70a585893001e030c5510820b571cf86497ff2c2c6534763f5d92d3cfe28037a24ec6879603a99fa0d104fe062379ef61b582da00997aceaf7cc82eb895fc318e5e19cb35074913d1a71ad18b14968b2e6b132682131aa80e3e1e0346be7cda087717a370d4f45a2a708f57f2fc4364f9b0b213da4dacfb0b3d9a26e29c6ab78f4ff27670614b77339d9cddf0acdca54863fb5fbc0b93144e4078d6022c28785e77280113c7c0a28cac770463780a73aed6d5bd9c670d3bf28edc56e28a8ef7ee0df30be3f202b7b35a06d7bc249d9959e4f5002be2c9418fe8cb361303eaaf8711588cc496abcfbb647633bdf8a9ef408eb0970c64d42728f7b15b21b694bd0b12c63a219bf570d2a83ef70a4e1d26677579b7e4b8b27b1a558013e46931b7096ab6f598a768a30d913484c4b0469ecd00ad8a27c313058c09b31db8a9e2d9188038a12d85b55c1aa5f04daee0431cfb84ee44a3db55f2631a41109c0f23b4465322a56142c8c8d7d7542c5c39874e76e9975c70e7f0aa4bd07d3a2248ea2575f8c5e654fbe0c553465c1161ff296364d49791521efe01b2dcc88f774217ee817e5b98f0df73a291b7da90ff46f48faf037b8cca42769554b0df7a902dbd1810f7578fde575e9800c873829c8f5e4ca04084016379c6a7dcbe1a752f03278435bf77c2b31d9ba9a1841b54c5dc7db3ecda729c72c6b333a6d032f9a45b94300f2f8454d41a8054559db6fa4169753858fea7ac9739177bde1a7fb6d70feacd73e01a834e33f4f00081f028aa8d5fef69315d52aa43d1743b278bf8a33df6067175d52900cf0e1081f2b0653f08850e54dd20356942d7bdf4063fd3a3e5ed84fe7c0ab3cfe0830d7dfcc3bf1a7af55e827c3d34fef40bd993e57774f393dcded994a8df2551c06cdb586a858f6f3a89e42ce7e74b7e8b2c4d92cbd3185240d79267b975c738599c6501a5f243ec6f878f30b5d0fbde514d5b491be825d136a4ccb6b6b3525b840143695d670cf9117890eb5db6b9e5704ba8205b28c4368236e03f9c18b324ea88254bd0dac12efb0d4445075cf4418697741f36f70768315f28a9ead0b4585d50ad642a1a905c554d6d7f0833d66af52c99a44172cd33fe74da09f1367da22d62d682442a54c6df98bf13f7635a6f3e6d8557532465bec435bbb45eb9f645640a8435935da27bb7e594e283d38b1a1d3b103ee41577a64b53fa47cb94d8184eedb32d0d44395f7d3536d847573ba3d6300752c6380362c6ddf4f54d47319694fe32c05e7124b4db09e0be413ab2c796b644abcba49e4cdad90f89a354a1ef709ac19d46003abb54649ab61dbf004d383f5557b89f767ff9f6473112cede73a29afe3742d57900a7e74647737a80dfc76d0576d0a745f6d0fd2f1c8e579ddebbea8519bbe597171e6a9b03db7136a6bdf77601b46e3419248177d3764c711b11f4ec3d9857dd825a92f04aafc45f02c1478417d0af31b49e8a6bd59d6006aa7b72300b92fb2387f33fb001510f5fdf48a7498ecbf4fa9ee495bd15047ff5cde4183da49c475b639fb83e79791d12f0d6cf90b9aa9a7ba3d2e9160efa8470f7c7d4b54b0805479bda274edb71fc7a072b817a84b89525aaf110674fb3f6471713ce4ece6b74d63fd65ab26b8d7277de714fdde707a18347fb2f1318ed637b32e1c9b0d1a3bde27a84c37307aef97d7ce9ecf1ec0d4d087ea32d2ea107da0fa6b4894e9998e9afde38dff165e159abafb81bb723b189da00de3f73606b8777d40e97301a175ffa7a01ccb94cba1250deef4bcc9f8aa29e9ca9c1f777b0449183acffe330329c21bd70dcdf39bf1c1ba67068d8876fd4bc5dd56c977b70dc3212579b0ea2826dfeb45ecc375ef47014720fff1756edd9d280e5b473da590062121f6374a882efaaec42228f3c7d9b8581a73b7aa3bf36a64d009bec3956ce6b8feaf244e9b458f89b15b94a0ea06947933c3de7e69a586266b5e49a74250a811735e22bb5eab066b3db49d63923a15d6356a66125e19df5f9aef4e332c4cb460919b0a84519ce74d752db1d289b80fa98b986cc22851f662aa2b3c9ce21651addcd0ff6611e65680daa5d1bcd2c2362f2e12a4de860007299dfe7d95102c808b2b13bb24693976bbc366d0712f3a3f4bc481b9fe103c1113b7ca0e6878afee11d3e3e700602262d13fe77a225c32c38dbfb5663c028923bbe04b1c6fa127d104f6830dcf2a862575bdc3df908469593d2fa25af1f15556647b1372e125d4890e8ee8dae12864c5265c377a94fd7aa083ca19cb4f65a10579af602f9579324a0956aabb414a27f52b3fe5a12fd58fd3f43c1ca484d1e7a5c577c2b78fece20e9e83405fb2c024b9500e036faa6be9115fa4a3f48c449edce668ce3916769290a0c60f7e4b44fd23d55be37f8a35c0a0d61591d51b14440af1fc0b66217b6da4e6356ee4482cdeb0b58bf489b5ff0905a0af3f88b1a8b636a3bf3b0856dcc9440793eba83249b1e0381d15fd3e50e2500d17b1764ee75cfc37dcb6cfb981e627da2d72643076f5e1cc8657c9611c44937cd6c5e62b66875aa0a7225b141caa1baae43877d51213c0c6e31a2f76bf1bd0885afce9367ccfdfe9502d9a1ca16ae73d16908cca5e270ae92baf9a97ea1f24b15c3a1c3ade20f671074ad2d4534fe25a55b281d3cd8d299ea4d8b8f7334ec9754bfd6282800a8867b7de2abb1db68f29d5185c985d2939933500ada7943b49879ccf224e85723cc6bdc7c2f7c6858a855249d69c19238bfd4b0257805bd77ed95c429013e844f63c491014e3148666ad5631e06fdf0812bfc50044a179c91a33592ade3be03a655c4b5c5c94f24ce14b2d3eaff1d9055532790c79ed2bfed01bfbb785d9960abe8ec2ef24fdb7ef20d694d01d5a4cd73725d1ec2373eab47556771e6ce685937e91bccbf903d68d16ee4493bfcccee6e7d82acd9c3f77a1446527f5235ee7d89145df8ff2d36a17095cf079bcbb093d9ef6b8fb37b2bbc0f2bc2ff35d2676bb3e05e5cb2c24c57377107e335f0886d01efb9750414ea4fc0064091ccba4ac0ec253e5170bf6ea22e6cffbe1eeab6284335d6627dbd1d4bd7f7af2ffbd426abf4c081314c7a2b088a68a46857b34cf93a73b729c360cb1dcb6e835a0a0e87d6a6edcf9a0aea5aee1e92faf8c3bd426202f7ffc51c789abe37434958bbb1771c25e428663a0ced124aac97e2fee3cdca5ac9073d52b7f7e5f8d79da36b500e23cf8e9e66df762b839ba6263cbcfc778ab6c0a2647529050c30706904cc0ab62c84ee5d19cfb00f6f63aca692eb60e68953fbb7fe0201c669fcd35ec5310a3a3f5d35d4d5bde7f35f680512dd740fafd8e60dcbc8029fca9890ec0d6990195f17d8abe0ce1571bdeb17dce400badef8489c13a5ece497cecfc4751d2a740ab456a818606195482a20ac08ab909e8e1fed1ca48e3213683b87cf5c5fbcf1c6c862442465ef4d1babde064786897414132cde270b670268eacaf9dc1af35abb0f6a68cfbc9f55cefe19b7f068af2fcc72e923935761dfa1aa06db2af6c34fbca234b83336f1ca306550395f3ddaf3164ad0cb06db2d2abe1258dce639a49bc51b61e9649f6506ee785481e8c66a6c9054df5aa182779097ec5a4e95927d91ed2ae4f0d71135efbf7915d635051f94c4287a704d2ba9dcfc8faa8715dcd60cdf9c0d5e0939bdce3a8ff1db71418cf1ae1b398b8d1d956737ca564322583df07a1b0453022c80115e53ce3bee99802d4a0274433ef9e3b82594487b4e75bdc3909a82b53734556b270f1072f78142af79651d6ac09cb93505720d20947ff7335979f4d80530382ac2a9d27418ef87d6bdd57895688a9f9f62770eb5c6269b301d0815f26326b3cf5b6efad1544498c057d9856553d5cf78f2d90032d5229e9383e7cbe89bb419b2a99b9aefdb6dec65b390cab2569b5009c9687b8ed183e64ccc6bb8037ff330400d8b22be361a974f2074dc7021c18b58f51a8450c7d20dfd4692ec2a876c822f5e43723ac1347a1950279e7d708fe410402704a5823ff1f96645cca67972a6e7871dd950100c39f9c700a1cd4b5ea361686928afb73c24b767a3ad08128051f88be98f860f61119da700cd0c0600ecdce42b4cc50a823fbf8097329eb4d81ab3fb1cc13b2d9d266cc7a1ed529e18ca70626024fce03ac8d394a6c9edd06124a0c202a295afa9801968249050d0de84a13accc29e781efc6ff19b8c718f73fa44159fe65eede1c358737ae73e010e87dffc74a54cb7e731a937beda1b163a0c8a039982d363373262cfcb197cef6570d7a88016228e388314e777179217ff7c90b97f0478fa1894238b6d2220d9bab03ee3209c74e094725d6d5325b1ed53419a64a511d32494a1ed229dcb0a3af862639b46d525834af2705218d42e03c4cca110e5eeacdbb2dd134b1484ba0fcc933166f2d9cdf68f53719906d22013709327ad1041b69c405f3fc406d5f4fc202b9b722400bce953ddea934d603d78e226852253e596dd7ce14d5d89e50f6f00f854c8b2397353ca143cc4176c3f784b03c5c234538c03b087cee7f95a9c5a6613ce475a537f537a28284551cf4a481c18e03146e5f44fe022bf75593e9f9b5e34eccace92659751752ff37700b3a92a1b631785daf1a6d1880a40b10cfa78fa5e6f1396d7b2b82f1dac6c3b43f97fba6e7063448f48520e21054f8cc739732838c1098f1080d969569e63e710c018e31ad6832bf7c8fd3f128100e1b3feafd838847e302200c3ce7f7dc0f6a4cd329eaeaca8abc231b7ed3cc3ca23998ef1310b972203fc929fb0bc3263cbf4dc10346bba6bd1320da81a97ee0649eaa07ec0c36a3ff97e115a23ba848dad74b69cd5b35d3f35c35b5022d351016b77506a9c63b6cd07b034da7db7e4cc1aa64704287fc4549255cba38f7dd16c563ef6df66a1a1ec00df0063df5045bd9e3ed2c8f8e315f2758b31e2b3a599da1e9ea7e8bc35b401af4835f111b2d636cd5f05f6f311d9a4a97f5f555f5251da3276330f143c86219a37604c8d5957a81b4834887a4a9ba4f29ccf8432659da3cd9a4ea3d53a8c1f43d396c92072b924c4e3e07424ebe08db00510641b33b5c51cdc2f76f55ed709da98b93d21fdbbe0a55fc5d4fa9e6d5e11e026aa4245b36b1dd83f594194770857631de61a2756bd90adf52792e6e0444b3aaa005b801f2b43395d65bd704c07f5b96b238d40e87ec50c2919504e85bccdbe523f3e79da24eab9edb3568bb6e4d22042854bd4fda3e80a79fcf9db58661a76e52bcff6f8938d249b81cc2faef1c041c9d3b85f6353c9d830c394b397078a18650755b75c8e0b12afd0ac229d152d57e5c45121e6d600fb468482bf8bbb27c79fd6843ce74a7946b95b5c0e463f6d737c93ef0df6db173131e2fdabb792be5167bca2254297b9a341b51102a03fe969fc5cb88fdb06993014c7974c0af5f88b45eb85007cf6afdabacc3f6f37d8059ce339ece06d6fb313e3b3df7b8d32082de5bc6a2e629122bf190bcada1c28f454c4b2dca591bb6bf07ade33c945ded7ff20a347b7216882240b4419fd15d92622c208f5bbf461c03b5a8631804425c84ea300df5823c8168a8282612e511e7d2547ccd015321d1602852231d078bb9a5704bf6ecf1e245db518ac50d6c91799d192b20d9369979c97a73ccc2c783edece1a2e5dbd0e33e329982cfbba0cc32bc9173b9bd3fec9f4c0d20ff947b20c64cb8bafa35d66c82aa844cc76dbd645685da24d78e91cacbc62fa407dd80eb73de963d0dddc23cfeb9cdef7c2c3023c313cdeba09cab792b1612fc64cde37d4684141041fd37b6fd828ef89deb38dd6f11d55016e3113c4dc736a61fbf8e74e04a6ddb2db9395ab7d1a82994b6a47ef55f0203deeb955404e34056d1cc4a22a4cc046de6434d9ed79d018f7fc49da14f71b966691cf1d61bad36b8e81184f4d8268d2034aecf29ae13b80b1941bcf8d2053825b7c2d39138c231de186785152b520b32ccf18f786104956fa749ff9d523bad35a010060efb5ca3bec2470e2ace1c7babedf05ac9a53a31a4b8166fa9997b3642008e0fd38dc4f31d2e5314f2b0af94f169509d51e375e328b598430241a60044087f9f00daec1d8e3d15c99733e078a90b5d08e718d3574e57f0b43b00edf5c55fdca99a1bdc6e1540216d7cf41933c7f9e4f2ac3068d45b9a2ee3371322cac61495e79a9734f3f344e9dd29f8672c7c4e27db427fc3738844fb0556837f96f7756649e07a0f0057db9975abaa1edb8609d43149bfe9506787cfca26afce729eabfa747f80b148281e774fd4626b5ab3353ee34107a14cf03548a77a27a942210a2d944f13425675f01d496512337f05f7ba054229f0e3a8a9b3299337d2c3e066899c4faa39b4589a6201abbd3b39568cd160970d2a4e1b1f8763c06ba6716bdba3fca4297753520bde78f1d8f090ecb75dfe6f793d6969920ba99eb7520f7113801b0e4be7e0c0358cdfce7776334f5df84408a66ede6a5483718be238548a4b3f3f56ba221963ec0a86ae0ac0c00b8c41d15366fd2b0fa7b7c0f01ebaec137d15e4881736194d0b3a5ccf5d66def0979a547f7ead0d0e9f171d0f6c4aeda3a623ae769304574df9ffc98a255b44606d3cf0303b87ee560b5bc57715187f049636350c35ad9407a5487b65338d90bca71506cb777d039f322c44548a4064d1581cbbd87cc100d66c7bb4bd3a0ace915deb20de574ba80bbc22e4d1351aa84fc52ee22acad40de9f67e78e944f755d9bdbe3c936f38e262e396632c3c6bcd86bc5212eeb5ed0ffd996f785e542b0adf65cf569bd1c84912e071c929a3c74bafd0df20d2f60cba20a1b79cbd7f34858d10a0317d8dd846e8380e7307835fe7ed786415fb4dd5f92d8b4e1c6f959075a1a48a578467561cb82dde7bd4f50d286d20b29b94b6e3133a36a7aa8f18614330ae32871d7bd1e17f8377c3cdb24aa1feb257a402cf409cbe3a277b27cad3b7b8c2b904ac5e93342ced75a7a32fc9d1e6e0a170379402953f8cf1707f1a136c03356c616ffc3c56c08c91e45e47b1497c26d9e28990ac69f4ed2bf8bf55de00ae718068177c72bbeadf1ca0eb8b34dd2bdee819dadbeb74721b08d9a4bfbfa67e0f0106c935e690550a696c06bfb44348a3203f59b04d594dc85abfa8a27803e0149514ac81d8bcef45ea7f43397ea1348847f3294912401bb8080d056dfee8090f00e666175dccb84cdda917d765408b4421b32b39b5628654badf988876cf0e08cba90f25d8220d3bd120d22901efe38b75d40a3573dbd12f473f948df8e6074a2f7b3ae1b13a416ef039ec8e0bd80932f84f4e1aa7736335157ba71515cfa1e8b045b26a5325b9e8dc606c20a9aee13c9fc716ae4810e6c13bbf0ca45432326854de81ae7b8cb9446acbb118ae4a21b9bba15cf7d87dbcc112f1ab8e1e446732257688cbc17d0c42b230b1c24c619364511eae62f17547b8fb048b0ed25af0f20c2a7d4691efd0d27fd1059f74ad98fb1e2603e3c68cc3619747a3903e0fcb82cf414afa3c0d0fc50d2a650e3554215cbe4c67498d8e6db1eefd1bd0432781e1394e8d4814b64dc7b45c4e3db97a168ff2d24d8ed7400943012c146f090f7a79eaceac282ac83a89b1f4c9bbdf35b56322a094db2ca78dc34fd5cde44db54f3e6de1dc0a6fdc734d19ad75382d5e1657ea90f9380b61459988eebbbe94d44edb671accc0bf080ef61203ede615332a06ce1c0c0956f1718f3b46895fb09d7d5247fe129d7f60ca1907a22b06b98db8d4c6557d85b932979cde2238b7e3e4d5a8e8b31d49bc8bdd7e321bfa8103b2021b161b7d74a9390e359523d06329421cdf19b1caa47f4cafa014e04765b76137f18e254bc44fda8124adcc407f6fa5dcfd3fe255a1edc83fd3e7df8c0a50fb7d3a455d068758566cd6c443385c305d7d330ecf225bb820dd0a7db0b55c81d8d10835a4d4da8e6c4afe55abe36cee10ac48bfe2bf4fbd8434f8069d8a971c03f3afec30614212274177ae7f3ac1f3a7f0acc11651472544ea5c338c9b97223a4321ce14121eb7bc015c49c44d2c7dbeb42cccb3dd9c2d7bafb388f68be793e160c11c85f641c27637f112571786871356df5928369a978e14e44b8dd7738e056e159445690112831bb5a5b71cbc3249962efaac8f90ae364362afa40a3a2c0b42b221478397ddd2fd7af9e99849879db18f45cc3a53bd23cbd17c28216af3702cf742ab9018a4f405bd3cf35a15eeb1c2f36eee1fb845234947743bd6c9b9dcd9f68d1ee2c4f607a5343abdc76c7fa8d3dd8d406fa56ba2dc8134f995a43f52e5105aff6941f832db3967c789a453c4c55eb1348f40099830a7b316ca656127db995435401ec6a176293371db8b083c1656a8312b0205477bcad0d4a201fd52924a99d4743391e02bc0c7b2afd6a525f8d7e5417a92fcb71174ec6c951fe5d8805c3fce1986eee9bfad06f9b16024c6c19e970acaaa1cc742f4643be1783f0e0cf0028ef14c6ed4df3a584bc416918c0a40c31d77a0874c7c64e3cd6bb55ab3144530c28346608bb744ce19b93e6e4046df1e4825eeca17f4b9b48209cdad2c8af31192f0841c2eb86a22dd1540e9b75851d5c6556de6acc36abbe8c328c3a2e662cade9eb17867b882d020a4965db733facda0adbd1c09df9f22ba9541567705828910abd56f4256d25826db28a24809ede185c3d52366c1d45b1a9bc78270e3dd397439885694efac3b44e9233bc134635be5a584d8d83c7ebb892037cd3df2fc96830ce5ba34d97fd0920b82b375466130b9c7cce93b1dea45e35c8a1fca0a59c513870676df038e887dc47d65dce909c7886bbd75ef30b32d64b667993947dba7e68f8a3afaa5a8c160e167d203bcb9f8ca3433f04610dd8554083083d851e4fc77a542ae6f4b3ac61ac8a8994f7f60cc42d9f521b27be26825d83a1d3e7c0d8fa3f39023dd1c1fb6a50526f9a3d2f857d007dd87e6f5e93d2ccfbe87f9408de13413b1696a6dc09b1b94bedfd0c1b9dbdbf18e05d7ee064a3d68f35b2e037baad26f5a900ea7b9eacb73328402679a7f0cb61d7c116764f33199032b920e89250d2af76e138fce113d3b39a5a04b98227474f1a9388f817068c77e381d69feba2b3adf38fba2fa2dd552c18a33d8d472762190fa0db46dfcf3bf99911fbcc2b1bb9c14e151f20c2f415ca5e98dc02ca31ef93a987d5f3acff6fa7d5e3f4cda883662b21831338840463222cb226d50a6abaf396f0d2b5c37fe6e679cfa68eff68892457e2c1c7d8b690aaa9924602fdc3bd3fefe4496fdcdb12f30ed2153ec7bfd2f967a20dd0d27cda923643291b8ec6c0ee403d1c594a1163a478149dad8d68d17660e4334af3a7776418e83222df705fb171f45c8dba2ea762a0f880eadc76cb83baeaa2faefe5e19015dbb8e4af4cfcfd47bd6b460b03b496df4c3a07c4e23fa276f9bd165d668ac31821f5c8b2b2b87ed2ec13cc8457964c70336780694d9de0d8139715acc67b2ee085483ad9f60ba8cc8a47917750a5f922ece07cbcbdc1a133369cae4fdebfde0d4dc1ce503b2829a5574bc0d77388c4f7b242dabd7a53c791186f03a069b6b6218102ec9d10c6da40ebcde63fae78220336ab0b7fafe6402170eb085c777aca5ca64c081903d3e51b1c62dccb2f0a7acbc0d86c13dea6a606cca62c1312ce27f290c1b42e787d43c8a0c3ce8d83daf8edd9a7e4ef7eea9768a37f033022513ea253d8547cb2e76251275ae9f4b18c5171c5b9abd8d947c7ed2049c15457b270de354a9ff23bbebf1cb95686dab12822b9a2ea4d05b13dfdb53a8da4b190165de6c14eccdd71b67833cf24323c0fa0ef7c0e8ba38342dc44b3c99f2ac2f90a066fa5daa57c3658e45c4f376df67735bfdc4c427624325d044da41b67a1db127187688f7cbdc1d3fcbbfede17e5a847362551c5777abaace8b2fd5df9bc4c35f7745b780db694e4d83bb6e8f7c60b41154538aefca85eed64cb8d96ebe7b8aed60c3a0fd8ad889ea898b84d82d1ac677d0c6ad756ac09797824bb84f7ab7868af8d17370cd427f832e6f7524b58b9708764b8c6b699efcf89ecab2100d44bd94910e76b15f63ace3aaf9c421d11ecdd08390a6def48d3e3f42c18037fa60290072c650b14fafac4f477cbdd8d3d4fc6493edf21011e32c904e2fe18a02b802aa9166aa4af7a792156b280030c61b11e1013b90d09c0a563d33545f19f20c6c4772e4cc95ea4042776f2a96d79b6a7bc8539454f9544035069ac058bad259594f925cade4b1406b10b0d955fd07019c727df3ac903bdc709ff230ca5384d95e51a8c3e8a7d95a1ef9082c06434109a730a9c123f11273982068a5c7e892e7ae3db0832a14051ec4a88833db1bc323500cf86eaa3b0e6874052e703b4e019adbc4e1ea52125a0775ca0585640cc1f54c453bce5476395febda640568bcc435fe572d0fc041a3ec78ea2856d15ca7c93b3c9532ee3cccfa2e69320badbb79f27c032170d616f024d2e10a202027917ff30f271f430bbf6fc33df90fb0ea52e0047776c5383140aea9ddc5feed209176e25bfcbd0713e6c994f075e715b0808efc82d3872c5a51d8a45c4e2248d62510bd56e7a60758aa79b37856f0c511066728343e81c236967ea106c24ecffdb0f756fc0c4aabc60e519827101812480e90daa838122bf062516b3032e0eb20335ed0195384b2fa814b63ec47000290a0c304f50705ed5ee73511b91fad6d822f9ad53e35167bbf4767c67aa720db79ac84e3868b961750d9dc4b42e0c20a74d6e28d0888a609d3f3f3d46863bd130229bad4067f874a9309f6060983c613caee44370107754b6add8870b2f77b890a78bb8b6cdf08a2f0165e4965eb4492a05b06553204d7dba760f5b57d65ca7c1fcf9113495dc8c7de34b9316ed4bf461a58c27abd7b9acbff96d9cc298c825bd083ffdb0602486399d4f58c2a38cc0b4f82a9ceef6afd13fe117ec5627eaf6afe5758a31a0548bf01d562932b7cd5c81b22a7e08505829bba711653218f6247eea2287ef6bfdb7e3d3877b20e1f4e5c87680c5fa95f3cafd819a1246268b2ab07b4f16e8f78a48b3cdf76293bdb758f83a6b11a17577a223df1d239898ffa432ddf4cb2b71abc6530fce149ddc12d2a0c460ae5f5536d26f120c468b46a9936ee50f8d3bed500a7fc58f6ad4a3a1c88daca94e6cb3e2e92a225704f3120ff19a9414519812713878feb6490efb03465859ec18494cdc0c78c4e100ae800dfe06ca198b62d593c38c400e7bf8ba6bebab98ce40a040e99bfb5e410dec774490d31d91d364c9691c8aa456284e32129205e5cfe05224c20d65db329060d0e1831844a1c728ec2fa2f1b5e568877331e861e4545d3f12fd5c01ecf2fefc833a5ad27f1449e16043fb6e9bad5258c6b84fcb37d209cdd98e8d386add5192d378ddf7a347d422dfdad85640d37fd922b5918a8c05ce6b74f4fa57c1827e526af7b0435275e73dff008aa0e6400ed924db738d0186e0a7b22f0e152fcd4c5f6f223144dd6e84279cdd0ba0ad70e50bfa9c9ffd5ec82517ca714de588bfe1643d1f582bc9d938fde17efad8b44925d63a672c607e4cdcbe59765aea090a053ce3e65613b953a521e15cc4e5e147c38ddec817bd37e9c4dc349797d6382a4cb1c386d4ada13aea0620e16354323b4e05793b641c5e3f236b6554df1f60943048b4b114266f32bb212dd82c43d167103e21e070626c31214f28ebd5ce0825fdf718b57a287115f0811eb0549c3c9dc85828c202d38336cdbab7e38ce3c7e8fedd53cfc23ede2d70aedced8bc3cfb36a0693564cf2d678e968562f156b61321923bbd5cafd24821e1969e9b6247bd897e922d97ef15b2a0e823a77f871d989692912004d17fe6a7f31d4a3c63c6b1b0dbc437e052e69175846bd714000a0154cc02f45d0a95cc62f90a549706b052c316b22fb9efb7c368e6e2b81c0c4969cce9f47ea0c3e8443c114f159745cc6913df539182e89f666ec17744404d45f3529c91e6508aaf9d65228309c0a2859cabbc962d24772ad8338ab75a85ddef5009f998bd5b172e482a3e045a645929a935b7d2268b694e4ee169d9dd43baba9fb2e03615904a5735417f066219e3ad49d839f80b62e2be59c96cbabbf3b39d7ab30bbe5cd538ba9216af13972000fa3587886afbad58a2e96b9a5c69e3974558a14bd811fda8a5a40a392de1bbdb51fdaf879fc8907065c80140c81f6501e1098cf89803f0aab2463c86088db18fabba387242355e132a6562b2dce23fd1cacc247cbea33aaef7d58562218cf7378eeb7871caaec54140f05d63d5a66885e48284e17e5518bfe72b1f206ff47ee45e14301217a763f502903b7a5f05499c2d1c0da1b9f6f01c55d8aeafb41bb0262ae77bd36f8e6394540cb7e65d541b6125b0687cf45aa6e857e233be99422a142631678d2afeba447509a03fc0b71fa679b686a597962a4c2b9c05c8af8fe71ebb4c2576771bc054eef5d5f7ec8f0fc5a3d2d51bf62f70c412ec6f91ff3b9005605742d105dece10eac747191e8d3f6e8f0a8e48e77cec373ff5dd30b664aa51a4e95e2a8647e5513444c5c6f1f247c0c19b1e4a43447043cfab6964a7bc2319d4e0e36761dd7e512daa5bd736d7acb6e67a1d277d027f41aa6545da75d2f87aaa82f717643e6b1f338f382fb068d44f67eb829439992eaa65cc7958688d00d6c9b2f7ee746cd7981a55b81f157efcd3f6316cc5d8bbd5d9c5a255c32e6989d11d19368e905295f742b5dd8ad42676005ed10d3cec7c835d53c646dd24eb46c5e14c5632469556e74135d19a7d6a058c676bf93a985db8aa8bc8ec43206a0b9c588b33a00c0b7ed4b3f230f94355b27d8441fc89b6d3c97e1362b0ca68a660118e314fb44f256803f514516cd6deeb10d4877cfcb93b73366090f3a04353300a8887dbca6bb8a53a1a31e88da426513bc22a6a1f9eb1c245ee1404b7cdf3fd0ec95aa81b37da3681a84a6def97a2e6d04580417f63287fa3c1a97b72900de2f46e5d0889047cc76eb151cf58c9e821baf3a157d3275aae080f59488d4a4abc2d6925ed01b4408527357e62d2403660dcc5fec6f3033af75659dae55e2849e948e54186aba4b57b0969e6c9fa61e78321a91604f5c42eae4499f68cf19e68ee1daad8cc7ec7f6b29dcb1673e26983e0909f9dad0bafaaa74072ca36702083436ce53846ecd39a8e8ef4d8f79919ca035a3e6908cd8bab82f2bef7bd25f2e2e022bfc4737383256a7655ae32c06da41cab81e32a751c947aa23b982223a20571dc85138afb1dc294d4fa7c69307ef1f1eb86a18062ffe8e5e76d3f21dfb81f9138554b1cbac01173186a6a7ffd4864b5a0bf70a975e7fc0897b7f7bc27a67f697ef5292d998aaaf20699c1e362e980813d48f7dca930eb3ac5cc68576998e8afafdf5c4d55df996d0c11f2963353bcfb64527361cdf6b8e3fd2d68570dfd486909446d571f572910274924d1850ec5460ebaebf251a356365f872110ffe32233d863c783123865b591620e72bea5e932587cbb109a9744b9a12a381b7e9ae3981b0794f9d988a587c21624e874db571bd1e2c689ffac2df3ceab11d13ec72db8d910b14c0466908c6bc0680138a2d54a581dbfc5c417a2335868e77ba38766da0408b7b0cc6f8ec9fe7fb6b8aa3538a7b75a94a66cc3b7e958ab6dade54df4f012c005bb51697985cd8338a50b9eacb5c6a2d4106c4cc6fde34198536be80eb5d1f5b69a52c0162ecc4de63ffa976352b7f3231ddf42159cc59706fb4031ae18a7512f711a3056066a7246165c47719e69465bf85f1036fac7c25d7d9b8b26967b55b5946aa8b9482143cadc3742629adccb294e40379ed013106a95a18f5f677df6993434bc03dcd042fe289417ab4b34fc12cba1f49301d575d5b8f2a145578dc6d93ab9b13601743bd626c076eff9c9b2c9ea7446d24df9619d42c59e6b3bb7cfe8e5eb7522d5d15876d7ad45f1ea4321ea5e959ab45bfe374c29e1bc4bc2ec8029487b2ad7d18bf9f73a363d8c72fce874013e076ff95d128ed3b2939b6629dd3c0d18b99373afdb5a7d1e8eb7d9a92a8f8368aaaba5a4afd7a2593f34818589047048999440c856d152228e2878a5a27643ad9508883712b84a3567859c7714c938445484444f0f191dc1b2025bcb9985ca004927a4a5d0d82a66cb6503b144ba6dc64d70589743e3a7b81fc3d69a622f1c6d83e3461d0f641645da0c10fe59708a7d70f2063258565cff98b1798b87dcefbe74e459ae8e898994119cfd45db3bc0be55945251aa377efc6c74a385750f5e02680e4e96f33f335764ee9f0e071ed3f58e295b61c1816496d5c53e5ee6f9d3d24e3310ddd652746453b6b19b71cf7e6911d37d311874fde60d0071670e15489ebbb3204f2060a785e355f6973b099070bbe8f875818ddfd51281b0035154676322248f54ba7f71cc5734093defbe124be61f485fe016b79c89113ab01c349396eb9c0d17a8cb012d6f1ed2ede9855ec15e68004826013554c4f0f7f625e86ed9bef7b134381295993739dcaec92e998450082bf7d514b103bafa880ae04abde20c9bc2fd0002c60b9d4f59bf6670685b1adc145cd0055c80315c6930dcf8c67b741a609e82b74ea1b4b85f0512f9824c9c32afa4739eaf5530ef18e572dc04b82090c14960cf4abc33b561be900b8b141ed82a12fe0af2f024c7b87c40e04e8deba50cd8e922d4fad9214c87c2e765213274d309a77d232d0a8f1d8e7242493b89cb70a565f091d0155350fc3bd3079f630b4e2169d870c06c75f675d64bed3d3525ea3553c6dd46a551441140090304d2c1ba140bb2a5d76f470b19f62ef1e1a58e43341ce5b054bb4f26050678671bfc51e2db01770155f27c57da1e26003cf3b0805f953d4fbe6bf454b6cf8f86c91c1319d2570ab7181b4fc387f583fd8cdffb268161042e0a5ab8b484635e28f0933b56bbb6e1a8bd8da78380c24f730ec4cbebbf9d8d7aae39649b390658d54a4f08b8a3942b5ad31ce982fe27bbf6cf2b68b6aef14683b5d641507ea1c7654b7c88624850506a32aacf2bc2b092aef8551b7456aaea697f100361fb1d4632778012ef12b71ca1ad9dacf3cc7f3cc03f668f3c7ed42845f92607240f13a6a2f481ead1d2189b274867e64cd4ee52ec2c5ee4ed9e59f4cd63f5a0337b423ac4944a44e49318a22115c5b6bdc1501ec9763d5382c3c40e872ae18971867abd22fddfa0ddddbd400cedeffdb53476c9a839090cf676ebf1d377d07ebdf97d062d86ce7c14c581de9b935f1b366cf3123cef23c760ec76137de8326a8866d698c4d027d77ca0de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
