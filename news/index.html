<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c3cd8be779f8a310b889a29e5a0ed8f7918708e98f7624e2407c20dc60fe23086ccab0b8162ae432928d5b9459c210de8c50366206e71b215b6d5e045a42a9dbf73111b875cefab7313c620bcf20747a16a6ceb033a4a4b25be05d8ebbd4bc80d86e35c4dc01349a21c5d5cec15fcf91f7545ada7db85abe54ccdc698a3d214f25242907258e1cfffd6a565426d85b71201a78e3c1b494f36c560b02e365287fc1be1852a140ad1e28acb1824d2ab5888ad000dd6dfc6c64771e803f7a00847ab7f05deb276692a2909828f8e9c7c5d9038990df03e1a67200b67202f61118e3319d9e4f48f7752054a6c80d890c821f447a1793c84cca95fcd4d60f94b255ffae852a0dc762547ff098e181c04a6aff0a468802adcb71fe48e23fe273ef18dec5fdebd7bfea4ecf0ed463f26ac74a05da378698eaba0e1ad896500acdfc4ee5d50136f8deffcc789e09c431b7c00757f2ab9a5580520a137f7252d221f71e58416bef8cf282f6e5fdbb640943a2a6743a565d508aa58e71e129c31d3f052e77740f6847b4eaf6f9e62e331b725ac2472f2aeb9cd2c80802ad1c91f3b84c60c3ca5c2f248ca2f8b3459eaccbf165f446e345e070ed8926ff7650d8da1af7683830f70ec68bc5927631eef6533ee125caaa3994c529bed4eeff58d6c985ab4ab0d7a56d9b2bdec75e63c6eec19b7c7828e41fabb784f0c7d307d0e65d9bc12adcec5d322c6ca631b76003b07d3c517d021f1fea367716d556874a674ce2df49d4d291bdd56e8ca69404040edf4b9c27083ab76bd390d291c29252ccaa6165ecd6d8679fc5c631a4dbcd606ffb3fe04b0aa686ad343e4deb9c07747ed338bed731197fc222efe1336cc7967196b0dc643718770808d75eee19fe2c628537d476866a5c6c88e118d006a72c35e4a9986380b1440b13ebad82c9067246371f7f8ba092f92a45e6850404f2fec705d7a32e2ea81bce9b3311a65e50b517449c63b3400c60cd8c58908c63486539af879cb956eed79faba5bcde29a69234181f11b129b89a1f8d75bb8498f3dbb965113be045c6652b441baae19382bb29865114b8217fd1b11a51dd62f3e0652f504f08d99d1537fc682c664c406e08f08b6dbb55b95775b2919819ea8a0ea42dc58c7c808d1d5e32dc585e1cdf02fca212015c5563d16920f42900cd2516171c2c5d757eb8a755d21af59685dd868a3ee75d85c5908f6a86a0ab1cbf972ef64b59cbbb3ffd170e075c473242036b7f86e3d1bbca6b759356d0e706d70e1fef24b127fae8faf1174192b8e3087e7dd3e57605aaf6306665dee79826a4dcccd3c2077420e0cafa2cc83d4c74ebc34a00ef8176bc053a20f560a63a0b3bd6b9335372ec51a3e31ad32978b2ca4006496bb95b983352e1725055f19ca1fed17c7cf8824024aeae2fe63b161c70c5efc7123282a108a8fbcfb0e70e0ae1be12a5a4a7dd782670c418732f137c9cfb931d09cb40547867514f88840b07a43e030e1cf61c1c3234681e303910d0ff5892374c062723d6e13917ed0d42a3f5d322e68c2009a7c08dfe2297694e3a7d05aab739b0341c5217ef551c68c1de6c602125fce910e8fe68df9a0c03ff9d9536bf35fa4cf344073d6ed76a82c37b93c79dd49532df7aef3006c609718c2ec0e7f3b20a50b0e7f044a3fd4c2f7db49447470c6b6839e438568b53d3657b4a20e8ea23654c093c274b6f11770bbcdb0ce48d3aa2d7686e43201f3a1e301d7d7b270b26200355f84370a01f607a868955a0e2d552f47cf655bbc7afb7500c2148984f85bc9d4c906af80c4a85c98e68ccb56e712c8dbcc47f757e397fe8f838f97590de2ddfaacae71ee20d09ddedf6b85c3ec4004cec5b41ae59e2377fa41b8dbc24f863ae542c25056a0e5a36314bac355b13e56dc65d171185c6107384f7ea3adc9c56a69f07996128b9436079e56041adfe542b8b986554c30b63a8b3893706e9541f9d2ddf643ea91c54429e95b44cdfa79a43ee8239d91aaa4849a9674c2b9e0e70d20da5b2e752352db0285f4d549f04713f03d80c71218926eab74bea1582cb5e35c418d794d9894cbd907f83d5b23a6e95ad09b4558a4535586a159fc6be22816b27a44302c8449a4e37b03b8f88bee9d1d78831878a3efe926a3cf08e01779e09e9a48a5bee9474fbe9b1adb09da43add3771d7c5f48ff5f6fd21d1349fd4ded599f1520a3805e7d04ed5172f5a4bb3e97764ec1dd76217f577b13ab86f7ba8eb844e46541eff668620fa49e1a27bb6c43a6a32cc518c25ed856bf91dff43c5e27a52d6078b182a5a40abe7b9438200470cbc8592788a1845b4822c3fcd2c9bc657c5702e477b86806fc0726e5978be4b8a6c88bdee256b3e5b5fc2c64724586bf5f048531ba96408fb964ade90a031d328fde67256d6ba9b1645130a70b115cc6b679eb07cb82b52704c6f90b07c97e69beaba6adad14ed6e89467110a44d8f0c1da5498f3ac8221c0ee950baccd886d3feeb257cd06603f373127a9621184b054664f1e656bf7a898de40ebaf9f73c94640dfc7584dc646bedeb43d6e29bed9d9baedf1475c16d045aa4da6a939f3f350a9780c9bc8280ee690a048f31974440c33d1eadbdc78a1ea179db30a0f312dd1f0284e7228988d5fcecfb694c91bf7d18f358ab68d687551085e0cd17c90f2a22168857455e0b0d73d234171658bf225dadced28489d96be8fed6f555aba5ea11cdd5fb508cec27b44d448f1870d88642ebf5e1a7bb55565be92ada12037e82fe34e3d70dc3fa7748f87e27b9dc275b14ed12f8efc2ccfef38da87cae7388a6c6668dbca5a9a81d2d7787fcf0de7b09ad18557a4d4e96464d63bea4251ce3dc8a75d08387a06220e55cd0b889f0879da89e48f5db38b1a45f9405684de9ac2a4eb16a8dce3f291ab307a6447e8d23841928bc7cacef35be911bc6722fc20f6c0db7205ad38f67e9f59d66f5de25430eb12862e03e8a801d673b0e0a5b84277dff3a734bee91442820d3c87a7e5b7880a91702f3fc6ec488e90968b04a0316a4f77df801d4818e5ab9afec9f27e9b218f0360a6e6676ccf140f788efbc6660fc8a92adf553d1ed9fc21e1bb79b716897de42ab30960f5df69933e1a23407bd39374a4d0e370f3806ccb5c888de37bd8785f55b48e4299eb81025c2e651c688ee210dcd1968d3eabac3d749f529ca44a49577490ee669bbb8f30c63a58d1e67748c9f67658640b87e41e4def519bbca4da72048c9e0ec8800a1520f5ff0699c420c33c4d440b1522dc4ec4def15c0d5d5aa68ff590e5748c23eceef13656808d8e95f39134fc5ea5c6ce411f0828ebd29097deda7959cea625778d6850ee9e3f744610ebd6b31ae1d838c4bada74646117ead0bcd66245808863bb110a3f196099800c3f0ed00964aff7148b8789ca3d483cd99aba76bd5078827094337a2d99012ee03a43e9d8e5a5d2440d245d5de9e31b894a0050cd31df347cf9fd9e29754fbab87cb0513310170d3d24e0a6d3dae39df6142d88498a9e9580622047c7fa7d2c74091c71de6b075d9a13ecc1b678da619be41bf956ca8dc303e8f21a9e3affbb34a9f5bcd65bbe641b3214773d6d9011734270bfcb9c1b0c303b5b0f54959a8a682e783317898bb77e311f5119b55e4490ba25e139cdf5970d5fd91b8fdebb387fc2aec2c085803f20f8b01faacd61f953d46f564135aa44db07aa448c51885fd2f46e3afb81feb357de503cb91d1086ce672ae8fce5614b4afcb1755075e5ad159ec803b6af6753cd75feae22fa4f05da3e9db44d69af2737114b99feb4602836c96dac051a32737e082db5677e734047a275e59719503d6557792ff474d74d9f358095316441fdbd00c23dbaec12ad4facab62c21cbb35e6f4f96040fe9168d4336338156d318d59a19578989f2adeecc047b4497d7fc5a5a35fe703659e7b880ec47d43d1854fa5effc346d3efd1f67d4df29ff29cb4112d128ecc7958cdcb233d1a74e435e0a01dd7aec9dbcbaf4574f4a3ef3c102a5661ad6e42e567efc6f4bc3ad7a87c48bd06dac7717def3419518b8713118a4c9e473139c85e89c9ee319999f3562be034daa60663698d6edc4bb2d4f74af9c3891644d753225e291f268ea7398c9aac237e47766f4a942c38c6991560e2e62cd81a180e6ffb3f53f94bb83191ae10c32de285b5a9bd141a7801c4b880faca87bf375ac7adcb01fdff26ea0701941e106072e4f2c6a125172d605cfa33631189432376637953d2834fb1b729e48a4dd595f4f75eaa580c3c9177c781f28fc6c40e4b1a6995b804fd635c7f8a848a1c6fa0576905e16b99780afa3fd020d2ff6068d05d1a19582d09f67ffe8f7442cd3cd6bb78521511d438fb22807be35cd8f072b93a21e5d8bbd0f6493e3cbf3073d950c01ad8470f52776a8aa090f980e08fd7b98c9eb5ad85f2db73440db4c17cad0a51e2b0c74d30021abc68946076316dca258064505ed42ccfaed549e10817ada28843673442acb917fb50bd4b3224932941ed44a6d837837121844a23f2175ae53403dbe42a2086f4cf37ea05e16bac6da2804e9bb041c7332846e611ac63be21a95e96d02ab2d47172ba36bb747a68f0f92a4e2f4a6f17bfcb679708eb8daca7ebdc43448a985b0f441442c2e7ce2c0b5175e64ca852bfe40658343ebda18f48428720ba1b46c97602ec5a20bef904d387275898e7cfebd8904d89de63dc5e979c8daeed13780b78a213d668e2d6546aceba6d646c9dd44e6ed32654c0aa77e94562e16053d71c57063cdecbe8247ff4c62db5a45c7d5e52a7c16bc0509e7e9d1fbb5037c455914888fc0986307897595fc93050b55a34fdc44cce4a17b4e364b53c0e3a72eda3262bbaeca71c42d3eacf5818e4a63044c4d5496637fdf2d455fbfb9385592de9c1b68010a0cb5ddaeebce386f3a2e442eec1a5a1d8530b753b7ecefb37b52fb2fb62517bd0de54d8b7d8153da248a92113bbb6f6812b6993b4f34dde40566abaf36e56d2ba1bacd8ba816eded0c539eaa48d5e8a354233f4daadf9ab185dae878d0aa9672e495e60fc1c5352340b4189c84355d0635812667fe3020c83aee2cf9aa341db6d899c2cd61ad09eedec15288894230c9f88b1cfda64604cd7115200e154af0fec171ac896649d250daf3b3558b0ac3ba39182176000c1465780e6768d292a13e11de83b4449639688405558fda3d94b325905cbba2d8cbcd7ea72bd8f62acb69ffbefa478bb26c781fe53760208a2066599d80af9357e327bac0d1c683db1192396f5d75039e535717d990037d562e33b6a56b9ab48d7d22dcd0abf4d08cc63aed430cd4f9a407e8e1cb273cc8238268c92ff3725923914c6effde802f388e27a46ea64d9b2daaed4a26ded346ad34cdc6c90dde0e65947313a2c391ccd2ef0401c1cabd4da1724b7e9251e0d70a2c812cc513c43cc936e6a39a198459473608d0561c2063e477a7dfc67a01d234ce60af706647de48603f705c9590a18a1b85e72900b4c361d6844297fa831bb7037bd2689524b2255c5d9e1c377e14576878f67354c770f700c51fe348caf6b30524fdc55ea3bbe60191c18ba78246deee1c806223570e37d6c54527cf55d400403db6783739636060b264ff51649a868bf0144022682d46ae57651b89e6916ef259ac5b65cac2b1d320ecb4906fdbcf2e3e05d388b4acfcbb376f06d12782e8b79d6d2a867657f301b4771dba52cc16ab7da6875a818ea285ad0079375d944db6b3a9c38c0c1970a1be13d3df7c4d7e336fef5908afee0241b9bd27238abe9e55e658528596f1c6013688cc2baff412bd1a9d2199ce7572c0d77d8a9a574d357e4a6a3307597cc0ffbc8f01498faa80fbd8dec2c1b3e9ce0d09e597ef67dd660657f13e423b0e7f039d4fbdfb6b980e42816d5caec179611bb116a3b2e1ee643abe08f9b79946fecd0ba77062153f28a7b3c9ef5ec63f0f11397eae68e1121bc2a4ff962a74184b115cf20fa2cd8fca550fe21f08dbb78c3e12307e875e83f9f9933f635f26284864f8a5b4e5717f4115062b84cb25d8f1b8e0a0b0e266842bb68905fe42f7dc3873fe7fd7ad26b5b43e48c512ed2d21716120d5c15a0b6c61bf7c2d63e413c3887e7c288426b9c2c93544de3c1dd23bdcf9b2408c4a202aca242c6c98bd2aed9c447f44984578981adba0f77736bb74448f50209b933a76b31b6b9459ef19777644705fa05a0d7e90a7e23f0e4d0824b8c03c6a73d061c64de0509c4c7251ae3b696a4df60014d00a8149f3fa7ced741a0012095822dbf16877019faebc1fa4e9d771c9caf06135903e1b4f045c17ff70a7e71c526dde8f58341e4e772b8097871d23c789088a4fb4ee85b3f4b75ea1ba7e5b0f8737e1ca1c9d7e76b2a4c5ccdd52a81bd5881f04d4bf8df231e2a6cd2bd6fbfc1d290957604df5b57c0addb8397ab4c5f9103ab9b4ee283f84453deb575477abf99d4a17d210bd4c2b2e72f51c4f59823a3e175d4c3762ba3ef41230f9cd937a93bc15705c89069abb05874c3681098bd259b1c1e3730d7dd36fb5fbb9f49e57b97e2f0864dd5e4b12ff9b809c5788a4d68ebffc984691518f4d4add344231f4a69a79684b9c70414bd0de640f722afb97b1ecbd00befc6838408f60c62cd7ddcd9dbcc3676226d96d79a4fb9f51814935f629bc6f5f6b7dbbe656c1ad69fe261e5cbafe619d4ea5aaa584244b288130205bf37a3966e08b9ca60f1a1d003d1a97a3fccc357e639fdb6685cfa8375540a9a68468651847a1c653d01a7b1e12e322b0dcee3c991ec2fb85334335d169f0463def99dfe803e51d7dcfc86b95129a6548a4ce5f88aab8e187d08ea7af1a0c72664a737ba94bd74d00f4ac0490d2ef60bad8afcc6b4c6f985713feb104bec80964e61006b673f8b2548b17c147ba8769e7d79c7a337f980d07dc65a86b4b26860ce74f5a840b34eaefa36faa0eb8ee66289a993cb4ae359033f966508c3a91f8777a14087837b54be9b613ae7f896fb7f64eaeec739082311d7f1d9d4f7ed3068ddd3ccd563b0e5e5951a765fe8a5360ffe89812d6b53cb387fb5db688816d769cba57b381041d35610aa0181e44313932f04fbffb4787c7d09067d2acd7f195351044edc4b875b7327f4a39e2a3ebe5b115c2870ca9246ba527dd1988effecb22ce5fbe2767d3c339f644f79e745811aa606269c2409f5d0a572fea6a805231a65b9e568033b031177c475b23e45fb9631622484bc06c80f4060180572e6a424dcf7bc507103af13634c9516e5ee2ff61f5af9876bc801e85dbc386b38944ad8286295484b4caf4fd7310cadb38a1588f7d3df893fd6e105464a245cacc5c11fd45a1491df588a9e73871f97ec89537b4f0624c6c6fd23d78d263860008d379e9686c3471868a8d213e58576b4e68120e34f7585ea825add9b3f2208b3e43c110811b9a38d4058d4c4afffedc5660091defa6083bdcf40cc10648a90a79059c7b08f2085ff16981e27866ab556d0afa7b6ef73b1ac34fa19944ef1a868ab2b66a46872833cc654d00aaba83e44c6a697620003fa9846222fc7d38e7b2f89a45a63ab37efae7f95645e6853406e29784f8f5c715ba828468b1e66cbd4eb281c59ef752cfe86de1cc222dc2d15b29ee8203bbf1710df3aaa38e36ce1a3f58eb4060523b8a457a52a07af87018029eafe81eb807e5e089bc4cb05fe0617dc85fb0c928e4dcad0515c79f8dac4b8be3b1246b498f784caef13b3a9dc90e97f87c8d2dbd141c58abd1aadfc1dc6097890fb35ad7643044facd5b1e6e2ed24d15f87d9137d23748676d8cf7da1f2f6ac8fad408174df8be364cb1bb15a156a6cbe28b4949d77c152e44febc371cb7708ca76598e07ed6782853f1cd48975cc3142d15a1eed7668fea55dfceba8da87d04b7c333d177b2ef75eec7030596564ffb0ab18278075f69317b8ecdc1d2c9160fb400942572e8acb43ed631dff2a46c1693553d2d0fe9d5a6ff7a4a73f2224df0d6e4fa2a21b594e0c1a6a1db52cfcfb5e9fa60769b76956415ba2fa4f3d6b93c157934efc62cc66e759b406c690cdce6aa69affec45aaa2ee9aeac5671584fb7ba16341f7fbe3995d82fe51c1f324bece25230084a5d2d4bc12bf2b9ff5b2a799b1c2ed441df7ae25070d5c93bf2b95de8dc1c30ad6bcc649a4f881e896cc6b2e2a214fb3926b8fccfc60638daa4b76a0b5578b00ac86522a5f1d9c1c452dd92e28bdd456d5085096a534c37f17ac5ba18bf43cabad5bb8a545a7613fc5ef7f6176de0a68a842ebba481632361f94a778b00cc6e5a75a42face3de15fc3818464fa2708a41ec96883514b98f8950065e5f6e4dd72e853ec5af9caf08f8430775161afc9c48464f81cb952c54cd24fad35750352ecba58df1e083764e825c200ad14a05531498bf77a75ac7a4a93a78a0013aa316b3b1fededff213d8480d867c23c65e403d6bcc25d5b5801c1fd0abf02cb4d8e2f4797470dda52eb859178abed140cdcac816d792cf646bb7ac4a91a405f2afd19645b7eb9b3c37ab23d2c04a1d8260eef0fa22e6ff7b621fd227b723f2c7898af069796f9cee8da23359bf64a0c61ea524b52fea735d50c1ef8bbc6a241b34d8a38e08e98edff4ec48e9577d93ff31a91a3dfdceb0778989770cb2f27bce37352c448950d9c49b7b0ba7f0ff77947abe700875577d3a0fc9226332e339ed73c8371d0f077935e47de15dbe282d9cb60e6590e0a82708bcbe4ebb27b278b71da3a921c20c50c634fbaa40a807bfed405621562f6707f446ed2bbffd4026371be1ab07db827917e1bc2773bedd009cc30c4bedce4bd5be2bc71f20784b49a1bd0a14cb3b7c1af05df66ada4c99662aa2d2bc60722cbe516ebd69ba506de2ef80ea39f78a17cec4dfc31c504cf64e5e0d3786fb894f4a5d10563d2107db4cf95ecb6a60f42f85cc978ad13cedf5aeaea4823d7d4287cb37151a521db90236130baf9db2871f2bfa3fd7d032c7387c23cea4dd633a7d0ccce6a097b943b69764d9d242df65b9772b17d6b2a753b8485bb01b983bac78e932e2097ea9242dc48da464e30f522f97f3fbab7f703f460d135192deda0caa5b897b11285b62508c6577909899b152f527269baf14f05319e98afe8cc88141541275a72e6ac34c39858ccdc18498f2d8ea3d466ca9d70efa17c2c8ca0feb1c427671a3ffb629b03cfa4fbe7713cbad0ddf17787a224af77a8c94480a58968a0c90b08bfef7c7ccd289b635c821076379fc24fc3f027fdf02edbb168144214c4b276b848b714a764418c266e0e81cdb587a34728fe0556f1884ee7117313a49ba370acf5e3fb44b466634cad2db446957f84eeaae11da2af6f6976af202ba56b657b0740716059045c69f586a5eff6cee8cce9c7047d132d958babe606679278cfef64fdbd36ac625e5454121ec4c960b1ade7be5d8411097d61b7cc5d35b14192680e386b3f1f0a30e4128999b07ab6068d91b826ef0465637976397108d3504214254b3ce9b95c8b47c8a3be59dd3db2cf1fa6b206898ccf24f50a9febdb7e2cfab77e88038caa7acd02ec37ff813eb14619d6b0c444f034a855fedae52c63640e05868a7c1c6515d2ccff9f5330bd8ebc3c139ebb19a9dd3c81f800007c9dfb3847eda0c0c30cf93df5b20d60029d7816f2bf47117aa6c834bf3f44db9bff46a548c48f01c2bcdfd33ac290a508cfe16ba4c7a2235b690dd05ce864cebca757fa256d668715536f3a41451172af49c13115040d553d5702d12f132a592d8ece9dca68e2e2b2f46d477929501ee64240dd4b91e6a88388bdd619c4e68ec92d0f10982386bc0d4124d9daa139abbc117510589d28fb51cddc40a6211343d501ce76ddde110261ac726c449936c469f69e6192696ea298f4005ee714146f6fc85d3e2f5b9842722b3fe6dfc3feaf3cd830379f73506d2fd19f6934f04e8fa7ee5538c5730a5d67e581eb9f640246a937f29ec636a51513dc0387aad8e7f5c38321a468f37432aed4f6103c86a04eaecdff551e0975b0fc3436776454173f6f299e9c1e78ffa210332d08484f61caf0c05795a7373a842b1937ab0b4eae5954b2d0b797aef30d86a0e7fc451f7cc9640f27defc188deb17b70a0442c57638","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
