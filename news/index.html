<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"edc3bb328a9ef44000c4652309cc018ec077627c4719d07a308a804e9968d3be2267bee0b7772646699440f7f3f159ce2922bcf6ad7593e127e891453727df15b1c4e4b25728fceda239d0e4c3e7b3980207a6aa5d5b61edcbfbac06d831b48f73ce783b0b47b1a6c470ce47e07b08a6a524f76039e3280c3fbb5623e0368b728811a19592a52096edb154b0a38e93e382dd27cb4ff54d6e6b058124ca82007bdb5016ed9cc57422fe97390c6f1e836890a0357e45dbacba199a333c58c6f360dc3881cf1612131f5abb2fcba9cf50757b5a8a6529b3a1e750128637a717ac2c3cef1312e0d4d26a9f833fc383fd2c1517270fa738605e6e56c90146a0a122f3d562d9a662743fd00256b3851d02d8ee1161654dc8621815c2006cd93bb52d7600897e8ff086e5d667580fb249a5b151516f9d7d8a8d89e37fed2bdf00d9f3e307b0e0a8b0686b71a5643120448a053f1ae24a30731a4c302a5ddf134845fe4146bfbeab3ce3e5966517c19d5972d0db567acbbe1eb1086b5fc949f47d400878da36916398c25f45ab3a284fae82aa9c11f50330b049d0d069eefd875ca4141415010d936d49ae33e661374dd063a7d3eaa93b29c1782266510a8c8428ebda2a7084177ab187fa6c118dc4dc69c4d09906889a9a618e3e0f344f558d92375e747544ea55b3f5965d81c1e4aa5b6afada40657f39eccdef3bd49d66ffe5efbf4711b693376a0af05cf57e92f13fc754b892e841f9d5cd1f87a01c296de10b08773a343af1fd65765d54e748848e2ed0412f423234ccaec6fcc5c0d993332a49dd17c01cf64163a8f8746e99890661485d639aa1a0688f4148ea6f555e99d9ee64a6d978dd327e8c208f5b9b3a4346a47fe514b0c3d4aa335bc394bf8b50d1d8b708f786071b070f557ecf8a5ba6c208aef8606ce3e68185f8688c1d2c9df1562b18d9bbfda8b77e7aced0569d4b1fcf3490ef9b256186fd236c98b77477254cf6950451f190df23c000cecf7ee115f59b0f6b9b316b3ba2a47bae202182baff4562be635c92ae4444aae4412d83c4bf250c4744729558ce4b4aa7a09d9d302f59074de772949eb472fa37b5687960a1c579456e6c5584cbf0942d28c2b87c83800fbcea04530ced11b97c9ff4c65e0ccb189a7bc5f36d934713b54e20ca5a46d1bc5187b8523847b26490283ac11c5f77bf1648cde28a212689ea13d03dc84b40dea3731d8d68334c72ef7020101be24c645e710701b487e2a05eefd8e2c51ee177a3375624eb9f381704a20e98c309a9d404398246922c4699c35352e4b71815c0908e43f8cdcbd5415b1c9824d96eac4927ce511fbe72fa1f2f1dcbfce98951a1bc32d0cceb8f0fcb5238f728fba4658b168e9eb1a740edc10c3f185137568f9500054d5230b466e6f6f6ea1170a86126d143c01da48b6fb991543537b6a68b581816c7a8cdc76ca3ff60252feb4a236f935635ff49f44fd2b2722a3effe4252fd31296b9287d9fbf667f84bd76d9a2d54ac4a79d10e471872ae41d50b8b5d0350d4a34c7ce4b3337438b59f5f5b0cf330c790949f6a0631b7917172e6219187d4696b30c203dbd195517ae6c269fc1b8dfd3c22d1648033854c86f67731ed3c5bcbb192628440bdf7d231a43120059a72248e65e7cb50c495d5f4bceedc44ff0020cf0557ceebad48fcdff75ce1ed47b29065da7ce71c802c196561925f6e53295b5a891c70b9f196d21cb041448084c89ffe83e4f2f448c9e8368cb9112cff9846ff7e7ea61839cba9c6ef22758f8f22450cfc20b6e800c7865e302682b2ac4f9fa7af2b288e9f8dc8694695f81982a8755b19065ad178d16a11be58e9f45e885d80b1cf23d688c1bcf9c336b9e46b0ed8867a3d26467a7d4cd6e876107117412190f8f86365b7bde09d747e27f51a5c98b76b8885af65fd01f081f4dcbacc2f19ec44607e8f35196071a1baaf680b6c899c1726ab933fe6c51c51cdb0c83194a461a3f7908a96942727920a0460a2e53be986b801ac14cc05b5387f4b4e854121c3f0e5d450bb5ef728d8a9ca41ab7f3f94c236b28eaa950fd4a312a006c089b00dea1d580d2e9ce755b5b057583ef7bd65f4709e5ef0c6b8d84ca3f9662272467a73e90468bc34032bd24a5776b5c81e406fb799465037e9f1c7ecafb427703a09d5161f68c51ea5d0ab519b08e09c74b31cdb983033e78736c052ccf456374970dd01af2af2d499abb97b7e13085bd985346694d6ff2c25a1372192aa94eb9cf49f1241d9111255bceaddb709ca1b1485d006e08b97b7855f02794bebbf65a1a1ab8781b2310106dfc639e538469d6bf244ff2e1e135491c0467624ae2f344f2448082035fbdce2dccc2b548ee8336e0396a593adb6268f5731ea8d22a9cd6f16cfa69c328b2ca60817b3c4f3f2acce0d8bd177d3f846f25542b007de0f62b9a96018a6768079c882ebbb1fdba628e7e0f48b542da6dc4e659cdd834025966a63490c40e8f63d9733142fce2b13eda573e4ed50a5d2f6715598fa5aa4983a8e28ee4104fb00b33b10dda99fe69a44704edbb6f8a7977c26918a37dd8dfb6a6d858ec76a4653eaf076333a171f24a0223854328680f9b6fdd0a77c6999a8d0a3251bbb4f02f7b1754739b46a629cc0a5514d8134640290b6f79f0b0bcaee500a3e25455401ec8c9a76f2022a12a38862ca31b1e07ec9ea368d75f99d231936806612034b66d4180d719557e3780169ae1950e117e89d726f2fdcb3a5b64e4906be216e427c474ae93ef0de132962b9999163f34ef2ac48072bab8fed1e451e32710021dfef8efced36bc515ce05c8c0012cbba0727878dd026cc3c5dd35e23a1e34c4c86ca4d08a374bdf14db9cfe9e853d42be8c3c83b9e5313077f5bcc3b5bd8919e94c1f2d4df4658599db5bf5ad14d2ec115b5e1d730dd73c5ebe566953d560c0599f799d8ebf8a54c9b130e4ed9d5c68b1c5100081d7561a998a41b1c2ea221f1a10c173454a3758a05d4a1e631d2eeab0e337cbd51f2d732125131f5df4c5f89706975f95e7b8c8656c492e4ed57788ac6a9b95cb10a307cd05065bba99b9c8d181d4b7333e4cc7ccaf05102ef5c7d8e9232279d354b8011f2968ca05957dd6ddfc1c439ffb6f40d80b9cfa0b828565ff3e855141ddadb1524d44b55f30942dfc392f6abff608a681f170ca4e93e9a8b7027d590f3768f84dade7637d0a4d274ca3e851da65f918d0aca88eb0bd09956f005bf90cd8d688f9ed807f5b325bbc8ead176942d117137635233d010db6da7ad2218aea7de9f940bdc9d911c42c5670632e8dbef4ddec06c7d5b603bc0fc7aa229fdf1bb3b5ae2bd99a34522dcaeb110e71d310f24d48e5b593fbb62b025a0668fc8d7e568f030c3595c7292ea2f1c1c79d778d06010781c9c199db71100dc41d6b64e62e8b2d562655453d83333274c6ee7cba4bc3a7c37fd2f45a3a079504b8bfb3692d226cc67280ab786dd5108cd9fb7693cacd158c107c95d0f7d7c2441e73c2241552d6aacdf7876a786da92be4e528506edeb0a8628ccca54fc46bd407278c269fea096a4762d240950a84fcf27207b1327adb561290b304a95043be010b9eca1c03ff9f31ec826c9f475e97c5dbefb8648d0dcf53e6cf1fcb22b501b30011759314c1b49734d6908369739c245a767a26423a357560ebdaa00474f344cbf201b7b00eec592b95f9b2506d3ac69a416bbbe125ed5b959fe219b2886d9012c915a13edab8eafaf08ae3a4e2d7052014ad71ffb02c1a7bf0ae65abb66adcdcb9c37ce9e994b730f1bc2df5ff324167910da7977d2a2f8536152fd517d9492900fe89eecd8cfa365527848fcfffc7164818aad2b256135f64ab85f4e6f1ee81f01827914fd8248ed0dc56a52bc8ee699d7979434c3ffcb0c51293990ad4762609c60008854a7d994710d24f5c6b7716c6d08e54183aedc5f73c130d4653bf30c0551519a7739029e8917a6a5c38805063bb98a6a4034c9a1d3fd61784c38e4fa0ef16568302f03787909b21475455f6b3e4e673a2157ed6cc12dbe825a31b7e593f1f648f58f68f922d3fc4492d24bb4b3f2fb046e945bb1931c9241eb76130126b3c4468dd75011726e3b4f2f4b8c9f630e501735be6402cdedf7715d4fbfcd2c0bd00b2dc5fb6d434a231926e89197a4f81973ee1b85fd1e9e57857e7ef32f16368f2cf81c67565b3660e8cd5bb5a10943908c65ffca17e55ee71cd387c2e9f83118fd5324e3bfa4213906ab698ed3f51825fca5ffd7b4ac69c58a495bcb995473c03ba490783d5c4fe92f331fc355734d2a6b92e59250ea54fee2ae7302aca76a927d3b175b358eca99364f67e1d420b020e732cf887c333d70bcf4e4081463fbfee85a3f2bb59f8714cb39725cbd6fbd0d87978d899b2bc13972ca471c0f1cb75034e9ddc3a0c7fb3a1b2633dc369637604e054a2aa759d72ce2780af886eda4927bc1d4314215f64d2dc0d0f477d78fb9c0883215a6a050ae3aebab4117102a6cac5f20d072133e027ab4dcf28a1ffaa8164c09fbcbe10c4e9d87702089899df3d3896a0f65c82b1a98f14eeaa132c3f0cc9047372a88cc775f27ce7d5db1ce90c2a6320cb83506ada7e1ee5d278783c11f2a36f2bc1204e47cd037832695cd9611ba6a15f316c87bbfbd8f910d74a52cfebf5d49eb89e9954288c1910c257cba642016fa2a360528389e48c2a4a3a0d231f3baa7173e75160932e58c28815869f444673e3efeea4c5f73374a3aab104440f8c51b173994b6341287c762ab374604cde9c41576630392921d91d14129ce40f37fe326c009ec079beec497554a1c8b724660e32b51186fa9a37195e2286a5b4e2568ebd958776b7799fc9a06570d7493d20cff4589595ac22d990b4b1df480d8b67039160697c955d6eec31a2091fd177085f75805203aac05bd95d5423c70c18c1e9461e614fe8a21f5aa81add4312677aee568a7377d0b2fdab27668266b9ed0f78f3322d8b6e7764bcd649cb12c76d9aef86cd52afa04e8b3813475f3211fe78da9978470aa384f11e467c67a1ecde52ff6cc3fb33b3bca585f392f72e6f31c84534094eaa70dd32826fa4f3fdb54900504e35009fa5d78f298d9265f3933f7d51401860a76f0655746fb0a5cb1a8ff6df2b1a64aa1e6107b2bb2d2711da03f3627421c374ee39b75d0298de29c925223f064f9aee7f7adbfff9d7e6157571142b7e01e8e1156c34d33f8b6c7551b4e3061c8361c2e42d67c6830e2ffe0567dd421d06027c574d0cf5321d15e3fafedf6b0f7f55d6e48007635923e723cf3c71a13606639d8b3c0dec64bd2139b9aeea7cc2504e75bb2fad5dda2babeb445dbe365899c6620a6ea7a5ead7f3112e62da4beebd1548e437cddd158ac193bc40de5f320024b067e31815c17687af5572e152cf95491d4874c53159fe797e5253b6e251c652a5201b0faba515a8317b1a5570352e217d2240b204817c34812411ea71a94a7c5e8b581759d83be2a742c99b507486cc26e3c255b4d92a0ee1e7231b7c2836ddd372d35bd13e47534308d6277e7fbad4752d0d0e4f11795b73c2a79e0ee74572e3b22f06e565f96b3ed38b5d90c8d1cc422ea40a75bc6ffb08009bb0dc95ef3c562cb78c6f5ae2536bcc6ac94273459d3b24b68e80b9c86db4c5dcc253f1b975a3105bc27e1abd73a255e518117646951c7dcc93919ebad365e49cd18a661f715c33df0ed15dbf6850345e4902a7067c31ebb2122bd9aaab5fcf4440c180b954cf7833bda2bf8b7e75b7061ec6c0f48550f56b1633f0d76afc5b14a0844b3affce2b0f657c8fb7590c4461f339746afc5cdf3cd00a38586443c60a4bc1629f8e59707a0c4ad9463723dda056b26d8fad2904ce9e134681c2594f049c5f6b499a7eb69092945177492d1632011160842b19b83f2b14379616b7cafe6d476790b6bfe2d764aefd3d3350201242f4ad118db74a7836cd94ef5a0094d1eb59ec5215cac1e592cbfc3367830835e7be3a9da5639247bea9440f2f65d642c528d61a1271ffbd34f9d5fa64f3bdbc0e97621cd718dcd3a578f359e0dfb4eebd7c3104938519eb45d39b4bfd0afaaba3b1c987efaf1ce114644dd7818b8f4b400ecee1e35a262e1147a05de5a36af42840a60982ddf2da5421626894deee884027389ece86eb848a9d8033d403bc23336fcd612cabc347ec3a4a89482a368bcbbf044fcc2ddce02ba04ba47480560603633f2a21898f526a6249416d4891b8e771b926ca82cb3b00150d0f93eaca1a9cee5a3720859274f6ded3f008278b9be08e8853fea01ac3fd3a86fdbd3fbab57483edb7809732aa6cb085a5155ed4cf8579008328088b4a2e89f140da7538a4b23d09951adececd84a877f25af1f6405f9d5d8e383e47dd01db4f97c34e0403683d0fa129ff25a81d880a3df22e66f770511e7c22e9fb1cd4ddfd45bffa2a2c2754f48320e37f0ebc70c5f59c7a20c54a29e3126023a8c8ecbcff140891d6a7b2c4f7869f004f69f7e4e6d1ea8d04f0d030fd4c6e21c9d9c436d4ceeff9d3eb6420428698303c6a0cebd3cd500d0137f29684c8a07d8d14eeb4c2345d06634f01f0314b885ef5bfd80bd5a22dcdd404f50f8f5031a892390e07a4093ae795ae3e179e41e5186c192ac49a4ec558b66984fed6b12ee83a0ce0ddd2a3e34c11ba78a64f291818f2ade59d02a64c08562cd3bba8e7dfa8770322003e827519a79d2691cec97412dad0b22045d1982a3dbd1e8258e479713b697c583943a4e873cf06d2de2a61e0ca1802a0328d12d678e64eb212c3a47c53a695cb918a9eced719b898d76e8d7c63b4ce38fc3ef191a6c58e86c825843e6eb8f1d9f4b753d1ac3fc5b1071e4bffa91708c18e4d63af1e5062c2b431e33652995cf1d8607a3acad58159a59917f02c648480c44d871b49132a784710373d20f695b700da8178770b75cd41542c922caacddbce44c39653ab8a2471213b76276afe7c6cbd2597b17e317c35ed575f9bc8ef5665f8bb7d1712cf559b312d5871508a1a385734803ed5cdf80c292458fce0d7e6268bbb85988b3daa2e434a124eea6671273de974317f7a6ada0bc9837c8627428b133496108d91771584c94764671de824f55d34db4af3d85e68b20b61511d9884d491d1dc04ef63312841b3a443596b7dfa9bee11128eab9948d4dfe6ee039bf286f119e1342f3248ddc54ff68807f30b302572618cb6ab7dbef69e908931d2a9a378c40aa8e449478cbbc226463b249194224b3f1ff3d13b07dcc567452b97f93405bf9211e340fcc7665c287737d97e72d2e04fa3cb7705291e5d79c0c5e850d7bf8b006fadc479ae35c8a57b558a0f8312267c225774b2f7d87c64c54106bfc47b1181808b7acb92ce2829405c7047f55d616aa21cff1e330822ddb4d73878f930514759cf695258176dccfe781d5e0666cff8657aab8045e76e9a9f02e411cdecb9125f6006159f0c16f2273f1686cf6d73a9f0b05212f79e831ab8737bbf790cefc80462c6e5824b98f2326c46402520638c6321e34d258edb49c381983ac68c3c23801b819643c94b6abb80236c4f6564d49baf8c9e5973417623e242c5c47e5a999a86a661650a5d36bedc85780cf6c1b15600e2f38c21cbd3da6a59098a01f1c9ac25e4b6d0c0131f090fdb1fa437c488f5a8e8dd0632ac400f12f4aa581a83c8686ebc25d6c97d704738d3236b040d6b92bff940d9b56990fb67bc60caaca9d7c42032b43375fb0a061ed346057b086f8733127e8d18792c6ec8720b6e2c79cbacf78404b1de640027faa2c03ce471fc4a57efcd00c0a44b3b0a0731225ea6d5626e8003a730db6f6ae89e2a8120b9a59590674994892f652b2d78af6b19e64f28003f799ac34b74f1b1b7c1166809f364c0e9b831b4401514a1c3c75f08511eea94432b7ca0d822055735344edc14cedbf5de2aa1b2fff94c99f08bbd85fc7ec772faba5cfd700061b9715db38e1d04bc7e904b5905d843d7df1dd62f83b9be79b744418e736fcf89f1706b0f1790aeeca3ea6bce3bd51645afbf1c2015c30b365b85cb89829bc3597a40da29ccd52ce337fd54a41177bee295100a3f3a06aa82c4436dbeb02701a845d4018bed6c7b16f6a8015bdb6bc5558bb9ee09afd7eb0d8cd7e623251f3bcca928ef010c39de03148bb2a9871eac72390ff424d81ad297969e9c61bd18f60ed101d33350fd2efc4b0806a8a79d54e48dd173a6992be430a464c04da34f3a32d8f6ea7a122e4ef66746a1afb84da308ddcac1747154ddf098f24946f6ae19790b631b3282de1ddab2cbe7ec66f21b0de0e2b21a6ebb3359d766971a1fa8fe371e3dbcca6e1fe69b710fb6d3a9ed7ab275ae939542f3590c7c1e581927c67c6e8d75b55b3405cba4ba6c98e6a4b2394d1159766764f8a6a7ecabf6fc19f2694bc3639499a2144d1e319cc6449f6ecf66b93acd26d776427097c435fedde0d5bfdb032dad0f41f3f67fab8df020f4966f34d5d1579c9add7b4380354367459ce40ccfb2464db52df470ab721cfd7ab46799970fe456ed836d99e74706cbe4c9a9c17faa70431e7bf4f24507930effe7c0834fa9cde75b2a95a939e4f4cb791299ee99d3fa6477663f9f96e7796f5d2e0d9e79921603927b4c15605904a8d346a9cb07d8e932d67ddce3466f3494c0092525c42d836e2048eb6741469ea1bdaa612dc68ca3e251e0ec022343acce298c8f1ecd47ef1eee84c797a2cd163f9bc207bffb9d34748fbc000ec94e2621a4ff8f084d77ba4cf3bec43a360dd3a0aaa5de23bcf7c8c8f409e0a8a1b3af5ba3f93c5dfe446e7ada959adf3ed0f5b3e00eb68c06710bfdbc5aa0ad8b34b42142d2fce232723cb0b5670d1874f11367de9bc0c1bf6e92a7bfbfeb05f8f75f8d2f13770524374c9a003e53791ac49eb348bb65c428fe80b2df8c94a248f84f2d918fe93b04620ed6d31e6b9dd942a20545bb11d49b357b23f60e397b97dff393e1578a2886465f13423aa03bd5edc7e2ec9b65992532964167c202ab198587d45a8957348c213f52f1637846f4b798b39236e089aac50a0d9b718b0fcddf4747d92bfddcc44051bc3d216f300bb9eaf9245e0f406f41822e12d051f964f7527bcd6a4ea21733bd8f89b74d2aeb7ed3029517af0d1bdd8c0646927aa125d809bd61b44297c45c423d4b463dc30fcbcbd7a153ee72fdd9ce1015c6632df738ba8d5586e4867d472f741e1bcf903cc2670c7e177a7096c662466d32bb483f7c7df89f498a62977741769b0762151275f804b8b1f3d8ba2da1e0d05c7326d5ee43137c4a56d10dd82f23e3f81c2c9e5090dcf74d549c139b2d5671a0f1bdba8c4e529e644b24bf83507c334eb300d8b33d3dee9c7a1dac0fcea782e8314d37a115c0d27b8c00866cf9425c75bd6431d50d1713aeb2560ecaa0e365df60ae6863e93705d62df251d2fe46ce829dbb8c5d2e6464c76afaecc5aebe65e72cd23696442952a589d3e2c7de9527a434283f25a250e660831e98fcf8ca03a905768aae3528c8f748683f970bd9ef9398540bdfc9d6af18babe86833006d5b0378e9900364cc0a7ae6a6059e3dd79bfdcfb597579f7b5f1612977477805e454cd419c1b2f44bb0d6b3e092a84bf475c051f1df98163b465fb3361979b3ddecccf3d11deb3c70453ce4a8da82796ac77e1f3a9d80e6403f701efa14e97c2712642575d0137da6cedd9e8e471ff73d7e5ba1128189bcd0b5e7374299b704721040e363756c63b503b6dbc16a43ba3a96a1c2fe990e1300f4cb1081a385e2759a8ab21d75ae984b712e04adfa6cb32b391be2bd81bb0f32e73d58e34703a825766eb034f27e54945c4e059d97d27d6c3658f901ca4eb453a7f9994f06d68974741429514c9f986651973d01e6f5b204ff246ed90fcd42fa9c8950552e00c886666d2f6d07bc43e7a9f7fe863e3df44586b827e9c4e0340b87289bfabc6ac815b86e454fae23135944b31b65280514177631ac76b7615e687fae0944bfc8e8e490eeb6ebe2ca5c89cac09be7c9c86dd0f17122b5bb90b86e4262846de7017e64b93e0feb7123f127aa3b4dce004c74f2d1a03355525699080d68c7e8f20ea35a5a7882a30762084a10f011e6db3dcb235de26cfb30fed81ebaccfa8dd775aeeb885f0b218c35b877b765dcdd770b3d35c9d210049538c12eec3eebd066e9aeb6b524f560a3f96726762947a116871abce56c80e74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
