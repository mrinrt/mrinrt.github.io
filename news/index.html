<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1624dae7beea221a88c6ad85490ec2a51d6f836f3bddc14d1179e8a699ad59a27ec44500cf16455deda9834fefe60f8a19aa33745ee506e695bc64aa4f4fbd6ab1b1f1a531694b5f56cdaa1a7e1bb08584a23e155c35e9ab7994fee2eee0b9e331e53e284e7824a45da4a7a6b555ccbfd83b122615275e3a70e805c95b2b4089f5ec3790acfacc8af3ccbf042fb8bbdcdf13a46b16db3d7be5cab4f2563c0c09ac7692e869d63a37e12f478fc5e9895ebce9a9c667f899c269a98aa55c6d04799478edf70215dde7690e61823777d9362dd31142d7cbc713986bd41ae8750c388844029f0f658500e1b176496f217219a1b86756bb700477a6a6081c015a2159b5ac4f5b8d318ae11c5f99b248c032ef8bfb6cfaa56694b88f56a25c8ce02dea5a876d49e6348ec5c64cfacb32724e8cbbfdeaf23d3255642e1fc9de76119df77142131ac36b8281c12105948e5f61e14d0b4196f167c66d6502b3db920301cdfc14d043745d4f5a0becddc74c785b8d14d8c10e4f7fb3096e4526cac507235e982b758ef5dcefd9a904bfedaafaf3aa04cc54fb435e4e977f06f0331e8cdf26c52772890e741f3eb8d1e23b8b54eadf675bc3fbf0c897a81ec79043b2f6be33feca1b43c5339970744bcee9ba124647d29ae27204dd8ca8b7417c44e33ee1e328e063178ca27b1e776afdecaa236a98e7e1afafe1b0992d180995ecb97dc5b9b9b13540bcc79fa8f33cc204864c79a6c4edaebf95f8249a3c03be9e80735cf8f0c7ee8b6ff68e8757a81d377ee3f7685231337993ca9d433e22ba94dc4f1254184fecedf7bafda570aa99d16e74c36c284a52b2c8b1e92a3dcc98b8b522a3f8cbf7dcf1a58bf42d5fa9e87ec826f0d14dc5016c52effacf136258bdc4d52242cdbd956207f1e50e6cf9b498742e26f0d45aafbe23addca018afcb1cedb2d121e9bce9b458f3703855a8615d26d790ac361c078eecd3499682b06da53d7e76f5f8cfe9f7278ad4b0c562281e52a464519a4a72fd236551c60ef1b4a87dff837ce52304339b872ddef5966fd1b48e98740dbec102b7ad14b9053b8e14e191e0e816bf492f34509041692fe375795d26a3829ddf9c86d53082632d3d790f2c79ad938ccfb781914118d5340564030f95162e3fef079ba6010aae1e99260fdf859409e4a013d377fd8264c9616729c0cc6b04abd9f4382d57706d74a0cf374d4b4339272816051e7fc46bf6c5dc3cbbd067b7ebd8efb76c0d979ee58db5172640d9ff397be298b710dfe4b763e89fcaf54fe7df40d16818492e90ba92ba2ecf319458f144a106240763f35f8cc2c51a8f1cc0524683cb027b68ad9d53643ea081469c7a42edd51de35c8a7dd7398a51e223fb09981ce301ca12b98538e74325ef8d4c70aa624a3a43406ee2d1582a68b7bb9ca229adbb2eed4e3008b18a6a5ed4f4ee11b3970253e27b49a2c6bd3a372d3226f47a0cfce0718dd13055141e748fbb21db764e1e5f3f60165902c40705ee82e704f80749c1afb2947e9fb8b0fcf9ce3388e81f9df1ade825bd22d09d021a332f36909d393a6ef7744a7c3ff5a58322a4be795a23993b9ff18aec65e6c88be396749c1c8a91dd388969ed79103986c216f57c8dd5042f64aa36847b9c9670298b2898934bfb34b9c3917f06f5c8977bd5f8f9320b7aa41441381264dcff5c05a2538f640cfa5d94e3d854e29a54933d68951c76829970996088ffd683a834bf8c6eb4626cba185cbbec19cce561f0269232fee2e32b6c437b60d20b8983d060faf8c419ffde47dceb9cf27ee42d6b91bdf5f09ec84302cc25a8d6052f09a0b7dcf593a0040ac065a304c3bb0f342f69a32c251033cd5f125c6c8cd64d26642d8f18e43c79b909889c8f76ed2ccd7b645246bf6942aa804634cf204f8dfa507f1ea3a3f299ffd148629ef7a82a1b0afb7ae4512e5bc41c22e849aef4dac4e64649a5a18323f53de5f2e662d52d9eced7fe4332696f19d3b39e53601ef5bca9106c6183bee42c372a460e878546dd30b2b3a49fe64261995b0dd5a9fc798936fbc519b8f254541a7a33fbc4abd9edb57b3b2aa463424dd1e444c2a58b3b9712e11879a6055baa67b3a292a43295154edc44367a27cc891845b9cd6912701dda4fe3550371801fbaa042283082cfe18b41c9a19e22eff8aee2f1c7440ab227e895dcf12cf1d515872b473ffbf1c570d7ec755cdaf9f05c89a5d19d0e385c14a12959980fa78064cf6094922469c7d94ea5592e3b631d36aff139b8e7c947444f13680727cc909d3def6c92b54523b45c3240ab99b173a2cf7a36021c078fcb7bb9c33a18a9e6b768921cb7bf6578ed35880a6c2e0d155f756e5fd4ea185138b73471b447f946697cf2229480defa9efc1a1527369c6fa120510dbcd243aba1df6b147c916e8b8ad5aaeaf7acd241cbc6bc4e3136381f2f9d7cbc22320ca759b57949aa99c9d85e1253459f7ab44bda4b33c25ee15c39f3fcfc48118d569b6265648f251576484cc150cbb659c1680a69494b1a9e4df71f09f896b9bd58e0dd839c6855dfbfb02c1625b0a4817aa3e8824c5b8f245eff2bbed60106eb6e4764494da054515ff163ca3010fc05a1cb1dd13a5bc2399632bb3d2ae44bd2cb04fbe1dccf3fd509f24711801eb5cc6009c2a2388ef2fb99339157bf189ff817121a4ef2ef6d52fd401d24c6f2229207cc7f723321b7a3c25ea9f3195a3415fefef3b34fb695ba362f687ee716ea3276c2ccd3d130d199366d0bd5836fa6f2bdb93fedda3f9e7e2ec5fcf3cc5490005937f12a15f5a2a29e66e8b2c3af645b1741b5b84f2f7551a243a97c394ac15434a955ef9f9c40d8944f170cc708410b78af176d4cd99b6cee842d443dc7dd3099e158180f3636f53209c2bf0b84772eb67daa4c27f1106c59987a8539095e80e0e7f1f59bbb1eb6414e23a24f7775ea5db228e83cbce2c5e4375b2b0749f8acc0647e9725d018a039d960975466dbc319f9b6301039a68f3e9a5f52a4ac30ff7ee789df0fdc9cb96bfd1cdce1dadbcb1377d5fdce6d4ca25143c950e51bf481127c7ac699882ec954355df439d4004f3e24f5d97f6d2bc0947746fbaf0bb44457a90694fa165c6cc92ef4f3f42c67b505596f9ce77a1b0ae53133e415a72c725fe0fddf7fcc383979d4b11fcb64e7588b42ce0b9a57ced2d03729adc5fd6be9bee0beeccf770debb7dec92177062b83b66b75ebe0eaf9672d7504269e172b408fda65e2771760c89c7ec81239ab2c8155e71dc458b7cb830a97921e0d4b45731233918fc451307fe7ef4414b215704451c69efb315ad776013511d6f8f4fb38a53d915a9f428ef42753cc59f5732dd0c9d277bfeb29a1f781a36b462583fe7b06aaebbeea6ba66ce246c8015d91a4838d936407c918a4d5c84d6b29976ff0fab1cdf2e0516c5f51054f6e98e7e83615978ec62d69a844ba3100609a5df9a1785c75d4998e42ec39eccb457ad429ca9c8b6970a17ba08d62e181bd0cca9eddbdbc701455e4dc1ff9e35e9acfd2b2e65cf6024b0b45f85dfbcb0992a418f38b8a4feb963681f4df10a83068955f51b8e07dd9462b8f437e3a26fb7b680f5ca5f76377b7fc25be25de70865510dd17fcbd68cea6ed95a859a162562cf3e366f9266461aacc41359a87b381eea5a05dcb42b21b6f8eb048304762037dfc67691bc67a5f66c2e45334ab5c6737d49bce35ad7888d864997304a13d30c2b14451d0469ed2587bf4937aab48cc1f6464ba2b8c12165a419923a96819fe74c7be676c9dfd414744e7896aa31e831b77e3d643c816738cf3ba33b5d6aa67e43974782de253b8f98d54f7409c26d6e6df9e7a91209e6ac4c604fe183a318071d63443a07d81527c9f11b882e3e314df65c3cb5c4e57f59a3a8e880abeaa56a8ace26b92fd30609244870bb058d62e13ffb25103acf07be1289be2088a1fb85fb5075cdef68694f411ad45eecae5e788fbd14b4a25c4732886c1528ffa7460806399d6e2095413b71e66068281897cea253c46393d761e39971327057886c291c8858fabe655f7b6b9fb48342ab42a91818913f350f34de3e04efacb067289bc77b613f4cafc7ac3e7051fc08a77c55f69c37df1013d64140897c84113fbd97ab24accb5ea819c170b4f4654dafb47aacbd367d0de1e2362d6199e87977a23a1bd585047efc17891745c318e386bf31a01b1bae3971502b84a9499021cc2eb00800bd9c66aa3b393897749b244f61d0fa3bd437dffaaf1e2203c4b8fd8de560a0481b922c47b01b64bb89c8f3cac17227d300f2cd42c53a0cbf0ce139c7d607c480c75fad83286a2ee29d0da3940780dec3e5fa03c467a0895505663723a6bbe8144c116aca6fbb12a32b711afd3ed908279c92965388099a504502637911d299eb0987225a0eea2864d3c584e5dc40bf773dcf28e66eb1b18368b550f585ee167a66eef6a6a8d23e42752fabc45fb1fa76bfb07bc6e4a515ca2d7da70b63fe53b85aa0bdf6b0edfde57d552c8d68a3d065a7087e3d1bb9e75e27232c97845d0926aecb5d4cb142e1572d786a101d83e4bb18e8fe128fd307302518f40ded12084ed490bdbfa1d5d3776bf78b396c98076cae22c664e2fa6153f5063dbf5e4069b905764cbef8593b62eb8ec8340fbf189aecfb1b9e925d5a86db2195bd9e132199967dabd9fa2820fc1a8cdaa0cff9f6b5590ff902a3e423e0ce6579841587ba7b7bd7e157d9722e81be5fc9400115f0bb286ac3193e9d167712faa553ef3d59718255a5151466df3ab73412979db5ac200ee17bd62ce579e40300b4bbee6fe4e0e5804d1bcf7b12c4e4e9e5c6eac620da306b1512cb7e60191d7474bedf0c1db61f665886b4b5c8b1b6fbf6d80bf97ffafee221052a45aa74e58f8c1e0eccc561baa88a700530f6ad0eedfa1171fe34e02a059d36917a31ffdeff457492d41191841b3e96e1a45bd97456317d0ee8baf49460777642cdfb447e7e735eae9b5343f1bdfcb1fcbec8aaad3e189676171d39630c725d9103a77ffbe3cbb854d5d1a47fdb4870da1fcb6324b2e849469c8cb6bbd2a866caf8c5e81873a4bc0bb8bc0277d89bc671d6ec5bf50bcd556970ad08674c50c27c2c1c66607bfed71d665e6e4d47971c987e997f33b41caa9d92684334513daf427d7570a8f1910b82430e91599e32022ca5716d2997ffecc5abba4120bee930b51cb31def03345e49f5d167c1979cef2322a242ac3230e15d599fb5cb8eb5153f071674261d3a28906d8f91ce4bcdf55d0161ea3a025cfe6c01d58c46133e2fed977c11c46a8d6b852335322e47dd0006fb82190c6ff55c4e398930f52971718b3a1eed2661dd8c6724d1fed984f05f854a3e32ecded8fbd6ef71413eb4db36837dbffae221a0e351afcee76f7bb2b89bfe1a7eb24833a98cdd9fb286b054c072ad701d9a399dbb5388f9e26fbb57d8af20a00cdc25b3b6e5ba2d7236288d3f8556cd2007bdf176b67dc54e55433b09a794215ffa80af96ce87646270068d62fa7a1a905083cc719051709197ba69227f20dd060cf83b2e7b0447f6e4647832881a7c464e2e9be6a33fb229964bb8716c52f469ed2b96fb890dac6859e1926693395543dd6707eb0db24295e697fcec9a8f118e64c9863214bd197acc7dcbf4535874b4044312aa836367ed8b718e7eef026cbf61c3cd98e324fba6b7ad8227297f58479bb662e6ba1dfb18a7f58442908c216a6f51e1d7ce8db91741c7852eed04a3ce005aae9cfc087811c4ec57523359b205eed17b26e7945656368a0e715f9cd94c89f599e7d9ddbbf73b2d6f4a11c2543b8c86c8443e3a7172c08ce3e844bd50efdcea315a6db1e0e5943d5b2841e47a9b56842db518bc4ae71b5817cfadb2a7b168e6f7b092379f9b42a6e89f498da7780d51c813b999b64b621f2edee0ccccf62420730bad247e1859742e7ea19f58d38f02ddfdc0e5437dd0aebe01e8e6b5f52b7eee6a6378a76fc7f3f08cabf1b19d77559969c6b9cdfb69eca5bb709ab85dae1f206f7ab90a55d7a7868901744c0077f6bf8431875d858c93c0a8efd3ffbaa554a394efc1cb0d1af4934fdb3b24290690fd52a0f9d23d6b3f067bebfa63f8fab63d737a51052534d5bb0484c52143cddfcc6f16993b1798077fb6780c0e6c534b6e47ecee3b7b3149131eb758a2922a6f003491fe7d7a392ce66d4cc2d3e6a6d8a53d6682e33df7b288f5a143f7b6950186627a3d52b56ec934e955ed76f75d4f80fa5bf0d311ac0dc2b04a73e1a8cfe8ddeaa44612301323db154686e9b8274dea98814f7c37b128270ede4b02be031ce856b665091969ba70168b726f3c6b1a7a206a8a16a1d637e45bf66d1a65c3ce0b54b403c3b88120f5ad41ec48df9e255ff1d687e47c3bb961c556f53471a6e228dfa2f74edd7c420c53505a140e0dfa57651212c1a0dd536b2547022b3d475dd7936080628e577a1799c4ca0b36fcbae3e83b22ba1fcc4901c4893806c083a25209e5654f6a8f5d41e5886b852faed501700766b581940ac1d429c005c2af2ff5a1416e3a9d3da857b268bee4e171d40e036070c5225b8bc3ffd808380cc30e1e6fb28e4c73f2c5a75629a22cb2012f8a80a9179b28b6d654812aa413d9ea70c287349f3f81d78e7e9a31743b4e5bc3652eefa51c51a086e5f61ab097a11d43f5383959c9065b5fbdd7f818dd46e6c1c3737cdc91407c76801eb7fd7fa682fa59fefeceee6260ae5c2e38f9289aff9fda5b04ef796a49e7217c36749461206a03d50e59b25f0e4f0866074d49e498bb5c8751f7daf9de882e367f0c036873b8636642ef7e43d57726822ceb3918d8003d884be7cf89bdb813da85aceed151dd1a321bfd4db0932bc5a42c6db9d045892a33721fbba078e3348c074800ded64d1a791c0c30c3fe78d5cd04ddca44b9c9852efde1157ceca575b2124de92e95ba85ebbcb8aa3de57fb818da829a09031c67c80e83a8794e22e5eeb5c17a687ab134968bad9de4de8492c511b6e5194ae0ce6d6b7e8f51cdaea46d2f4f8532705d01b2ecb9870555635770ab1b51c6b74f02757e754e50b9485bf3be2f8d0762f4583d7e0a7cdf117f9d5865c5db6abded41cfbccc92f33d7bf48551ceaf05aa4112f8d968b42ded658095e73c6450e3a652dbe2d861f179dd696b5f124204b89a3ae996e0d53b60042531e64d8532cc62321ac52a5308d46ee5f182cecfd6d493e1e9dfb5955b8234f5dfca0b4f82d59131b9d59bfc2f255e6a682decd810d1a91ba3266c916edb2f835e8dfc6c549f3e613763add64d74ab9575b0a3f2a5e44a8e3fd118018a81117d9c963d217eb01be8b75a31fd9f0e85aed0aad7b3c3f91e0639ca49e2497c6aeb58e689493bbf242b1fd85d478af65de41bcd8bfcc1bde0b32a1b8abb654f889735202889666b654ae848e91a213704f9edeae26027393254443161a7037b093ab461c9a63695cbb239d0d22fcd86fc3c4099fc1851d8f0b214467485eab4098e84ca82a5cf1b715b9e18d7ee1f420393198dc6fb8c7328e442afc41f155366baf110b12b395447b14110b382d46aad2e84759afec39bb532fa7cba1b5ef01f0e6683df65f5e6a8dec9d9101ae1c7eeac16830ac9aa6f84a345e506fe181bde665d0c2d92264cc67ffcb4c3c5af1996dece6b4987ad2c622e4644ead207eff3775d9db59ed62308d64977837d0e8c37c4fe901fc032b61d1b30d1ab03e10c4a3da86b596ab8f0e1121608444e0058a45688882cfa53d00c0edd6b4454dc659491d59dbb77832e02a5dfea03a8a5712bbc5df4b968750c4451374712c72d9677697b0c1356a87f667ab52469358bb990ac3cfc3f92e639ecb1a7e6f9a4ece814468bbf255270d0d474cafb16d8b8768f3f900b7afa394ab79a6a02f31ae06640cf9462cb02a82a737164d321277f7e42ae2fd5f7e639e6d3ca65ffaadaabec81d12ea3ae960431c8574dac883fa91647206f307c1d2f33df6539ef273d4fa1ddd435dc01d682db34054acb312f4be99f8348f565ed69eacdcd586a88343890c35339d43109de666f63903d10f94791761d8e22a03faae13aabfd5c2f23e994d99006aa67d75479fe2eee7b1480b38afa1fc8d4eda94bf6327ce13dd6192c5bcea731e77a6e240ef73afc50a86bb57558ea6a8695b2ca8db5973cf70f086899beb4d10dc3761f2a2dca6db73f8e19dde481df6d959533d1d690a24164e21f7d696bffff0f81ba7ed872118b80c28d05a8c9833d67921d8ce60ae03d83a67bf86c2ff959ba0b36579310335d5fe6c9be362461627b862b175e0ddb97d608ae757e40b95e805b0c407c08b845bf740f9eaf60a6325034303005060b6cec18496f2d57a35d84c86aef6250b4bbb969ebc941c460deb822b650d78c33c44b89a7df9ec42c7451466358c0940999e63ba33c61680ee6fa651e8c23c5e5158eb60ea4af9e2c457be6f9f9a899f61bd56b061d416adac3e4835dd950933be27b844e0e5c91a23fc9c7884a67401ef6f8d27a25943d7c4a5633cd9d559627d6d28ede2b174b66508c36a0480d933319b9275e0ba55684b21afccbbb6b9c6840641ac7ca0dc013d20f4f26091d6d39f7e147288c68ecc16e7df318d82647172b05a71ca9e9909343af08eb95d81d4e13979d68d08bc5ed1f7726bbddff27c00424c8a52a93914ff43afe9c29ff2ea89948f3b4b8219f338028d318f6a1c37e33eed24a90907be87fa67d53237e07ad0820ad4abcdb5d0fe6c58e035f0620039e604f51e96907d90ee8680c86cca37dd5ad7abb72712db3bb8237f7ace5558395431ab2a0173b73618221a93b40cec1c860f50a60fbc3f6cd4ad116825d43c01dfd9ad2e6470df465c58a773c4896c7c9b516b619f1bfdcf4767ef60e0bf12c585364e918c546ec715a978a411d7f50a5a446581f1585fb538b0d6563b59a5b1cdf939f7d3ea5bf286fc44f8aeca131830d767b42129ec25856765b6df11fd10413a6bc6ebd940700ac98d158ae08951ff011dca8ec53c8c848ddd8baadf414dcd1b5d945ff64d9068af8f7a119d65a294cb819e8ad7b04ffb925110781316eefb31b96b334db943200248af0e64f72457e1dda577f18f15af9494d95f6542547c32b6438fddac802a5674d43505b479a404aeea96c02af9c37c9e3fc4025f2d085efa801e69f5f08cb42e853b3669520b370b4340937fcafdc9ced453162a4d51d9af22b7a0501e3b00574870752ca650f043fd299d33619ebe58e510a52206c14d742fbf530a67bb9dbd9b0830229c546b11affa54717c3cb5d16a7d35d5095d2b4c2bbbc193c3a164f203e3381a0b45e6bc7e26b236017df0e06793292128d20496c2e1c217bb4209d5ac08c266b12243c324a364e6b4977179b01d11df0122bdc9288d0071389999c611bceba1a407bdd4c8ac863f53b803b3e8935ce7f6155e2f6a32862c4ff4151cd50e35b0ee44cbfc5a8a51a2a869ced77a5a26fbd0fccc8be078f97664429740c3d1cc95e40670c2e151fab397c2c09c974d0e84cd8c91384f6eccacdcb40d62058eff6d9b1d25c993ef96cee68e241d4be143e8355d8d9cb1335d2811b67ba0a00d7dde358c9dd3bb7feba5d2758ceb77fb75d7a8eaaa491c8ce58ae1cccd3efc10a5c11a35401c2e9855ad8c9b8a58c1d3fa2f2d2b95926d2c810d1a1b7a307f32a4e6fc4b62fe83797ac72a2141b3a29fe86c3904a6d0527646b1990ed7b293d9086332c73c209e452ab12d536ad7ab02b08b333d4a15299ceaed7301d59b92d0850cf39dacd87103ad309808a112fd440151716d1a92f3a1e3a1be330a28e6b4f9644bc66d360a0b13c9a1eca7c77ad7fb693a1bf8a81bb6a483ae9fc5c46245ab3e96fc48826ba41c588ac400eb88a64a50f5c2fdfad0e444789a9dabaede9efd36e9f6cb8c000539edc36759d0c2d0268ac03bbfc8fc761df64b1a2345512d1ce99101ed3162583e98885bbf7814771d4e0884dc6ce65e70a6c8b0378e4d1f863f2f3f016ceb69e077941be0cf20bec77ebeb8b9d1b8ec3752146a183f89d5f32044a6cfae7dc70dfac4c6bc1882a45d05b2d7812a0c9e1d283c01cc2eaa230dbdda03e5c89bde6a1bccb9a4ade382134509672b7428252fb8a2c33d2b3710050b25112278a44c0dc3cb2a189976a68a18af1cf6bdcccdfff5f6094f8bebb382f6e8f343a8d8b32f97d71c8790526f505e1e633c6492191c95f71f45713e0a73cb1537748fbbf884214e1831d05f669265979acb0bfe8282ad50aa3becba6ebfa1a8db7bdcd6679c3a1f0c4bc7b108abae9622df580b73b6289b31f0a2735bb1be449360c8ff633400c676b32c813f770b881cbd688204f1a3063e608d0cd6d52fd173185b537b96284a04a885e3c5ebe69e6ec60cc54b7c0c7dcf1e6f0ca9f495e3a23d799585fd40076daa75bdf6f0b53a6340ebb4e8fae4427803f54f5ed8ce7d1252751dc48148e0a15669dfa5d597ad290af248b89c0036acb9fc041cc9f79ce1b2759e68cc79cb9375c33001210388f2501eb5e106902dfac657884d60286c2ec0288a7df10efc714160ac543892d7e73c7cf6ddd86d96517352437df9f71886d6adeec1e590093fdc054aa54feff8dd5e35ca6ac4e71e775437b34d579dd1c534067d1508efb59956c2e2409c4a1632ddf887d1fd99fa23fbac316cf52998fdabf8b2444aafb6986cb5eb88c4ea5e0105599f899926116b60de2a14aa10187e0fe9fdf33e89b97cb65f2b40e60204bd002fd3cbaff438c406a3dfeb0c6d9c19c5610b021ef5f9d53e9d9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
