<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44d6802df298adb6a3ed411ae04d3d359e73d564946b51b49c57f8d057a41804015616b20744723f307203131a09bcc71938ef1226c619ca3c1295c1cc8c166fa49910664989dbcf0b724b6bd64ca4ad4647d4f5248527f8ffc096a99ac1bab3ca26f9937c2f87f83e070d541f183c0cb75504109db1ba9f416f843b17c9f104454e4a1f16ddfa992f4dbf3cd43edb292071d2c0b6da599155045974945434d22b580764752fc230a2abf92150ae839ff6b314f39f8482e4bd6ae5bf977b7b488a97d1971300b00ca3b9099922be8ab7315936f446bf662c255b9b41c2dec46e572bf4837a7a05801b2e076788b0081665e91366652dd3c7132b612698bb092a34953b007d8bc0f7032d2141ab0b1f7b0c3c78efd038e54cdb195cd358085e604e977dad39a37c91209d898671b6ac15e6d20cd2b1f9beac2ec4f6a60c3e3e70054df8f01a18e2eec540ea974b3e11ef40f66a894e4587569b0305ab36c2e15ae201c7b0d81371b0e7eefc097064df2148df842aec071b9f2a1ade2ee2c78c6287eabdf32a6788376f3dcfdc4db9099b1a11ad408a00666e735f50fde17b7bb506c28eaa18dce05c5085ed6f060bcabaf24e4787c369d111dff2bf74b9a4f372050295414561210e260ae08c8ec3c6e8b7975d93f03044b063c53dc248a0353e5060f841204dd9f153d47df28962812c4ed2b4568a386046785e49782b88d2ba7a53b198508527f0aae6b4f463a739bc0847065221ca4aedca2567e60b9a216c3aeb45c7a02d6860859cbe175d509767b4b67aefbd44668f41ae84452b474654008a3ad3c6e583e4a81e9b351aa8473db32ad422bf2a6a908d0e8adefc9dba41012c36e8cc42bfbcff4b4c48670382ec30218b631b007a805a4a7d7af9714cb4d5b1bb8ba47980adf36d7da90f0bef7ae3d4fa4a7ff3c6cd9f5f6aed03e8f12765bf2e5da9ee81fb0e5d3877c56159ddf50609923aa816240fa2176a4038adba9f1b6bda30f531a524b35b172f80318e5ba00f9d9f7b9af938f3157055ba616db6c520506a9e142c336dcc1755e06ffd731fc66d4212f6aa2f3fcc999e9d47b10ff873761e442b9e1e75eef8dcf718540902f8bb77a65ad97ce9680273fadf516ccc744ace0556263e4f84ee3752032cb8e847b7c337b8fe1d9a9be9a66a0e518d30875cb122e5ac43ff2928aab18750a8719f621421ce70358dba6ce441a94d948867632d2dcef2ee122650cde4b75ad2eb7201fe2468b830a7265a687ea1a495358f817d353f20d985d16345e345104851001eb183f02f9fa7bf2dddca4c822158a5490bf32bf06715ed169c844c1d61e1cebc79ec5ba72e98311adb361c70e68dc637e0ccbbe84a0e1b9655e6ebad335bfe03207f486b6a15e6bdec5683046af00a2dae737e7b34b5b1bd158f1cb8130fcca4e6d22704b7fdbb5c5af776bb4e2937a39d2d213dd5f38e71e0a4ec63028ccdf9ba04be9a2535f5d2e43df7a238122b0d2b1a4d0b0323b32b41ccde46979902035690a9c76c7f6c4dc3bd712c4a6ad036b88dd9d67eab205961aca7bd30a9700c28138497196200bb994d870bbca7ec6db6082ca19f01f5c020dab79004d29d715369c2def307d017b2b4af80fa0f0381700a63558d427a2abeb498e11ad6efdb0762e1a451af093df93335aea9288c7b4c50ab9c97e618cf93eea6806dbc13e115d87f5089465eaba251f5a4cb9e6bb2a219742a48800d0ced1b4a1c20594f8473f2c9bfe63c0ee21665a094b2e1a93c078047c9b2f7fb3ed76a6cb81d1854defc8345a0d1a075f1e3795e038b2151f49ac8afebdf3c331580e294306427d9b9b336a7d2f03a4b04bfe3563109f6bb0dabd3e6afa7c7eed2ccf3fc7be9e11529d06c87d2dee781ca3520b4db0c20c296a9d0ad4783c1dadd93719e5e3f9660dd5859c209a4744964fa3e9e5642104018ae36d173cb2d781836a4dfe0b131bf6fb8f808c51812e84788adbfd2f4387b5f743e9f7282ebac646f1efdb4e3a87dbe37e88feeb517f2eb0eecffc55126e2f0b417e3eae64ce6710147e407d5dcb5ac14cedba9eab7fc505697de5337e1eef109fc88c3b610057add5c32ef88cd7910e6814102beca94a94fd76e17b708e39253a09ecf35d61ea6cb4d9f00c04d1e0009444a664783582c3afa828a520f2717181d97bae61bef8394c64048b15f4ce7d8d7757c5a5147bb4166dc701a6cf5b15fc8fc74ce42c4b6edc7317b7e1e4cb7bff93cffd278c706a15322625d97957147a5ec04357a34ebd87f587bbc77adeee65ba40c4a1177f9a7757afa0811147619b31b9c04591df964f14ac617bd5fdbaf15614807a546b66cd9239993272523bdf808b219cd1daf218febfddfcd551b3385e8e76fbed065434a041a9feb0f4329ddd275a82af2527536abb8da4c9b8f44f6f4f2fad58231e9e796a6c21f3d4df452ba0c3e48588b4ecceac251d87ab5af0df9423db4c437d4ee05b9b0fc8399b07f768b3e0e5511768a62fab5e01fb888de3d90a881ef82ab5fb6f8a93b84d94dfad5a91a9a8dfcd9ce37c4962bfb0e843c2cfe649abac0640a7a9b58f81cb1f1581737e81a7b303f892d7c7146ec4c158e6e7a59713630f60f71fe0470cfc93782e14aa953880e95336f9e2a3b5cc681c57f83727fc72f84308e5fd1ef0bd42f41f072ae3dc2c35ae80da3c4c7029e43e03123dc92c82085e6f7b2c2a3910f75d4974f124f16ac799c52431b4bc4b584a94ac379e24ced64e954a4a0a96c4518fd46219c88833bc6c53b2d475b93f15ea053c84acaf32091d927d2b5c97494830c0b86a6cdba4809c6d34113202e8d2eb07fa339cb1577badaf54079566dce7bdc8248bbdd60902a943503cd0aec298625e0035c214038384dc7cc51a78cd61e7148d5ecae24722922549b088772eb7c36c5374f04ac33133b08492eaf90ba485e516ffd761be44f155f36e77c054e6671fb56879933f5a9ac553ac786c2e2bedda50bea5c710c4e87ff87a2b537de74903a4b4a50977ee4c7572a3d5f598edb6d65bb6cee9ddc8e5066277a533a2f66a8be8983fde14edbee36514377eeb12822209a7cbbb5e2f1f76b3237446512a9fb038604bff8a395acfa1c260190c9244cc7cc91bebd0423b56d3411acabb1ebf3ac9533ce4d522a23846989c3fd3d7ef8fe6b58a0e84a8b272a5a87fddaa169368f2fa5b67db156cf9b213a9b65fcf308249bf5786d37ebf722695aef91bc8bff18263847f364c2e54db47dcabbb61785bfdd0a7a0c06129b51244eaac8001bf31570cb66e2f0bb8d827a3fc405e8f2dbe4961cb14cc10cad568c38dec8fa1e8e9d826256d6f91aff78437c846739ef81f3a20e8c3c4c43f8a305d14b02f3fee710cb5391255f2f1350f911092335a3b62fcb7e8670d43e01738e8ab02b9e816492b6b06ff8dac2413051a2eb620e4775cffb166344ec7115d096152766904fe94bf5b9c45d34699d5af09fdfa56f04e772f761a4c42becc44fc59b10d089cab5664debadca2ea239dde6bae45e4f8aebb2915490d21bf9907bd3ad51659b6fdbce9ee93b88ba1041957d28d8bd75632c50d959450b1b6a0a98816f2748dee3a3ab57672a0ee9bf6bf449cb1e2bb6944f6ca23bd8c22616293d6db4828df24a38c63577083904a21dc2fe4d0476634d2e4e8c7df36baedbc2646298de2fdc2b9e9f6ccf58cc254345d0ef64d2aad58abd661b8462fb1b607eb19e0e6ab60fc4bde3ad4f21a02d7ec399da2403b3910e16f3fcf3a634803622ba34e8810ea62a019f6d6f8908ca757c504df4945ea44aeaeee59aaee11f4e2511144aae660835559a4b6727d7e68b60fe439258ec7854091d3bedc47fa80a2f5542b297c4ab8944bafff9bc8ef25baaf16b78dc57d7632995443917fefd5a88f9039d9cf5d0cb038239a436e55ba1ce3ff2a82ee23cbd18ace8032bd2523b90f7940cc061e9c77b328803eeda0d2b9edc18190d3084e1666859fe38a5ef1475eea2bc96e04e6ebff67d6efa0449b94e810883c6f28a5b5024aa91b2e367f2f130b924dcd6413c336b2e4c0fbe40d37023fbbe3010acd3ab5b3a0583568f733624a19b0bceaa846aaccc7f1bff4e5dd5cc20fcbf897c0b86d31d006082772886b19bee3b6f26a23513fea2e2a5f3cda9d1f3c79822e77792e07439794995cd3ef940c669ba826d1faf511cee33be6f4dc03f4cc61d1fc79ebebbcf7d6ab9adb5fbce94af59eed51ef56e27ba626f57884cbc8632be8b4c1824945e7b9b422ab6425ba4402a975e10b53cced86588a772c82cbca73f2ec520d03aa32eb4edc010871da54e52cac88224c61754095a4e06c39be79064825ab3bebf31e7ae06bc4c8e56b315a5aa4ff492e6dd4fa9eab87b00f645dbd7f04d8ce27a8d03d91267aa89efbdcb777f266de79a98622c835fc6011038d4c0c03beabfbc0faaae0023ee9ff1f072ce4bde7626c2b8df11bfa6b5c56ddba5a64ce192192a055d298bd5838e86b5ab52f16f1d9c4ce8f974357ad749a77eb80dc146edb5fe841762e7cfde1ac894123649411071ec5dfc7524b568f29ead88e860e93166068dbf98c8a2139f372d227e1397d1c4cc5e0fc5a083a692c7fc5646e7b7e5f5889cc077bf2bd2ff8c2b4ab3b7cc8f5bdb3924a7dfb0c84d84fb8e21190521d6acf40d09031fafc50ea23896c3a32b5206e8872a59a146108313d423fe54f2e4272bcd14f2d117ff5630314ab97576cf68f57dbf8cdc90702431a3152e7627b0a6c7a23eb737011a22768595a5671b78baeda0721847c860a1675d2619f06d5e7089e03a607ed1758114dc1a6dd0dcc611cd5a96d10360047fd6a09f3857b51195e5acf004c8752925e9c52a8f1df621482bb0b7c310cf8d53da187fae6ac889c90be3c0ca883121db07d6f07aeceb15831b5a47e1ea5df6fb5e69b7322875685c0fe7affcd02a61ff8e0893579f64dda500874017ef5d16298d8dbf0f63924881ca41b0e26e4fb6284f24ef82324b7b3ab4049e5559b1f1f7549c4baf45130e8f7f8a52ff373714e4c40ef617c49e7939bd30aae5ea217c9688a7588d5b914c25f6493a1144a39c279908d4bb8f0f3a5b2ae31065530288741d5bdabb67f5bdf67a78519a6d1d66145405d6010b15883fedf59f33ce2d4e76740a9f670e44f1f6341141c48e0d28494bf15546634776d1929096307c5b66046d657d474476e6476c14b9fa4f71d36873b678a7e023fe967d56d01ed56d08ee7c84804f1b9d31f2dda2c3589a359c83fe15d8c6f83cebdffdecedb86b20a8b4de591e8182e473a1d88dc278a7d5fb7e2557cf08aace9070580ea56bcbe89c397d502495b31077c29c8d318e9ee9289ab864204954c04c10d20df5d7161f77327c7e85ee45d5155e2da9ad437f7950b97b8aa14b1e69f1ee0157be6cdd48c96e43ab8ddeede2db7e21be1f6387a8672ac6fd22840fed130a222c29466529f75e6ac3dd5060fe9b0b279c5eab12351f08af3916f840929dae56fa1eb904d754d5f90825ee7c76e3e2a98e36722aeb0b968b069cc0862ded002a6e61211b2c53e41b154d0a1aabf723850b2913faf6585de38879460d80a6639d783a19c44ea1ade6235ac2937a0f5568680105b5b016762b2bd97994f07eb1300b4cfe2aaffb5c03caab0a33973fc6ad9ae969759cf8ba329d5e3d4d144206cd157ab2fe73cd6af587ac1c65a014593473bb91356e7f57cd2b2c60c0c6a5e8b643dcf6f94d9d3bfa68146836a8aad6c53873febc62cd4a8ca63986f9df0b309077fd279a4185beb2f15a56bac052cc5206fe111a8293164bac8b82ff8c98d800463699b05d20e1cc2a6fa3fcf5883c9ab7d6190dfc4a64769d1c5a72f736d5de09ddd208791cbb269e3c929c8cf3d738b23923cb9c447f1aa52bcaa442e81bfefe652aab5b02cd74f1a26164a9501d96e8035cbf3411ebdd969fe157670212046b9c33150aa9314e1399f835d917f3049b98182c4d9a4f58d695937a8492a3fb66e99a79a447640f038c30119aa6aed38a9b0979140d9b637f45075a4580aafc694a58aacf7da8fa92f26e11e0b37d5dae416f420de18edcc32e77d289c31bfc7ccb62af0da9ae62d63071207762d62bb1f7d54eb26feefe34b240aac9bda555dca9f030b7ced72ca742c38ec1239b1ab16890af3c917367147348ce21dbd55ebd4bf1d4d471a2045ce06fab0cde8f2081083db6d527ba95fe720967886750352ded1a24a7a8d2f72d5562ed271990a41723aa7e5b060987a979512241179f844847a17380e758a19d2b5d460c22a745236de909a75d647cabf741de2943cb553d55d2834be73ac40b2c8a967d6110f6a7a579ddec03368206ff0df109234e6f5f3eba3c5b8714a43d9926d3f0b687b7c334577762892a91e81847edde1e1c9b2c49f821eacdfa0af8c195be300600a8b6a6d0c72a82b2617192dd159d38fbbddd160a4005ca599b2641ab8b701be85be2ad88ffe2d7337071660691802eb15aa78e4be9d0c0b963a076e9fe9074f632a46ebbc5827c5335293b816daebd240353130d4cd6e8f39bb359b8f317d10b171b58eda81813e6183134f0da7e6f3670890443e6f4e95db37a3678ece4962237e113f264e1233f5abec4224d14ab3f3eb9825a3ff399caf1b684456de5ef7acd532dadb8da8ae12388a5ecb934361d228386247ce699c57acdb394159c46c84024e0dbbc4cb7d903da9ee1f0881d7c2b4c00943a692e88aae71b0177e872fe1edfbb769a3082e59336ea0cbd12031236fff371b0eb47a721e04844d62a68b3aabdf902bf8d55221a3328862a7e99d409fbdcd4ed6eff3b11930d845638f32261487abb7c28f89960427c02f616dd2bfbf532144327bb59b6c8462f4eeaf2e3f4a8627f92fd1a1801155bbef4407dd4e608dc0f56585c65882e96a3f7b8e5e2569e3dd7e9404eea71da04d8b09c7dd032ea9fbde915d3c6a3ab6f93c78ff568ccaa21be626a9c552c8f53d80f4d8037d65b40029f7e26afce317992411ba489432a39d2e9eb4af6be59ee8464933f7e2d6d34e1802e11ff7b041d61fc5978b2bcc78a29adfd6c74eb6fb2c50d574e6290fbb0ff52787f27015437b321535fcbf93b4cc84de616b42bb5462a107906e315719373e4ca47671134712106d9f00d7a7335d24650c86d269ce6090513cdc8b45850ec552242074f3e7320d0ecc8b09ad6f713f7594e7ee1229e1d1149112ac8917df2996020d49b8a7e57f2c53adda7358dbcd42a536359be53c6d79bc7491a526b2577d140ecb9558faabe09810fc4d4e42a865acd5f55a2847b2c05ed285fbac51ea6467838eb18a48006f68c2a3d325d7e86f6419747eaa90b197c658226e7ecfa97ec6223501872888c950f38e06f0bdddc9790cc7033a2cfa21499b2e8f0e3928e69035566ad1b5a815cf670f1bf1aa953a5bf61a0887fea30f8f385da6c45bbb142b7d1743a051079f308e9c583f37639806313326bfb55844389451d523e47fcf2ada3df9dfaf338bb151d6ceffe0c933c8ba1afd4ffe00f5a07fff431c5b88a61c46749129a6b5a833925b54408e7e9b2dfc489b3726f878894423c333e93b65f56f6bb34b1bde3b0804e9d90a3750d218a48a47c954166e81b791696a18e20f0c3f12feda56f4e7fd15b519b1f11a13b1d0236f12fce8cd35f70845e9d505b9bd58b7841bb0232444af11c99ec5565c49badc053f01f344eea3c9f6815210283e5cf8e58ef84c4bbc95d3c41bd9dc4b11755be86653db09bafbc14014bf616c0f8245230573508711bf518bd176ddcd6453269cf316e9399d1a0cee86b5e3f17d63e33e7af4ce9396efd9bc49fefb261b872ab94c1c63e6708616e17c4863088cbd8dcd1401bba98dba247a2aeebe3d6cda120a6bc0e62b71476dd6626d1781613d7b218f159a408a6d28ca98ce13e2dcacc838c5ce42b241984a968b1706aa666d31781fb7b9ec7c95dc9a1826806fed19dd97b9a12aaecd60a29ec8b19070227b3ba56be79edf102d6051708ce0eefde3fe1693b43322bb7fe3ec8bea0fa3b5a08a7a0ab9600ce8e5452ba8e49cd0ae2c5774f9654cca138e8ca4af837a075662652e6cb312750deec25ff94a027ab12789f7a1aec4cbdf85d91342e45043663b7a909d19a44d4b5ec739e7c6f55623bb51e94220e68895724e31350888b0f35dfa1c5a7edf6afb6c4ad6fb06a40849ba765e16e5f5bab9af0d40eb207520978068307cf2404d1cab33504aec45d8a2b51cb29c4b63d7a47e2372512b4b2593e8c55b06a731d3183e50636feaadad962d6b53fe3584107398c233591b0a1b7a81e483d926e94bad9f14f0a5c05fc1b816abf58160e2bad9c060fb0636a9a68bcc6cedb4e6ed5a08b773c2822c72354a29cd1a4d235e56b69a8b208f78608999b162f10590c6a4565bbb40751f33a886735884a7187a0733f5266a33e855f402331a70d7ae7056aaf82e490ed20b19db5f59a89bef89122883ac33b8f18330ce5bc9ea54ceaca7ce3589e2458ae5950b0f682f919a680647af66bfe57313536ebaf59cf76a7346eacbca567ad44642c5ea24a349680bfa1210ae919e364a3a4d4ec231e8747f0007547bc228719ade51d0e84d737a89eaf678d3313e01a5fe9a219b9429233d1c3235a4c298530f5885f40a85c502c83ec950a778d473c8de6af0cf53ff5763bd81a81890123fbc43ae271f9d7caae78da460bc971963a181b3dfa4afbf9ccdbf384e3beca20b8170cf3f3f7f492abeebfdf4a7b734afc32534eba1efc665916f2936d41ffcf08457e724f2406586592940e163b934cda4014c6e23ab1e2d78ae1197c6a5185c7b2a9dbdeaf6b213911cd0641bebbc165440dbeb9f08aef973ec528ac2702086d348fa92da5f32cbeb39b010a852fd2dc150278c03680604a3b60775759cce7091135233de7db14fe56575d9bf17c6daa1ff7a7aec4b88777f2a46c5e98e00d0378bb1c060ba6e6b2c1de50a3e6eff71fe5001f135d8c67b7e4b43da455163081a260d9132c311912d3746401f54b7006864b31809bec75de770614adf58d910ecc477f0adcca044d5139dc416e6e0066bfccdd65cc0011293a84973c37bc7d7523e0e64e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
