<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"495e6ca2a50abfa03b1d8443e04b7dc516102c9ee20228626b0900fe924dfc2ef81c5f4a88a1094b8c689988d1fdcc74196418c538e80defc5e820325910c8eae197b55361654a6db5e66f20981e879244743f1cee4d8abc9c6e4c8285112e30e402db13394e628b54c469b829f6e95ee66ddb9e5fdb5aa6d2abe80cfbd271778ed704ddd74de1961119063bebba06b590473d063407b42fa26bfc548baea9ec38de95c17252ce9431689212ae388c5d9f5a352cce7aa8668ce0afee93555778a25bb20defaf8e8c4ac683230b9455cf5c01777de046f3478d2807dd26cef8b62ab3969774aff73abbec7c923e57e82ceaad96c261ff532d886d4141d37bcc8912ce6dcb0497b4ef61b1743cee1af0dd43fb8c05941f12cbff3989ec57198bc81efd7e52b52bb47eaa0b245ff14b87dc9d6f79263bab306f0072ed0aa07edc580dd3bf99f4b3374ed4351049488278465f4d29bf11e734bef3e642945fc6fc7f3438fd2c4cbf01893eec3c0f6188d36022271c818a08dc9023caa7f663437f82f605852b711244e0a500407e3dc7b8fdc3d1de98c9e8798af0699c9bda93ba800787d4ff9ec2748eddf4b95d8bece3e8444a268b7b4820f4e2b80f631b915524698894bfe225ecca8d48d312ef03ab3183ab35a71c762a51540922c7c6797e4ac37e057e35a00659277ec399372b8a84b4501a34f4a91f7848ad82cc41e36ac3b6ee03fee0f5c751b168225047ebaaced06542b9968df236f681d035a46b0cb11dbd7f286dd8325508886cf260b2b10b2f54638e19c6d06a5d546331d77ddbdad35fb3cf88d50c2c881ec201c5bb8a04f1e8cf019de9ba3c21f4166c79747baa0d5a1c9ebfcd2d7c3faa41f68bfccac89a06ee16ecba393ec3705262a9b5d3441a114062e00c7cbddbb29f615cbaaefc4512714ba8c5820954a232b9e28298011afdd8eb26bfa9da3b83bb7f93ecaf2e1a0c86b1fd54c3b2ca994f72252ff76d49f86fc6db24b971de98a2986b5d13835b869c1c63fc57d374373a0c3bfc99cb45dfc0b67e43948dce23477b3ef4de0e74a0b343abbb1d5310a4f6a995247b303154a22557c1ec845211af6eb9d9fa8a82a554bf63bc1df3d772d916aa0be6dd6a731a76abc72925e8ffd51f29e156b12536156088132d67df14a03fdd268186105b972334db5a23c6248939afbff46c372544fcdffd903806fc53fb2c2af307c18622bbe85651f191b2e34234540caaccd0339f4091d2701ad0c60d14b2fab09f6845972267a5197106d940890c096c165e78986448c546e483de31565900a9f21fb17b1fa38258768a3d71ff54d4e11196f4b4a9bd0397d5aff831bfbedfacaa7b40f2b801f26791b80db5451b262bd50f3dc1fea16edea4bc0fa2e17d8660cc9fc273f3bf9edb39acb302965afc1a8a5370c10d8989ff6fdd2a618277e6be776c2d4f2220169e2582e13116d25c1457a9e4ce01db1d9de597e3a1148191910d289d3d2b9695760cac6b12eee3276361b863d554bb67ca55fd1cca036e1405b53da252a478e9c8b7b96f9bae5fee47b46f8685368a12e577a29a86311507fa79b75bdd9bb819b6ba21ee59a1739ddc0ff8b94f916646e442fe5ce2cbd6e5289b7f6f42c0303d8cfe70127ea559330b9c7c89e6c90f373933871f71693e30955d28825047cdf7febe8ac5d2c94f6644d0e49ebb3b672c27bf5798f4b2b7da0de96d1732cd3fd165305018d090307e1a79aa82d60ee8be7a1cbaeb1b1c985d676a1494e30d6204639d969937f31aaa69b8e0633e4b53408e6fdf32d631245b94a53875f3b2c9d94e0fea485ab3f40c6c02bede4b974ac955356c648268c6acffc8b4447e37d4d6ec66aeb62e1cc27192c4bc13feeff7cb866335633a15864c52464be3c5d79c96d209af33e9624df9f5f9bcac10a211057c7f1fdb927ca7a8b3de370ed5d7b7aede9cb6535d9dd8c4d9b7a7c74b455d0c9f3e6df3298a8eee349107f579197d18dbf37d0f79a8e266366e37e80111030f7d73a14220930f087bab001af67132373977a1c890d2378db5fb4fd367166c9d9ee6b9c871f316c217ee710cae4d3c6b7d6e72530f5d28b0efe049f65a473f8d60cded0c1c406496be669176b6a6fd46a157aa7ebfed92351c1558865ad26a97673f0518a66bc0685bb3b957247c389cb03128a4df8e6589539f20833a4ce0830a03b28bd3dcc76580bafd15a95023f7ee75ae0dd79b410fcb2756370096a7c3945fb0e210cc281a7670ea1f9601f191e1c9e5c373419d0954f314fd2fce27680133dfb1112798a54e2fd005e43f576f8e1d32a2faf52500eef7f4a0084885d411f68979d471f6ced382cb5bdefbd5ebbc939704c70e33d1870bf3801e8124d0f789fd23b6cb1725d3903ac270b97cf5108b2f27184669aabf64d7c83d72c04a4088580761a278b7100ec7fc904cd9372b00f860707897ea730810fa982f315169f7780c04d261856fff46b118bd71316ffd99c227494df6912f74aa1ef9338247f2fb5f2e2b12721c967b6f036ecbebcd2cfac86a04a8c8f710d25e7e751435ed6b2438f41a9744584fc56afa581485af94b00088802a3207b54aa57c1de814562fe1518a64dd30d07ca95c8c341785034d3fca5f147d621e8ab5af0aa25e0bd2c1b1331c1fa5478bb009f523ba94fbeadbfa9ee0e8fc42d88ff39c8d4ca6d9f115f3394e1071e500df71eb489fa365a36104b4a91351cf259b0b10d089f68a7261ac66caa9daa035783c543beb7c651ebce759fb1fde3dbaeffb262e4de1dd3a82401baf9d3609859aa472fd851a9b191f17a666db1b80afde925cbabb84f5b939f2da63f982692e2453f2853e3508f5be5f9e0ac9c0175b84cb33dbd8b0fc8c1795958c168a1e9bbaf213ae595907c72060568b53850a0bfaeddd85c3972071c0d9b34c30dc6755380d3ef1ebe51498b6c4acc3300ccdb8b8766f9e68587ad67b4d2bccfc1174a05671d49cc331ceb003b13fc8f18e38cc7d92bbb5d50a7c45803b01448ef3f6730f4aa734b2c86bc4d449794f48b36c02b4d644f9823b6c3703db2043c0cd419b8a5224b85d50ccea07335ab6e417c285edd6f2f8973709f3529227ef36d21efcdfc472fa9980e2dc77c46be9672d19388264a4aca9bc4e9fb684557fd5e2d18a29e98cfe99b36bb30c143ae47efabcda35c7ef1be48c7782fe5926b4f23a94518b5aa224f38a4de5bf1f4d8fefbf0d0634de6d0bb95ab4d961a4361dfc7598a2fe9946ffa1369676ad364c627939e85aad1e7f2692ffbf2e7b48b9afe01922fe579cc55baf00b040b5daee0e7f5ef1b1a4fd5a30c923a957e8e7c4874d5b967df29014b54ad193453205505631b1e1d98fb7ed2dbbf7b2fa5e6d1ee6ad3f7a58627fd0513c52af595cc4dcb13e863c226f249db21e62cef0bf9b84b6c613f79652ae42cac2cf4c084fdc9a20bf2a1b275d4bf430717d96b74ae7cbc51fc185d3aca79e892c38f86b67e183be116f3100ebd81532103ab0539984c38d01898be3ad688d2fdfcd80fd2cb700b3228f982c3eab288ab56ec854f95aed9ec95b713b98c40aa261906ba6d8cdb8357631e04b7b2edc6c144ca7ca8d54b262f6dd12ceb64a203f8bb7104f2b52391d8fcf86f305aee273f500340ec1bd49b23831b9ca34d2b789ef324448d06b91e71387fe949e6528fe419f7fb10126e0e3b8a820ebec5473c919342a3b997dee5cf4c859c2d242fb8e18432cdb00261bc05fc281b43bedecd42cd6d04c957090868c15951795614f814ec42a3465e1db911d84cd703b480532bc50f2c3e4a5f0b60091102ff56059edb8f972b7b26cb8c8dfc41726707bc939b63dac4b68555008727ba3ac5c83a20f9a47d8b0626c19db97a68ae02bff1b5654a213b9fd1b2df8f5737f7c7b9f62fa15dcbb585e7c106dcdad482074f1fc64d9c10ae5b5cb6e3eaaa1f4ccdc6d6d22d81e19c808f849192c004be737e8bc510ca9abf09485e1f2e07eb8727cb582174dfaad4d56ea9efb41843e85c05ed89b6ab493452021cde1fa4c6a7ddf4cfa33bba1c9c38fab5c434b353648c06997055f14cdc8eed4842a9cdaff3b67f1c775c5640cbb74a5adaa318855f8d5651baf7d7f1db8431e78e8a94efcdc6a819aa92c91ff97baf5bff5ec4e71b94fa2f86be089d60f0c8e9724c36da9cec5f3cfd0140cf051fc2eaec5f0cb3df7a9989aa4a39461b436c655d94e55f09ca30dc086cf756eb392c6db0aaef3d5fbd49586b5c66feebe135715845f013674e818837807704fbfb17edde30d3c95269f79d53b7325fa437be882d836cc3958775268e4d1a36eb8e9982b2f2b373e3ef5bc843e966f5b957de3e766a13653cdbad370ab10173908791cd6cab34a40ad9153c51c2528d84660aac82b40bee4299567439f01abb10c88252f68238ae645ed838a57d60125d2475d4375199aeb15e9555c6c0521e22e522f31c924d0a82ef38a323a9dca347354d42cd4c5a15d27e49f8100165e3b1ce2a1065bf133ff92d3dae19a357d7427633519cf859683b5b3c61e53fad35ca3b72408a6d65d96cee7e28a19a0e2bae7063623a83358f2e36336059ffc8f7a2b4ca79c769f669938c6896de1c5e8ce46b536169d49338d867a8e4811656aeddb599dbff359f666e736115a20c38dc63cfd3bfcf8319c99d6b1f3414a8a8a20719663c18906ceb4b81b663569dd3051fafba31e1c0d951eb733a1ae8b751b0b547d6c844cd8ebdd317fcd8a56dce30b4f52f23b40074f10787265bd01b529b0cd769ed76ba90023b0cf8a60b33144380b3ff6a57050a8aa8464bb0dbb5e00672ba9a72b6ee9b4766af6ade57daaeb2d6a8652d039a2ea3ee6040b0616d0e2578c285223d87b72dfb53b8c3b31c38e1d562f08fc21eb40dea55875019111d5fe1eb29bf61634fd24228842cd6018353fc82db6977b894d135618deb61516806cf896cdd45abbadbe2521401d5a3a666d3036372d17f3a67a0229110bc59611f0012d72ae26bc63ae9fc22d8aaa637f25c7dc7b666bd7c4c287a1e0aa62c88ce2c55665510856eaa2dc056efa5431a4243347aeea199a98921480e7ba061f1121b2ecb6c41f3418741f34d56a07d26ef3d55d8a5b921d3679567aee8e3a2e8b3b208988c8a8e596c88dc72de286391d4db95839114bc4ce560017abdc1826cc3ad1a52875185eb05352ce1f15b4308023461633c05c4f852d957458ed6634de4a83ad711b578a7984a4a63c5774c3f809e81991d25d295a7e7e848f0cb758e6bd415a8b210807adfc482683f0a75a12280800653dfba97334ca94b4ce04a40d1d00de6cc08a50ca8c289475fe046cd1fbf1f541a2652dfee0a37c5f045d87fc5e34a44c4198e2d26cd9597b2afb64aec0b4e79b1d46de711eb9b4259831451e138b2a393d62ede4077af8c599f0e6c407cd79bd9a944a346b5fd1f6fc764d77ff8919bef05503be3eea56892f41e84330a5cd4a034ddbd9bac172e88ea5224963d2a18f8fea4b9c5d110f2c53931b5d9ecb6ae5f0e4df2f22ef824743e38516fabdbbfd141b18eaaa37994f69b748b1513590aeb30c9af362d28514422dedb42368e861c4391fa9b437dde57b35f5b75a8c3d86144f4a06e80fde207afb484f243dcae0fff6dd7cbbce77e016deb1305b5476d8007c62fedb58591852a2e56787cdb9b181f0238e44b0d9db08fb94aae2abe565181c368ec03b1d875486a0038003bed29f6c5fb2771648469c41396feaf6726e4b281679f2c72a3e14184e3bda5151662f5abec2eb5b08015a0b074d065c53e0d01aefa71676e9017614cb295c674f7dae8bdfca4fc9b0e3aab981366dcd139bdeee946cfa5b69434e69ad9c4d218e3164daaf0ed99b52159f2e46d746f47ddbc81efa8f0d09a694c4ccb3e40663dea6a31f6875c818bd287e5d15eedbca29a4326713aff39b46131586d1333bd0b695a39ed9218a0d109b358612cba32acd76eff934999e4d1fffe6dbf1501836e093c9e18145ea04eef6ae45deec6b969e6143e04922f318fc0051be34d95b9e63e7db9287e36aeeb802c5194d6aa40c43f7c802faeb9b75598a3fab2044cf00a2210fa2a2d249f0047673726ed11f06256d2482bf44bcd4ae6a13291a54a718bfd3867f89baec2ce4927bcafa895158f8a674caa867ffd8d9a33d4652f6329328dbc578e6f5c4a0de92ba1143498c0ed011c71a10c8cffee356dfce25be5846d79cf3cf84b0218715e274eda37274059d1cc5ed6573f8b0c17ef2473a22552fda3d8865a69959aaeb5b15b442c6c250de87f94a0c7a84d8aaa9cd3f0803c3e81557e9d1d957de3110fd2a53d6b4ce1ab43aae98f0f822d5d8d31f48f9ab32d8e5643ccc96fb8b0a057bf9c8214e4dd49ee33e5ff3a496d4262923b24a0f29819be13d5dcb06f33cbb2a121d08e12e237e940f73abd734c0a556e221e4654434078e3b2d3ec8f72feed05aebb20628956215adb99bfcbbeae269348f7fad95f2eb1c4589e170927d7aeccd371597a998de30d5aa3fc867cabc311db45161c23b2cf1831a6c520ab127a7c29695b421080828ecfc2f16c4eaa34a70bf5dde64190eb779001319286ab576356a00a5c3d082c0e7ddadebffe19973d6544499f0053b6f7918239a1a3bb3a0e649f54a09a05bab045133f23582cb43813f38d863c84d737034a02e98a1a412d8a99767b09ce0d07527af77a936032f6c73f23aca4355b44b748746af259980487adcebc67797371dfcb3245cd0e8279d7b0588d404b6f94f892dab3ebddc1995e3bf677e465a834a85bbabb31227f7cd1459cebd02bc050ac7b7dccdacf213a1eab8673160dd127ffa7a5a9a71782a5e220da3958c546ebf73e2eeb04afd23e175601130be71309cc7d15607902f389efcb7fa190d3d2f1923d528c62f4dd6ecc49a651e5cb2a96464415835a6935a77559f422e894b215721c030466f81aff785a060c645beada731429271927ef503262df5ee4521dcbe5eaa3e842d54b32a3c20055b15ea175697953ca7d7ff3ed37d42a26d8976fe1429341359c8b8724b6b970a3ce7b9412aa7583fd5aa6553b38f36772d24421ef7d699b7fb7903754a141b775a86cf4824ad25b593002d248b702c9447a856ffcc29712c6d974eb2ebbcc85e772faf783d910f11344c4ea963021b468ef4e60e2caa4622fc5c7a9f94b712976c1986e135c10702a8377e60c0342b5a7990ca98c3209b06ce93635a383e319ab7f33670b31eb6f231dd0183f54f2feba10f34eb4fac98fb629627bd610a9a3c602fecca29e9d25f47bc3fabb74af2b433ecbacfda3d76a7b5fa0313383ada3339bf2f699e84b3990b5ae4e9f3ad862b4ce5827a6ccba36765ca69c913f24e1c8388999974ed6122e46fe1c29d07def9c9246e24a9c94656b59ea97da8bb8ec8f72a69e70dd68b9e614ee81aa673b6d7e480fd3de94af9fd569bdd02df36661402db60a62fbc493c77a8a2daf7b88efef87785b723847b40714fa20ff17c0f867e1e941972d8b7b26befd084d9d97d07d31b0eed5505311aaf3f633700158b7213cc57995b31d7d29fc6e0fd2e2fc4e4ba285d80c9f13f41f3275302b890c5953396760f640ee697bb8cee6fd03d40b7328bc03baa206825347a7698277d2a91517e4f346eace75a4b5bc8c288bb675f905684e782d601993de9466bd3a7262c2d2cdb73e6d2812385e8b82eff14a5d60bae9f8ea3f72ef2d947d976facca375f6cbaf5711640dc71d454c01c71f83b87a79dc420be6020d421c296ac4b6942b363f3630d6e0f7991dbd113700ad9832e344b34d19d6c78bb551ef72966fb082ef39dceef85c33b76861c56ef50f31260070ac712bd438aa52d75c848824a00bc4777cde3f929abbc76474797d78069b3838ecdfc1ad7629ee7daefdf55e8b75aa877e60211e0aafba17269b94a076fb1751ec2f7dc71802a23fdd6bec9bb19d70a3ff52cb94d6c27150208ac3bc7f64266311a480efd2c64c57f79b3ea95e11e09b6b7aa6534d4fb1441c76d6505b89d029e10fd205aef8bf8b202dcb9fd63b735a3e873a6b3c6b3be5ca9786476267ef5c4cf768f89583692ee3ac666733a85e93fbd2fe83ccca5e9ef5b4748d17960e44c4ddad831b6e05e87f3d86718365bbde48f5a6d8b186718da51a29c55bd905f98dee63b58a54b905c626b5b944285909911146e9eccd7906e46cc41c42a113a1bd74e8a6925caf7a85d07d29d968d50ff108d413166feb2d1bf1f22313c856f6a76ad2cf1b71fca0c8d7e664b647808c455f6e6434a3e0c0523cf8d004976b5c03a8aad15697826e30da8cdaaf81737c98fd48c885ec7ad36280ee3bb519378fdcb3befdcac41ca1bee77ee8b19a0a69084fbf8250872b0309a563c2b8d71d1751b4ec4570fb5ff562c9d737bd658cd50223bd195e83456876de0b73c858a7fedaeda49471076f016e2bc54e89ec2b45441b542dc94ba4db07f80d27f3dcab87ba9f440e231885ea9ad715f91045b14f0e57d87d15f9c2425d522454c41593744f4aed6cd3166a5412d7c791d449e12c448ca453c5dc72bcef4980b748759bfbbaa3302f3b992785e414369111e6cd7ab55d75926103233b3ad3f6aaa12e11c85813ee8ea0f308aad7306d4a799a16cc193e8bb0bddcb0c80625fc5a75311db79acfcd6f757ce1d8190a2ca211a422eb3e6cc8bb9c7c05c4cca01cb79e3fcfaa3dfc67be59b1454664aad4678417cfbf54876bac29379545d45433572d0cc273522bcf6bdcad54b50821cc173f8678493d3f4174e82a791f0eb6aeca0f8eb7614bd35a0a26c0046f57b3d57ddae54e5e2bd20d4127259599434040e2d7561b87dd05f651c22619d359ff3487f8e4728ec8dffeeeafbc9f55685485c26bdbeca26383ad314cd82d54c9ddf1467c4eb04aa6a45f9c43e5495722e6e8f10e0462c49fbb280adea20d4f0f988a9a5d9e1b93f798ca2e12ac973706edd43901f2697b798af9119db4986166fee5bbfcd20f260b5771ef8971926df713f628bbd94b3fffee5fdebc1809960ae491e92c9e8705d2c34fa63e163c5f6bdd210fc47abfcd7260a05a4dcf16fdaf24261f59efd3f6302e025b6e9d96cf1f2e8241a3dcc1b3943ed638afab3aa6c56d7c8d0bb59c0d5160ce830d78146293b52a4fc6123211bde6a78bcd39810a590a0843fcf969c8db16dcca96df23430de0effe9a80b923c707ea4d6995fdaf48602a363465133da64666a58788523780ce706d58c19cb988f6ddd46906e482f06a21774401d7a161cea6b65d039026d0ee0f38ba3c25b1325907baf9ac8a6c0dee9c2a27795c6b302ac5d406780e2f2cb59a2f3f504dfae157d77e7f9aa894f7d4fad984f11b5165aa7b43e0f746f22f277c7b5a5fcf357a39d79c63176fe66ebe5d1622b71a4d199aa2aa7db2323cf030d9a0af9d9525208d36b0965efce5b94bac8ad23a21516886c09ff45291215c622792d270be0f2f67c772fe07295ec04c0ac10084fee29c807efca1231694daa5047d9fa6044d0fc734dc97eb2a05c43e99aa5bf29a81f152de1c63700eba0f5c868ffbc6fc41dc9850cd22e7cc9ebbb36293d844882fc2dbfc0b20c454f49a1fbf6226a34771c8040a11df6b1892a3fcfd1fd049c3ce18afefe1a3c75591022c45214f34213fddac812cf0a54146d0554bf4f9f4b4d734482be4eb60d40f311e9f8929192aab4351abf6ddd743e0b517f1a1f78de30bfa53e5148356a63cc041ce1e7dffba25e15e6c6ca79cc94299924e54920985a229a80ddaccc2c98075c580a5a5d851a4b95661cdde2c9882162e54c8858f68504d3f14dd65a2f0603ba346ab8ff70da3c35ba2c26daf85375eabf01db649e6e225064c96bd3d8a1174e0528cd07cdd8d7480b29e4828393df32fff610f0299f87313076b827f37c657aebdbfd96ff5939529776c0d8761787b306816dc18bd33a0c997df6add8e86964124077e3540debef54f9fdcec00986649546a5fa254e00a34cd7e73261cb102b9fcb5f860518ccd2387b8ed275d6df2aec78208aaa0dcdcfb6dda67b43db1e503b10bf2c626d39b4b2aa43f952bf80a7bd5629bd461dec87a200c465e44249f57b243e8665c7aab5899ca08154aaebd9be44b2b24887271e1e45984d4bcde892a0908436f2997c967bd35c867b61623df327e758eeffa4fb817602d9f76bccb997d01dbfa96841547408862f9771db051b4e418198cace465cb40e3c029c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
