<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0aea163bba599604fb2ae24ba7a2409207bf44d2ee0939b0e208ee6f415740954e274e2eafaeb7e3d6b131ce6ba466cf302b0460fd0fc6372d8f2cbee64fb8d79849d5cf0a2880698e73980e1f121f916cd600ba5a12f2f100854becfd691a2a45a3e978abc2ba460de8ab9eb52f48b5e0ab8f177ecc75b0a6a8bfa9a82ce4ed548a27a16e2b6d0dd0f9994772eba034cc9aad17feea051d2551b05b880152dbad035168f7656f294d7f36b6526c8f62038f2faa8301f5aac70a14eacd809181b3466fba842d6cf666f9bdc663c8a4bbcb95f17a2af311c24d09d5131be967f034f9cd6510af8aef0fbe5b862e295e165ec69af3296e836eda87d10d3aa6cfe8f09c0c2becc9d20e77b0a76846e35e65531e0c7bf4ff03758a10d522770126f0b0b92d3cf5b4818f71f1ac0f4d592358f3e895ff0f1bdb6151d17cf31ddacaf6e66d2b228ba391a6be84c335ec43ca52df8ad11fb70955bf704323f3c8a773ed2c61280e02d2b6ba9c336478ee76b17300055debc2fc1aa48b25db2f3ac023fae533fa29d3c2f4b0647914b6851c59098ddaa6d6b97a50138910aef255c7d3428207ea88b4bbc1b5996fc964ce45df279264610de02b02d9041355214a6dd9f1beaa85b4b9bed39a4560ee210bb74fda64aa01e3494094167c7cca6599cd47cc83de37afb01d81c3df580386cce9b1c2be469dd9bf4338695f6ba02270607367e8122286ed333bd9058843282ea86badbc26ae203e8a6c1e761ef2778ac9a8eab054d60508f9a8b92ec16056c47d877ab66cedbadd5338be3c8041f4463c23f8577b377bddbe6f5a98a6cdda6d7a69f1b719dd9ae157d1f5f3b8882a4a08eb6007346b594889514b51c2f994e1068024f0439fae1436444c94950068f15f4cc3123359f405c1d2a29e66614c00b5d7478186edf7e371ce259a2b0236a3ca9cbae754b3e1966ea736f2b1fee853b44b31c0454d19e25abc4f8c8e7d7b26a5c8a7b28acdfb2d33e6c7a7a8592a6cb6f879d62cdc73865a7d8d469b9e38ef6cea11b3514f2c498ca778011706ee35cefaf4fb3c3797efd3eac7dbe4f274b556fad6291cb8f9c8ae9c4b2ba4b5a5d713dde74f652233ea2f24530d417b4bf6d5a66d1ba11de63db36380ec08a6188d2dc29118d79ed4b46233abd847308b9a463969ea35247b187dbf3ba1b072232192073b4d85b1daea45fc47bdc5052733430793e603576c9169eafbe7d843fbd1bd9db1e986f0739247d75706766cdbc8e987a871ea047ffa7f432f18088f0aecfab9f900173a0e4b07952747355d4e86c3f5ed9d77857c4b788340a6a802e8705b9733e5caf6abfa331517a715e1029aeccf4d56fe0c23a72d3422e871781631b63d515ed54b3921ca89cc9d8a505f77286bfd6ef6043ffad98397db0bdaa6987e65d156fbf4c05b78042783d8934a2c2e980487ae7965cae962bea49ed4c3c3ef3d35f8c5aca11770a3ca6a54c11b2c42853eb6ba376bcfc766f59ab4d14e7053a966288896c86c604c8eaf8dbaed74fb00109cc465e22f93c7ebfac0e0fb1306eac628dbc102bafc6084733d52bb4e2659b15a8cad139b152ffd33dad7ac4ce311844a84f14c5463fc09c70bfb7835be3426a3c5b8cd7a4af43b16817471bde8076fc2d08bc82c453453e33235d6f2726788156675004cd70e1051b235493a58edaf9c01e2614e948aa447e666f7a295a48bc967f7a0f520b64b52399451bd653be83f1b12d907c4d248982ea343ffd16c86aae33d5bf3887ad57fe6dd87788477e4c77aa9a080a603161e81f66f0657a5f80b4094b15c21c533b194bf7e8f709ade896343898e521938284d5f1f2527f80721facb261bb776eed38bb9938a40ac92181ec6906193d4e1f5f0f410a6613a7b4f74a09e5d077c77d57b5c2988de6263b578272c949129682333f5a60564f8396d2f1103a6118b69a5c249a66547a1663009941c6db502ab15c748e4b1a79699470c48ee88bff6e67f7232bb7e0a7ca1231ec846b0ea19636e6e5f7713c14078b392cc83e6149feef335625ed8737b46c9318c997d5f8d6b7fe37df05f008e95b3b8c0334ab4fbf4f516ef42804e690ea3b3d42af50fb4445789772000091d562af81fc6c6ef24dd31477e4705f5de6c4dc5839522b8745901a26037ab2d795d3216874f24f2a3dd6e1ef804c97abc3346eab0c2867730b2a2d6465454bf8aedc7f35c94802d9ff5cc0642c79a1836ff6b7b0bd7d8e7f3e9a29f40de4e2b687978dd9a8058a5af85f26df5911dba91dde045be0bcbcf7ac61e7adba9c4aa5b8eb42b429e42375ace88c48ecd86126a70f66521c39fb32c346f49653c709094578f7c27909170a4b438ef0b174a7be4b9e9fa2943a0ae944b9b89b0b8bee15e8ecafb03acb7d9e4dfeb8db28814675fbea7e91293b3dde99fc281b67a308a0acdb0db923cb82a08f669fa3ea92c61d1888319a87232ecd61c8b86b8bf81ac7a3a272c7ca8180edd51fb99be145cbd8e9edde687a2fb6e66d992064a3feca7f3f61f3bf029636ddea7149cdc1d1f21da7b91157945f67c35b5dda15da934e5f1e9b9a34b88d334afa4b38be1ba492f8c72793e706258bed0942ef7faab9707590796499664b5a9b6c95f12f54a1ff124ee96e1f340cc762360145961360695b6b32f45b15af303656de7d7fa26d22c0fe28378b5a2d882f56759f546f63b9c2db658dad6f5311271ff79546ebe7ddc1610c97a08aab17c9a2908f35e861dac173b7d39734d9b300e1e676364bb96d445a54314c8efffd1cb65a5bf0aaba00aa285630e37e06040e9a49f9a6e3bee0fc4c53581867cf07b65d1ca1aa1c378c017944e69ddeebcf2a2e2d5d13cf0c1544ead2efb72f0a02e5cd2b8dae70ced11c7d0a0ad66176adc5c2064628c4c647590fb2d268c317a803445d4e44397bac62cf118e1360a8fe85fdff53744f1042e72618b037d7d1c5f4270962f41fb768b1fef1740dcf5dc2e28c5f8077d7739aad7c3d606b69f9944740cb49cc0197be836cd2b313e0d055240c630620f0a88c1e2b221055faa3ba9dcfbfce650288ec3aabf066c245dd437a01226738c7481e88530acb3157e47eb2aee613217eda1db8c0593d4f2afa0eea28e28589d7a9dccbd40c3410781722745aa1df2ea015c9a3babdfa208545334d356c396ee3d8e2798855b5a3ab42a7b0735f359eb7d7eeed911d58edc52e36bed30b7033451ae1f6a3f5dfe73858db7a867896a242a39dbb9c6cc80832a001b64907f3cd802c2fac6ec0e20978a60866eeb9b39170376b7424b8e62bda64a365b436319c81dc4c118fa736e22403bb7a119b3a15d2f4f80d5e24fe2f623e3728035814051c8321c2bb530189112d22a10359ac4932978ddc23b880a27904a54ed6626d417e91385c8e9f7a6bed9a449b2cf1ec8994421a9aa6a2ec9eb803d91fea1b90cd141e762ae1783a56655f000e9cfa8dba023d9bf1c5adf37855966ea67adeac7ff8dee8aa5ad8d665013d7d86285921b2430b587adb8f8018fd8fa63fa66a8e925cf36850fedde25c8945efe71035a0d9765fcd7ccc13251f482e44524ce2b7ab696c5fb9e1e888bb3169200c4f1758fcba42ecc99234e71c2510d1f56e2a6cd3164c4eaf6e69450a65d878c7d415af547471305ae8f6b589b25635781d3817197d9d85d45040c94d8287895cefd841d86625b77cab2a7e67a2d5e453c93399c6150e51147c549e5edfd71ce3b529e6bb22d5bc9f23c130d3ecc09b5b21dceb86361f4c7d1dcfbd94f330f78d84ab346040cd4591084794cb2c25310ea73d9f485c749497b389b7008b1671ff3b42994cfdb5e2b885fc68f780042dfaea4b6f38ef3bed46cc0a930b0d53ba489de998f44e5bbcf881960ab5d55aeea18eed8e2ed0833b96a9da32b88881cc953fe5800b7173555648982df409f81a3217b8eeedb3f67750f14cb475bddadf6bf0b25964f51d87a3b88e6b47f7df23fb553346c0c2f8acd6bea5ad980992413a0a59d1c0a77e28904713265215814b7b5acc33d6caa2430d2222fe7e45353a8bee09cb7b7e2d2297c679edb546f22145319b5ef70f7b0feae278e52c35c8f8735d68ba90b5d4301f523a7239e55146805f723591533c2725688ca01bb1d3b10dee4084a15f7eed76d0230c87744cdacfac8c5f3e93d1d14b315ff4306375db492e1808fc100e9823324819f5cf71decffcfa2ecf14a71cebc22dd360f61a3490a3b2e821793580c6e64ed19bc178a5beb2362e4e9c66610f09bdbd9ec02803de204838fad44aac4f9a03edea1c0cc67948ca7226eafb84d3f9e28cf0fe0be6e2044dab71722dcae35de7ddb2aca19c17894ccb5a4b63f8d7f2993955b06cabdb0025e0751f56a428dad43ec47d527dbc5116038a89f65833e4d1a943a62227384ad1e6e58136063adc87c7d4beff69b73e01d240031e77175efbd77a053181bbedecdfb014e3c112509ba5fe482494f15a1356341980594edf47097042ffa21a09d56a5e296540325a49e155a9b1ecf35eae4dc9f88602f47dca52601d34714cb7e0bac92f6fad7d48a0e0026f2b764400378269c9daa58b8b2b25b1338a98dc8263c3d2c37a7cabf808c3903f1c6153c06e445841ad02d087cb1254f95af78209809c5edd7c4079aa5f0adf597221b45d1f340f2d3e8e6b32614f62a06ef11b91bce5a50a90c7aba45a171a3c414995d4474d5c72779d407e53fb3bb65df1ec89922aadadd959b85a3acc5288f1ed6891ae5f39d6e394d3b5d2bcb393b2e8896f5da4559bfdb809c4b60c2487da1cc35410abf17119407b557e21f5ad6e3812950daa9867c6372da3b58022f9000c428c0f7a864e27ba64a6a0aa3609ba766ddfd3337890656dfd7f162a162a8468a841ce46278ed5d36f704f9207361f4b084b538b10d29648676aff4c383acdaccf5601b219c49f170c5bd8db9a15027989ffbff8e3d400cd950d04b558695e9babd935f6f2b25dd0f4714565f37bdab8c7a6a44936cd95fa0ee70e06e9ced409670fd0409ba10ccdfaa1ec3f0f7f240011741261dd6a80862795f356ca07a679e7fb6661e39de83c09e0a0d91090a03331278436e178390a32db3fe752ac186ee170664a5459c62fb0f8a5b1a58dc0adbc82c4f52523a258ac88b4ac27bd31dc32bbdff90910ad27f20bf0b54708eb138ac83dc5b14fc289400e5ca829854f3dae0d43ecf8289f50732e9a4059cf285a7a9d78129e358a607f6a4ead4c8e79309c2a0895a1a3a2a1dbb90baecd33da553f7674eb268ee6529d4f85ec2dc51c6e6cc4569ac01c5f2a6f132f626dc666e4ee67cee8bb38e1e211b12415ccdf1de346639ea29333eeee448dc84ba49bfd58d1c8cbef1b5d81670c223782ef7afe49f9f5d6a171c8653ea787162e7b59fc6ebf69cd8d611c1f160a3dfd02aea0e54912144283c6f8327cbeaea76e878207a3c9dd0420f91028221d331f24854afbc27a93b6baec8cbd0639902ee21595f41a57e039d2ec1401626123638ec4c3fee24aa091d06001772485d917e744c49c701b237d71f8b8b1610905ea205a66bbd63687d1dcf2609fd51109791627d5860db34e5f2c15e0ec9811cf914bbda94debec7b9d52b0692410e378dde814be05db40bad43a824e70a0ddbccdc615e7c3ff26f12cb820a46e13642b3483c5f5a835de67c69d62bb8cb15c35b0431dc5b99620696478ffccff6cd9ae180faf49c9901774f35de5706726994aace7e0c760f48c0741b9dae39b83676acb6d1112f82c83372b2599c15fdf05e71c3585cc6f65e58ac51843f64c7f2b9b9b7f80bdd1b8f087cf66358f9c1ad66573ba09b36dfe7b7b9e19e6930ca8d7fde0606615950a5e21121ec1e63de4b9a4142dc5b82a0fcdd7514d8debf788b2f4fd300aac5bc77593ce3658c9257edcc0005ae35ecc387cce4585c6ccce7f0e1a2b9d7186c810c626b1f731c6dbbffeed64920abc68fb116addc7e958f81a379a859c62989fe13e9f3ab8a7af1d3a562ab4015871d38f99cb52d81ea70ec1fbb5f0a321c88a76aa9a4d078ac5e0c0bf08b1c200e9f7dc0611dcd780ba4eed6d503ad863a01ca3f2c11117572596b0900dd7b96e72fa7f947b6601f62c6ec573d86b6e97b5ac512bb0005ef060b9bc1a20ea0c5bec9c2ce13419376f209cd94f119c2c676f7b7b6da5beb07a72f4918b3d00e2fc16a6b49c86e2c81e20759f1c920598bdbbb6ec72e098ac5fa57a2fff496d29f5987c4d5c29b9ec51ed5be5f1a4c6881d52d69b8154467dd75e6a13c48d1a16b7bc5ebc1fd9a1906cd41df3c1220e33c718ecfd08bf17fddf1bf10fd5d835d42f5dad07f72119ec53c95f5723bed60ad374411ba9bef95990a3e765cbf90a327621c95920c2f293c2eb7f67b581bb3d1bf09c38aa7bca341aabde4babfe69e794c028715983b5374907f304f72ed0767f1734b722f0499574f88fb1701b8856c514ea282520283a570eb68b129a6d9c5cbb72006b68ae58d04d2f523457ac8759b752d816172f21c190008129aa71fe51ba5da8c1b1deedda36d9d9a22b9a0af7aab1432d1b388f2a5b8510546f75171872fe9d65156649fb81c5adac84cbe0cc8a352541b5e8a4c4bf0226a4997a19afb4201e9d4552de1df8ce3ddb5e3697298b0446e834326e3683c36f68ae7f229ebc61ceb3867ead51634d4d57451cea730d24bd766e9ca36a5e0ca55b7f17fcbb0621717f4d7702a15f469ea659e818a29107438f70d84e57991b3b8d99f10acb0bcf11117425fc40b7aa41061631cc15dbabb9bd130713ac4419e1911b5c1d938a1bd15fd73648c3f1acb4155775c3f669be084dba7d4821800a0e3f47f0dcedb6d3175e9f74a0d7faee7a058d224e12eb98680a8c1b30e51ad355e53b94f478ee1ba7db955635ea1d30802f7b2f84819da0891d1fe3989c7f111c42af41fc0da8d963f82333c68cc7909c5846fbdf401d5c0ecfde0c2bad5ede1eaedbd8284ef9caf8a7aebb453e305a900e32207979f7f53c7d2335c5f6d2caf652cefd974471d0adb5ca07699eabdcd8bdad3e6d159debc8e1d432fb841c897680b26264d86989f2e6784cc0862b3017b8bc9e9b1a1fdea21dca81c80c30fffb7e581a1c8fa22395028409d65e0daaf66f863eb90da707ac5dfffbae379c671dc17494da727767670399a373dd9bb75cd357b65893aab97a25bd39dfacadbabdf1518d9c214113aabf3e6219c1ccde509a278f8c7819dd424787828104a803c956b7b10007e7bfeda588f9017349941e092f8584869de585967388fbe0c039f03f497723fcab4342fb1b61362746383d9403e448a17506a9a5641ba4760202d52a4629240baaf1348770d732d3dbd3b15015ca577df7c518174b1dfa2da10628bb4af8071853fbaaa4927508e6102d4716b7e2cb48fb996da3bd1d19d9f43f847098f5470284048b1ff9402502656dd6f263eeb134d4f4498a0309c511b667af03cd54833d50bbbc5e6ab8cbe9752e900d873a6be777f6b6d26aac55f78c25ee048a721960a64dd57f5d5ff6ea746b0f0298629628f319235a27d8811e92e0e2d459b966ef050059caeb912102c1094a38cc2d8d96835d6b96a13d3b6bcadd43c3f5b129b48dc38f9e747ae2c89ee8cf9c5e43bd22ec191a7d2981c0702cc4c96e59daba05c1b23f9225e793c3f13bb4d9c60668ce6548a92b58d7943fe1e777f874e3bf129d512103805388f055a2ccb15eae9c1e41dfff56abc3e680dbed00f6f5aa8f62cdd73f02bb18779dd0de0097c116e2f789e1250c3a0a745f59a40155c6668c807c92134b0c10a8ec9832a5dfbf455c8bf0f90bb090ad3cb9516e1ab4bece512dc786cf2f465b8c2882fe93bff8963d6f4f09bce138fd5e7bcb1c969e17b103e6dc602b2041dcd9805db42409d3bc21bc8da22169cfe91bda13cff0cdc54cce4dd6f4ca62ec97e4e8e1514041165009ed0b3ada026ce954184d84424092b62862de65ef6494cf090604d17bae6971f93098e64fe6675e54f3edc874220ea7c9998ece798fe888b04b587ffa75e5d133e990987d35f3cb9b69cbe28a83d071b07b2f984307e1edfedbbff463bac5846a4e981c99695a809fdeebbc39001d00608552c0b69405d2792b403d1ca0d54a2db2b85442453b0f853d1becb96f3fc1e000b6a6b0b0a58ddef2cf7b9f2255cdfd1fac24902a2a93ea9173a0b3b3e1fd1ed6fe661a7f808ce5304a4715362043be09a9a3b875f68912c4882aa579fce0e213ad4df60e72f0b3ab88d3905211d55f7b7c4bd61a12ad44ec0e2eb9d3fc26be6904bb1154a2f85cefa40e598d777151d22cc559be37a04fece5b309b400e70fc47555204b5fed59ea14d88216d9d4475d964c46425fd150f6c4f19c025bc052f3474fdf140026865f9578cfb2313614e350929193f6f766cee6f86195d41e6dcd2ee561bdee705354fa9b3848c279b72529caed4de4f8d03d313560b3014a228febe00bdfc22b5e768456256aa8328a0afc354e031d4b2d579fea0b97a28a2ac6fadbae7f6d5dc658b04c43180e481c6559b3ccd848b24503b083fa00899c419737c0fb1a85937a024a53a32a4377fdd6660e1a5d4408d991acab8f69f0d6ab1f3aaeff955a102d2eb89259e96d37edd146dcb88fd5bde2b40c9be3050b956559a5178fb1478eec3a8616338b8dfc5f081fdcec2ff70cf74b909fce6c355ea1eff8cb861beda0435de3b57aeada5f716334d520f28f7c89a7dd0f6720ea61bf3f474eafb7097b2a560ee14bb6acebd9034b75bb9d7c229f83599b47dce7b49d9d1957106252765d2b1d060ad0743bb0fb60445db09a23294a659fab27254c26face563fec836d60f61e9df3b8350f71603dd57126f97b3fe73e679f44a6de2c3ae81d789d9a73619a5b195a528c0eee174b8833cc062ab71498bb8910df52353d240eff3d4b19cad69e8cd1bcf7d0426858b875b1e18a7227c8b402880d129bd7070d9e372d82897fddee7f3a063fc51b27e28de7c74f2a736205524768d7c0fd37d33e0f3ef721775ea15425f8c8a96a104f9280ed73913bcad564906caae969e5a1c37e6c94a2e513af7d5998cd4be7d0e67e29f922fdf63628f5e3ff51bee3fc65b51b58a51d215d6e717d1589abaed94349986bf5a6991a29aa148de1a9213207380574a4660a62fcc34b15c79171ae82ac1c8e00be529d0c3f78abf4d711aa3adba00b5b53f099386573465ce117869a7b96f0853f5d81df0646347b4177697090d046fef7f2f3182c61712fff70d29eb350f29acf6b547e865a178898e9e202fd8d509cc72a23cc3de1cb2fb7e8545d02a5a712d2deac7ec4bc9891835ee7b12eca90bae8dbd961f941eaffcfaaa7f5cce3cf5eecdfd0fab520fb5edbb15019195c4983e8b05b7b7fb76fe764c32369c8590cea27a2bf20f53585a93e8742276096bba5a9d2e421702863d308c3087ecd197806b1028beb43faca0449da74543188e3451b5b6743a96b05259f5009f5fcfc039061a95f486dfa570aa5c59fbdca42624ec5fc4b21b6e84956c4c7a194b8807acfafea308814400688d33dadfe21c945610c2371bd32af898a314f1503f57df0999fdadc8f4b727a0e3315a52e85d73d7706ece8362c3f6421e6ee594d28e0b5cc50284e13af0cd22b5074b55b54241f3169215c14cd5a542a3cfc2704185c88c716cbf4ec673c2c1c2099a203e7ecb0b6e94b500843cb99670f1dbc74ac55fc445fab633d024cc632d02c3df7fb7df6e8095a25055ac673e448cde1ccdf48ead12f6340facc4a1885d8a229ad6d713254070a1dbcab9962d332b4df45904f932b33aa57e4cbb592b1b34c5722d1353a28a34b314364fa7e00ba7ebf58c807386e39882ccad9ac5564f97834acaea77d8288f9ef3363b77f4697eaa5dd8f664200a7c467f9c0dec38fcbef00b2fdfe71f38519977660bcff91cd5f40108dee654e14199af734d00a36364de6ffab85ea341cd0c95f0935a4b6cc234b01c2cdb94922e6c09204f1df7c3dc393dde28dd02db2075f2d6a3f95415adf4b95eb4e9e2840ec4b70da46ed1e640e3d56494b112c0710c8b6aeed5b40dbd3770cd963202d2cb827152d568a9fb2e82c131d713f50de5136cb6d34ba158ee624406aeb0eaff0ab9610b64382b0dc2b02258c8581dd295b607bb407b674d697ad12efbefe3b88a66ff4ff57eb36757fc039058a72407772c004c93c38a8583f93269594f7c6846a035bda41ae3ba80e264e730a196c4948f249c5454b056aaa65ae114963ce94d93b3408ed0cf93d3c3a9d5e927094e2c75da618cc27fcbe81ff07aa82ae8a48a12248ca77e13d3046329e985ca884c877e4602d92ca5f73dea6111376215a43a486f464935a41e45d5e009c6e3baade58b69df8c646ffe9e171f322b73e3ce4bd299bc68f4ad095427b97a5fac62c0a54b9071152faadb2b9bbdbeea7bbc558f70871bb325a2d494168c86b9a8e07391efa6b1c8e6c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
