<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15203c17891e71026d78be2fd3b26fe49313d539d390c5235b9b31d8f8c94c98b6f1b29cecaafe2968c4f321a442c15825dc0be31b78cbaa88e5532521f3635b3091d73e80bf0a85c4b3b1f5d78fcf3c6b24a0aaf667b94dee7c7eb151d6084cdac4bb8b5bd87517cf3d55053a51a1e55ae69121df6a31960d64bdbef71fbda75cb1a944b8627deec8fe942de296d4df2d83b5514c570de6a0153905e5284f227c25c9d189efb0ad4a269c535f426877f71930cc7bd197ceada2ffae750f7620facdb613b1e1d12db825820822555380ad9432114dda23bd77ef0933735c2fc6a25ac02fc5f02344e34cbc60e6948e42cdc457df7d04a746a7723659aba04d4a4704336216dc99ae531abe99c4f91670b15dbb745321cf23698846dee7d2d1acbfdccd3bab09b9e652dab03350b6079b290d596b60426f3016b7b492e7f5c28bc03c965c740bdc00ec43955c651f63735de8f94a9bd7313251de785c2dbe589a2844fbb01ad658166c86c01f07bd040749ee19ae2ee0a24d0016816dd5f04030e33f4ce7779d144e93987490cda7019778db29c70f897563ae1209645a221e61282c410ffb6d130c873041ac211bbd8c3f24789df1038a51fbc45cb27479a7ed60a79dde99218af582fdfb0a7e93cf919523e14eb3d3fc28daac4d634881aa33c4268962ae8aac96fb4a2594e353f6dcb1a351f9744a1b71a08ff1172152f0925f46d167229bfc459f2fe884df45f1738e29c0b8b2117e54346a59eb3fa40ee2bdb5004dcf79033f9a116b50a1811db635c11906a052e0ad3f9ca4086d2a8065f96ddc5e2d28f258811240af2af11bd8952b903cf698c32cb62504456a88cc051530b09eb0a7be02738d8cd2c5636a27a52e303700f79780cf4f6719b392a2251f8d1359ab03c8258bfca32842ada10d5e6081cdbe5fca0d83b88b8f170b399ad8a54091577063ad9d2cf3dc778a9d6c8aeac28ee7b346460c60da2958ccaf64b3d0fda9559d0a938f4daf75a49b9ec5f13a470136f69e3fab51f0c85d3dd4e6241abdfe78b58ac666c2fd4776681f64c556bd94d40d08d8d391bce741746b0111850191990d183873516b09975ed1a38ba2d28f045c14309be3e9597113775b02818e6cee5e41fc3bb12dc28218ce42c86290c6fa9288c3af7efa0f77b21950cb3d9ebb9f732d2517d63dab518c7ad7b14fca30e4f4d8453b38dc0b93f3b633773ca0f448b3be9d4404517fe8f7e3079456f58c0d49a6fb8b28f66a5f0d65ad646367380b0fce20ef837eefe74c19048d507b7ccd13ca9660ee4aeef7d5cb5948bf86c713cc68141638a834b84b31d6b7e057a73886c02e0542062b1baf88032586ea525644c413ef1dd0f5b4fcb35b8f50133529334003d27b9223b7674aa969aa2a3a56a8b9aa674331cb03ab3ac8f22f2de1700fd84c992e1c27156a2005d5c40c8faa9e6cae464b2d712e9f9c1a253c4f325644eb2586b8e5c70f53b8025c8c6f3a7d4a99178f74d647962998622760c7d5ec3516189c1549ba9e0b937373572a72aa3a4219fbe929d558db813b1f77a17552171c04a9a5e9e1c8f774d4e6d124a20bb8a9b603c444fdde319c961e3ddc5d5f8359e685c0c389bbac74830c5d30db30c73c4079a94ca2484aa3fdfec792edbe8ad869b25465bea93287178c9f250933c6553174f954d86509f8e7375fd3c3262be3c24e15a9633fb48cc3284f07b0ca75d47d2de37365ee76258d06f0991e6c7390a0d508213a128ca15c96c8459bd55287d311f1313ccb19c48f542c33eab2162df1928cdc5d3777bbe75a9bce2b3a5a5a02d9197dde976021fd3c66c9b5838c225f57bbbccfdc3f91c45b26f52e80c9e3fd8de06981c6018300953566358e8545d3d8fcf63054f56d234fa62c2df51e945e917c086c47bfeb2768da7d420849ea48a5a3c9e4498a2eb3ae63890c03fb709f6efdd2ff03b013c2acfad9e455793b90fc2692d43b2633e10ff95dd5f0cda7381a1271a0c966fc993fd1882058982de2e004962513dea816bbcc07239862a127d2ec158f86891aff1c56a02f06e4b9a34d96b55bff4770d817b8cd6624a2188f29c2ae1bb96121c1ba0395ec98cce99f5a91680f3e9d17818e76248dcad9f33f30e21794798e42dfe4557648c1dc6ef37507951e60e84bdac90fe0a83cc695b32cb8283fc9ec15a2e93c661712a24b2a3530b973ec358b61d76d783860d191d401224d5ba446394bfb6b986a48e92224d1efee83459a70b1e30e131f63e31e5a13a7255b642bfe7f2a7568922c368534789b94b69404829227d5b6ca5b6d038974743b6d1c9b646ece6b9c1e459f4a6a492f12258e38c1c1fe4a91ea41ac85a18a68d769f9717c880095f2d3400854597a17f742027a53f629d673043595c346b13615d79799083ce3e7dd3b39bd6ad2136577310aae5483d4215d62c9acccc21f5a48bd968fc4fc9282057d20f8e9127e6796153047e965af567c7b9d41fd25e86f756723583c545bb4847ad9a54b007d9db8d8cff510630c5b2458e3674cf69c954989795515390e8dbcfbb5f005dbd6c59cfcf5dfd5998be9fe53c325d149d17ea5a4f35275c0a4e9c66ee1f2a60eacbf53d0fdaaed76ee4a09dbb0bdc1d07d9fd562c5c6fc7ebac390807c100f0e00a61ce457abd60c25a43bc1ec68e9e7d15e5faf17cadaf5f1ff3e0c42d4f62abf9a06a0789304dd611a427226efc1c94f42a2960205acd01d2b52d7b68d22c2788e9b0715131669777a0f3cc24801d399615b1587799f6e352beec434e971db78bb5df4bc018070e97992030ac14425d7c552c65a3bb4aad4b21ec28eb47bbab8c983039115e7ea7fdf17d11cd35838a1c153bb07ba76696abda3f61d5a0de3954917d53e3ee270fad12fcceee89b4b9ee1d89c2802fea296cba59da99f3d393eb4ce87855914b4299a528bbf5d9a67990b40c874ef0f33662cb769ff16a9995e37680fde7e6348d581a509e3d2d86d22d1d8f5799b8dbaa3066512d695a8fc22f1291c8f462c22902ab2a36596b7696e674758108e326c5ebd5b13c1501cae179ccd9e562d5cb165654415ee329b83bfdbb1dd31ddca77f463164dffcc1b0df5ed29b7a64d46b2f7cfd6a40e520651f67dc5edcc051283ae3e32b0e7de5193001f333e87bc09b37d6486c993babde42fd27a372b4e86f1a16342d7564ec370cb5e00434345cf5632b8f7586bbbfa7346b46cf997f37771e2de4b45cdd89129b2f8987d84502a03d9240b3a5d3ea9b91cd80f3c2d059df1ca76309c0a1f70885a4a8680d6042774025336f1ae9495f990983df4b4020b969069ffaa388ed2590dac6e2d8860ce2c0de7c36e051c9745e52811588cd1803dea45f433fd5e681e21384a82055496297fb02cf093535c637eab3a5be76035aa6203be964d5a00181ec6763cf2de161dbde4c094523fbf9bfbe284972cd59882f4708d2ebebac32c7ef6e80a2e4d9e3a2cee237d22d26dff7e4d5c5bfc76af41978d05d4b26d63d5cfb6b615c7025b99fd718f109cd279f2b906a7213470da7212e905d600909fd7ba51d04989d8cc203d6fd23c725a8a6a8622fd9064d34f1b36c99a8b82e987ea5ed29d18d8f9b941470a1bb6ccdf625f668214adfb7761d0602f30114851e21641be92df215df70d984e977bef076e0cdf937f78785f47a753b7b8a156da56d349da2036b2c4c74c6262a3bd9c443c9c9d45ec16c0b4aceb892f8f6ca2c41b6237aae3d1bcfa3abc5b992581a175d43449b3dc7905be1d811247bdff3f0c5521c7d44ae98e6362e9fa58f5e46c84eb0c8f8391bb10f9befb95df9118f381d553419d9a9f805a4841420a1a55e7257b6fc82ee4d36be611478a58faaec18c75149b647257e7a6f02bf7599cf01ec5f2e1ffdda550a1474c00bf6858d1f845ed9482f1313ff47fb1e72efd1ae3c42eba9c5a4f6c532ee3ad4451956d2ff0cfa5ff28a3642414351ce41ed4539b53cace5b3c3274d43223f6ef8ae105c64fa42143b472afab723214f80bdcc8efc6d338d1f355827184725a5e173e7eb64abdfb4ca4809229d81b2fe6fff3e8f7ba38b82edaf7aa2f40d7edc90931bfb5f4f16e37fed4f46f44fb492068ee57e327a4f073378ea4007521bbbcf283d1740fafc53fe9b36aa21df235c3747eac5e12d3268480b40c15a6995b4b7a00ae97393bf02dee2bf49568fcfc4a67cf421657a73e522970793bfe50256913b469a40a242926cd75d9ba20b6bedf0c30a8ee4aedc487bfe3c68b5ff071e35e9fb61cb72bafcd70397ae69584daa9bc64c716fd0aef164a5e3c112613145986f69748ca927b130326ec627a8a1369222cf8eb5a7beddac9ba9aaf996cc029af5dba017c9588425dbf953bef96d3956e1b57b9a31d56dbe745395bcbaf535a8d89634c2ee5873d78b1ffe46d9d00e0c404efb10397601014dc86904c199b9c8c3dfaa62aa3d38932122eb1757ed436f7e50934117d4e50c72a12733bde4c743fe86d98163ef55b264962a7256816531d9d22edde816e006fea1e2a042cbd33b656a6084df37a62d2c67f2a6d5e1e9fcd7089830101bd030d4940eb8afba6985ae0813cc8fc357a06c79a892a89f045667abaa3428d3fb9149af197c66b5ec044397729e53a72f025fcaf186b7f977e1df235b7385dc73e767b2d955a40a9c5ddb6ce09f9454aef7bbd5af69c4baa4199885d93c594f44491a9925b8ae25f8c6edeebfe189eb3e5f7e0c0cc315308407a6def36fe65096ae6ff72123b2b444f934d8a01fc75493bf5048fcc4da425c68cbe58969fad0929159a9fd41d8082015c5ab6d4956f3dcf24fee904f2fc5a6eb6f64a99d1a34938dc828d783236016d905a2f743a279817b959d7d75a8f9c36f1bc6fec29b143ba80a35ca24a70852ee2605e20da9494385059b8d7dfdbf0e2145fe81c80897a309899ddcb25c59ae2f11319887683b0381df3f65ad869fa1f6461a5b89abc35926fdc3b692a9ffa4aff5f7fd9d3e75ab0b57eae15ebef17d23a5064c28b9cd934f5f74341f252da2bcb48ec0c0694da4c7ec9e794032599e585b4ace0e8660ca05b9c0313d39af5c97d0905932278b61e39a3bdcfde10d8ab4d1b5cdc83adfef98b2281ad3c11d719479b42f15e85de3b5c6751f40dfb03e7a982b52a48f4a3f4327b46227d65d87b2bc546cb659672cdaf9b98c0d1d62d52afbe6aedee358e3f1ab4166d1fc5ee0e8fc56fbdea9a869602476a640bf903dee0bedca78260c84832c9a2718c8739d30f994a93bed2aaca367cadaae19490aee6a308d878518a8e21266c3d51d9dc040df509e92d4c3e2ab8d405c2ac5ad10acc75ae1d467f3b8ac3cfbcdc56c6032119b7612acacb0a58027a22e2d2699156703a24bbc69d4da01d790d3ccc015e355f71c9a1fb4425bf18dc9e9930e18c4f5050dc41a1a6b866f8a21c208a08b7a65fce22e8fb27ef38ffd12316d516697040a2ebef315aa1acf36e430b5cbf65cdd7d026a4c5984d9a151667b52bc8a65e8a333dadec596650e625ec8be9173287acd96a64fc1c2a94fb8bcf90aa35398a51668e5e18bc45e0db31264e1e82751e364fdeb20f8e73157f35e8ab69e55f06f6ed8e76b067e23afe5614498ab5079360bbc875595bfbc536bc3a3023a530a1159bf9ae5490209a5ab39c3eb6b68cba442135b992f31605585b3b66e553577033aea0b049247227ae0cd34cd57168d652b5c034343eaa581b20f2a3537bcb5b9721fd8057c128c6b5d9a466edb07cae6be36e33ba81d9e6446bf6f81aa9f3555ed10ec9bcc4563961b49be9419a963f7168c54c8061b00081f6bf17feed77983479994ecb15d94f59731551180ad981f1417a2e2e52967d12f5a08c63f2d36d86c4949cdb4d1fb97db72c1ddc675e9f5e0b13281babdd2e7aba2b374d522079e975b105f3770a8c9148bd0c9699a19117ef5da4ed933fe12a77fcc14b6220deb509b5bd9e730bfd440b331f5efce3a0260ef40832a8a198087a23ab18933de1ed3aee4b1678376435ff3ee36cfab642d1a18903ad8c55b996a96d77a68096cd770bdacd5242bbbe543015d35297bd470d50f789dfe15af759ac27ef63adfd73983852a0835dc5627b2d4a86c91e83f7fda5137461f939428a80703712f17bbf701a8374ab74f0b314a806269e91c5508713ab781cd348fb44acf3463858b514a1bbd95e61762b9bb8d591cd2bbe9ca25705e41c48c6699398846f85ace6d46e05adbc1ae95c6982a9c3570e50c34b0840cd5767b8584ff7143e5396b266341378c529542e9882c3dc854408d5a3df340d218dda0125a6b3929974696c7a7081b7bf466967b448f7476092dd453f9ae8286ae51a89d970229b471e63f66157723777b9a608817f9d64d937e34d030a454bb0942739389a85791ecf6e4846fbbb56f90e4ffb9c7d953e176c252e012e0258bc1113456c4088e76e98bf0c000058ace2b77971fe3ce52bbb81318ca8fead77f260601894e9d5ebd46e77dfa2982f4a509f1b1f774f52c2c856e9e92597f2c94512ee27b2eb97d5371d219ce98eb6e4e772e91ae19d50929bdad81289164bd64e4aee030cb13f21f80e3790be4a3f90edfae703f22d0a4cf1afaddb5bdccf970183e078f48c344094cd38e2715e28634f7db10c6bc44695ca0c0591590e89b58d816ef5d8351111446de0d923ee0d0d493376f6c119e20bdbf9251d25b3ee2c7df31ec97657fb26f493a33f7e64099361d8ec6977ef96ff976f6cf8fdbe369ebd7d19cd35b82583f797ce9daff68fa7ad78d4c51e19e299ecf2e00073b5df2bfcf6faa09dad75feb9cf3fd80e85d0cd2bc1f9320948e928e00f3d78283e5569efe84284971e8c81e035e82edde5d18cfa6754e64340d1b6ef2a2ada8486a33369fe68bbc3a5f6b370649fd03bc1b6078e5316c0669e435cb6de7677a5f0b61e3eb9e8ce1708430f8400a054512f9ff59ecb3d723ec5bf1284dc6d0ffe87e481492aaa78331ead3989ce7959a1ee9ae10ca0b478ab38620398b0084a9d03f4b75a62e3901883dd9028b74b5fe94dbfe3e434afddaa612b1792b991e21b0ffe37c98a07768989b5ef87eba2d8bd434d6e28f31a48e5472b53adeccec94adb3755aeaed52f4d29ef7cb9da5641e927d1b7bf6a317b6533870591924f90410475fc7d430e93b8ddc9ec4548bea578d602a96b9437880f5e8ede04d634073f968905f1b7dbe55a0d7fef66df1f9519977ab64d2c70d19e2dc7d1aa20835696bd852f941a2711c0d09941a2015cbf6fb78c0beb10499eb9f5e26e820a376399aee7717c2b66eabce2bfd044ae749da4f567aaf8ad0e958daedbdf80ac0f1560d58207827b9773136e19572dfa265af951c071df15c4b11dad8ef131c65fadcc8e8b9d7ac3f16fd04a15662141e3a44a02f398da4f1f3288cac3b5849a52a9ededb3a8c47f7e979763c062408f82e801ad2fcc1218bd9530a101dec30d2c60884382069dc072a2703a42cca29582edac9a103214472f66d8fc3cfa8bac1fe95cdbb1e30294de1fffb6ceae5928d00d1fcb547c646ee6c2b3381c25e3b49cb5d78675d7c3b7237e067b0dc4820f1c14dbec89dd931abdb09725c6c766ad379b6a66da674c1758a5dad61abadd94dc5429f4b398c77799549f54b4ad8c1e0c04079c1708e41cea8c29624d708673f6c7a29dc7470895e52833998378c1cddf0fc91dc53213e916befaaedad022117950687c237631f00554986c2a917c63134fec432276a06ae9ca0eb0ec56948afd732ae1d03f6d52626e7d1008c726f41372574cf4608ee34ac49c0f7eb279213b565ac75e2c70c707e5db5ed009cc12949e5665f5eb32d2d0d633081f20773c1da8ba1f53885659eb8d0656cc1f62c32d4fa62ddd6f7c20c42d86b2989d518d77f158c8cffef4f94ffe9efa7cf3b33dd2ca3d457501d4f796484eb878a79c0a494a5a267cb53fea0b10316079ef6dba5219f4d110b0ac57526471c9f1261066cfaf83818c799a6a617c5a8bcea86f682bc3a2e166c0c8134d11b3f871ad20f4b7db0a2e5bf7ef3b7f60c5b3af9af932304bd1b2db7043e9896b6cc171fca19249db824ba1b7fd5c71ecd4dbb0682fd24fe57872e6368969ff08e06b6f3b5387892667a65becbd20d61300fa54ea14c887e8141a1784d84f42b5eba4f504f8644769ef81a6f3335f85f6e4e07f676abdfb5e2cec68caa3ae9143e5f7db42b4570ac52bebb7eb444ff3d87c3856692b3d728260b66da661573ced59ee0569163dfb9c60b4ccaae17920b0784b4dcc23abc73c5ba156409a0a951ee6cf92e10e2412ddc8616cd6cb8942a15d44b6c6c890a3ef4a2d931240ec0a76b58ab9e7ea7ea52163eb48498076922021d35f5ebf0c9e875e92bd841ffd44994eb897bc2e7ba6b39f7fb31179848c43fe4b3e86df4a0af97cdb5135b0f39056c8dad450ff74ae124951227242500a44e2894a01010f3f58f6947e468457f957ac954a9d058555f8712088be41de475e92945215e26d44aad1dfac5b59ad1d206106a85c473ad15e935d3bdcd6f6c1ec1a1a47e6bbcd19e4c0d64cf7e6c01304c92525f60b83134b8a41664d8d103a25dd578c8450a6bbc03d7b85374074ffe3a4cfd32d2c7583d852005138a689d1645d601f019e85433f2155f728ece80ca58054a028d4d07cb842d9b8425c0a17d6e21fa1cbebcfa53d13a67f0ca81556ec30857364a2863ecf050b259c4dbd2e18812d4cd43bb0744352353c4a3a3b0d8142e692e760bf5710c6128769a0d4a2700ce13060a593aa20aafc0828ca1a9f8ee47f5337e5ca94e9eacdcff581bb138e643a40c806824a014877ade61f543e8b5870d64fbd7e13c4bf33dcbd941b4090409d49968fabd7d1ce9fbdcfeab1454d7ef882209a5dc1628a3264fdded6c7dac7bb500c6c5a7e02457a85a855ec25d40b593a72e506894df237b48bb1c49167cae16988b2f38d0c8fc202fbaba932ab5d8fdd2fdfef8fe637772fcd283127c0538062d5bf6928e4a43d5f4cef382aeb61c89f7e6449ff9d75df4009cd3bb27f4c1bca147bcda9b2aa13346f5b409612cb0b72db4f17908584f8f1bd9177b5f617af2d49351044582b35c264684d7155e845f4481e4037ed8de96f528cc971862ecbb8792c2900514eb7f6028204ede8d5f2b09dc7feec0e4b3cacfc9b87445de022b79f19318ba7ac633f15fa51711c09b8b5e078989b03beaf47901cfd9de526f38c764c37e78d04a1ba542e8b4b1b54c52574006de236ea3a8dfa4a6d7e9a9eb4d9b20cd01cf5b3592f241650af4ce88fe6651faa5bec5d850c03ac9cec6aaed9bfaff162c5f43abbcb4518d5b18ca71a09c82be809515acfaeaf67676eb6862bf7700cba669eaf74593dfdd4dd2adc36aed3398bf2ca899977a414b7d87255f5c7ad3f1c07ad441f09ee8f1d9792d8024f7deddaee1feedcd38c60d961153e9ad980439bebc51d441c0b0e817d7ebcdb17082ab9abbbea6dc6b2ad3ae7200896b481f6c0de75c38af7ee0e9d7ddf5f3f5797a590f7fb8b97a16d0f2502377a8c848330abfaf7b5231610d85f2dee0931f60fb25ff0e0de700424687e1ef29010c9c51cc755edd5b55765e5849d0bd513ab6ed5761d84d58e38975b31526223452e9e9ce3c9eb24644fd1327c3034d210f3be9a55e581afe649904d81d078667e977c26eb44fb711c4a1a27e25873c07fd0272b53958c0f5440ad53cf31135d9569d8b5fd71f59075e66113e468601c615a71ffb40bc85b64643bbc5c6344f1eb77cf2e167172636d4c79e8285ca9940bfcabad60a42d694239597fb309a5ec7d5dcbaa6eb7864827634b8b9e5a4e16daadc6df5a143990498f8ffc26d055923e4f4ef7923c4f9de73a5611608159e60ec739986b30ae26a126cae6367bc5ecc0d65e8c8c4114dd5afe1ee234e013221938977004e6f4de7f090cf51eca7079d886b258da161eac091240c5b6f982b85bc486895aafd7c81471b9fc16bd008ed41f100f6bb6821bf12fa4571cf591484b346c6c0dedf9ee02dfadbfbe0d140675751ae480b2bd3ed0dd035f2403d47924963760cd82abd4204b17817aaef1ed630aab8939ce6abd4595c1c21851e451fc51f8f58d8dc413a830f0f8df2ef944c7c27a7b1790a25c8eb6c420505b9816f0dccb188fd4877e81a919d1ed01c209cfd37b32214f54fff19384b1abdab719c7a54b4ef6caf3ad4b953d3a6f964a924dd9e1126fe8b6dc8ed3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
