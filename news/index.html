<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7fdbdbcca3d4eb1b6c312b8cef155df85e476666eb15c2c73b4ef0ff3678c13891a01d29487b9c5d1b7f10857b0bc51cae9100cfe18c899cc3fc25f4d03ffa61f75aa22fae53135ea3d805785c8e0381942e90ddd12e027eb69b0d3697d1ff0a058261d3aef1a8d6383f838728a831a95fe123b249585cfed1b98bf86c4e3a50f1477d3abf18d490e03c4a1c07003c2a3d1afe82bd9f8efa374aab39ea961c5dbeb13ac83244e0705462a421d023687f9ae85046fb3add6e50b917a15aff0fe28d08303381b2ed04875906105d8e8355f0116be2e89131f24170b8b6293b09015b94ab7100f789db2538960fc52ba1c44bf52ced817bf189719bc5baf7abe78c4d317eb8220df56fe7832a3dae37482587562592a543b82299702f4f6aef88a6db6570cbb829285ac7f774ae87b27939af21ed59c89bb86665ca8419290ca42640b9baaf601e6d7730235df3ed2fa514317813b989de35b80167c117b873a0a930021331ab8f3ce1a96752e7bd50452ca00c12cc47029a989877bd2a911ae4d0ee1a0664b0b4725e4e3b5d39333963c858e0053053e6e654c240c4d8a7a9c7f7e27a12ff899977ce8d880bc73f615375192b8ad4cbb582f025661b02a81670e40a11c2ff2115c556bbd6b974b7ca06c1e57b4053e57e3686ccba8d0b0f4478b2bdf47b07e3dcfc54e4fcb34424aafecbc641433773300bca67a21b0e08c1f5dd76d40e09a18b8add74c034c1b9e27cba36479054e2e72f5869fb59b0d559639d633cc6b9cdd20af267737e24988450b7da721ff130a1cdc4442bddc90386c378a1e68aea8ed9205f54f4678d01c20f50b69eabeb5f3cc1b190cdd76f8efb7ba09b31040e025605fcf18b4d5f1bab740c3a5db3b1aca4ca67b1d96a84918434be270e284f63a78e376a7e8edcdf50b9aa61caa17f62e201f1df291556a02058cdf856a78e212d1ae7af4a3af4711c18977488d605f02b7b04eaa154acce56de0283e61a4fd06eafc31e80de5e4868e5705f539f7c14cbf78f923cc674101f7ef0f026a0e823ff6a1b9899c032760d16a7794ba5a35459ded4ce7938e1dc8bcaf3ae7f51530064ee11c6bbac2eac9d71ac6e2351f46ab6ff8a5280be69c840a748f6002d86e93ab3d133ec2d2c89f31e3f844aab673556d2f3bdcd6a1d37de8496c54f66d4c5242207fc5b1f37866b3473eddd8753b6e7307759f77e61a0be81fb6463d217ed129dcf45feaedd1f53704aeea4673378159e1d6b16e9fd2bf933e330da5ff62591f025a00b94b25fe37f56f0973d0ea731a50fa277e4e4c9c9ec624837d757d649dca710620c73ab83fbed5c37622adb0cfdf8b62c1423a3a410a777a4af4cae7a0ad805f5024b70a041662036d1b4f17f5c6f6e7ff91bc075cca04230e26f73cda9516ef82e956e9f66e4c5bebf8761cc296b4d3e1318040fd4f63bc36b38dfac6a8b25f873986d2a100fb120b4306b6550154542c57c76140dc255686a0bd1627598068ec1d3356e1eb8bdb78c8a8e03c429d32f2b35f0c982ae448bfd168dd38326eed7527a5b3774a45ff0ca0e1a728d7be0613e807e12f733447c6338fa8a0a34e25d9e5a11b424aeb9e8f80f3fa9131a2bfdf5a8a6cf585f0ef7e11c9d1aff887e39e7859c3e93d8216d9589680c275ab4b7709c5c929d94441f754ba58b3566c0f2a634d22a8d1c121d4cbf070cc474fc372d30aa7a6ea2d32b9c45d61c3e0bb37fd5f48ec3c93106c27ffc2a350c4191c661b3bbfe9f781afef853cbf343e1809ff8a0d7e9bceabd396538c68be3f7f87ff9f66c6f0cc2fbbd3267aba77d8d3b8de86af5afffff7ca6ad174c8b47aed8c9ea6c71d5df47f0e71e91659aa4e1a074afd821fcf2f18f6b37f1ae011aecab0673bd53aa9f374607dbe6a3c465c52f16ec5f5a55b04d3adad22039a2aaa3f49bce22ddf89fa8e43db68a1444dfb999e39134dcf9cfb3a7a452dae0e8d1a471ad9b01e2297921e9378d45410215e9508cf43976628325028db2b64a45509b11b4e5f5ebf103067fb6238b92be8fdedbe882e4d142ff0774492abbc33b9d37bcdd99b8bb91910081d597d2497f1fa790afa98c0b847b13526368695898f9baa530239f5c0d1b4ddd7c7a8bc274b0f3a5d0953e717ff3a7b4b499f0b012c7b5f8e49e123584bb50e4fa59300b3000913619aef182f10445f4fca72ded467bac982e4f8b02ebd0a38ab6650e1d524bab8a3c87c3668308f495c956ae4c08c664e2cf13c7d91c82529d8ddebb946690d9330a6febf62d0f80a3847379f009e31a072e0a54322602163b255f6fc7fc242807320b1f121c638d0a1b2c3d878fa0d875e2146c644fbf93b4edfad68b526d642f0bde018d820676b8b75964e4b72892e125bc55b3065c1af0c2088c36052ec7d611f6b697c8f1d8d92d86d250885398ff96a9021795ee50c98b0c5e4162b401f75dd20f13af9a6747a897419e0f765ca251ec50e2b0567560e6241c33d781198bd5ae61050c55be3a4092db28e31c98a9319570f3e426094d8b522c8eeaa35b1d0813d9f347ea860faaf95d2414f3b23d46e9c25c012c3ed39988249dde7be2bb47e72a100d7ec1aa86939ff78b11ab7082f191a57f27cc32cd8e9e71e32bf2485e836f95d1c82f4d833aa92ae81b5ecd1a4306d31026b9a89c961a71dc62471ca34529cc86c5a6bfd211ab9fc9cb581d60bc4aaa4471c70876b7538ae7ed1cb7944efc264d3f48031067ca215a3dfc166e110ae493da4cb201f89fed727214b0e63223776258533235b1a49a4c774ad362793b0a7483dfb1cf7c3f511c5780753eb47264c0eba57c47194f77d9f7cc37ac632bf762fe79ad5ddf938c3f2ed189f6ae9a1704401143d37188aa295f1a9153f0d366dd02d3d29c6b3e88bde3f128fdd4490e34f95aa0859bc285f78355ccfa2e578849a7d187085483b8a9a41f340cf3c76667e17fbc5d24e113d1c97964abcfb266826b292f4da80fa7a8f7945f6ec833af2ab1c25ea613a64788623358464d4ced5a0bce35a421ae27edf87a53cda305717fb697a72aef4226d90600b28efaaebcb68050a9aee37f0215279a4eb399053be62dc375a0cf5b5754b1dce435037e1df068e0cb6c95a17ce2db154adc87ec516da917ae09674fb46a719cf26bdec3092a6034f57918d65b0afc2a43c9bdacdd5e35ee33150b7cca37b0a0c20939dae7ab70f52a87b16dd2ea91b06b876c60679db60785415557a887d563730f81244beca17ec475c30356c2687f8f28fa7c480b81f2904d0db98b1c03649f757c44f6600d4f10cccdaa2f3d6055fc29576ebcdc676832582a5bf2a2a70dd4b4dda8cf64eba36a63fe0dda6a08286c1f0a913fc372383099404ee89529d357bcd60fe1906230f2b41560db22344c40a5a7c1276ce756d78b79dfa6a95a5a6f42cf1dff168ac8a03a58547150090f84e83559a83ca3b7842af00321469d48dced8c3a0151721453058d42bfa381fbeaa6c649f032acb64fbf677b78b9f061ec00924ac6dd3ba14738c386fe64a698d0b5e7cb937d35898251c1698b947fcc234e390d6a4bc90a5839392ba464f876f26b810460282597049c7d10cdd851556c3cdd01666a6c2e1ca03637751c56ac6f34011286dda195ac2fcc9f7e82a822b514f22755358f30a2a5af36400a3d9a133dff9e1d0c1df3dd620e76d3ddae47cf81de7ef095e1374d1e864613095b78a617c1568785e21c6891768663ba51aaf116bcb2f32dc60746da96736390f31fc7f3f7f68194ffb1b6b308cd9ce99e75a3faa176d70e766f68d83fe5be963a7b713836ab0d50dd531336005ee669df0be40f2bdf80043c359d7f9c50c42a590c5b636295cd959f15dbe46d2aca723cef919baabd3b3ac8446d0e9bd1dc87b401903d02daf00988e5ffb8d93e4bce54c97b5b65873905a5085b80ef8411a1a34a4947010b1ca21d8f78f0e60c4f2d007979f8754d4bfc09c5e2e079c986f760ddf302e840b10db467e4a8729c9ea6fada61d656c0e4e3e0eb2c520d260e85f24f2062100b5f622bc80bb765d8c56675c00ddee36dc669e03254c3ebd8c0894860434b179d59be4666e17a94769af4e4eb86fb44f282ba65703bcf517edcf129b17fbbb7408e27f8a090ff64c7737ec2950207c0bac812096ec08ca5231f8a82b60d9cf9758fc122b47d5c8e6aa5f947b46720ee80438bc102083c2dd5bedeeaadd685313b073d108439e390602f2d2ffe425ff0d2cea645bf45e8196c803518b4c43ede5f50c4d7494a000dcbc64f8ad61fbbbb5bc1f5d33cd38899e228d5ae212665eaa2868f0e647a055c99d0a1e38353f08161b792e1020994ad5a17411b88216f65bf9c00f873bf57484cd89d16fd541da8c25c3a264dc7d3d080934d8d0814586b7223d5aca3f04a8984030cd4599e0db52f366b96856b36cd9262fb430500d780a771b7cca51e0d4cc5d6e39259e2e5a9466830119f2e605b5174d28cf1f071f48a6e776eb0f0539c5726afcc97950d42df5bb535ffae977f40e270bcfa2d0615f9344e57f2e2b225aeb7f85beb5e3c190200f4cb621c3277e59c58f22e6cf0b7ff756c22beb4250f85a97b5d91a68b8b78e14378f7babdd1cb22284629ab01d7e0840230a41bfc0d25b9f51e8bfa294b16855c24c628be0038522eff500b521aa8d2ef5b66954c14b76e1f859235bada3923751d5b016d950d0f67905ef1455d965453f2fccc040cddfab7ff476eb34dbbdc5c7af60faa3ff83a387ef2e81ff9e526b0f0e92d37143eaf027823015d095637abdc0eee782f2b9f741a359b7f6b4c70af42d34ad58d9b71c83daf8ec0974fb02863efeb044b06ecf8959d21f4b7663ce1103c0204e2ed6602b88f2375a7d41ac3c2c6784cf0338a18f871ea6f99a1f5c253e70d3913195b8599cc225c2b21f0ba73431926f30f44b2ad5e85b1c9b61af07ee7e7e2e0f5dcec70772260e7af9a508af072c78e92ff9548ec50435d535af3a6660a4a7fdd02a8f26212caf1da4816ab39c8c7c8e3a62b954628132baf8db92831d7fcf3ada77dd46a7dbe2418b8569ccc8e4d179059eb921a34b837ad65c8b23f2e53dfd742488e28e94e684b74ab876fe9252ab31389e5adc73a640a0478dae34e46bf5cdfd09e16e903d65e53658725ad2d15b79a1bedaccd3e362202e1595a76667bdbc2d51cf6004eb156e9eb1ea28f1b098419191966425da39e6d99f398c012187773ac49fae0c9c6f07eb55340439da942d34a429e227360e20ffed45e12cb49ff5e3a63c7b9480555da574b86b30cacdf1d4d33c3de2cbe4919c8b859d0bf4bc515452e56501439524838375675302a800afde5cfe0bdf23f8c9f7bfc77ea535ccd92e821ddf4f07630b77866fb0d5dceaf60aa381233cc162e4fa878d0b1f7a5ebaa148de20b38eb8db1f84f66257aca939beb852428fb094238ef38fd430a445a48cda26383e725b5e32dc8fb4ce81e9be06ed4ba7d400ac93c1e8265f9d1eb20f827a7916cab75a3a0bfd5bd46bbcf90409fc228a810c584cb63e67418cdeb4cf8167c75b345782c55bb131655b292f2bc6b25e10e8b366dfa36e3fd8086f2bf2ec04720e16e1e818fee7b865ea1d02f3d76aaa20a3cf27fd9a4e9afb5a35f0f99085a9303cb8e1c6be0c108e2dd350df12ba3708f3bb022ef9b9633389f00565f9fd71c726a5b87aef19edbe6c541e0fb3bd5b49d7638e99262fe2ea002c9871824c41cf84f379ce84b20a0c313401b813b80fc15bafe024fc3547988aed410f362cf9229e597a08f0b59b0774aaeeec96012d79c09849a49417e1dd1d199dece287fcb244fcb64e1cec42ecfd5d23578cb8be99fca4097a1eb5defc07dc573588dc42c28e7cde51c34e681ae6db11b718a093e724c9f08ee28fd8670b1c6a4df88cae575d83ab0ea9353a0630e9aa99898bdee12e69a078e11f46945f6ced38d611656f6b9199d292a16b945f607b96b8ec7ad49f50d7c56152c86dbc18be987262525d58fbb5c465541cd5ee23d6496c1b03533a02d39ddec5aa3c27f1c011e3730ba6deb616c3646c2210acb8183c83f8d329d5e8e14e66721305aace3000f8c1d59f0173c0a320668031107389e01275b8bf749935d084a21e22942d84649e6048101ae14aebe080053833f6f1016323fd44249f7ccc3a4eb655d04463f18d3b83a28aa6c46177e35c1459a30a4ff2f42a51c732036815fa5d8b25ac2452fbf9aab2f412ba5aeeb12fe5d51f9486c76039ae9f16270a449095ec33877e6b55936997d80b2bd5ca22792094a32ed954e2107fa988ece54d576b9eae563ab08186791de62af2d5f4c50f86882bb7783d88d91d91998f93cca6dca4ad429710c9d312a98b1d34e696fa9ac32c945b1ec33b5147c5208f0a2ac3c0d558ac1823a549df73c19ecccc0444a5a97b22fae31e8396521b09683bcf0fe1e6c289c6dfa6ccebeae1b12cd1240c36b054f7c4401420399dee10a362d702738a12693baff0e4f8758b36a27eb192078289b2ed0c0188e2a617520a71b9e43cde6d2792eb2167895a9d4b9351d34a9cd86cb9320fb58f3d22ebba3841ad07bdebc269bcddd084cd83d86e7ea3993c948f02f00ac1f3720031f013651cb270acf07546dcabc926aa392a4db1b58e7743673b47cfc14ac289086c3aad75c85aff331c58ea6e37bb8536f9db69a8d7e15d4576d42f647c5c6bf392935686c609b5c8d40d6868e857a9b98d58a33bdbd24f73f605f64ba359d1de44ebbda8f41dace51e5274da7c75b263993c3a65a5d51609b27acc6f1feba1ea743d3ae91ddea0cf4ef1b72b7ca282cf411cea3b9678a9af6df347450a6a17a84445db17036457b8becc288c415a9f229f7cc92f41e02486c7693c96cb451bbaf672e5f33c8b7b010ff344fd2217c41e6d03b1d23d8138081b7cbaa2682893973996e6f5d7e0e740aa2ea595b148f19dcb0d2c8eb215fd110c68d6bce0ff9da6f9b1efdeb89bb5f774bfcb0bfa3b74d230bab41a0cf4132eced34b89552beeeed5755fb8e04aa076de733bccae4bbd4b85e69b19036943004f0d43ec64e0b722fa2f4d5b5cabe292dd560ef25abcae64e462a9a0245ba3b88193a577fce42f08f5f896c316bb7247e602a20370b876463f963f75672a2ab7d3cdba65580fb52692aaec8e7cb5be0988cacd71bcc58c30e612e037a1e8483fe60c8e7d381a8132613d3ab4ceb7bfb9081c777415d4b6fe89e37a002cfea785a84e516429e4254e1a825d7ba7ffa3d7cefc99e2d4186eb1e378e3ba03414777f0d06cbd81e8b55aec4d581e2c9c9680eb1be0c6fb5229e194b18dea1f7128d75407380cb380e8ee65d43461ee023d11584ff597ed848ca4029c4bd15e59cc23ec232965438cddbc0ddb930278fb6eec3484ed6674dfe9e82b481574fbf8746f13dc72c4d8eeea300ac12a83c7460f5d11d69ba661bb893a07548538696331102f2a75b0bc6be0445bf28deefe443b7112e048eaeee74eb977a0b6ddf24c516b94ce4b16bcf5dc787b1054fd021d6d34c68b774608da240fd58aa4506bcbbc8a25b3d488712205093b1596c06adee35218ebbcba6f1a2689035cf52ec5cd6693d0c4fe0f5feb1db1fa22a539efc1c249bab701d559a4269c05e8a7722a443d04965f7963fc0e07b42d26ca2da07178603c4cd756553fdb1f5ba693a7b4da323ccfcd5e6e263e4379d1e1f14022e5454200749f3f12a242d133ec67656a863a4872600a274d63c2e21b7ad3241e70d37cf5e8a90d4303699f2b2d3cd4d20b9074ec81f801ec93e73e67c733470f8a3cd8c5748939a96e34fd42b553c7527a98594131098330f3416e4cd20f2c1232b53ca6c5cf9fee34d2ef6df7f26b0139bd70453d3ce7e5c9c61120d1c5046c93fbdee8eb1f5590da70a39caf3f207456a7378733541914c98f38f8dc9e3c1fe5b1babeba4ecf63705f414467f36202705286ca8cd9a98945af812eeaea785073b7159981fbe9e44bcdb46ea6107c64a5df2a013a1834c84a4c41b62f867be358480af3a52b4612c0e67738c7a49d8412c0076199c423d52db57283c165b82a80e2b23d0b91f307e809fd5b2ffa65fcb49d51b410756e8d97260246ab99a6aa94794bcbca919464ff9c54d82b7b38d6c04196de478bee1eca13389ea47bd000e5a473bae42a99c31e9f2dd8f16346748b4792a260831294542f8cc530ceba41ebf315d1ad73e2d82a0ffef34186d0a2a742154179656aaeaf122ee9fcf899e8c07e01f7bcff23a0a2c449855ffde6710103569268b734a244d5e2f854031d9ea2620330479346ff6f030062e2c2689eb46e078990a7a663236351a8b44c71a1c61d8c0fb9da6d6392ef718920e1a4bed33a0aada965afc3f34584580b126fdebb107da1f815db8ba4df0443ce8f5f641beabc1f6f31111605bdafd9d9921a7c6000ea8c235dcad8e307b4cf0de087f5598009b8ea9b659c34e93ccd33ed763d90975e19f808dd4310d17c5c9bac7e634af8ce3d6a1d59b8a5970d0897bd1222b5aa2552f5fc8093b5fea23da87c6000e34a15b90998f5970fef14adba3e737af8b03aefc32cfb0b110e1b217f9798a38614f815daa898e64e90c4769d7c2ceaf56200ee828baf006becdee646f6e03a0905a8d00186abb6fd01ecf290d9b4d12df1684773d4e697c952c69be098268c22d48e59af32af183b2c6ea2244dd40c6d9cd280281e7e9519fd0e8fd4b9764109f809ed31401dc623f1f592050a4f2b545e8deae969f83ee6009028c06c8d8914ee84948d7d43eda17e64baf28224df1a9afa8946fe80059cc9222153759ef573103873603bd65c4bc751bb315c7c7768fbc6e171d64a32807f145e820b099efa77ee838236445425b9a9831c58454ba9a951cd350ea9447da50a98af95a9ccaf0d1c5b2ec1c6fd9e11a6c3ab0d67dd09303eb155bdaba3cc628899fe038eb23119841f72cc12f30e47ad6265fd9f4e98ae1d72babea728e8b0d852a4a9f7ca73e1affcb735953e38dac0f19fd5a391c6f657254941a21a7b19b01d6ba1697c346ec4701b0a085277ad3388ff99968d6172294f47b381a779613d4859e06ec8779730030b8b6617dfd21b5712229b5326a61868f49e82326e39395dc9b99e7092885d66bf9a2839965164b25ce4bb999fa0e8e4a17d7d10be8f4ab878a7a5b3d9084f548c307a398ea4c30690272e38c345139a6415faa30bb4c6f8298d7e89c34ef3bbb0069bd32642d59590f8e17366194bfd20a2ccc3be07f81c7c3cdb05ace3f32f002f33f0f74bf001916b19fe00d3a65dc6f20798e0042ba6c140000998c5be53660ac3eb67455353c2c97dd8e5ba7bd2aab86b16ce888b2fe17f4e555e38cb697db611e4a97ca179265e8e0c137247c14bc2a34a137078e0bb633ffa5c095f81a748f8ba84619299b401e37fe4cefff3a971e1a01d89f61e8beb36f48b3ccd20c4e00c02581fb751af83cf71f800e53041656c58d8852a7d7635e10a9634f35624929041772af554d0bf5c72f28c44e68b6589e08812d5ae9d1e2c0a744257f49854905f1b505e84c181c9917f61b1a17f95fa0ff7f2aaa7e32b5b933b5dccf6985c8772b6ded41bedb5bb35d0c393aec63952612c6185b2e79cb567adbcc0ad0b0ebc933689ce03fe6c5f6f3df9e9da868580de5fd8a5d98c7d4639372a85313a71db00f63e200293847981401fb8645bdf6fe6f1df2ea4eaffc88a2740a8b205e06a238481a4b38492bfe6b00951fb4b4494dbf2549e9895dd733ceb6ea90466f53549da08cace575e22da2cbe2f9075bb113d32c63b84f18413d146394353703de64bdcf5fda92f1a565e36dc76d2d27ade4e583b02bc7384cd98e8cbe390a077e89d6da986c64482b621cae5c632784e69c1a72d10b45b8406e13da332dba4db9565010300549690ea5faadfa6072d3b2d5b1c13a4256b6afff177f1aaeed4d0429135c95ea7c3f4cf8ba2912c142b92fdb78645be9e67e392d7093a96eb588200231f68c4fcdfa3b15467f57f9235bcee94ff611425c7344da3b722469cb93a3cbb74066928c8e62ebae80de1b3ea908386727a99ac0d98de211a5177c7f0f56ddefe8ca30c1e8bcdcf9b4a248f0ef86aefce3732c8086d3e7bf8c14aa32479765387bcdd44999d2f54b77d761202ed0a9c1c392ba06050bccaa4588e08a8d93564396502dd32ac6959346872ec34fa99830e26158b5f0df77d7c2143f9e6cbeb93ae8e41746ba73ab196d5000b61531176b58e0bf66197d42ac62a32974864309b77c29884669df630e4f84ff85a5552c56eee1d09ef6860231e538bc3137f3e165f7da5dff87e11a2da5bb60f15a754854798a6e588bb5bf355fc1404ddca4a09151ce40568ec7ef4b0bb392ef333c5bdcfbf1b0e30e458ebba65d80f5f39c33875e6d11d708ec0b7375485c51f79a5fcedfb5424354bf6cbe36e809486d1aec45021a5205f78ed056227db8356a59707b7685179e33da1b96ebc0c5004cec52a91775bad4e8c50e18659fa75c9af81e60d83505cfd2e3781f22b88604137cae501b04af2254819645de897af7b5b82898dbc777d42d049514cf6247e8e8167317523bd89e183e8d6f04745a68804e9f76d48b8a8ba1f0efa5ad37564b7cf02b3fc7a6ee33f413bf07ee4097f14925ba8df140e4a44f7a2546a3302ac2ec97e36d9fc7d503e8a37aa7a0f2400a814fb7b2bea725090f2bd9833d5122282d3b15c9ad1a3f5084363d0834a6728f7c86d4d16369ff334043adff80b79c0ba3a3ac5441c6034c10095eee287d73eb48375f065dddfc5d7bc1c7218","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
