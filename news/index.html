<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"738c0fae0f02a051cdfe772c261c8e89a7a147cd5c143392e434336f31ca6aa85ec040fb18fc2052e8db41bc2e7c09848e5c94728856535dac759b8169eb442eafc7118994b130122614354c17301f91123c41a032f51c0763cc64b2b67e4e14e64573f72e9c3078d3a2370ab78724656f9d0e042e42011c81192b7f2b82ef0904dcc84878082979bc78829c6aefa9a625a9fb3e1fb704eeb80ff114751411443d91760d95e95801325b9a75bd53ccefa2a5f17bae6628f654949760d322296db8c60b18b6407b2e07e3056a3112cd70e402a0b736349732636f95794e6975100924773a0da6982fa0d520982a82fe55bb930424ae82a0c5c63297b596eb66986abd3861f62ff8ee582ec691ab1ff6e56fb5067e5be523dfa5e74c89a6d77b96c5060447cdbe4e3f3614adf40a59ad99fc32bcdbb4639bb738346d0e91ce2b16b8470e817e401e3d49851aac1459c5b632eb86e00efa1c1eedc049a4d106ccaa65a2414cf20e7e3d5f720ca8e9e6a48e09553210190f3e30ca7e6cb4f8db3f8688648d42e4b4cf6de76854e9ba797253daee6480484036d0f1d67a634147e57736772b8431aa70b51a44bd92d93942811ecb50da3ad15aa72af2cf196f4fded2b3614f948a6ee8d1c262d5a15d9d0ac0f2b69c0117e8b292a0697151ff7a598269f52d7891e3b1d305b01436005f178c7362ad0a84aa15863a230b89619538d27f132412ca6e6e4ee3339ee6bb352097435e141a0a56d528e93ab2c529a80362acc717b02546db8533f936ecf152072a42f811a23102ddc1fad927abbcce6a8d30a7db567cfc4bb7b9f3cff0683853245d9d988925121a9d321cca94440c4dbc32e96f49f37e2b90875164fe216c034999e9aa7092997ece854635c9339c9fa38aa296c34d48951e3541491e0c07c028db7fff8a3f24e18bf6fbeaaeffaf38d6aaa518407ef55e34cd6bd3206a9e12c51e2daae19aa7e411240c8e30608c031b690f044e48a1046e68560dc7f5528ca8ab2b4bfa165009d7bcbac133f67671676c0c4ff3b826fed0dab27b47999eef4c8d43b604efc6e4a2c13b3c8585b5b19dae4b8cb66caa3c78750076c173524a9807703bb8d8a817d77c9150446ab374834675c429b78ca077874c17825c3436481cae4a9f2f39592bd4b0faf6fc60e7cfe037b5168d23729118d5b5dafeedc3ac4913cb56df20f3eb02f4e475232bcca5de98dae740f8e37b5a7b22ea70420bdaa4c3baffea1d3127ce4adccae6e1279f17d131013f46aac929c5435243a3c135309e4d59fcdecbcfaa1d88ae43a88d2f4b98cf809878d1b51d803d3cbcfe5e36af05a629dd4e56a177eead8e0b95a14ca4a896de739723783980a8c980cd65f1754dd1beebefe944dc3e4417975938dc7da5b90555783adc1f27af3071444c65b80c8bc9d8cbbadc8a6eb5c4b5d998ecf55553ea27440fb5dea92366aec47554e6aeadb5e79dd9c750a71173102e9f4950b1f1658c21baa1510ec112ef5a56848bd06323a08ed5e30c8c5c2155084673c98728846fa23bb5743125b3ccb8139571571e7ea18ee989eb1e282a7385861eecb83ab2c370682f8edc1bba58fa7f90e4d52fbe4d47e650c1c7781c6d86026f412178d451dcc1666c37d05f78a4a317cab4c1dc074eb26c3ca581a7e2c79f69a62fe96e7737343935c315f8499c8b84fc7909a8e37e31c165fcef9122a8e79bf98a064dae721cfb56484d44898097a1ec8b2dfb621057f188b231578a4e08da5a550f40740d1c20f3896683bd2bbbae02e32eea2013257b4cfcfeda20f75bae32a90c56d657988b615e42e42785077aae8abb43bed1274d52e53c5d745f4d57c0e0d48ff10818dd1c07de0120045fab92f264060048f2e6b1f12f8b8fb65f5e41577b8604714696673342385e16d1d58a26e2ea6caf33c24d831883038ff494b5cb80e29aab0061358722690ac44d3cbf8c2047a934530fea18979ba58ac8437ee19297b9592bf7a47a050cba0e18b2cb2840fa12d04402d30a9d76dd7a5fecf9e8de31a76780db972bb67887defc89a22e676270b600b598c81612fdca7d41d532c2d068808d31c09ab26fa80b6d0ec1157989bf641189d7fb703b616656a6a9d698a076921f418931e01d54dd819ce9399bf662935ab861790e865b15bcbd5f324b6319a9fbd2169923bbab6df3d40a76522bfeb485e3da6c4aeee30adc25c3267751f9799a3d217c610c10f3b3157fffa7c220f508322451e9de5188c1181a939f4e37a7d20385286449279d62c53dbabba9bd81fa95b761d20aa52165980e63ffdcf06c56ce8e2243497083b5ae2a71f57e8272a81421551a2fdaa21c6269c7fec10ca9ff222f176827bf203c20e5890f0cccdfae49a14a1b0c1e65a68a8772f518159bbbae2412eb7042dd0b5aed74f642a43ab3c362ac19aa2ac4e1fab0ce577f765afdb79dc29c6e5d12d25b1aa540c2813bc1ebbec14c21985dcdbccab58ec31f64df86bcbc64187415a1d7d70a3cae1392b97f57ec3747a3d5ae9e7d5b94fa57f8b7919753f42095d790012e284821a349c69b0180d4b2710db126e0977ecc99e36a4ed446aabf882bc6e9f3e841b2f05227e7645be74ff6e2f3d33551c476490ec7db0e5f857186943802bb02031670cb46b28a19c340e1247468f6460ef2a75fa938fe7a3593550a39adafe8e27a849bf55d65a76edcf483ca6c03ffc9f5f211be8020b34b440d2ea235a5d598c834fc12bc7544509025f6dd1c1350d72348018792d55f190e6873701426e2f98b334625c58a990ec2f4b8354580e87caf866407aa4a7f5c7fe7d0f3ffa5ce1eb521bce4ff57e5198115df7358661edca6494e96504904950f94b0cbb5870230077b768766e8f079d704b7f66afc696ec6d3126087653df66231451f5a8f605bafc65d666a63cb70a4f1b4a9ef3098ad020d538da9050e05b2dca9528e0d7582008bef75d35a1fe4f18d6e3bf1d640a61b3baaa104ff1e846dbd0461a353a260284acba0a41da446a9ff6c7309479609a73be52e288736ddd8348c5a2829c1d8057d5a6a5dc0aaf7f7a20c912f62dbd38370563838d014e806f61f60778effe05a1da21c014d5eac0a6dd4f2bfea68a2f8f87f3e147bf02e4381e1093b71c856a7137cb6fb9db011cbbd5566946205dbe22b084ecbbd5e232c41172e97b598753ab3a489822c0cf476bb01e83aa5fd0008159a8d6e31b466e144df2ff6d3f299f2a51b1f5bd7741a9262b264e6df15974045da985525d5baef6446fd65654a99877924a94a9f007b9e5c7961227924b8d475066aaaddf503918645b33141cd90307213d95dffdced4fd3949a176e4ff4fb3002ee8e547c9df258c6bfe8bb4c6c3eb2805f23079429dcb81d48f9988979690db122e46bfd97108b3dd5327be75f2c589e14291bf71bbac914df66a8510ddca09c5f74e7320fd46f4a12d80c8af9e38a1049c277e1bdd3f5f84805e1447dc67d2f93edbb8404b6ffe5a142593347c0e8153c9f954ebcc2175a43cae4af4ad138fec7d6f55368c74a9574d1e2400a4f8d6e5936d373594ff7b8e19c0f0dfac1fd53434c5bec4daac3dd18b3ae635b3741c792e71788b338f04e32a7468001196ca34c66a34d69eee05c50caa1bb649806a3a2e00b8fd863bf15d9f0593e03288e7db3e78570aef3b0c398c006b18748d5ca489714877a42c230708e7782e4b8c91deddf47024d9dd725166ff15b01883f5b9b98a5d99388c70053fd192af2003f70db87bd05b9703443be674a224df4dd6db5b9ca4f46c9ae1b2a722f52fb36deef4b140f33c8c549779025fb40d3fab3c90fb579c28cbe20de7c5a19e7ee3e50762b19f97d31ed00d1cc3f5b142a5d20f04aab63ec4f5e24b5093aeea419c4afc678b6ae6175c82244fbe8ecfd9c49ea5ff39f68d92c3f61b30cebc545970c30a83bbfc5d37329630a0ace7fc91dbd0ba96d204d39d134954bf434ae1a4e3f6778924f5593c359e9f01f0e7360ef9de26df6fae59ec8770ac3e1b1b0c27ad161c185f08a39dbe05d98510f4c7090bd1261192d24a7005d64884ab47849332cf5b1cdde58be19b0e63d84f82f489dc03d010afd7a1ba9c099cbc2fa69e95e1c9a0279647988604776e45a49ae32ece86528d6c9c159f7ce19ca8e626de612a074f39f693c8ade47e2cc75a3964eddcc4053b962e2c0290056f60c7c37406efe7a2a3e818b353ce384a18f1f3524aa85ee24779e300048da2fc14f0ee33b07e8693a7cf0f2f86f733b7ef6a3bfe043c15d1c1b90c0da2146e43a5721efd7dfbb6939d154ddd26ffd518f2389019d402bf12b3908ba6886318e93e8c6e01d870f425f9385a4c5c4bd67286ec1be49684ba6bf779223844e9c4775cf6ff8a542eb27854fbf5945157fbd8a1a32edb529d4247b1602367cdfcc669cacf07eeeb9b182bfab6e52d0388e662c23f0b9c439d02cce626bb2521b866d9af304d5c3803c690e9dbf5367d4795027e1cc9cc239bd61c2b852f569558ad757fcc29f42a967334044c71f8073679212ae7d9fafb71e0dbecec77fb4f949e2728c93eebf433e03da790f5575304139b894cfc6b7474385afef8567d4c22204fee1d9057059fda23c303fec6a932eaf99766c9129dadd62209e756b411dc6bd049c01042c9736c138d62b10de676c11e57bc83eb3d04926fc2d1ab376291cc576f8767504d306d69907f64ac35d0b6478f8ddcff94c4a3ccdfe1c3aac600c4e08659032058e649577131409be15e0a574752d950d1d330da6c5f839ff360dbe6e19701117167e5b434f313a2368e9573ea7a7b47cb676f61dcbe8f618aa495f13a773224cb54e7955e6d6c07972ee3e75260022674aa7c5c66072c06b7c05691ae57abec3b44199403b55f8e7464d5b6f24e34faaab96b89afddad6e0ae45a690314c909f4acb9e75746147f414fea3b71ab9f7ecaaff7f31833713db3d59550ddf3ad32dfae3198317fd5b60a9916c90928e4657dc7c83590f67d781c9a431df390776b3973aa2846cb7d9a832440e2d14eedbec1e1d42ddecc58cf3ad6b4abc4789ed0ff91b92a0b20d487792d23e14a49805e7ee005157e268c0aafbbf23af2868d08e82fb82175e60ff65eddf29d3195385e327b3daa0783dc05fb730ca9a788f40744f8092dd82ec9f2b097aaec5b9060b15c8f9509e1dcf192674af08ff4e5ef4562aea1e041ae09bd9981f7685db45ffa1bda2dff7ece7481d38c66c8385e86d4e07c56d4bf09b047279a9734e16a341e34126c2eb1d3e2667b8a134d029c1955a43cbcecb6a9cf33e10d3e0ecb815a303616ab8006fbadd46b3e63cccfc365f54fdd627808e549ed5a97dbb24b74137122faaf64dce64b5111174986b831f055f0bc1dabcf3b2f0f74737cbc917ccbd68bc6da084cb7dd6f149eacc8cfa1dbb9485508939ce60bec3a798055e2413bd1126da2b1add6a9496f0c9a5e6aa01ea4812b036fca96ab518ce1a920f52985464b0e4d22e892e7b510c28a910fe5ccc99dfb83b0a75a85f2a1896e9224f397656e790ff7f0eac0b4b53ef9be36688640e91aaf80e6cd7989682fd6daf77fc6d5333f719bde4df4368842e2fb13e792986799d67114506fa9bcc87d395b87e535b6d90e8df4438f19bbeeb48572f2ca3b1b9cc627608abb53eabb76f9617fea8d2fac93551f559af2c9db82e1928f78368a55fd03d77f2e80a6d36f0eb3ce3c7054256712962c99eaccdd8bc42892ee2dfa8b83cc324f0a015b7369753c1f2edc019c97d454d43acc5474f7770c317d6b5fac1f0bb8e95e7a0ce3f5992475da21280f2bf0199545a16adbd81a9cc4557e6ac90650b84110016c0ea8d97ece7d60b90e827f007ff70ee2314df5b712d784d31622eed4d4ed956e240fc5ee081d717f86d43807a7e8e83507d20df6be88192a986edfd48f9cc5f8cc5c2cd05db8207851e604165e27a941999b0938f01d36eb031f97e5f78b541c5b18e4a1de21aa22681558379ec488a876d0b40950bf749a9a54a36e128cfb42c74fb8d03426eb64a9d85ec0c5b6a5a5ad8ab32964abb829158911aac194cdd332180c93bde83f7bac900e16ef036afcb37c7c635b09af4472f7c9348986f051a97a2c69641df0abe965a838403a0868f8162933ff79e5412cc53cda95c2cc5c6e5b96d75e620f52225b208df2ee286159ca980d525168255dfc19214ac6dbda791f861a20535fcb8a09043c035a6fcf886e6176f421d869ce633d443006ae0c6719d97270e4369c9ef3feb6aeeacd0362dceaa4e663e49b994c2b9c63d71add41b2c4e316c3a44df9a4c9c982f7697d396855e82e65ba1b8bdc9ed02cc320afd22a7f06f15580862597d1f5d32bfc1467ba8a31beef769569b3093bdef282eadee62f074cfa5dbac4478a2d458dbc4945ab622b7e1ad375c6695c57695f3fc514b8a747759045bd8fd51e99342089bb6d8fda069f267bfdfaf5e3bab3c445d0214c200b4a065f255550da24925007e8e9f21b59167736578505037019e02dfc9037872f726f9178184c29de1dc0bb31a49907f72779d7f35352e6daf3bb40540bf7ed3f9196286ad9fb06bca4639892798654ba9467c11d458d7e0974e4e8205c397c66685ea7193eccbd848ab7fb595f117190f488adf03f1d3b1c739aacdf298f3522de6889329af4204611f0d609744d35a020b114ef035b5f5cc66abbb9984fab5b232d5ef5f412672ad24d7e6c694307996db49c779ed62b1d54323c4fb8f511cae7dce0eb15c48612fbf67147f217b5fd4ed3194f8a29f289f7544b8d1d4ba6569af35dc8275ebbbf059ecbf2d72788a6bd0b821293e6070fc74ae4c62b29b6821836e227925a5fed683378e59f9963920f3c502a469843f82b7ac3946ae4f35a0fa7c0233ac6ec58b937f8ea86c0a882924a64198702108c8b4da1b9522d4b5074497ea9cda1fe565ed2db54024c680238f347a5b0a9b8760c704f8a1cfe279f3ff53dabc6f82616b5f40bb6a642cf8f7eb95fc7a4f4205d637f8df45e11eae76734d04648c1e884e1b0c1067e4a9d51e259d2226b913a2679d6e694bc7e8e395bd15aaad857ee7a4c3ff061fbc57aab2c90f41a39a15d39d9b3c8f429e5192dbafe98fba17fcea96ca40c9abe121fbe36b8bab62d23aae111d38fb9a69db6c06815b90af65f35c0eceaa5cc78608943e7aa175cb3cc4da00861bcec1e990d9b98356bc1bfc0bb84662173e5ea9b11232ea16123194a00ff65f2ab040d08069e3aaef4c1c9b08d2bc91a0432d68ed525503a5935361904f3d5786d12dd8e63e5f220432824e5f63230fce89395e2ab6fd27ae705ea259ad82c46554a8af660936378ff7b86de7233749beb4fb7524bc0af7b933fba95853b1fc43d1ab51633682a3352e101b6795502fed0964ef15f88ea2e05efb207d3a12a0ff6fd48cec31adb4be4ffc048f85632de6e232d8cc85ccbea772dbb07c4012137e4b242a8c18f30b84b4ef923f13dc1abc0555305271d62211894f8cb115d73c84886f1161f0e1ede2efa23e984c0a8fac0599de7a2d582b55b2074af42365e40af6b36ba2e031a3d5cd7d7c2245aca672fd6b8f67931adc3d3c2f201f446b836f7e76fead286dfd0807b7bcde6d27cdc1b219c3064fd00f32afabeb2a2a4a7778be9d27fe3c2cf8447e9aa870cc240802127dd79dd0bd7b23d222575fc0ae5748ff042b696baa08f3b8e4340a729fec3d907778e2e243ae4f950c70c06e90a17117769c79c7ff3fc1a17d2afff6bf538a5b1f6fa95ed1e4cf9a9c1eea5ba70789712d4ab730231aaab048156bf95376c26cb78af4ca190d03fec680cfbbb8c64b01f8f2c749e70c0292d229a12c52d843a6bec202564f6e4fb77cab9c5bc794758c1b31674a4f2a72b0f6b6c7372d6937baf491da8c9c1413ccb7063c5379ff9bc9be020211b8f05b172e21e58de5e02396a86d43a1d15b8c3636b7c108ebe141b1c0562e6b6878e424f0d74bc975cd3b30832744dfe55015d57df813af7d9e2f08967d33ea8b9d4f9cc09cfaf017796820e8911dc109b8a2be4aeb28dbf7d2eba4209cae46f8f47dd3e459a61cc4628a3786a6395a1bb4ffabc707372ccdebd5e57bc8cdfad7b91d6b22d03592c9c7685b58214eaa39fbea942af5a7d5bcc5baa3af98aa152c0d606a6bad684561f6803586584866481007df9edaaf95136955cd72a797213a0f598ce2e6af07375fdbabac327f353b28460c1817aaa367b3a7b0405e0551fd313cc0a39c5b1f7b0d0845b78bbadb8b7c93ea2ec84e521cfde219ac270e29378bf14cb94c439aa1a1b36f924f591b38db1ab449a7854cbf039a205cf576ec87ee5cc7e5ac643e52ef49dbf93cd22c456b12bf1604b76ba703a5cc46bec8e2a5bc585b6e8da6e284672b93c2e4472a2f6c6515ee1b521a35fd82cc85be4fb8f82ce33c5b079cda080ed8452c9206e6f99fabc7088cc177125b0643f12de602c11145e056af2929c8f66482a567309b0692ecb5962af501a7d9a3116891b455390fede3a273fbc63d360e9665b3212b5ee7416d0b555eea6521cc661128cafeb70e4cb8d52cf7c352fdb9dfdb402fbddc4069d1e45151b409e4e83848f95bbbd4d1302373cd14b7cc7e9334eb3b29fa83c138b807b8529380da46712274405246f1afc19cfbd25afdddcd859c62aeb13f8f75111c36c88c009ac9cbd51c73468247","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
