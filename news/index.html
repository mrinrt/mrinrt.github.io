<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eaaa51f53a76b46544cc3f4f52177bf4916f93c96bb46af3f58f34dcee3e823d3afc58a86b945cf428206b7682e5412f5dab473ef67966d887788b563decec43fcf43d03d880c5dd7a8d66106060beb00ee1cce51ab3f49582b9f86e6ecd9f257bd4cce7a0d1afa487917b6965d179dcbb232e80eb10072090d68a79de0deade8a303682cbb3bb7b17b53a26332c17ad204c5fe5240a2afecbc873772919f140a5aaf06254831a82b75a22afa941dac01f063a7ce7672fabc0c1bfb65e48c9af3dfcc60ce65be1689a111361194663276f697cfa367458842c4ef0236c1dcda0837e5bbe821275581bd9c0059a5abc8fdb424f8fecef6b801d08af4896cb6d682531e1d20a6fbb721f7f4a60c7c33aa0175d5c825b98da0760e33335b144c0709a4a010882805cda6d6817a0f6d2f7343ccc7e6e27431fb0ed4e1c7601c61da791bd64a9e1c646ec9472671149b6d4fa9bda8a7c45c941a074999f17c3106d3340728ce490775593c09da66f0d0e870b171984b891e6ffa006285e76818e72ac2b1fc25dd0757f627e7c6cab338c6d0778d4038f12562676184437515d76690fb27045971d561a2aa78db33c3005af2395f028b45020946cff47c9cb96a7667c7f59bd991f322c10d2e6ed9caf47cd04d8d6c7a443e8d2d6188c525147a1c1de4e5d761638272cdfce60a3803311b1c30e3678f0bf72a2a1efe2f86bd19826e21f129d71760e6aa041809d841e6cba0824fd0fdb4ade14630ac40c2c2bc3d9548b59e271254f643f58f4f2916726466f09d2a44a943494241e57cda7c1866fa8fd50fff60c3f37f6fb21810fa723608459d68f91ddf27c11e60733b9c35ccdb08f6e68a13261f498a40e16c1599ee97c839d2c2017d04a5ad476bbf20c8df364118903e9db1150bf229e561076bd88692a79002f940858a3c4a4bd3eeb1e1e39363048910d21468caa58423668307fa49fb2e70059e38f0a1a49c4bbca6120c76ad74515876d4abfb9e3d35906c257db4e722cfd5449bc2420007e111914ae1283c46d5a4c639dfe1c78e5eea1e414080a9dd9267f454959ba1df83d0265cf5f8b8057dc885e337b226af8e6bdcef584bb36ecec5b7bc529fb46e5c3130bfd6d78049780892ea992adf1670bac950f5c6098d1fa3501c4f569a553d7acd19f414539d7a0b259c12cd080a6ce400074e078e856769449c486eff0aba4350668af2434df76a436b2fd0f97bd3f0d4a7c95076e49e9eb5108d6f77821a2ea296d731cc69775d1926d496203cb921727bb64db662d41c867f79c7c81040c1209ecf0e079b1e4ac53b1d0cb1deef8099f190899dede78af8b415aae8541952062f6ea59b7ba0742931086de8e0eb234273356809643a26ce0b1b708f60bc867279cf6b5111135a31b21ba9ef36242dc9c7f9268d756e4f315ecd1300cfcbf72d14635f3b14d0b11b75d357f0b53fd342bcdafc87f3a988dd45802e65d34ce3e0040e948a0a19fd31f6ce7dd2758aee35b5c0ce46e8dc9d93bdbd4393262637427ec79dd22c2db2a54924799576a53821e0801defdd4dac9bdae89d2bde8a70ac31ad34dbb6f01182267b6b829d747e265be399e4d99339b255b88cbcf63f2dcc012144f871c3a649751aca4a417c295726709814cca2fd073b9359b54eb65f0959b076aaea0f6d8ef350dbcb72018d0f60d6aa04306d40160b875d874d633a49ca1cd7ea5648556dcdb7cdb0477288bb510742833d701c5cbd9926a4eaf0bf7961b56d89075359353fe47e79560aa94c9c30032aac3ea8b4aff312bf8065ae10034f0c795ec512dfcaad783e323d484abc5c31f62028bd991b58c6c684a77fa10333646262fa8e5b37a94fc7198c29b30d60473520b7ee71a501840fa98b3d26e398e25a8941d4ae1cfeb563140a24fb37b85603b29be0d23de989c6b46110577d8a1dcbac4ec577c2f5930b673e900c4c8cf723e370bb6d5ce6c52f9f3baaa3d4eb17a58345e2717d5910a963ab678d8e98be91b169f0a51f4ada35e6c0ea988574aa7e2156528e70f439f4624b0472d17d785e97377ee386338443138f674b2f3905a6be5bf2c2e5297688838a10f50a5db61221fbb1b3b430831021a1787beeb6b14bf385dd8321fce9ea07c4ef4e1d92df35cb157f17285fdb0addf277f5ecdf51037ee37406965cf6ace94635b4eb88e4d3c640469172fbb42e6d6427354434725f599edda24bba81d440d38f6011a69e4606bfdc877db09bf9c0fe6df41b4ce2371feeceb146f4199bf867584a0a71712cca905a499fd04b914109b444be47946728379504c880620a45528141907a4a5c903601f4df69d64af82e4986129da4412495eb57075cd7c7e7b729fff4e354397a33dc8a8145eed026c401f27f997ad42d2ec76a99beac99b192b5592d13be145b828a65f3e96f58f5a337614ea0beecb842406ac8c9236de0d9464bffc0105b237fb743e9288a70da0759547ffbb99d0d5383621f3c3de153b2779812766901bccc75b6eec53a0f4a5a0c4f45a488babffd4a861de6721052b898af76cbc0025255ab77c2954ab62f45c8d26cba9e72dccef5b38c9b8b6d4ceb2e00c3cf11d4be7f9f86686c92f7238e6b55e0fe27dc06336ddb6a31ff0a4585d15b6b29c0e1f6d5a76668c8d8226946e63f4b9278845756d1d02a1dfb82001dcd76c5ec057d695880777ab52a5eaba6be1b8ef3457251193ffe0690429403cf8730cae1759130bab0ed536d630a3412ddb5a22adea6583b472dc104c1adc3e9eb46b9d11f2ca28b4cf7833faa353cdec559d217bf6a680703ac635164ac1d0116be638b66b6c3346c6cd54d05bd8264bc71e8a2bc3cdc21dd7549257f16cead40b8b92dbec6d75ae323d61bc9bcf8aac32a6cb84a49463ecb68a371ce34864a5bf38b100a7dfbcf7aa6efffd2044a161211b529db1f730320fb388122bd2aa8d9f716cc540c0f757279de8cfdaf922e52f0d6a7b0218b49495798496b9d9cf6e1a9105f88e6cb9ad46b027a232281a4810a043d86e3ac965c257b595de839d441aad0e9b7389eb761895e54898be7f5ba7de9e38d4e087cde507426fb6c5c9b7a71ef39794cd5b0c65d92a365bda6d1c5f16ca4de372a28eb0f2e2d1228ebd424f847fbdc6d1b5407d07cee4843b64d58d765b35f3510160e57f7295d4887942b0c6e2b47b0a423558142b5ab585acf9a2051e7cb0cc1e7c5d9504820981a14da120a471f920dc87a40a451d09e8c13b7b46a1fe179a66a49cf91a4795515952a2f20077252562d8d9645539ef483a27bb3875d9eda34163392851a8ea038370ff5bb42204167b22dd6cf7fa462bd3f2973852013dc638731cf5262f8e609f1783048db45482f9d9e4ba2455673dce5c03414ae70644ed6f9ff8c4a58bd247b4ccb379725eb1c39cfeebd458d8b53fe304442f43b29c552634933c5952adde3d7ea22dd0908933bd991da988809af911716f9a0f789a1b56773926f4b2bcd0d97cecbd68b48d2b323786c5e0dcc685b77664530490df6f42863147380a1608a600e61eb560badf09ab626af09164a51d8f967c572d39b2526b12c3b744ec379e391ce1c539d92547ddb5d4e849f3fbd87fed16b778dc85626e1d44d5095de49af0a4a6f968e175fbd29e7ab8a6d713e5b2ea9de860c69c9796856c17bc1f571c45410a659b0afe9288e7391687e6ed6c11010ee932f4622ee1d67eedca51631d18d2ba6aa3c2a2eeb251e133d5d2422317189838d84b9cda999435b728dc1389dff84f5104b23a6b01cb18dfb53dd982d00dbdd742eeb4a95e9d1dfb973d3b6b268dcb20dc656d87df7cbf2cb395f6fb41000ca269b51d627a8f5a1e19c5656a4d0fdbc691e9b2641f2f010b9e31d04b7db424225681ac2a7d5e86376aa7c9f1d102fbed0e9d1d9d08c239b6aa22e74d1dec057ac90ff274ee99f845458a09c3ece1b31d317ed5ace1a042c09223cea8a91c0697a6906c13843ad2bdc9cdc95f1c32dc6a2a3299adc8029392d198c5ce5a14f872cd9557baca2423c0bc023157d3510386ea0425659688a5f86a5d3dca5586e7574256c3654a22e5a93999ec28fc2abbdf7b3f6f383e833baa35e88f2025a6d13c88d885354dfef7a900b889a36d61f7b98a81fb76c970ebf9f8be370103aa4e1e7a3da8ca83aa5d3011adf5f1fbb5a3adcc1a06d9bef3a55c116f9ed6d633963313d651702b97d57e764ac5d80df6cdeb9bd52e54f2c86f3e47b2d629a95e29b9b3989214d90bf8eb545b05bbe7ad92230137b066db258d55b3f39dd172478bc736df639570e1288e2133d473bf49bb43c6e5ae53a155360eaab1c9af82e7ee680a667adb2de097fc3a9629a9189f3ad7b07de607e0f65452656136cad89e1b2fd5d41140fe2f1a2f31904a42054329fd3aaaae88831a2ea8477e6a53c51ee0b886deed179707d698ad8e38ad0b33db5e2e869810e0b31aa11cc5eef2bbb94dac8d529dd3fb83052d058142943c1ee426d1fc0d941ea596f815d834a638b381374c8bbe20ea73001d1bc84cb693c9b94a9fb6607e0c2a9ca567582ccd7a87fd42362dc88d5f9145aae481d7674c24105d675f3964dac61d116eb5641dde3f9b579796a9d158b32b13219d28bfe5786ecc43f33d6934c8df0ce5e33a458f96175337cbb4a78ab04db3819e5c40941988b43c5f11f71a561fc18cddaeda406e00567ebc74b0e545770cd135b32bb3cb96c023d30e3dbc843208570030829e96057f89ad1bc66d077599da312987618979d63d1ec63b0c11a8f9dff568d784f2630bd3d6b92a71dae5319f99979e5fa6ccd492e72faf584187dd4b03471e9a2bce5fe10ed1d53a642350a9c4ba812cfb8867c7c12b38cde930015b4f92d32d19915d76487b7602e9bd7886e5d8220e4eb3664ef919c27321d3d2271694900b836484d2a7cf8a74cd65603404fc2aaa1c3e5234bd873d3190e71bc06e196759141384a0a7a08c90606de31798683bcdae8d555678d7310d6726097e291466c752503aa71f857410154bf774cf1d5cb968a3b5cdab71bdd552a94272a7972788f054493105d2ed856d4594393cb19a41b5d04d1053c003d83baaab89f4710479e5079d26041dad0001a187a2e2b575f2214db2ab41ef4a5bbfb41ffb836c63873a9cfedd7b05f9d9ff24c906f05366a61044bd1148ed36b5622bd0c06a5d20da15279c04feb2336f2ca6482ae20c44386617c2ecb4a8acc15f000d7a8fc786f10e4f85aa7437068e172e425db5dce6f47b3f3fda3223a2eb6717340eedad1de6b9e4191d53b20cb910a6e89b99d921e278356fee9277a0e6dfc07ecc211582f62dfa1e0c70feb164d6abdb1809fa39616d3b2c05703904add866ba61091fd30b44de6373afa4c052fe22fd6eff63f942b50a7c221da172135e88717bef65c3133920bda09567bdc5f589bd76c281579cf91d9acb4173be4d88cffff62a61aa3d2ea133f04d4dc74b1023ec54e5593ca8d2eec5223723cfb11f80723c098b80d750f0754b4c1c42ae115d3a3cb50e773655441448e78d4a1c8ef70fb9d56b9e1f5833518cdd4d08749069dc7049c733f6138804d9ea6f742fcb7ada485afb3a6f3ba69ca0a68483b687a80f778255f508041c9deaef4f19c3fb73293da98ea41c534a48e739ac4ecdd8042884167a872d2a9bc80ac2b8a944b6689059ead3c46f0005121bd2774ca40cb04e60acd245f0a1e90ce5965b6bd7df3ceb5f889ed6280d0bc9281ae99949b3fdf90ba1da152f849ecdfdfee03cc016447a8db3979c11225425389d01dfaa241bbcb2292810ee346d219174f8c3cbabb09cf0c79e42cfd7dd9ed790b9b62f23e4c2f7720b29e45888cd9d04fc8711e426ebaeafe1d9f0dbd49eb148da0824058fc72b32f591b7f15dae383205496f5955e013c7dc72afe9a9b7756aa24d722866e402011c9cb1806a890d8c49cbac8e84b1d1f40af80f28f479db1f6f673d2d8dfa003f19d220a42372f6454a62e68903b01dd6d9989d7c4d07ad8e7e0a9d2b520a6ab4cfd15748d5b964d8b8baefbeab390d8f23f9592224cdf97fd4637487bc59baf7f40eb78205f349900ce4158f358ecfb88c7f1a0a65ae6f74028a7af90e082519111550382fe4eed1c578a9989d7c3c574cfe3a1f82665a2982b07fac40e5c32934d3623962d44b70baaeea6170f737be8f397460af706d92c57519474e27a8ee743655f41c7e81323cd845918ede6723360b74c8f11ed6e503f1a03f676a93d57bd3b65fef33874cf40d880a161722782b8042069b392734fd9be30ce323a7bff5aaf41d7dd4c191f5c6f1c50ac1f2859aeeab30aa342232ea14e5a12f2d77c8ee8c9bd8b4cc5f11ff58cce92f71d7f0de3fe2ca089c1a53d05c33768892a074563b0c4a6bca1c88f8fb2e4f40f7f35200eedf98f787f464bd32a08b1da45f00d2f0c712dcaa0e778cceca621c47ca18eec3358e5db24b9c642b7dc8109e70aa3f58e56ee6dba3eff1a903f474cd4121459d48d25b8462370b9b6cefb9f2c28bf38e517feee104b18ec6a8cbf1a8a8972432a7e5decd008df0d1765df582d5d1980f410c7c41eb4769f9b6255dec845f718cccd793b42808071ff2ba1c5cb567a2902181bb55d949a75149651b113fa063f2b47013a452bd0bb5a5d9d79e1e8282f5468be98abfb11f5ec9ff47dccf840acd6a94530a6081fba42712f980c32ea4b228dfe91eab63d9f0d0ba9ab71d7e0b2e2dd9a65298c7641290ea939d33639f10bf5a89a4cf0f02f1f0c1769fb425e19f14afbb12d046ec441b85ab1cceba97a1ce8138d5aa7be864a0223e433b64e892833e9609e24a4aa9937da359fd47b21bcc90fc7f2adc84d97219862bf445a1064d9b7e46eaebc6a76b6f0fbe9c0e3885c1714a1371afe70257984166f6981690fa855049fd74ead64759c2614aeaa584d510fc60165a39670e99e09ef3972c06d7b5d6fc545ec55c5432cfe0ea6c1010a7beda38e0d66e067882723b3fd8ee9a944b9dba6c997cee63b84abb34b6e356a0e4e7c45533591405dfbf19c99782dfbd95b4f72a9f2c6ec1cebff3cf59b6a1f6a5e7abe2146fbd6dcb8d77c8f3c48957dd175e714554f8946ca3f3a810fb5d0f765152304bacf52ec88478318e19e10ab87d0a58598729b1f8c621cf5198d87e96d97c9078d4e7956bad0f1b53ca6272bf7849e91730df34d6379fb186839e1136fd55d85b9b1cefdcef1a8f1409be21fa017d9bc1cda3a31dc3e6746c3fcac1b825dfd5061bfc6f0035fe2f78216af8c1ce64a3f906e58065b89102529aca33467edde4a80b9b3258eeed9fa3eae0df48cfb3e9a73cb5bce1c5bc769cc9381dd6e30a4e800868ceac137a6f8e45dae9bb12b7856019f328722702c6f18e4b9a863b97ba9876274e924d25973a6a622dc110f82a1cca524ba32e3c1c646f51744c683d426f74aaaf6ff9cc3733bfdc3fa60f93d1d75bf02c115fde81385dafa9c68652bf073eda379b8a95a0d680128808a1a2cf83d92986ec6b8a1f422d092ecc69a955c38b475e85b58835fbfe8a544d3d319f0f828f43dc2e97d37a966a215bcc0b0629b1fd0ee5a87f30524152a3b151b7063b8ac69e5a498c30102e5b342ab4b311c2b1d5b6b26b84c858458c7eafefffdd23b452a080bf89434349e63f736a319504cb598bdbdef8c6b1c167c60114809471941a44e8606efd80e8389507f31fc233b9d76bb2abe301373eedf5bd573f273aaff7465e3a48335913bd1d4473a2f4e50bc044fb9e79f3ec3b4262b5ba1ffa0f2e81386991ef0badba16d01694331b9e7acc8a7854ea16eab0bbf4acf06ba32a62297ecd98c917a6e61f638abf0b3fbb422ff9f8c0faf03679a7cb94e747af91e17cf29dc4be816d3d12d42a637495491e37c3ce640485e4154d39989c7ba2d3d2de6004fdf47ce9ad52591c4e91d984db361f80d8d2338041fff6ad53feadc99ae62d307754224308b06f11375105d7107762a875f14ddaee68cc16ab00668f9664c0c8b9751c5e0e99f8a24664df20c31efa435159c2145148cbd8d8cdc9cb391ce7c182ca621e4a33b4d365ad3c07eb5be24df8c849744ab9ec0e9c6cdaae343c4a42d3bf8c932f69531deb7035af391d8281351399610e40a436f98432ed4bd315d235f4f19b1c735f9b49408f9dea92515e79ec6de7965128781e9ee2f980190b9680e3a85059a338f1894c89f4a84ec314fb53539e216bc42aa55f87ec00081acfa83e738ae3eebfbcd8697459d1d423d716c8f84a8bd32472c55699ce9246a5cc0e63cba2c385fdfa300919eddc329044629b2f54dc087114944b0a2dc9b05eccc67cf14fc24d945ca9e1a0e7967f01c8e539de06c29cf384b056a601c021635603c0785b542c4c495031085bb6d7b8376277cf4f1197fd909343261e4b15a249d1517cf3fdf5f2f38830598e024b89385532657552eea1b40aa77822311987271f7ba9f1f1c16c26a0052082d20d93f12fc58636ebf8c67ba6d57a28b536e86b3b3609708c79a47309d5fa1c54acf10aba787c934e4e48ad158cdbf1ebf06db48cd0057cee671a022dcaccea8c5c8fe6a2161ff3f611912a6d68b9e00a70794d356e796b42357fa5ef836ce3c854a10b54213b5897b9e9ef6f76b0536ae58a3aff6914be74be08627c536adcafba4b6bb9adca088f5674d1af00ab8612a7893764eacf18e53ddba470545ee9ce2b3042df00b269f806ea646a42a9cd07edd3f8be8ed846ca99b0a9a55a5d82dc62f96a914a64f7fc576e1d737daaa06a8522d1965735475bb3ef8a1b1da6272f7ddb95c8950bcfb9015196b4ef3bf86c219174300ef41e83c8cda5998bdd6513b8252450d5032598fd5947a6419b7c33e190db2172259c5665de595e6c3ab5289d2d8041fa33a9907c4f02e6884e09088fa565f88dfaf62989a86e18956eb403a21148b729c34c687c6d34bec7bacb269f1bbdf4b521929ef250fc60eb507b97c5bdc8ccad3046f2c40b5e4701ea5f3ae8eb0e2063d0a2349c3ab61fe32e005d140ea6e345baefc94f88a15769f21ee1787c2e6e2adef6e9d0e60653a0ff502e931295349ceadc29a926aa935fd5a4d056adb62dcc6ccfd3e22ba58926213fc518bf3d10bc29794efdb4dff5398403fb4851b1fbe0f502091ae765124880a0c37db5d579504ffd1460f0ebe568ad7b9621bae8b368be495691e9175fff7a16f80d3bbbc1ed68579f1671c002d91b596b480f010389e6a8901d82c963a8cc1a86f3f68aa1825966d58e480a34087db40fb2d7b6340dcf22cd45b830190fbc6b209724ae0d1861f87f71690158e1d20f479e4378a598f444346417113bc0dd12df3dee1309a4122c596af05ade77dbdfae25f4be6ae74ccff3d3b7dda7f70b287ed5c4cdabadf763a7245725bddf06bf713dd2507aa55bf84f726e3c61b5fd775e2c1ed3d0841b70c200fa1e097ae2ba30596ed8c673a0a6fb46302c236fd1c720672e433ef71f860fb59c9adc398f078e011a60c4df3bbfca77a76687095abd4fce8f8ecb6c21862f090419cd5b78541a2fad2dd3043ece78b8f48873f01cf936f6d69d01177cfee2fa8e3314ce78ae8c8a4c7f586202943697019be8f0228c08ff201216a6f1ba61fe57472bbe18a7da3c69e3a9e8f7d40c6e2c2d33e3e9b6540f9d48d4fb64f1e99ce186abcf0e93d8404a6fec3704e3e52d97db865aa1e32b22addf9edb6216bfcb4596356a50f52ca4bc44f4a661e9517ac37d172e1cdb36f6b744a4326b2542b15b97735f18ff514e83b5a655c0fb551a59a35fe4eea3f81fd9a57ef8d8713f18c99e6ca799f3bb7eca80a3516afc5638947a62e94211e1969c143ca847fa5bb23b0400d4a713e1a1cc4550e9a01a0302dbbbfda0558d5f923b0b3c5fab2b3d050e5ba2cb59c61c4d0cdee9515892ce017d1d459d8282f59585c89b336e8139fc7a7d8171e8bcebe78b5e6e6b46be47481a244224a1610b63e3200d4ffc9d39ee469363fc93cc43998cc2250d3a682650a1e829facd5e2ee863b9af410b699f575ac0d0f5cd1b2f023afe7e7f2db85b4037d64a2ab6a3df0d0c2a128ad26c5b2f6b03c7aec8fc46c5c9908e9a353474483452db98cff72dc23984b1ed7d813b2e6a51f6a17f405923b0648494884f152e0da21da684d01cad91e4d61d60d2f4fb920b3a6ed92876728c7bd928da2b4b374a38a94459812b229ebf517bedcd7994dbaf67198b173b5db3f6bd3b316c965319e55558763aa6e5b3e88cb44a2c7620303ddfbe0e95cd1ff0e635b8574bd33b551ef1a41fa00e6b33a08163b22b879edce4d2ea9e23926f6a92960dee0526b4c93069ae8f410afdbc589c604dce22166896cf01","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
