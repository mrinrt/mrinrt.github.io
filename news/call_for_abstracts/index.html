<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffcbdddad7ac3badfc431d601314f5ebf3a48bd8e7faa3b06c9612945bce66d1fd72d90ffcfdb79821a3a925d2378c531f4985f5e80d950f82cab21369dc114aed0cda44c2c4da59b109eb4668d6a375113dc4ddaaa710111bf5e4f21061d33ee9af519032ceee7cc6f7030239b286ee433c9c52c18d70f593ac86ebc9254664412995b79f96568205d86dc122b221cd9f0de6c9335b01fc7fd794dd4e1dc8754057b63b48001cce739edd91c003d7c1652710e71ec6be9effdd66e2d8469b3cfeb9fb5cf311ae21a5b2f26751b56ffda88ab25919f708478bcf3cde21a64a63c3e65938b0eb2e8f6c973da046defd9dc0c40ff824491ed185304481207e73413739cc2d8ce24c6b5743d81d5a910756ac8d1a167c41f6f6c6c8140c4ea996beca5e20e21d42ab3f0c5e2d3c20dd4719344f08134c34f3d2790c0292a7dbe321f7fa3f97f96519eb3fa5845dc9049d73f6e896d549c292a17c1d20e5f65cf10cf4d6ba71f5db5e45a2b8c7ffa1a8022fcf3e43f264a3bd07c323cab0248e95cc79331f3feae450c6faa234c9fc287c4b5e6be49011d1dd28f1b4b97aabebce5102453852c86f812cbbbcf3000760f464af361788dde55a5198a7106c673fd9ae6f967c28604ed528bd889520a70c4acfb9fa853799759002dcc9992d83c898478660bd71b6b358d8219e58b0cf9c3aa2d405f4bde927509adedb15c3d892594737fc041885cfbbe35eb714d23a0f648a4db9fac9164833f6b5aea2a49bfdb5e5d8db6f4985ef67ec86b57cde3b02d1890f4e5d137e0d1223997aac93f2f8a6a35ab741aab87c883f8069fd87e78908c3e56f27d9860e016beb20572892964d3cff65a2f8a4979be3b941924e425a491390c1356eead4e4b620c3af76a6b381a7d108390f055ac2120f7d4b95b38e90731dc8dab44d94bd2957cd89e5880ca56124588cfedd4bf56da78b6494bd51037ee4796eefe0e1ea6e0a42b4df59c9a76413b124c75c20728f4e42388c62f2f695079796bff157bc174ba48e24138be0145f0409917a5e2ad7038e3958d46d54576fe24f08bfe8ab8148fb1da8fab76a2cb29f358cd7cec9eaec654db2dcd95103330a3e4b8502a0c4c45f225f0394d443c51a5789e0882799f72b729898a792e01036b5bf724def94bbea1a3de4b222edc7d8d0ea4be06f21ea32133371dc61c36292197e395f8fc4ea42e883c7166194ec091928e25bfdf68fd745c3c6e4590ae4c8d626ba440a2d786a07940163cb1aea2154229ae109bc247dd8e078c450df512d4b601d516fca87f4eae04c25c526797c06cb69dcb2820d16ecde197f864dace273030f2a2e2c070bff95aeb4127e0a88f7f12a289b524658d3123ec6e540a3ce535d634cbf89ed346a0ec328476f54ed4c972f5a679a26f76cc3fc935ccc124766148a388271885200c2e8bcb53efce3cec37ba124f512b77844c2fc3a2b8c78d25bebbd4ac2754044448b415071fe583920bef9866bfdbc68202f1b9c2b4469f63b095e1188e1074f0b20bcad7abe96e4ef68ff42223fe11d7a35382c9c317fcec6e4a8ccdad370ff1e3d2391b94428ed63d35db6c6dd12750ade1285f95774c4aeff3e74c9901e6d82b9c783aea730176ad999a4a16d148fa83f104ff5db6e68b1f4b2e47ad24a4958d7a00bcb7c0a65b9283d943a0f666657d8a1bf964c0b3d984b03214effd3bfad65994648b47108ff2dafa0a6e4ba3b8258a5085743f284fc3702073e38979ed13232cc7541d7e6290902651d89463157e69366edd809a989f3649f7eee9f14f1536d94be7498ccf1ee19b053afa720eb6aaeb6079a6b735a7535f2377dd485ea88fced9f169430b0e2f4f11d405d73be9fa2ece074a38e2dc2e5b23fdc1a4f76692f4e3485b8aa05b34f25193302b75cee0bf02aa19205c7281e3312eb8aede28d98790daf50e625beced44c112b7a6118a78b7f181852556acd36252ad3e7783f8a1fdd98f0501230a15e3727a6ac695f3c2b5d4ba51ba83df76f4ef4418180422cf64f7faebbb9ab26ab263f290b3f0f19b9c3200168f775b0d48efe9718e2865882ac9a364d8bc06db5b79efb56cfe76c692ce9ae6eb5bf22121cdf10d60fde28042257c87363f9c6ec7ad739dd661c5e0587598596924ce9cd10f35c9489ed6b487a80f6dbd06d2671a16d4c67a84294e80b285b3ee4b91b1b86da41568c6c092eefa6691864c49159956d9573f699f520d94f6fdf0c4b4569e0f94c60fc345e66997a15bc449970ac12b0c8bdc357e4c57498eed3ffcaf6853637e6ce747671889461eee89175c4c35cc6792bbf3b61fc209511d4bb28cc5e6954f94ca56f18e56dc37dd39e42ff3bc8d36c8dd1d0c8f2c0d1354dea982f88f57777ba7985d907474f934827a5bc300262346ef49c32903ae815c36b2a8744943483a0db63c21dd0a13e81a4fbb9904fe4a9d6bb1ef1c37e68d0a4a679d042903fb7dcccb7ae2fe98a305f46ac13f5829e47af7d48f72ca31309d04cd9663cb08e2fcbcadeadc84783427fc1b0007afec37d743fb29c32e0fd2fb5fc9e98f0dc15a6a0dbe7fe6a3882d78eb55028fd3e12c8cb52c7ee1d7c927199a04622e0bedbfa2888e443070957f448bcc3d62beb928da06cfd85c9c66d2926e6b799b03b220f3749b4049df02a50f03d5e841f51a5fd055b31a602060d59a129c92d2c3025099b88ebfec62ec4ad7a431fccb8524e155ae563002507412f37af6144b864d22c54903e02424f6340aa513c521068ef52b8cea6dc2af5b321a142cffb8ab6ad6a732ccce82b228e44ff1cb478c86056a2e9198f65c61132797c246365605d304ee14172b5a6a5a50ed85dc300447f0a572a00bcf3028c101ea7283fea68f1e370bb93add5b2a7937af76ddd3f8fa5707c95c20e02b37170be661354d126148b9010383311df24d54685830e8daf88bffb5034d554e77d0e04380ee79cd0c72aecc221bbe0f9d4acdde3ac078a7792ff9755a79b13ad9576f76361520019a326761120cf42c21e48fc1374f3dfca9e96187e8032abfc3592a8e220887e90bcbcaaae49bdf86ee1252cfa52b74af8a117452d9dbde234fdba81a8ccf76555c11a32143898e74edc50bf735e90b4305ec3a16062011a8d2a57ccfc4eae57d545aed3cd807a25b803c9ca28ff5b833db5c61884ea9cbe1467c5bce2089874dadcdbf36a613a1b1c37136d1427779260e294748fb675255e9336f7d67876179fc2ad2499e0c122120f08468d180a1f163e62d843baef90e3786d97eabaa9907de1ef90b516ff1ae83f21c834828fa513e33062d2115b93f6ba659b4083666f7dcb2ef4bb982897b3a5c1d903944b9b7acaba22d928baf3c41f88031f0b165cf63a5ee077e328e08582fe80db3fecf0eba20ccd304759cdeab8295eef4232a6a368d64f81c280d2b29516a5be4d853aa44a68bf8247b14cd0d7b380c328ed7703545832c6d4554d85ea1b24390e2538f3cc3e8ac51fcf3b2fb0336307a9980c80e872c06ef1043fa28ffa6a58a01e18f4f945a8659623d4da2170a6cac3190508e73231a9b4985b1d5642813d6d8f47e00e97476b18df13b23b16109181cffc1124613d90cff3f4c9bbd7ecc53bc5230ba7192290b9e1ffb620945ae4ab87c8703ffbd2f9ec9a27cff00e0633a4e00f4f1e48ebdb9319d04c3a0221808cb36a02e6a41cd4b1f54e9d52338da0ef373d2b5d1f650fd7c96f4b3e5190402be7da3fb02a93e4101213f3be8b671f88e0da01074fd46664597d715d13aa27e48b8a64ee9f67df21d2324d3ae009c8b3696ae5e881e87ee50ed9e0fdda3ac388146f4033df01e2d30ce253739c80c07a107b1c92090ca5157934d49573d207af8be3d2c04cdc0eb3579fac526e25c3fe000a9491c8069c8d0bb955aec806ab9a167ee834e541824bee8c1fb7c57d0f38ac9ff6708a87471a1f04d4a249c63eb9c5e0775cbe356022fb283d3f58a06a3de3bc54ae20f5b4f6aa6a11e17c9e9d10f684e6d3b034a46fbf8e87544829424d121b9b9e2dba82eacfe6503097d7e3ce32deb08fa81d65d92d036f8a6025ec0d80646352f9e5bc3e878e842ab5a419ae3326e15d9c552499c816aa4317ae43bb23996f81bd8906e5429b1442aaadf93df2128e24418b594fe7adba8dcd14f3b01007a7b890b6f4b5586c277833eae023d76e348e654833823590ea10492053d32a2e50e0bd9ebb7708cd9a21fdbbab74890df85d8b175ddc8e1c67328553f3b8d309ffc816b2580933c1a0f329802ed6b4ca7936a095a40cb14482e21a309d016860b4effa9616768d4565a4b1bfa889a3f7d3c9ca475e4f26b9e2f49e2c89804fec1ccdf1354f148b424cc263597b6ec3c3cf5b1570fa07ebb1894ea000edfe959f5fcc0b6f58129d385d1fa7ec056ecb84326e8b8be4549c65f2eecc5fe93d689a8a8ce6478c40a93572a63ab5f9a33de84eab88069f5a521d4af3566c6736b143fb7ab20dcd9c1a397e7aec5ea467b822e798af567a6c595e621a9228a0e4c4becb340cff780542a627f2434463c7fbbf5b679fa27fda78a32fa1140bdb2ce7fce2978085e2d3f6adff23a025d33bf83d6b8b0ab690788be99df2893ac1e113aa5710b33d3a3eb7185dbee3e560a34ea7e2e4256afab90cebc56adf23bbe0cab007e4ab094604a2c79e826d0fdfdfe8c079f8377c8f65f3004cf5a0e049287481cfd30ac7c7fa59e3d1ea40eb28823e7a5f4982cb0ef09934bf01597e9954d012aadb6abfe198a46cb369d7299c03c44271d7bb45859539082bbf3f0ee4a46a59bb54c12fc03f473cbbf7a6eb026f7901a898cd55bc905fe0d95da284a301e237c9dc9b5558fadc929abfebea43e547ee466d9b2121509ce1a06bd589cd349bd2241dab32cc218c5f559d985e2bd2850ed1269fa294431814dc10eecc3ffe7ac7067bfe1144ceff2c5b1cfe354ae02e4f5af07a544486906ab28d69ddffbb6016ccc4f3ab897a06b6cb4d2a354686dff1bef3788db4efcbc1b4a6fc29280512a01ae172930a6dc13ab9588e99759e18209d57a6840c2e33eaffb0de57c0b94798faa44065eaf3d6d7cbfa2ccf47cc0890b03f13d78e4f4fac6447e915659958669438184c882158a80434c9ca3c1c7ab400e9cd5dd992ea37223042d703163011c9942ceb0ea1dbae2007a8f693181b5591ebe5086be2b7b0d8859a98d09e8437db0c3f7aed51495e0d2e14cd8a157c9694f533b3c93dbab536cb65122309ed74a6163be762377e10f07cd494e4158d4801d4276eb06c5470a3616e6492d8e5385b12e306c994ad9dfff0ed09d1be15705ddbc8a1f3b0ab825fd27fc22b3d0c9d790f16a41cb20a60f11f01e04e43b83f9ba74cce2ea178ecc0700dfa33818a80dbed8f686910d798cdfc4d5e75bd532c80c36258c8f030b1116a9fb362f22064a448e2bd407371537723934b418bb92ae2672ed0446805a6ac5e6c983466aa076353e370abd7821257d2764213ed976d9946472b16adec2aac274efb186961e4c43c2cc7993b6288a2d28cff7cf4669cab6d3b6f041820e0558fad2df7c698a946a9ea21dfd3febde3c1aae0bd2f9a0d0468e6604e2d9bbdcee329af9d310567f304abe559da10398f36eb840f5b12ead86ff134964fb0bdc922e6afc573841901ac6a8a9834b2e999958b880ce874c1579638209110556d415c9633db8a3f7919995b0726a0421e7fe797e5fef3395ccdca11152f72ebcdf7082f7eb4dc5b015e76576ded1da54518aa5d3d77ee4a5eb45aa3fa33f6d0418d607133bd7d2845dca1691b89c11e024be007b11c39877240fcaa54e4e7ace5658301263e8e5de9d668e07bcb8c16657d96c29d97b0b905423a643513b14dec156a020e635fac510ecd5c8bfeb3c50e81b66e2b7fc77b02d2158390282422b5a9483e1d9f85757ec6d6882c57fa882213b5f7ff00259e1a7cd3ce7990880984944f3e758bf32a0323c9eca2fae83cc3b1cc68128503480abf99ec5144a70240804f17e54f58b150cba5ec697b784f536f8b9627300d44b8a7bf48ce694274880def7ee49fef9c8c5365b0ff4bfad729a7d1b3fdc80bc4cfe3bc62ca314853468fb411894d37d4c07c815b37974a9c0a50d6e98dd9721f32ee6d5e05f5e478c45be34daa4d7ebbc5f5315e0c43f1c46eb309a5fc5122ef36356cf7aed345a0cc709e2f457a3d8bdaaa299a32a80fe3199b3878c670dd8818d6e38db19f770bda62c034fe9c3b13c3d96eef3483e6be0cedcbb1f2c02d290f0c40bb98b7ad826c9f62f4d63562975787202b224b4daa6b1615f85670feb8ba0cb34b01165807cf915f81ae4a5477b084e708c4d443405ad1358e241622c1e5b223e28348af24b2e2686d883fcc714f3d4b737817559c3ee8e3ecaad8c3c4029b247c8b9358322a171a5186e56548c71d8c607b0e3e87f3069a7e652bbed61aecd2e90c6fffdec9fac75567d08f2b5cf65340ddefc20c35814c266a84567174118d6e31e63dce25dcbc99eb2785eb659230cb8e7554f836dc7bb45c639ddb14b3c380b9d5d110b82c6b20ed0a61f8d97bd102fb6f7f850cca9b41ff1dee45d17767caf38ca0e8ef3d73c53aab039862b968708796449cd43ba633d31714de2e2420cd986f953e8602e24595920c0c76ff56abcc03c0e7687c1df1234b98756f023ee4855f608f47ff3c8300be7f769451562ef1232e9d168573ec59ab6950b96dc1ddf99f4c38911a8e7262bf0ddc7c3ba40e8d90a3c391fcd3715a3218d8e09970ee1fed121412b0f3af0276634ada81e579acb9b225fb514e695ee3fcda29fce4d1f850558115f3e685c224dcc5ce97787ffbdfbfb03a552197094c2d8edfd08b609d81694c470c2eab1b36ad794f1430d246fe8174919c505a28c7505f058adda3b7b1880012dfbcfba7c550751d3d3761767b8c76fb8aabcdfa8ecafb97e64384c314121079a0053ce5af689b50c0eab8fcd720dd47b7513c2afc57c281f78e41fe73c090210c541a9b91b4b70bafd1d7a54102fb769130155485a8b36733a5f8c7382376b879d83e417e49435519bc15ad16e554e46523c35d6215d851a39470ef3b3d28255ef3a5b8fd4dbd65a406762d00dd166d993c8b6abb91cdbf9463231cfd9aa4ee66dcebe1b2e63ee151bdfe9ed696efed00528553b3be1f7713d3ba07233a82a6eaaa69c961458b84b93c0eb0c734b230e5c206577fc1a1e759b605c072c03de32d35778218bd12451b5f3d2dbc0ff86e093a7567a5abdb29f977135a0d0ec12ba86ecf526eb376ba3dc30fe0a08baa19c862128aae1c52e4f30815f2a011207566f3e49bb830492853dce51c8539589b493a45463c7b8e0ea4da76b71cc0da6dd995597b3f3f229744e0cbda620db403899906caf2ea9febd1a488ace82ae02f6070035aff66865e799156d44fb928836801279b60520f7664e855fdb5d95e905102cc240f999d90765e00e2cd5f38766f8ac50397eba8617d3a37522ec769d1d10df64633d8766e7872efa0196cdbe588d3a9da68b80d9ff232d61e2863c896ae5a5fab48a9e5c973da446fe8c766133a199c2e4106b80c0c694b65ed5a28b473cad1f503c74804370303ca8428deb01da9bb909c85eb305fd3cb77f05bb663ba10e45c71c20513cdbdb05b72782d64f5eec64466337d8513d7cfd8dda8301f3db5495f27a2a3f4ec78121827c620aab594ddfc998b815ae7a124139edc9dfdc12d00fbdaf6c387c0437d9762d7c4db2166402b630734238fe420db6664bb1e5b9a68954a855916b783a66943511c4105b1786452cf685616310335e17ce3a714b06bf1ec5896c310ab9e0c2e1205e0a21200517184e1116a5d50414356d8cde60c71f36725b1f4a1ae640bac39e88cc9294acb9a258bf35e6ba17465e637e7663956a92f23fb9916c97e3e8c120e7a5d117d485ec5674e97363472120be86a5008accc30ee7b68d7f13ab4ac942217c099c49dce6e559415a36fb62ce8d2605c9fbc5637c1f6901382007eee1de69f733f7e5cf9ef39cb0044e44c5586aef9cd8a2ec1bdb8337b2856de84278a4785cff42f57f9d66832cf965664f524fc686a1e831a3e5493c6dfb389230d4a1d00859b7e28bea94c5dcadf74ba340e92754f6d2729050fda9059dea69f95b1ee33ac0536b1e10581313a34367fb71a84156eeaa9f389fa8b6d98b7b481302d4063e257086e116030294d51742fba6c5951d82fff7a1ba63508a9b8f0e54831ed29d49ffad3d1a5d4d6855b55f0402ad4fbc1497b552486a56366ca43cc081805f4f31b0c9f572c26ce7db1c31b1a6f952864e09abb9b77ca8b56bf25551ffcf8cdc398af8f7127c18482901d699992ae7aa942398de8d6a7e6ce3f85f0aee70dc4e44a91770606ce9087b76f1364f9f1acce2085b05a1d1a184b904779734ba674dcc835c2d894a2a1f23f90f0e78176b2b905272c120b123c9d7a046f85dc558c4b42cfdeb8845f612461f1be7765a496e5d7f06129731ac9e6b0cc6e106d93823d24f2eb564807daed9f3f4a7d2bc8d21f1e5b54aea4013740486bf8505fe6942db386b47b35ea4c96b92495b5d52861b60e95af11901d985ee8670c98fb4ad7fc5539a862f9bf8fb1fc1d14714e299a4384176d00de96d9588d413c7ec12b28b95f5b2bd8d86af0b7cd314735aa760513e4e43c1601972066bc875fb04074d44b8df3239446ebc1b36b794f7d9d4618e937d654006133296ee6990c8f2907c9e351331912eb3abb18957c0447749764e88800080b83f65c79d9a0a90408f2c71b3a10f3f68e56f9e0cbf37a276452317a665095ab4ffa01bff15ca9532541e2621940646f5cff8f85dcc04b4291bc6d697c191c349fb049a79f6fe0c69c2118a6458e736f021074466878c1afe14ce66949df1f3720e45c193dec85fc1a8a0412696329cdbd9cecc9af50300d5980d56377e4adc80cae53cad46e58bc1a472a7161d7c6fdb49ac3928b3ce847d4c24d5ebc5167f448f3f6c6952980faa92ec1dd709c618e8f8fdf6ab45649a396829c74bc73e5d11e8d0a69c1e58b267cf336e2e09b1a2112ebc3ecab7b053679a3488383256a886d72c9e22e9556292ce292d06fee50d2ee781d7e8f41116ebb111615fbd0ca7c3852f5e6165e190d16fb3bafa138cdf9e637c2307321d66b89471e0c9fea86e8aa035a47811b0e42177cee7e7c564c666c056f46eb124487b84227ec050caf8d8205030118e83a76ec0b9201343b64eba14c252d23b93127c5ce222563bd7c08aa0dbb9dbb9b31130df6acc1a89be50f66d49502dc6593b63fed95fa6feaf875c28b13355ade3eb2cc31d4ea277657fb1d3b6e0b9c744745ed2e784723a65a344af2a2e831901bb91539c63413047b14d176c2a88b3dd51cf12ede8a2a5386ea9db0689e71570979ef068d8ede03b97115d1c68e50d93fe3f45fe0f7a48044f6c08f8e8cb24cd65b85402b6d37ae69025004f4c6e2d4fe8910990cde2687bf0677a11621c8c625a8ff7b479728c6c5e48396048c2fe8e6dcd868fbff2dc5f5100c60c33bd45f33eed54ce5b9615b20cb2810b0cee12dcda283a43473ad4eefd1da06a94104aba71cfd1b65e01c08fcf27d6bdc0fe485c4d75eb616c74a135593dc3f38e5ceb17ec97b138e635febbf9db6f11e3bd0d0c898e3ca152c803abfe6ff5887738c6114a093f0bb47d8b25a354e8dbda55c1fa521bee62cef91458db10f67351cf552e5a244e76300d5b6ceb2577aa43663398daada0e99b5a9427a022b8f874b02ecc78da93db06bc8f4d2ad70ecc9cd5b8d2c5e675ecce512499a881aa3094a2bda4a1f38a679fa5b42a32f4faa8de53a4132b027c99cea81abb69ccc28bdb2feb110eab1cddd2de101cd3a48e69d162d1c5bc3bdb4c51f8aa2e4ff85b949bbdd4fd7921fa63acbc74a68ef5269c2e35f2115b5cc151f60f4f82ef37315110c11f393142957b2ed601d87633908374d827ef0fa4565e81620ab6ad4373ff6fa4e249664356079210b57427135639151dfb2bbf35df1432ef0ebb2166eb38f211e4a94473f719e3a6cb99d55ecf404aed181b66af47d31e949b610a34445a855b0e2169fcd7c97f7fca5be6999507c87bd98f7d7f42fefbd599b046af6529a60c87d50cbe74f5d674dde0eeacd9ad862c9482363e61b8ae5659c739cc9a57d4d177324609330bce3739b1e0171e7a6d1cd4a52ee4f1d90fd70600b2ead1d726d2c775d4826546725419e0a5bf921cf197dc175752d0605eea13cedcd7d0a3396829a89aa09b2f9745df7835e7f6a879b8a577769758953ad13c87389e271839d9f07886cd11835b6e5f485b54d418f168ad42807b715160044bbcf115315f5e1a96d112cdd173dd01950cb277390ced8648fb39da7e3727352736353c079c045c203d636f85a90fe716e91cf29f562ef5165352898404f1df4aa76a10ed9c86363d12686b80cdc4714bd16b6d946f12d8f0f877823765983d20eba4af59ae0dc83474207bc551cbb1ce62e3d6a0be1111aa666d9911c08c1c24d272a98c86cdc3ecd063f02d795d9e8f1fc140a4942afb7ab2463fa93390d7f19b3e55273d4b2861ad1fb51827455c35362b28c25bfee2b2108a0fe94d9171558d50a8df29affe92a483ba54ead712343e54fbbd8eb89db309b33c0b22a08ca549d712ff8ba3f286023855cfc1250c9e11dae669e49becc96a3a744a6bbbc989bb9848f7b9a3b752281da9822ce90a1ff31a9cabe14c02d1efbd7378a3f78f9b72498a28199ac0d849a22589c725f92db98062341854dd8cb7fe2557a7af10a277f2b54dbf71be698c8377de2df4cdc7f4f028abd0965214f8daa247cf7b7bba17dff8973fd41a6b4ba5ca50992cca6f06d65f0791da064a002b79da851cb15415a04b50a652cb2cd4291c38114ce9c2d687ecc92689fcc6cc25fa1b3b977645a1d05be81d6859e3f7f5eaa000964f81ccc6dd3e0293538b630d7d41dc60d2e51c4cd74345121da1bb72848f621f84110b8a317871125fa420fef2ab109456a1935cbf1bd5238e8e6d1d2a99eeb055bae2e85ff2a31dbc53264920e8d51632b78459b6ab116dee44f639a97d43334ec3707376676ef4b3e49a074902574d4e29a70d892f2867d92035ea66489f184ff4d17bf900d2a866ad572e821d12afaa73741204bedff7c89f42df3b41dc421fa2361f3a1f415fb2fe099d66164c00214226f7f1ce15b237fd9060a62a791a6e2177431038c0234f7c1a7a2d4163633563fbe4b9bbf03cea10251e3acc4d6a34e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
