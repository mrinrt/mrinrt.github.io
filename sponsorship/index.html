<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d8525896b326f4ce0dafbb2eb3b31e55571547c2f7c272d2bceef1ebee2b550deb25265020cef87bd138643db1a27e064a3370709bc0ba091ede9f6a663e4a137476710b8af5b4dee736ff52baa9c0832a3d8d36b8c85187daf07120e781b9a5bbdf319ac15ea371565917ac66a7eef5a0ef6873b868cdd64da1b4dfd6351cd0cf86661be51a379c2985393432fbf9b903adbe0b86c06d18c809d47cd4a67ee78268ac7e42c74865d6ffb29682d80a91476002b5850cf9973b2b61c90e11f5575a6bd150b61959fe2ee080a7a77309f01d866969906cd38287d2b88dc07d8beaf654ea42f962ef17724f028957542f0aae94ff1e9460bcd31217aa5b9f94b608b033734763322247b0722d5adf1c44d25667e47f5d7087979445cfc7c7aea59766b4e484cb8a30792ceccaaa5ef5fd78ffd860f73aab94e3a156a01a736e866ef81e122df37790d90492fbc3178048cf9643bbf178312962c9b2ae877ae73b9f24e78d4d4bef02aa8e729fe48c654bbf1288ebdb6f26d127016bde00f6b835886f310d3cec10b90e9e1627cec0bad92b516ac1f23a919c263ab461935204c55eca57b85dc9e8beb13881e53886dda6f2d194b73b37a2fdcf862fc1d564a7d23320cde0be13a7ea45651c51d49f31d7e18b6369e0d8b1ead6c95a777cc4f58f702d8abdaa09e59d925576fa19e9912ee1da725486b30546a6495d0fcf015a28388fae13315de76f5eca90fedc31a9e33ca7fc80b5a95faf4dbc666e59b7d849336ffd742a8fc01da1ac1da6166c1d280b2daf67c6d1bcf061748ef4b59f18f6eda320a5fb6d948955c883c28803b93e34b9a1218b74bcce4c3ca9c1160bc62920891a190d3f7669c7710fcd16b304ba248c56eb82b9669451f9030c52e61c9af832bb403ddfec56dd067a602ab39cc3a82edb9d0f965f19010e154967bec71a4d9479860122e43b5b5d9efa7cfeee3b21bb9fbd72c18778739ae090535ffbf58f9f07ec40f653a74e4eda5c8b93ff9602cae90fb1e1c07420ac09b704f5938a6964104915d1b68e9f1ec6b11500237eb16bddf680526fd3def19e1f0bde6771ab94b0e22a04635d605382323a49dacb3843f42ce5890e855e861707fd12378c7b82256140be9e486d8589e80f7c890f777432ff241ae06b790b945b9c0d8db3f3ce8e3568486152db96e10f9ff1ec0c135be24c1717655bc4e7c8ca183835c10f4230ae894e47c741a9ab394e7139080695b8f87d1c8d5a0868506a656978977d50a8132f8cc24ee2b71bd0de434df2b7fe9cfc7ad9f57b03cd5dea6d9efc685e20540b83fdae4f812a86f0fecab933098498f2a4cc0891d5fde94111c65d04f1f25d8557173418bbca4417a2cffdad2f1e370985e5973b9b78e1dba3dad71c5721919f2b6f9487a3a9ef94d9c92417484d2a594c01a314c978120460ba6938c325b087e62a091c1e7b1f28370c36317c944c10f5b0dae03cd362fdb48ff0037716350eb1569873dc57c23984f9b96052bbf3b7ab9f3eacedd2da579de896f6ddef2d93b327bc4c57321922fe67a5fa6f10585fc9e941ebb24d6ff628b7338af019cb39bf627abc6790face2692280f5053be9fbd1804ea85d089e6b6c600c3c780a6576d9bad73f6ac788cde54de5b04796da9377e01203fba53f031672ff9847729eefa691b6aa8f5bf7c18fdbfee39f5d61f24699ffb43423bce7a3036123105d6d5e77dc3ebd34761958362babc8ac9fe44eab15cbbe24c62b1a597d5b3d77c919114059c19cc2e462315014dd343a4db93b2c50b457222c6e6049be4d48ccdc7e1860af7b48c29c70959231578ccacf021293308bce4763de6962eec28ad6bae667998bdc28812ff68808497079afdd17672dce68134a1c0cee6468983b8c618fda774f996b862eecbe848050051ca43df4714f930db597a5eec007e5d27a5bd72df856adbcfa5d70036c9c28bb39b06ed1507b9d5d53646e1cff7f0f16f6f664229aee87a6e2e03fc9fc828355923a0e9b3d2a59b057d818ec11f9f62c18fd02485765bb4544a38050f1d7a7db72e047a90c8fd37f68265f675ecbdf3d1a206ae9e1d9bf667b8c53ea3751781cdd55fd6ee724d5a2bfe7c8f6703f3fc563e5f10b923847ead8ae8af446cab946dc4cf084d33a1b385dfe5632872972dba4721fea8a6c53fcec48478251f51955060813f3af557972fdcaaf8343fc9265672aa082e8511b2bffa9168127c6f7396f58e7d450f643d0539d0a0b4d8c1ee103e0552999d8175b02518877b89cf4519468ba442bb915f151283c1e5cafdc8bf7d9705fb3b0e69399ba39e3b96aeda3f5cb113ea6bf36c53552e80aa19b236690559ec05713dba1404aba6964112ec7706b023af7e738f5b3ec1f6dad774c17531d9ef0211ff92164c581182fff17870ac012b26def30f9e2072bf1d13e9874d4458fb36ba0af36e6a872337bdcd301fbe1b5a05cf1b11a0a0b80667ef5beb6f0c778dd2a458ab4302af0276a0647e7a0730dfd04e08d722b0b036ae68532f813beb7f331dfcf60006c5721ce814bf052b870689d47151f82d8641928741de79c97a3ec4ff8ef3ec5bf0e4798f6a3dbe33d3418d4d58bce40c96d1706a3201555e86e24aec4fc5b2f2505f23cf22fb088ece7f764657d797288491a3ef5d9418687a14d2d77605e1b9b88ad6b4c00c69006f2c2ae365937af745da7275335cb8838d470a236953c27d3bd8a76f3ce19f409c386ded3dcd8b29e51c098d8583aa6f45da7803fad0d5b9a0103ed92a3c442441ad0891b517d98e3e2e3305b5f69eb63b8375413cf2ab0c61700ccce1e5ae60d6b3781e477030babee231a182100a0d34f84995498f9ad4e00e8de95cedb4d5143f69b2d0ce35183112392bb2bb7a21310a1a6be306d8687f0088242479d6327ce4d6c5bff9d5a009dab859a49cdef87ccd81943f18731ac43a6322e48010b8c934e521bcd8c1bde79c5cbaed81128580f1249eb807a82069d2fd1c783d5be84c92d57de7f19d38b78d113484365df31c5c9561be60953dfaeb35347a4b40b15cb5fa18e0981f9acf663aca4cf78fee4aaed74937f458b45563ad03a298f0cf164474197a9e5fe69cf04fc38e7d3b114a3890e1b441544900883aa0f79d72814a55edaa67ecd631f4083463e5f4772202db010409931c2098230d39fb93be5941dc8bd4ea0972dade91ca11ebe57110f9912cfe3fca0f50f8c2d68e25d63c0ab696542b0e25b09038a63c8dab88758082e5a4bb1451770525648322e9e0d7c3fbdf9e9dcdc141b5a1596e97bad34f5cc07c007f9800ad978ac848ba8ba0136b047d9739b65c45efbf771df404c2946f7eff3e6c639a77b1bdb0b0cc8ad0fbd0d966f26e7c0c6b0e279827fa31a91b4c0a03011c612532f4114e19e9a86ce7d05c0b6fa72887fc7be60da18649089d80f68a50b281733c0a7782096bf5f318c1c777529eb41f592ebc17424629cda2d5fb6c650afbdc4d07af42fafa0885d1478428fb57918c95034931ba5c95cb20f42052c08f713ebef708042d40de671db6842997e1f918e460406cebe84e94af3a3c27154b4b8f32966e003777cf4600161891dd3b638cd8123dc2b51ba2da5c9c7a383db9790741680be630e6ee12a5682fd994f6fc3bafc86b701a43a51534f27ecf3852e48661e723d7776c44b8ccc9b8fa9c2eec7400ad5e1b1af2d17ce4e705480a9909eed35b9d17fe761c455d9bca8160334ba4f52072f52b1157c25ed12b6e0ff3f48f7cfc4ae5ffd9965dd8901dd4728d13189e8aea6fc43fc515c3a339e5db1c182eca4a21271962eba4fc6a97876f29de0186c24a66be557d98b9f4895c5d473fe65600294f6b3e36708592ecfbed8a86938024e0820bddbb03db802a77e6323b251efc57b006c35c8a8e01e15acb94e49b6c89685104379381bba8b2df7ef487f84d58aacad1ddad6811ee5f05dbbe80b224a94d43040885f04ea8b9fae2187531493731b0dbcfb1c35929308c41773c8cc33deb7c39f46f08d71cff763f346f1233380b306c1671a557c5e2fc42b949e22902fd1f5e82ee349f58039ecc6d2f799d729006f5aa5a9447a9d6becbcd8314b7d2aefd262108528589246462bff29c424d5ff0ce90db19243fb082076233aad4f18f0d290c3b3013a1617ac670f3f9906b347736a2501b54f82f9c25960df3707729c36b287541c07cc6534d507b4d097bd004812e3ca4cfb2f093b269ef8290f798a47e652733df6e03820381451e9b8d77b528f1563d6c643650a84231f1db89f4ca4346ddc981935b223fa6f63f088ce30854dcf5346c0ebead2ddf33dc048b6008b4dde615316e7ddcc12741f16285fc9053d3975c5588823a457244bfd69678a95f191f6d7f69c8d24093f0987b5b9cdd3c8c55f73a8a60b85f7e27394a3720099add6917faea2a5adcda6341ddb3da573322e861bef70177a843b52d98a235ee8d25e830a634ce95f023505194c3a4eee53535686301cda1d82484c1e01789fa48b53dcb78787afa3d630d09ab7082e985ee0596016d0e58e83f54a2e8931a8e48755b182b793efd75e546c4354956780a61449a4f330a1335ba653b30f6649a6f1c454b4dc1fb0b338f4c4529e930c535f4a20edd28ade4bbe1e4a305592c84b6d90231f69b736d80d554cdacc8b774aade0cff1e296c423e7614a6a7b0dbf3e05f1f26c2bc9fcab9beea087d03b8591678d47c80d77213dda808bd1534178f7bd4b0f925f17063020c9f175a4c895a7b028fab5505bfb8aa23f712250a0393f8fd450c7799cd68adee0ff875011dab70cd77b715f4248d47e1351d74708910e417417bd1f87ed0b315d80d98c7d0bdcda5f69daaff10ece22fb7ef19ef6ced54b7ef474bb84232f9035e45e64fded313945dc6e3775321ee7a88d7f3a140674863c5754a40bbd539a1accffbb0b94b2388b6a040fe13e4e6242d9e772d4644523692f671de269ee790354952902afef47e8e3a66004fa3671d243acd294c86968d63db27d7f4ccc91bca12810d41afe16c8d7f886d5c2e29899bd58e8190a811fe2847f0bb0c4570fab2aa8ee48bb3873045342fbc71b78221a0863a744671f81888496ebe60d5609dda312f8cf6877f9c655837ba839194472ca92e591d4154aacf437c1197fb23dc83fd06011edddf7e3dfa73fc5a3c0f8de8d2337c547bb668323dd2eae911705067bac967ae0241bff543d4d38c1678a8fa6f3d4860aac70491bcd366cebbf56982b89919748dd15c099b0f50a0bd7383ae78f530f36466285fc4cae7d6acaf27e54c9557f2d1ca3a90d3d36c5330b7ebe3adc102295339ec2536bf94f73810669bbff97bca76206986ce2b27e7e84407c3b91bf540b66098467f6ffe4339fb242c8fba9e8688310ce3c5af43410b8d4ca8462c5c37fb7f2f3f04f70b1c4d36fea2fab63a54e649eb9f54ede4b5857368b0f31951b669185d00abeda2718e7257ce90e5933a16e9af7e134672678fa54e040ad5bf04632d093e0171eb27b66c7a6e73e49baa7c1cbb587e7927de21b548fdf5286fddbd941d23c43185eb29cb0a05bee8a3892c7d084676851f5301ed4257bb508e4ec5c1e80f98dbe785110653bfe9452aed0d16ac044bcd588370bd8fc015c01b87856405a9221789dd0d052a9fa36fffe3657fd58238cd85f754d5628443e66e6dafb3f5eab488de8a947ffaf8cd50a99955e87ad5587d8d263942d964328efd0f9d256763b6ac070d903aa55243bbc67793f252047d35d3c2c6ce1c662338a77ea3ecbbb86f58e07cd86d62866d846faaf0a73c0593d1a00ba80051d128268a877edbd3abb836bf9a36ad270d9ace11cd0c7b6693619ea3b97e64bf41b215174370fa62a7bdc173c03a4739009e4ebb5ed89fb77adad1fdd188c4686c090d700f9e6d6d7a46fe9f4b4673d17f5981c48e093bb61c2e4920c23131e58f726d473cb554b668e9ce4d58ca491120d06e695fd621af3866b10bb504abb646e73a70da9ef775a98eabc022423a53ed78d1a081d4d6c6b8f74c13276421e73d87e933cd588dbd9a318366e03cbe6f8f42600b85693dd90aae81e47e5ff3df26b64d3e640fbcbdda0b4b8dd3bfbd34a931568d752110bf9b59bb47bee3746ed6236e8a564a7201bbb3cf9b1a67948c166a74f81e73e14b5edc4cf739b8476b8fe8826a8d5dbe50dadf3adb8048bc2147c64c72d99e5a1de8908f1433e6de1fd5d524324ec9b01ba582e8b072153c3519466d7ce5f80ab7272f8610e2ecf72db3a2fdf0204d9ed6e900fbae8be10ee21292af7fab7ab4e1a739c6b2260e1bdf16aae61d751e46883ff383acd077cf012702069a4cb8f256ca2a443edb8425fc7bb285436acda74dfb56ee6d9e2a875bf7846fbc23cf30303f77b6f9e7614dd46ca3272278565079d1a708d9aa3c47e2c40e99bccde88e4c582d93d1debfc27136117a9a36e1266236ea0aa9549c173c6d083b12000988fb529eec8f9c8ca228d84d4c96434c5ccf835bad3ce4335ec298702f8cf040de3ca85cbdc75a12f9dab8faa2fe49651c3a6bd6acb2778d1654349ed7c70786d42d6480a5097e4a04a934b5011bd9d6a46dbfb9ad6b0f09a7753b3f92cdb3ff73c5ee5ea8549902d51bd9d029a480eb9f3a08d396b8116ea645f896c99ce64036c48cfe3cf0aef5753a8a0e9e59df446fbf89d943cb1364ce80c733fcf96d98d759014a85036e66509ae8a1c66423dbf3f1cb80d818ba9c340b94ff24737e915fbba52a33759e81590596ad96b4de8692821070306092600b3ea64ce37f9fd1556d612367f3c7770760395fd4d992f318216c50d7e6944d51644971a5f31a651c4c912654f8bff37856afc7754dce9eb3fdec38a848b093cc2c911ec1569387c8a06e834ac5ef08a4bf5fc238ef0a993b89853b2fe51644c8a055b21c6ffd9c1af74529fa7fd3031177d3805d939b64cbe5a306c9b96903c8e814057466bc1f89b1334eacff378122a88d346a22ddedff6591a891dd520b78fde1762e85d6b1a08504050b3d6d72066130671b3c7f4ba3bec3e61cdf3994d146f89a36ad81ca86fe59337fc1a31962d27e58a17487985d2d8b95243c768004c3cee437a9ab3b8750cb94178d29e815c29eb49626e836402f08e0880f26210b5a977bb02a065714c9ea9573ced239edbd6ccb4d67cb3027ba88a61be49db0eeadea8c48a251655cfa0a43e964c58ad8a012518ee6bcdb9ff45d842f9f04f2b733fcd1ca419ea6716222b2a404ef62ef07a624af09d32b6144caedd1975d29663d10e47a8579c43cf4b1cf9ce6427a4c1937a2831de2c2abc4bbcc276d11d0cedb10d3b09be3a196341582956dfdc98dabad270006df9c8d9eddd8e6035eabf8c795604a48495e24a2b41b9aa3e38b88656ab27626f4f44b020cd3875a52921f08b68aed006973c37d790434c0d496026fcea3d15a676fb5483a9fff91d2501a65095230224488c6ef4dfc801621181e3a108e23eefa7533f490df7cb566b9251225d07d256ac5ee691dcd13378f4848c07757c7b919d618fb96eb811a0016ba0c448929850eb29268f6186a34afc1f1fb83b634150ee931dca779ab3efc54de9725dbd3c99d512f454028b5a1155f5f7ccfa4e79aab7732538d685738cb8df0b2d8abdc9c542d2569eb6cb385cddc4fb9a1da35d938a24338b30550e4dfa743e50f8d59c7eae9ad578e86d0184a18f819c750ee4d628b075820fc813ac499ea2c24a87d907e7de6ae1da8b8ca946d54f2d123a2a614620e0c63fcf79879e58665fa1943cdc1db706a1cabd6c69110bbb54d5ff586fd3b3b404e5f8977574906b1d482c66a8d4f4d1eebc42fbf7d201ef731ffa1f4cb1082edd95130ccfea7503bc5b4c867f11bf3209fb7209afb8e44e276d92628e666c6758ee9be42af7cf9de63dd7dd6e42d85d4d7d510260463b8f8b0c01b37704697e6fa4b39cc6a7fdf72b1fc9a67faf2505e038ef3c31c27ef1efe3136efe77b77d9ed93ebba385a1a45d598534cddce7239624524a52549cfdc020841b3a35882588a4d5b93f21575c4a0de5d983a5e21177698db3dd0014eb4de185d4d1c7db7723ab135748636d407fcd72d2febfc0473e70e128ab804dc1d8bc4d6510aef010b0b6819de16bdb292f8a1fe27ed08b5a0be8abd1f5d39847e7a49bbc365f9ab58afadb7cbcbef5541c6bb532ce1305818877c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
