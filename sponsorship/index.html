<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3dd4c29e01816665e90095375513d703f77d1187286dd1fed01ba5cdd48b911e9da5d1619417cfb588a654e4dd52936a09914f9fee7aa08c9de24107fc870794de73dd930b5d71e9ac699629fd1fba199296e0fef833073108cc2589732c2b989bb45302704d0502d3eb4e36eee2cba6278895debd4e67e1a369a46e2787f916a1974ca5e16f1e4ed645c3444f64726eb7ab663a982033e4f905767898fdbdc5ce45e0a21c6be34a65be228c61a7da8582e67ae8901f764215b618de1296ad5221db3c1f5b3b2a4f25bb11998b59d728b9bb367a50e201120301360cd4fc796b4693e3e43c0f0241b0d998fc9e739684bad966e4b6e873974b2302c229ba4cb4b8871c37ea302a2fbcf437510c73db0c1dea2d35508616cdf6e182f0f0120b10c4219031bf7477896a1f8e02e54505f30a95e216563a1886fe5f5222526ed1b2bef4b6aede6e8f56594ff52187578a32b377782ab528e601f9ca31b4991721cbb560be89742c72b8446975bdd145e90427fe8af61ce088e19093c2a14115003a5b2fc5acb406ae36c0d1afcd3f9d3f6c3f3a156d5051de93de384824bc5f7702ec4226699cddd1c54511f5155bf9a72e1d480d2bd7281a8769b73f8187804716f2c9a53c929f8056bb9301b3e19f8ecd0b71c9efc9c8b74f9e9ba65c147ffa8a8676a250c1791384509af2285e5c2b00593bdf628e34237b5008070bc36c40b6cf7131a902d99482f47eed3fa4a12ad6f3e96dad72498ec1debd40f938f780da0ac05395a6f11063d69a5620a4f26febc404b5f2bb66dc01ef215b17c105d1a254aa4f43d7e44806c333c266bb2f744c72da57f7731fa798eba93ce5b98d557baacf005242b5e50f2fab2280e4ad3a2c406a94380e8f61a3e7c10d7910df9852ff745920c6be94e06e41c7de97f79c4effed3836c47f0f2cd5bedc4c4339b4a975bbf149d41b600ee30b798b24858a7916128278be899d212752426ae6d63629671778aff0a27bd42f1a9505060c3aa23f58246e811162136c5174d351a5a9c721bab617d1690de0f761a262ba8f97a9dcb12cdea88fa2714ca4b615795bbb49070f201f5e12e4e64e5f1eb256787a1b44b6857ad58ea1fcbb8f1edee60fd2497f8be188fd462b87b874a18bffd002cfe6ef7a17d21743a726575eafd24776b633a03ae136b6120ebb6c00009961e4d78c5d42a7fbb02c13fd7ce8befe51c9f70b228ea7db3add780d6176004fe133a37af737a7ad33f45c81aff1e65121a50f5da1ed7fd79b949a58c4b2233061c0b2cf7c7e1cb4ae73e605554c1fc35a99d1422fe81eebbb9bf352af943680eff93477abedb9b9314925f58f42f7ca423feb2db5b0d7da5d45d79cf12f3cad46ec03fa34c27fcc30ee96bfd5d2ee6841cc368ab2ccb99aaccbcaeb0c5fa511766493ec99fdf78c3fe972635eef5b09c3bd3deb111760f018755aa5df921153a60459ebe1176e34f12c817c3530cb20e91f60c4d3e187c3d4a84b5c843ab19904b0046dea3fffba34b20c0b93da9975ae38d96104c8973542e87ede71a33319f2483c40dc9f5461874e1f5ac16b33a639dbdd1bf6e30ec3728eb9c958b61852a3d6fe9189552cd8c2ac1bbaa1eb251cc0010ee2c5c99244c9fcc1b480953b9d0a4831e274250f4a844359f56ed3d6a68c4005fdda135dc642e7b64c1e69a854a072446fb1423a70d59c35cf3dd6501e67793f76ab910553dacab7cbf535007a8310ca37487274925dc83739db9d79b58b2f4b0c141b610a86848a0a52325768dcece5a7ee29673ab6e418963b340c6e11108c4f1248c657b56c0474807f8c78b799a4187a229eefe099ae17ba94213dba72481ddf0753fa7d002fd42a671c6a12bc0919b35bec85313096ffc5ae4ac4af51609219e6b4cb762bf46d6c2363abd329bde0d5f809276f5bdfc93577dc92f7c3f7e7146ef4ecb3918965bf218194c445fbe2e6bb860ddac5cae98e1ca8f553ca6c6ee3d5588e7faeecc6d22ceb8295528ef7d57c19de9343092d66fc36687112fbd3dd1d96a85d31d3c9e4b45291feaa546656f1fb2688f415645c74e1d4796938e3cf481c61e8804f29bc8d655e5909136d03b960d2cacb9658a6d41e75e681488e15ab1f44e32a5c2e6c4e98c83d60054acb7a182cc59b3a03f49583000454d3a1ad48e5ea4cd1c201e5d3194618294f90820483228c445c5c16db46806461ecf671953a1162d9918d8c85d32f75174c6be157f79a49fdc7b5623bc58ea9b8589c51928cc81f03aaa314a10f0bf8b0165b62cba5189a35e0bf30f2002c718f2485b246167cda2680dd12dee1630f82462a106bcf86f460967fe67ef42ebb29e66c83397c5234281e1e4a70e80c44f9d2a7965c181ce510f0fa944b0e4da0addc0c0bf05b6f99967d8da170bfc51426f82fbd7528b92a722528b26df7c59dc751ae08e1d27b8b07e9b667ee9238c8b3a1200b64c10cc4571ba37d14a083a41bbf40c75127f8416f00db470ec6f27f5232c3f3eb0727fee06fc7012edeba70dd5aa3df38f2ecc59facd057632838a2e76712fc4600190415a2f6f7f81732340a23e70e4d8e52329db30d8091f249339eb5851d2589c6fb58973b86918a0d94e34975b98857c12e12801fa6c9da1e937888051b72ff7b86211d3918670e5170eccc989803d1ed9de04f1c07711ce63e365a67dceb5addafddb26316200af6efa51dce0a50953aa5c73f50ff452bb7a62b4f8a6617d838002abd5175925030d1181a8bd75fe4c2ec9d67e0a1e7f6a59a3f887a0ce561fb0985e75ed5e13afd7aba9fd8e6dd9c8abd0a201f98547c0a109f99b55cb622aee3f307ee3ab42a7cf31476aca04d16b98d39ee065bbc78d1f7eaa572f58801b928195202072fc4b2fc15821ac9d5dc667abb35408cf9b80f1779bcf882badb05f73c173b699057abfcf9120740b252f18534237d04f9c312ad314dea27433f701bf83e6161dc093602c2dbb574ed977e0f5b9b4f2cdcb8d5e61a2fa84c87ed7e9aa636381a95b2e48eeed966b5276ad8a9c67dbcd65d50593cf292befc818d85f66e5ff5655061938b5705d9d7f87f7261a16620bc55f543d7ce47d86cd11f72893863647d220529ba003a9bc0d0016bbf2b3bed451c340fa339298193110ad54eecd25bc14f5c45b32260668dcd0e8c8e7b5d0b54496fde666efd842a1039abe8b82758dde417038956673ef0b2624f771d888a889a977578f12161d500d8b364edd18913139dfd0981fad9f42e3fb92c739dc79639e7fd7694a15f17e55910af557bdf722a76c98fd9abf05b679b00880b9b5715b671ee2bf12edd7bbe10346ddddc167c5d390d1dc371cbb7048786045ea070141d8d623de90185f88231455fa4f209e638bf7cba443ea5ed1071bc79c69c7cb87a0167e7a36d9df2e6dd22764b3195165503e2acc88093dd92bb36e4ae8ec534cf0505497b5adcf3f9dcca2e312d07833fe68f5d7af9e415ba0e67ecae26143f02288bef003bd746721e5b0f279957cdcfc255f6e0b8a2bbb88f0695c3537c0249e8f8a9dfa495977ef53b27451340946a4217d2e4e71b53cf2385b068dc1bda693c610e006c271b5b56c2aef35c5df8a8482b7950917437bc60f0377d29f1f2daadedc70dc6edbf0b0765780d481493896f08996e90fcacbf5a9728f46aa58d06f116ade79901c258b4d1ea5e84d6213b42fa76a15768c0aef12613ac3fd192fcebf363234144d62d3369a7a387fcd0f08f460adb56a43d02ca9efcceb9192c3be3071e1d0f8b4341071123f22932b0ef43e3c049a8bb842a41973ef209c8885c2964a7634ff108b5322763ce85ffbfa5637aa83d787cabe25a88fe9e1f0daf6cc88a812e19c33c63f3dd0955c59c783bc58f9aa0380716e68a585437939610ef88848c63fd26f37d42a9e12fe253f4d2491406cfb87a43b189bd892e6d35cbd9c8038324917d172e924096ee52d422053e0dde4c495307779a6dd25c89b77c289e97117e20b4e6b794b9d89a2d180ffdd4b5186349f4331b4df6066caaba32514de071d8454354c96b2de521b24e9f87d2da6ca629e6018ecc1da4b11c63bff58baac8b41144d20a5d58ad72e018b5ef0c1f722f4d2bb783243e21e3fb44c3f3386cfe34392110411e921c9ac0e37ce6ff80859b5137a31caedf72e260f530cbd654f6fce7857c406f18880630745d31a3bb5ab322d9f1b2327ede2adb804e81abc0432ed6aa2ac33895ac6813184a97b2abf15959d4c369159e9f00c6f762e231b6a098f36d302b27be2cc96635797ba6566b7243f21b87ac2021fa6d8ee526ce1c96b8bc1edaed4ccdec7385600d95f8d700991995cfb999a4933dd2698fa8116894e112a98da8abda30e38dd26f7bf80846fb1414a4b73097d53d85ac826742a617505735cd459374ef539e036d2ec946316f2a62004fceb466e80663c63b37f8ae33caea2c14bdff8b9e21aa3bed587930649d4db636e2599169446e85b9df0e915deace3b870af3c682e93e4ca1d0d7f9bc2a3ce20268d49a9ccff33e2d50bd58710113436b43ce6118a0ca3f0dc97124ab4a47ec26d7f14cc2d6582da8fdefcd61c589e38abcbb3f6d4d3b4923ae772806bec62e9eccf2d2594adfea4f5a7e7283a5a0bbc5ec7fcc52e1083ae8fbd9eb9b1eda2c45879a1cb8243b08edb117bfa7009d549d5bc30ff66a0b83fa532c32e45f305a90de71c2e84d885f150ab2c1360b80fed0fd20bb75ed7dcd56f52396fe1bbe96e7728cf24750b6c0a2655d1c1e7a5d727449aa22c7ec7eb15b9f2a5c0c7099a7ff79834de5744d9d54f9d870c3ed55107ff140aeb13edf1e845d9005efb14d35b6a54a77f9b57ee680e3bdb1cf67fa28801f9ae392400614679f1ef0e6c390aa2aa23d9d525444599106f9719796c0671b510824ed0e22d824da39b2d7ec04ddfce2f01fd9117e456969ac2d90278a1e5ca6774247b3563b0a971948f94991a92647db3425e5b93ff6a051023ebbab0cdd33cfc220f34131bc548cbd820c6d5914b637bfcbbe64d60d63f9f27ce5ff1517db4bd9cb011e6276ea5eb6b81c1c5f638df9befb0e7475316d1bf7fc2fab3bb8213368fbedfd7ccd50c27de51a945c07c82793d4785bdbb7fcd48600faef5e2fb4d015fb1854876cfe516f5263091a637e5ec51ba87e86daad78af73ac905b0db85503cd1aaa80b6e29a2e12eaad5ff9f9f94b3a06589d528e0776f3aaa88fc05264260abd21eef18aea45fdd8e22d009191e804f2bb049e93c17da649c88280aa317cd2f7ea7458a2c4b59b8ba694c7cc0d9cf27e38c1360a5085dd38e0b1bde717d0a37997715d095ae49511528a0c6e1dc2bd46c86930bc6aa6469c277cec7141f512a5042b6a0298badaff6f28eca4c991ff314c9fddd8a5bb456e866f28d534254fac2e3a213f7e1b6e5d28b1141733575092c5992ac24423eaf48ea4929efc04ec07a382927c98f63fa0d0f12f7ae2b59a315d656cd1d0426d8a41468032e920186bd70117e0a1c6ebcd604314537d6c2ae7fa9ee0d560c931495d0ee208b3d4a8c672b00599d3f0aecddf34e35be420bbfbb0cf04e38624ad93e497a7628c5843bbbcf68bc41e463d01d651be5d1cb91e6d7c4d84c41894c15871defd91822155f3fb4ff5cbc69a0365227d625c499e2bc1cd290f8836f6ebda17131ea3fc392edf0c843f75819e683db168fea64234d40cb7f94b805ca4d6a94dff37c7c65c02a31865c3f5f11cc3d83840e0ef17d5bbd568fee12cadd0a36604f3ca0feac5f5e6bf74c457f5bd155203d74e3aa2cf1a35f433dcecd1be154eb883a15c0ddbfe967684ec609d177a6a605ea75e4b8f8c2d0a27f3d9786a696f9738c1cbac80faf15585faaab60ac144f063a2c3f89b63990214c2a116ee2b25fadf6c271bb5a233140bd2435e573437d05ae1eca7652ccf1757316054cb2fd6fb61b6ed9cbc1a218e9218727ec27cab6bd055a6ddfc92e602ba697abfcf250b5803747bbd309f28a6cb7ee3320d112f0c9d5ff12f251dec22dd15f2f9615e5e66360de2901f5148a3e2d34a9f645ef5efe5e71fe35ae683f6f408c93fac4c33cdc208204f75512fb653992a6e2a810dab09154f888da240d1aab51d664a44c9083ebd8e21ee139f2a55f47e100cf8cf6c306c4d0a10481df7566713d99d03b8d594a47f3ddaa946a574385801f50c85b8c5379d0d2b4f413407b8e744443e73bc7f434a6a8ef0b663f55f077a356b865ec85f5598dfa935d46f03faff4d1c52cd541286de1c20e5fdf62e02e8236c244161e3c55af68d2580968d6241ec427411f6d6b2526dc8cd618b4ab780a14a1b4f0a8f316fc27e53d0944bfbdb2f91441fc2ca7c74e7ab7fefbbab3e3e6847b809eb6a49ba66ba4c48ad9e1dbdcd4bedee088918cf3d9ac225c53f12cecb8493d523f68be1e7232a528942aa26e22a3815095c8764b37ce6710fec19f1fec7ffa4a877b8724debc19c8c106ec5d3b6d9b196634156053a51182ff52f38a69dc22c563247bc94a4dedd76f87c0ee65ba4faa53436186427ed347a81a5ec17baed02498cb18af57272b0341da0d9b1db602512546c72670861811204420218e2eb8d05fac4cc553e23a1ad3f4b4daad3c3d6e2be054c8c928cdbf09a12d2536eb0a038739bda2879dea8e4a3521803ab6d97edcc26d8def52a25fff5b5c65249ca9e70f12b484b309b919eb588b376f2a3c195f53c489ea85e0ad6a2630d2872dd4d4238153f24b4ca4f545aa8bc6814b31eb634134b01962ce8dd63d1214707ccf3181c7f39d26e540a9ea64924efc0d1eb33daecbcb79a0b986a761ff7615143acbc592d9d32028a5283daa6bf11e194f6543673ddbcc2b4f9a91f0b17d3235b06779d8662a11854f55b208c58851f4afbab31274b76372ae7b16c5c4980a322918a0434c9eab2a03014a330e46988fa62d39f1f9ddda67e2ffec19ea45a04037d1a1453d2422e73b42579f02e52d1313a7119e4cab3a6fcc9c0e9616d72e584e9089d77d87c6d3347565cdeaa76d280ddf94ee34f8ef4536a7afd487230d0046dd6f3ee8121be0cdfa15fd996db5c51acf7dc96a39f88f81a81f45c05897cda111fb7a196804dff8939a5b20a612b19eb49926895b5e337eb086335c5a663d33ed2e2a176da1bb10ac027922d2af54a3d9b95cc5f7f8de9108aea6fb9793909b3aff3b1d166873ee12921c3c920c7d7ad033f1e620f24b890a0769eafaebce11f388d455a7a100acb1c58e4342a26661ec3e8f78af07ebc6865c93bf337c4952223e76519f48232b8385b128cd221a2c7b9acd4a92d467d445aa69a517e12daf8cf6d10b131828c3f43a95c90a0344d583e5bd1a238fe0f655e4eef8a4cd39bd24f5485bac61d9fe37e2cd39f6c6177d87f09fe0f711df54b237a06b0d8c6e8b3089edc819d5ac3a3e060bd246471adb87afe2eb9b4b6b764a2c337b167ee9c58be10b32fcd869079600f6cd68152b2ff8749696a60295087188644e583c69164a072fdfd3a3ed626f61e711ac67419ebc3d520b8524b522e5ed9adeea85563550aca08d1fd07ec3058754dd6d9515b2b0bb25d5cb8b9b59023d7af60e7616abdc135a42dd8558e2044610668fd73ace60a8cd7bcc72161ca48ebeedff2bcf6155a33a7c1a41242e291c1f1f0c10a8c7c6fc8550b3ba551289a4899a100667709eabf2db263f1b623ec765ee11be3f530863df7511ad5ce9da5e23fb650b2cececa7395bc46a1011cd043244afe4772ca272bd7b2adc2210965965b5407c2bbe183299c5e8d4bfe6182c70702bf4d601edddec4a48caed54ab8f59c9b7001d1549b7b21deac4ed57f29b03afe9d440631301ab92b2dc7e0aa09be6eab364d7e4f1171f1e056bdfd8f7c340b07aa5ee053d1e1fa1cae83cffaa3e5d3cf8c0c5174a263edb3e4407b65583454dbc7ea1b4f005e8cbc47e10d3cb172830c6fe5e60664a7fd8e816e7234b8aa6d90bb533c66723fe66b3599ab2c310315cd624b44ae18b96f860e7306d44d989eafeea3f5f38ddd2a7260fddbbb0a919f2239007751cc8343634e205a7ca53c830a4fb0505e908ed2d292598a74fcfd7f3ad6901842d48ea31cda9a0087b44ab44e551c5a89500bec2dcb19c8f6e414cdfa9a022946c027364d8bbbe06e5d860eb2acc508980321f4d215fbfb535465d40a40762fab77c4f98ec1b0da61bca83875655e340986e85eacbad9bb7244f1e94a3f7344e2b7cc4daafc368d464ec66cf4766f8a4e269b2f5175156aca961d35bce20e9b7e98b29de79a418a2f1cb991fdb40402f2966e63161b6da394d6a48c02492b564551794c998e306966b7535874fd64718ce06461df5fd2a9d61bc8d1e893e467e7764827b2bf44892c06b799e733249037f90ff49c3bd4f586936c77a8ac6b7d81ad56e2525301886e2d8f2dc53c50d5de9feae0888455b83d8c4b34223100e60e70a5e9e2e607ff7271baddc46b4a084ebead4285a07231a0c7ec241c420d86ff4f9fb5a50c4a98125e086fa7eb99d629c650ea3f2edbc23a28d092fcdd70deb2d6a56a42bc6277119ce0271752bdcc1dba886c7bf4565bfc45fa111390f49112ef7d8ff4c8cae284e611635f5977f6d803a0e34ef76e4507757700405b34038c22e84f3a5cbcbc5bbab07f8546f39879e6e123e97748334de1fd6effe3a72b6b89e98220359948f49064e56a3bba9c799480d4ac1cb1af81a0ec20e90df5f43f0f98398ef270c8c986659a7f35b49e2db68a56ceff6530e25113908122c38bd144c0f4c5b17e2999b5a00964f27448ad72c7e0fb1c401dcbfc5d1d1793fde1592ecff6da0a5d9a2dad9c350e06d69076f2e2c84147537e89f22b3e387a2a1f4cd8d08fb36d949553169f840e67ba6123e717e9a046e173c007594df4c8ef50fec5c0a8f60592f93273c192d3cc34bde37df92812668b15dc0fdbe3b304ab754b02b74f35bc040f68bcb77d36a17558469c047509d9cb7e1a2cfa02041ebfcfd82b5d7a6b0a1b80e876c39a92f936f8c8928b3bb7c680e50c89b1e1752403ad35e2a764d2f8c8a8d85295076fe337c1ec5e2b44c672f7b3068b56e70ddbf3fed1f954ec93bb0e73e75b510c31d19ab9d8333f3b6cca8aee2b452f69780787ce0ad0fe8e77b2a32cd82ae82e2ccd1fc0c9d15c5076bde10f799880d4b8230903e7b259a3147b2e4049154f73fb6be9ed2419efcc1f07fdf2c1829efa70d2ffedcd87501e359802b01a59f419c02ca97eb377c23e0b3a9cf42bd47e019c8cef8dc6f8a4de3be79d183ffdb25a1e8c5aa706886c5f8216869759e600b8391020e6fcb544cf41f24452b7a8b47db54beeea60e8bc1ef412ab8d75ef8835a306a6b956c14e774cb2496358fb7ad4c09ee1d81ccfdc42e099048413320280c6ebfeea0571e13ede32c866ca4887abd65cd2743164b96569e04d6f8e945049f677cb1152c0c0b7b00e17fbfe610646eaf2ee06dad2dc62bb15f1818fc15cc7f787591879f2f61ae08477383c8c22971f16ef8d56bd4e5b5e4865f8cd1b0204170c58e497dc6bfaf9038ae62933a165c0e49f1329f9953aa5e00b36c2fec9f65e6da57c3b159215bb57d20b03fe81d4ab98f687c4fc73dd547e1e2bc80255ba558f41c078d6488cacb8a981739d7c141c86fc7c57a5f9f937067d30a1d425ac5ab09bb18f9a4fc932c301f1722e633b871f53b600096ee120b3ad2887f34cf3da5bd8be7e95a34de114a64604f0cf5dfda53dfc989c879378c08489d3862a42f4a8b55a41a7735520bb3a2c455cb0b557a75d79ebac1fe7dc387346cb6e6ca10c30ba4d75a4b897eb40c137eb02c648b52357236bc1fb358ea15382f5e53864a37be3e600a09f3e12393ab9a193c57b071a643909fab7d4a82d2eea31730d015d0d605467cf6195c7791be6d0be1795885d7345f1d4eda21775efc141da9c63b628a3cf0e224b7803caabe5df6f3ba2b7c8a7a51c8de0481447f674ee0e55efeece5dd86b98f776088bb676a3965400f4838ade5980f699b474995441da7dce028aea2e9f7ed0881d0a9572087aeb07d719de780c30b2742e120cb421c314e2d7e73351168d3ac1a4ab91a19d8cbf02402a5446ea4fc3f94ef7497961123361b8d16de8e012eacfaf2f045032d6633a65ec7aac54e9f29a4fe92f7ea9e1776c419b20233fcdd3158d2169309a076df827896ed80430467c120a6fb68bd58c0b94fa14f35f1e2b3186f9e96d37dfd09e476d72bf3cffbdfe8440cd20f2d1d0cee464c8c5526974034a22db06237378879fd2a8729c0306ebe3f37f0506f0e388a17eeb23ca43275db54781de2b5e13f1ab3220b052908d183afe5553b0819bf46cdd2727d5066465e530ee069cc5b26f21df81a490e3b63e066b7c57e8bb2d0dd4d9465322491ced5aae3f23b966cefc4b2b4616fc92b226b63ec2a0f5c0ea3f7573738c052a2b679dec88fdae888eafa59605d9060ef08c1c779205c6022230a8134acaaa03a22e3c42f90fc2c7a5a27cf97c6c98a5846baaa94d472021b059af7bb49a389a0a4177d63b032c8ab2e11759d87babbd215446e4865ea076f5f6e1db7bd49645bc38b8b568f120770deacce4718cd3206e56934bf8c5e1cd3f0efeb3cf0c189e530fcc7e81bfc26fa3696e18c297870d592bb47708d9d55b700ab9f6a40d5ace852922ebb66db3157fa2d64e1a27e57af516eabfb9ab599da1e9d283171747ab1bd1147ac60eb5b869f983d9c51fec9800fda2f983e49103bf190124679da0f08fa44885ad2b0dfb94d9b321d58f955717108b1764a510e50e3962a8219cb4c4d5a5f026fa3aea769e0ad0fcfe8b0dc1c64e2a564df3fa9e0703c42558e639588acc1309693e5cc0198990953ac812f4784fee7ca31be1acdf72227364547834d13eeaf7196e9f25bae498fbe104a1e72775a1d4ef6cbdaa3e7351abfa9acf8b38e1a25481f484cb5d75d81df8b5eec2ecbb21298a60d3b78b3a3f0621cd679309442f6a3a9372ad5d3cb46892abd73ed7e1df131f7a7fdd87bd281dfc87705a108f703fc93e858fc457edc9823ea73e53dde83480121de096474d0e0702be1cfe0523b35236369b533708974af2de692f047f4453217311518bff610ab401d6d319c9e0fe7d4fb8fa4f1d648e89633a763812e3d0d112efe0b3962e8f61a56bde0cc2c91e40bc7900f1ce668581961f6fd4ea3ebc65e0b00c36958d3bce278ed3a510df4929a8d80950b70e504276fa72c833e1e807466669fd4db02aeda8f0d066d52f20f9a35e23a86bd7fd2119de38ca30e68f424a7ae288f56c8e97eddc5cda2466aeea9a838ff6da45cbdc5a9796bece52f7dee761429ba36917ff974784259acb936636f60b569922f6f4d3602c16c4dcc702af9d6dd873ffc7f72cf74a7ddc9fdd3a69d6a2c09282a891661acb2873d712d62603b54834a3b67e19e8a3577d75e56551104ac65f949637e156f28e9611b66da445c40c3878bfff96f5b95782e85aed26fea17df9970e1b777a636aa7cef69f973fbf92567db88e6d8cb577cb799a17af28ef3654becb2d76df17f76af92396aa3da60408ea2b5a17dcdf976678179e49c6c11449bd3fef684f8ea702d52c251f43b65408537f44ae637dd784c984fde94a756d81a6dcb01b6d0499893bda05c8f8cb061342c856e35fa3d31d3cc5fa667016a8012c8948932be2125f8d7a9f14ce8a742d43dde8ea46d5fb92877af1113c48b5c595d6b058a974f68c65a2e8d8f12978251a1237edfd866dbda0faf04b8b647f001bee94e0fdbe8058ca29a62420b996d60c749c181c50a5b05b62aecd2546011ebc56ef67948fcc7359b6650307c90c9cb11cb5c905985788c85ef0bf8f8009f5b760d8f3391fb4bda2990539af78510273dbdad960c9789b528dd9ba4834490e3c3b46551b4a9a11ba3b8d1e82125b27554b9ebf38021ea6167be2efed2a2e5341d92407b43aa169cd97dc4c7ee78d83b507754687d5934ea5c5b69ee4465b9df6f70d1939ba57ac5c7e51d9063361d9996b7b0f73b88b5e9c92879a3acd554be34060433411dab6434b926b18faa487805f9a181541895b6ba6f2d4191047f50c1ff3a16df7bcfbbeeec5b58a8f31f3e83d12c6347ba6d63c890380cbb1b488b1258eaefae452c02ca9631ebae97d620dfeac797fb85c13d4de710cfca1df4a408537fa9f4e57337d3bb254e700a0c4426960aab5fb5cd56572ca7a6ef8bbf0fb1d77a059900eb776cd1382baee4e5713e9f1ddb6f2f544846acf021aec252664f06bb09cac4f3fc1f42fd11cac39708cc51c3804827df7b55809587be6c21f78e8b8eba9651d5020d59e7cbb483c64996a977e50d6af2d3dd752affc19b6ec04fa0791b0b2b0b1145aaafd516ea3cd5188cbaf5a4e7d73cfc9a89d46e67b940fb06606941db9bf152e47c135ef94d8443e608cdb7c162d3a6c9f8dd972db75b025afba7364a84ee9c52c04741d364a6625c347620086c7cb1babbdbb53e8f91ce28183cbdbf29579ca9891d0a30e7c689771ad9f73ed3d92e170654b2b5000d6ba38677a951dfccb2d63fa412f926dd86d4ab4615dd463358a0b5a1013aaf9c8fd4038b88436457cab86ad2860c977c0ecf05809f1a8b6cb3daa76973b086705bc1c463e25751a506948bb56c1a8e41c4c0a2bb41a95b97eb99fbf1c699df6ccdb257878adcbfeba98b471ec5a14e4e1512ce633b37f4999de9e5586c9ef0196a18691cf69038ca5b6e5be5b662ccb9fbce51391328f772329dc690f3ea14e9892b1da9195bd50f1d11868d2d85934bd9a4df09ec3c5d7279fd4891308f5149b6914dc8132ea414068a17e035020a4a76ea224ac8a5fdeffda34e67407af8b5e671c75935ae208bcf1ac8307399706fccaa4b4bc653a06e6f9675145a3d91702907e91d3680dd43c0860d563e872014195d88df3be226d377fa618209dac0dd2cfc2201cda3adec4278842c474911d4b7ae5f450585a4bde27fdabd8666f6bbc110421a8b4502844435a6ddb6c374380675b5de3b3c1dc09f39a017b2dab2b7b307684eebbde1fc69706b9ac4897ac9eda2ff2bc4c8a3492fdc8a143927163abe6141c86bfc6066cbb34fce98c389b81c19549a5c16b414c7b7efa5bfa35c3953366eeb3f5ae35d54735576dd69dde2ac7db878d7c19e4b2ad920af6028db9cd41d3eee1d42510cfe6200f530f83bbff0d7c3ed43e318536729c3d8bec310cb2c0b516497666a16d15328f7ea61322c92ddff6bcb491220933b08916b5ab7387e0539b4f733448e910805409e4298e906fb20c7282e908cfa45291b885d146fdb178284a5c2129e6c6dae9cfccb0190c23774e6d0f5cadba740a1038b90886ed4bf93603ca47e6da1d90e94e0edb59a37b7ec40929e4b4dbc94742e37e670bd1c179e81fdb72dd7cc917685636942b2ec0bb48b700b05fee618e480db3ea59ec0f8d90354fb90d568e827a4810cce7bc5599ebaf86cfe6f9ad30f630770c7585e574c2bd3fd444405ecf5c07fe4c01d90fe5900c4b20ab73fc19470509f37586737321024b72c9c2be46fae4e096d20ebc08012ddd97237874e3c0da2daeff152ebf526ce983e9e2bbe002f4544f8319042ff1e0f4a4ad59aff5358c034f79886df380b6e148ec05ccddb973bab92555093a1b8d91b0009c2b3e2993b232da032bc63d7fb21e2f0bd6948773b3e34538ae00e250b2596cf6738b08297eaf3d3d26727f1bb3c1af3febaa9a8ce4d812a145baa97548567b6ba2324904ee2cb15b1a29c1507f669981a378c58031c7f66cb4f2c3e0be4d946e1e8373827c2982a7b06e57028161e657d9850a02af9583acad684aa8c6095af3712abee8b3eb819d878fcf789e63d070aa738c311e872d2b090aee9570d559cfef543b28d241f785121ce3fa41704715813a958b0a426eab85f39201b9c6f032c6dedf1efe81514a554d86a0227e238ead329890b1a52e89d78612bf60a4516bc6bbf3bdbb94c670620883039a97e5668691a7cc776e5650fa3c7a264df140f657fcbf8df1f0f155626682346d905a4f39e87a13f83ead79f499abc3acbbe485fc40cb242a1d72425556edcf3e6023a08201a4867c0155229401c6523a00d2ae351314052620df4c81fdc7910a054b775dd5142fc2c5b922d73f42d1cd6d319e5f70f24d87c473aa02c6b2e5c0598e56435910009e4baaaa32ec0aaaaa532efed77ab02013b0481f43ad610363416855fe798f79b666a7b137bf49a2ad5c3802576f38a5bcbbcb04fb0ecd4329c10c7867cc07a0b329c30f1988360f12f84782496ac326a3ead5b947f26b7174886de275fb0661e4349b8d25280ce905899407f71b79a1d13426ca462a17f01cafe2369b525d6118dc007e0338a12c78622c986a8b54b274bbbddda6d52f97cb4ea0960b4481c48522bd85457d2315b78100e0bfee72899d4acc65c1bace0bfb282213735b1abb69c381dc05d65a391d3bce7f5fc347997fc284ea0ab973d2ad4bdb2407441b274ee47c38e6b5b723778e244c0f764fb456035bca7ad492691d05a81e80d734712143492287b794c6795430e3fd43294f2fe8e72da7e3a610a9d8449f72a344e5a091ab56eb0045d120f1273ae82c73fe7c3090f9cfb928fc9181e3e9fde7d1c3ae5b9fbe1468","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
