<!DOCTYPE html>
<<<<<<< HEAD
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=62535&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>MRinRT</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  
  <link href="/assets/img/favicon.png" rel="icon">
  <link href="/assets/img/apple-touch-icon.png" rel="apple-touch-icon">

  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,700,700i|Raleway:300,400,500,700,800" rel="stylesheet">

  
  <link href="/assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="/assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="/assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="/assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  
  <link href="/assets/css/style.css" rel="stylesheet">

  
</head>

<body>

  
  <header id="header" class="d-flex align-items-center header-inner">
    <div class="container-fluid container-xxl d-flex align-items-center">

      <div id="logo" class="me-auto">
        
        <h1><a href="index.html">Logo</span></a></h1>
        
      </div>

      <nav id="navbar" class="navbar order-last order-lg-0">
        <ul>
          <li><a class="nav-link scrollto " href="/#hero">Home</a></li>
          <li><a class="nav-link scrollto" href="/#about">About</a></li>
          <li><a class="nav-link scrollto" href="/#schedule">Program</a></li>
          <li><a class="nav-link scrollto" href="/#venue">Venue</a></li>
          <li><a class="nav-link scrollto" href="/#speakers">Speakers</a></li>
          <li><a class="nav-link scrollto" href="/#hotels">Hotels</a></li>
          
          
          
          <li><a class="nav-link " href="/news">News</a></li>
          
        </ul>
        <i class="bi bi-list mobile-nav-toggle"></i>
      </nav>
      <a class="buy-tickets" href="/register">Register Now</a>

    </div>
  </header>



<main id="main" class="main-page">
    <section id="" class="mb-5">
      <div class="container">
        <div class="row">
          <div class="col mt-5">
            <div class="section-header">
            <h2 >Sponsorship Opportunities</h2>
            </div>
            <p>TODO</p>

        </div>
        </div>
      </div>
    </section>
</main>


<footer id="footer">
  <div class="footer-top">
    <div class="container">
      <div class="row">

        <div class="col-lg-6 col-md-12 footer-info">
          <img src="/assets/img/logo.png" alt="TheEvenet">
          <p> Pellentesque adipiscing commodo elit at imperdiet dui accumsan sit amet. Sed risus pretium quam vulputate
            dignissim suspendisse in est ante. Mauris cursus mattis molestie a iaculis at erat pellentesque. Purus non
            enim praesent elementum facilisis leo. </p>
        </div>

        <div class="col-lg-3 col-md-6 footer-links">
          <h4>Useful Links</h4>
          <ul>
            <li><i class="bi bi-chevron-right"></i> <a href="https://cai2r.net/i2i" target="_blank">i2i Workshop</a>
            </li>
            <li><i class="bi bi-chevron-right"></i> <a
                href="https://med.nyu.edu/departments-institutes/radiology/research" target="_blank">NYU Center for
                Biomedical Imaging</a></li>
            <li><i class="bi bi-chevron-right"></i> <a href="https://www.opensourceimaging.org"
                target="_blank">Open-Source Imaging</a></li>
            <li><i class="bi bi-chevron-right"></i> <a href="/privacy">Privacy Policy</a></li>
          </ul>
        </div>

        <div class="col-lg-3 col-md-6 footer-contact">
          <h4>Contact Us</h4>
          <p style="margin-bottom: 20px;">
            Center for Biomedical Imaging<br>
            Department of Radiology<br>
            NYU Langone Health<br>
            660 First Avenue, 4th Floor<br>
            New York City, NY-10016, USA<br></p>
          <p><strong>Phone:</strong> +1 212-263-3970<br>
            <strong>Email:</strong> <a href="mailto:mri4all.org@gmail.com">mri4all.org@gmail.com</a><br>
          </p>

          <div class="social-links">
            <a href="https://twitter.com/cai2r" class="twitter" target="_blank"><i class="bi bi-twitter"></i></a>
            <a href="https://www.linkedin.com/company/cai2r" class="linkedin" target="_blank"><i
                class="bi bi-linkedin"></i></a>
            <a href="https://github.com/mri4all" class="instagram" target="_blank"><i class="bi bi-github"></i></a>
          </div>

        </div>

      </div>
    </div>
  </div>

  <div class="container">
    <div class="copyright">
      &copy; Copyright Center for Biomedical Imaging. All Rights Reserved.
    </div>
  </div>
</footer>

<a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>


<script src="/assets/vendor/aos/aos.js"></script>
<script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/glightbox/js/glightbox.min.js"></script>
<script src="/assets/vendor/swiper/swiper-bundle.min.js"></script>


<script src="/assets/js/main.js"></script>

</body>

</html>

=======
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13b46f77da7ccf490f5a9f5fdae22d7cfbe941442332d904c4d92f982537ccfa561cf7688d6acb6b0da2f0a9d1eade5eee46a5925b6cad265f8751fd75f4cf2f6dca1dbc2ba3cb6f7efee1158fdc6ca248f2c30bec79c50f6d7fabdbb1bdde6c24d98dc16d2d7a95f80b109cfc74faf03c1a16387f41db374fad5a135d38ffab03d6188c55e6fadb98135347e1ac9cac2e323a333d207f997d12be7a4de7b230814b2428c7ab0ac2728ed5b7416fb3a73b4372d4a6e0093f14dd3d9d4aad0474bf5f678ee30c2fa2aacc1d7871bc1fe95599a450b29319fc7b47a7f1e735e2d1958071ba4ee0d35529462a93c08026a771e901a8f9f634481b72f78d80bf0181755284aba74ad707b0b844bd03b6c2ac8c43673d22becc976277b3a0fb92757132e70c7927a68e8c7f62fdf6762ed9b437bb6567d80de438f118507dd7283bb19baefa28b20599b6d35c9007e186c3572e54c6f51b559eced550df3ed40b4674f9e56d0477b428b07e7b75ae90088d8a14d00dbe3fa44295432f724d2661b7d27daf95d3acd1e3a2c34ee943db874219d3d683c00db61cb664159c959ee92f64050641e35c5301dc12874af97fef45ebebb6b7fda826c5d0d78b1c76f26a79923aa6d8194a0eb4e43d40626bfb7e1a7fc2452f9f1e053e0e8ea0d9e6f6e51b3d7a4b185121edcb0e8f9ffeafb8b6d7b37e01a11117c53e6b702eda6c21a9a2caf7c78c75395372d0b46c14b1a97c0d4768f04fc76972e1f817538d0573a58c795c2699706c63957c47169af5f352181a34d721082adbd0f3cea12e5785784dff84b242e51eea6fb45f9f7b31c519e1dfe7caf8fdf52c94b9e340af8c595d27379bdb83e30f99c6b2e76c7970565237e3e8ddf937b21d800147d794a754a6bd7fe71d1032416cf7f5fe67b2333f98e7f046266c7ed2f4a79565586c4b52d4a9bc685d5783724fb368b855b3318a5287517b2b57cb7ce8efcbd0f4303de5edf20dc7342f47f852fc6f20a4b3e978cf97cdce3fc075dbf7b558db3ac17fe91c8f18122c6b8a1f3b4d31a65623046feb042814ba77f10932cbe26533cae63032f33231018f93fb22f4bbbf3c39bcb6f8256e3211aec4b47865f86e01a9cedba19c0b72e7ed26df55710e6a3542c00bc2b90a1da3b66279d3820426890867e2fabff945df9db74e952159e0d89db5c92be413befa2c363ef69d97cd4a6863984005a06f373f87bc4fbf5863189de16140680c201eb9af95233e7cd7317c256c2e2494884845177d6a7f5b889e56d343bd56cc4f08c6af95f144adc7821f84522c2295916f313242a78db6d9256edb93606728da8bcd057fbb54adc6ce1f02d4f02c5acb7f43ed6504d6fc7f881988a02d8c4f7e070864e2f7eeb46150a26dd9f63451d295da11b1c2b30a8d88889b729c1e26cd7dc200c29b354a38e27966d2102569d91c27bce8941190c27b2ea980960e19a5f54d18b81e441723fda7f398b1a0bdf7b695ee96a17af03c20470cd477c67e5769747779912c03377b25937840c8eebffbf7f9b23494083b3c7c8bc56934da33576236e344a6e079561896b840b246e4ce5180b0e1f6b858c18c03f3fdcefb8129923c8dfd985a5afac0346a3011be71806b16f9f4f1535a5726f9319b4f00be882339e6b36eb6499bd7994603b3c420983144571b837fb950c265252d84575562adae58cc66d77c3bf00c37a7342a6013463772ba03efd4feed01467320f3c12b5bd7d8c6f83f5f81719672c73ff74ce2dbe8b30fd64e136e96952516f69d219f89a71fd3909ca069c403697388c819eb3e39c1390faaa4ac4480c5aa8a302fa4ce9bda8561864cf96c635ee2130e2a3e1f51c3a49107d4422ab050af58a4193777860337b5f333ea4c6392905d43d4bceade9f4f30868b3de09e644beab494049fc215ff3604af65a484de8977a299fdeee95b520c3f93b14bfcdee93b76683c6641624077f9bf36e42ae44679d81026833cde541f75747dc977d76a99facc228def2ce79ee66bb7b54c3daa495ee3231ca2f952fc96ed4cc1dd9376d2f182d2d5f6c0170e6d88d4481fd2091d30ad9da1988da35ebf895f9fb673e06f6306ef0aab46fe7795bba33946363ae7bbef5965a8bdcc71413dde09c6a8c31c38957e12e6e31b55ba9cb8f191d205d8568db45e2dabe56baa74cd78d0fdadcdeb06a55d037c34da225b0349031a7255d2fe6b50ebeee68168b5c567575cd93071368c1e1a7dc744b52ff92b54741d79f8f4fec5aa9efbc20989f0da4d4770e2083ee131b7586ec6c4d2fc739dc8f45cb0d54363533fa0e5eecef152accccca80b2acde15df9c84855b13ced69b460d64c38ddb661226e1f7185b92232fb2edbb592549999fddc23624ba18f14ba10bec388130c4d5914b48825c077e76dcc45c8a2573f90ddae2df41c4c9453d8f0d748e0acf7b49552f14808b4027b256cbbfb54fb7037ca02f5c043e1c2cc48d278d3afdb4e422496f4a91e2f51b2aafc4b41cb83c103a6aeb017985600c6b5c51683fd8b6b61228e33182837b82edb7f6133ed8e87e247c38139b9b8bd76e1677d129ecd286e5eedf6f58d64f731e8376d0ae7bef50b87a3c1fdba02147c6f24f88271c19aba76ac45faf592dfb982eb1c9455de4ccdf89889c3a40a2818a28c3ccc5cedad66ab1e0122316be24f1ffd83491b34e9ecfca63ee0eb85b8adb7b9d236eea4b1e19f8321cf96fac23c76f055d1dc073fe0049dac0edde56df91be9c93491f7522a50fa239a4bdd2ce06e4e89d963d5553eb7b4270f04d070b582726933e654b5d44e760422b10e91571af51150a300ccb3434329050226b0d4868ef5b5033952eeca561c52af920ad4205c8c0402ea347d4d7697f6d3d4e3dcbf8e9c1233f16f276c78e6b09edba7f52acf220b362640849c1d8f1246119fd253f8c4f7b4861a263bd8d098c73b87903981ecd50c56a0991ca4924e0b51b18581119339b87f9ee9549be2bf03b3d91f6f68d8fba79e93f94031efd7e7f9d912d1c7bec337a056fd86e39b1d7f9c334593f22d3c87d051e0c04bf1cc8a3b43b3e37a7aef9e608fe4b2f3cc27814cfd3ceb5b1bdce7ea0da2863b96abb0a301dc99416a4aec1f288bbddc16538151c81c56a0a4034774c3baf5e69754e922d9bb7fba53777b3935b05d25555038e570de62b2c005dbf234fbd1e1a87b2f0feb1d780af859a74a4b8a20934054488ae2375c2a0113cb4e4b010af56a9b08f34668710f6d4e5ee92c2ad72f6656018ef567543c21d0d1369fdaa4bf01a42bfbc5a75a79f042c03e3439c8fdba4ce419d763cb9ea23fa5964994c6e2799bdb37dfb76d6c55052c01014ee4552cd14cc194a53f590ff90ddd6ff65042a8fa97ea47e59750fd3fbc1a27edf57c6ce26729a63b7843ff7326a9acdb27f46191f48324d4d508310a5a9945580c15c9497d8f7e7beb71487b16572706bd1b74d8b59bb62f88504abf7923ad178868e6132b82ecca0df1ba6ce0aa2e27067f6eb6c11557203c38cf65992d214dfce278e46fc2413d874ff039b4616c41be293cd51147247f8ccfaa40b1592c0c92f304cc53b93d9e6e933ab3bd211201ce10e83892a0bb7239a2ad5c17834d457106e11609bd70cee3f4c7eaafc4f191ab85c9014a5d40388791eaadef1d5e74a94c04eef380c513c61af9b0515944293c5c400478ef533c5542698db7b50c51bc0144b4091299f27d80c6c69e9093fd5c9a25cd4ac770689b55b9d826743412bf0dee4bed5b95f07547a8635d2e0cefd81a8c19ee3cfbabf9f89d593bc40db20c55081ba3b9391ad5afabf44a8d53e2226c5818fe5f162c83af1ddc47de5217aec41b5ded802617dca1e2a74be05a72a8d69b9d5724ffbee4c87e88f7c3cc18ffabf7bf4a995829ebd343221bd8e5df1aaed45c6e144445026b95cd709775d9e4dd3d25cb76a3b4bd0643ca56d78beea694d5acbfc36a16efe4745b3d88e737669a456bcbfbedc990d75597da607a73c89d3857214bf7c4a4365e18d0428c0bd1bf1a26708d5d247117b9b0bc7c7f43f44516a2837bfed31e3b47d0d2098b68fda9f36628d9ce9a857ed25c6ec42bff7f10c5c637a16f5c2de398b6161a54cc39caf413a73383da37f8ed7628b4efc3c320e040f88747a8dd822bae4e59de953323d0889fd4fa43ce23d00304cec158959cf8d643ff0bfad0d5adbe7a77709845dde9b7318b3a0c2a4d1a80844a22d54822edc184c427c97ec6bf0aa1330058879813635901e75cd4d5629af3a2a304294657db7f5a938ee2b896e9f4b201146bd7a44d49ec278d6b22f76c7280fc5cfc3aff93929fe3a00c68d689236c2e0da99c77c73b5628dcba156efd049b454ef8c41002e82d113fc23f0dd16a01a41f055a171a6366b57b47fd4b9fd735ca82303e6331516d355e7ad8e3e15f81cfd8ac9ad1e40009b60d45315d06ed0aba57a03a1bf2cb80e6c38348d0d53be172fdd127fdd8eb9a13d5d77be036d98af9277cf9b1863cf3b3cce732e0314d0e2c48402e89a9f33e3ef2b864edc3b7f68c755c585e75fed2000705204c89e83ad0a80543ee5032258f1805505067ab5448573c23f34f1ac456a07d2695edafa7f5aa62fc208de1f8528faaf040e163e40e55c50036b1459e287dbf3ff5cc28b9658b49845414db68e7771911a283f26a3d3f1628b2c72046bc41b37adea72c68c0d4c891e129af97b90a5266251490f5c9359b0c660283111d910c59b86e6db1d5aa00592f0965f92e1acc7eb196556d5697102bd0c01787b87c04a35ccbd677c5c1ca9ab4a62b409a3dacbc1f79bd25a47a48d95e3e3876b8e8953ddacc2084e80006f8557f284d7d91db4ea98d7341c0f49900c49baf35d819dc65d7793059e09ebad20597dc8451bfcfb011064af6238583cc56e280ee193d8c321bf44cae97ee384e4c8dfe9dc953aa152dbaf36ad360ffc388eb7ae20ef0189b8e0885cc3391794c9bfe487e9b7d02ecfe0ca76c3418d28c86b972f1ddc465ca861a11562a630d485343bda666a7f4a2264fb785ba3bfced5679500c72630c750cde760e723db770d90d71640d0c6793bbed8f348265e013e67564a99edea959b358bb875d1e5e49be0dab233c395bfde023846cfffd16c323830d2ddff511876f62059231f7c7fcc168ba0afbd5dce727f2e1e41d44584a49f35c2dc92555d37381816518eaaeb469ac895b48218ea8d7eb7fa87311f4f86b8280eb8650266d4cd490779b9a160d7c28c525bf332c65f12277019a4415d2176b9a7d718dc30114b5b2f0c01ff9d7e4d5940c8e1391f4a7ccbc65d0b3374ca112a2be453a783e21cfce9e369ebb62e04dcd393cee70537f2241c1f1a12a7cfa195d0fc2f0ebfa6f2e6d6da964f9fa250622e511d29a8192e730cc7683cdfe0afb3cdf576c56ef865c972928ad726065e89b1f02eb024d75efd63ddde9832e387699e35582559f719085d59f2249b532bcf67613f1589695e6187ea82c56342685ef2680003010b28b9a9d0d29e38dd1bee71556d09a440471e1baaae84f169a8b31f00654287903c83dee97d5af665d0837fa5d5385c62e8b840d521536f85d4538059e41dae61e9753a110533d3994d2dc46e08e96e18101750489aca720ef52a0bb361a9220c3168714f5eb2f595b3eccd56cdfe1c27357cd431c8cc2c260fe26ca56b76af6febe4f7d42ca9922612e1f95672a9d42e9c8cab4b9b93aecfab6130df6cde6a86a457ea649aa2482fc317201d978863b88644e5d31a3e70a7eea1c90d15e7762346ca0945e76403f137ab1735048b4f30c38a09c8a3f302594e3b78d3f4e8cf20cf6de6d2ee9e152b8eb990b30e3c2b1eb41b7cbaae8ff0da4ab61154aa1b7f90e834334921f4c7e8d840b2dd96835b3ea575f2641151f5833f80c7144ecdd81c888fa32c13f0c1964382dea2e9d6f093e7737e955789da79cf7c42717a405239e1a2c93f9f69374f03bc3ecc3b368ebcbfb54e626832380ea00d034e6a05280ab8cc7b5006ad458c9abfe5922affe5664135d5817652549095199bc0db7ff1d7918f532e6e7816576e9c22852d1bf30d5a2785730ec3bce674611452bb744cace068574ddd88d18e801efe8a9166f28d9bb2a584189834d5cb3950ddb645f3595f81b677a7ec8adee388aeec16355210ceb7ed728f0f29f48e7f624004a52b97dbffe978dc09d9f9af747bb80f851dd1fbbf7e30398972a1eb8b5bf0c38f019788e6ccc7891540aadfb6987a353848d8e723acc5641768e2fb6856df0553b21b406ece719d37d0c22d1da974f8fdfc981df4527876461a0d8e6feddda017b4d0acfbf247cc7c0080666d808092fc40a4a63f17c092c5a982312e61b9c232f23f35a68b817a3291833107b375757cc454d999fb420f0eea0bd781edcce3128ee9a5fd5cfab7835f53759947219ba2aec564f431a519f432646657cac0c362d11a40f78610fd137e3f2951829a125f08bf3abec7bdc255d8e7ad45b04f8e92d8437c818f1c099f2e9ead1ade47011fc004b6f0c3c674eaaedf4252de7719fd6236262e0c50d90bbf6f1d711934a2ef32fae78da43d8560358e671c33a1e339e0a0368103bcc675bd497c49b7023489d00cde05947f0c268646538ecee90c5976b61df08b7ccbfbefdd2ae47537457f0b774a50e712d9d89680290e3507db389138fb994da94e749d680f2a0c116c5bb4ba16cc50237234efb9042f590abf6a9b2f8c9e82fe8263ba60118b7201163905822b88e4b77d39b9152af99ff55e45e7ae88fc76479c0e9d635fd306178b4f9858059bf4da591049aca163aa8ebe391f5f0dbed0c33e49e8275dd4a6c9e06db37393bfe5717b5144d2647e1e07f8d5db0974accea94985d4489e052ff7da4920ea9cc741be0921e163d516206eb78226e390dfde8ff82386071c2cd3e5036d215da6b823743417e904fc525893f8fa24f20418a5c271f1c7929894d3a0a701551b0f7b82227651c3d2608b1c3eb0e2ec16e7b1f84d0206dc98a4eb6e560dad1fdc12b29131ac52ac54a9a71bdf5c4f98759c363ee7cda830334f5a56b5f78df35bb12f01df129e4e01b401fbe1a507147cd09e7d97b8324efb6c5f2db631b4faf3238952ebb584d4349cff9dbf86b85a75456574bebaf2b22faaf478e2b82d8ff89abbc77feded3c443cce526de3ba0152c04e67d721d1ed71bc9cd9b765f262ac264911518530ee8ebaf50389fcceb3305f02579c66afaf957185bbbc2d9347fbd458530b17a7e3738fb9b2b13248459a46e45fc0a4dd637a78cc1113cdf8b5cfd57d236cacc36706868218bb4c67ee49c33e181447e17cbb84016195b710886c21bbe508354160401dc0eb082b4432b397f17f2da4a9e375ed107961c1531c475c266c3949ee0b507a58102bb3314ea103f7199b7d3b2adf62dadb042258ee301a895301e095f4e611187ea3ed2d24f1d6462861742eee3eb88761ccfdaa19fd22837b9fe312d619942568c3123152d1ad1eaaaa481fe51b8e42fc39b20eed4b91a4927bedfc0c543c28e305f800f4eab53ba2e0c58f60f2c59dab4cfc4cbb3fb7e5fd40cd66f0e0733801babbca46fac2a6ecc45d987c931a951e0019f4ffe1aadf58efb6c22da6dcc70933d680c3aa03bb30acbb5f58dbce2b629b65adbf1f9484c90614ac3048abd44c77abae344682c835dee5492b8aa0c0581db704333885291392e44f2ebd9d1325c0c1bce1d276bff5302ffc33a3ec34191d1b245c03b8c163b74db8641b6a619061f583b41897c47759f957437121c018a25f3ac26f1d6f2dd3915dbc01c0bf77a37aca4bbc390552c68aaa33679dca4a09dc76418ea45bef767298ee3b12822c017fad12c889fd00c0037b483eddb04525da6e2e763fd0c2c9f2d2dff553b83bbbc21290997b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
>>>>>>> 0a5ffb10cb320f50f2148adc762689425cd5508a
