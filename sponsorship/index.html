<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39b808c82aed7909d0acdfe15f29a361a53f374f475a82a5ab4c5a585852dc53bd738fa603a246822a756f9341dfc7ade642cde3f5b2fa58a0167c8aefd5f995443cfaf29bb88caa3df536cf4325be0e3cf2505ea2384b35d905739bc6c44be8ba9283975b0039682de3136d1cf0ab3a6194972e683162c9a566e207dcb510b7444253aa4e96e3e390e90cab633331672c71f3f8c8e2d8434ff88b230071c81a6fbbaa9792f5b998e9bf51636ebe9a8d6156bf4b74b2e4e03bf6919b8d9a2365674cb7525d0eaa128584048adc3d32e2dbee9cdd4a918b565f55c9676371bfe5d4bed5b6749245e398b3377384b07cebe0e57fef9ac27c866055c0e0f30fd12476aae1faa4a8c865d8801fcace26118b113f586fff5799af1ecc168233988b20c6e5a74dcbce9c6676cc2b6616e1cf8298ccba1061d84ffd0e191ec67c86b2fb37a191a6621e7d726e70b84e1b4b4fe3767fe54cc26d1f299790de05b5225f575ec3f687e497f4bc4ec28fd844ac26b74f77b997a09870f284eba41d6e5b8d296a7a2a487ef4578b13142b0e5066f1a607f99c827de915503dc9b8740e9f81b702a6ea157f6dcddc11390a2bced479dd4d6dbc3f6f8f902ed5791f47b317e1dec034362eef501213d9d53aac6690d9e622fc5c2d9a9387805af4e3ce973e415d62f7e207188ca8de3f0ac118d5abb9f484c32955b46acf7a4a3696da2c235b6562b9b6b7e68b662361b26803059a8a9d3beef1c84bd4d2e621b21be9165fa022571dacf789a0e39c520fd331f78d6abfd3258ea9ce8a32a19359b8c1f0fa1cca6f210c8dab2a1b5a6136e4619692f5ff58b3c871a5940231669f16d09f8ff01cf547d9da031904f4d1622a1e5a62cf762dccd333ef6ba3bd13230952e002c00e1f5be6b7f837bc643e2556366bf402f08ee88df3f871f317a3a24e9e4fd8e705f89d8f12e428ce5f26a874b2ccd60c4493200863170c1811d1055dbfff2c48038739f24a0c8560797685f5cd64a35b11440ed260bfbb4aff2aa3e2e40781424dc21d09ee9294619bb093c5ecdbfcebc11952fe7b060cfbd161653a5b257b00f162f3d43de8ccf5b4f36f2bf8b15aa05f3fd80f382f7ece7767b78f427cc2949eeff840bbd1108cf9b9cb221c34d9d699d8cff70b8bf5ae9d68761c99e28f4547c854fc15e2f1e778652b1966cece265dcd0e809c5a0a8671a4d8f62c3ddae8d95da1db9fbc2d3ed8a3d4ae18886d9128b680eb8e34cbbe00fa808c33b49afcf36738feaf701f9b37965207c11772c7b4a7a8086971ece8c29bcb0e1637f41b18ee7c5f53958aaf0a85016ca488f8b203979f4b034d2550fa2ac44d90e46791a7cd3c0f9bfc07068cd65e2fff2e0f1f3790ea3bbc0d44aefb569e11cb1b99ac97d06bbc08ce227c1af26766fa87091dbd88e047e8dcc410ef3e4bcae729ddaa40efb3097ad18730251ab0fe5b774243023e0fe9e365561ba42841495220c99144e958f4ff5f2fcae0f59bfa21f1b873b1647a260fdd5a3a2e877cc9eba966ba1210e5e1dc8604c25382b94fe2ac8e63ccfebd1ef188d72106cb7a41a316aba5ef2f927e864a06b2817d4703b9b0eaf9b74f6845c1fc1ef00919d225abf1b32fdf5f93009c5595469cf05b05c01bd793cc7db6d4171d651ab4a6f17a99e07d36c29f9d251353d67cd7eabfa1d1611f86689d0cfab97e90ae97ec366fd44865c2535b4cd7606e2d155fcac2662f841dffc614838f297786bb208c0d9132d5a91926d07eea09655d149eec3ba99c811070b612a61d6e89b468c837cc26522528fae5258d591c8242299896d99cce1f71d2c5bb2493754be0d973a65df34b61d297cc7f7560e095455fa92eed5d181aa9ced5ede8d918a3bdf997c19ed3d7a4c7c02de483a67ccb6542c90be419cd63dd4ee1e5a2aae79eb07c6eed63c45fd6642cadba4de64b6349e7395b2c9c75cb76cacdf549650ae420f4a8799937187d9aea2825b179056caa4758883075f7b9788f6ae285117af43a72a9f815f6e93e1d63b88a86454bb2cbcb45ace39ebf6fe7758a64630c2b47e9728a1b7ff12cf410f771e336a4fa5b15fbd1c35337eedcad60bab3e2b8ce019e2e9b7c8b033f27f340fe8a150e6e5c4eb8342c1b88c735535b8364bdfb125ff4662c0f08cc651f66622e9ff0f56682d5fc8ca071e0e30f66538807daa3394846ce4bdfe7de86d87565501e9d99a61196d4407585ff6fe2c5da6ecaee035f08f6ccd5d933d2850214c96f79451574f3453a514a52933d6f0bc5d092169ca060522a40da1f1cbce0b93146a3a8409ee84177508c433aa3c2e132e6af6231e005f92d8fc506bb986ede65ba120dccfba72bd0e477c7940be9a420f519a50052eb4c86733fb89af6053ecacfded0c40685a966a820c07dcd836d58d657d2e4b5049628f44556c6ffcf50150b857b3ff1c3e81fe03839943259fb7b299217d5b99532080715758925cc2edd51be8be812871d9ad120b1a8630f7be72bbdf2d450f833bbc75280cdb8f174c356eca1a9ed1e35a23206e61508a47a3fe162cec87c7a25a6b5350a6560b82b4b714905f8edc24cf5460abc75f25f4420cd1eef6df12ccf4a8ff4cbe6cd13625be28ecf9971fc67b5ec6c1576963d791bcb752702215487c01c87d0d9808ec08641aefdadbc5d5ec306398d5400683df23a6d262d9e295359336586d376c212c9fd88fe80d985c601e78c01218d6fae160fa5e33b3f30c24251312d1e600b23ada5ceb6c9ff30be8ff1e157f00f70fb91fe749068ac5a5a1cec7ee629917055cf7279ea4b7a689ac5efd72bdb84ce43635545cd37f322fde29972f211fdd7f03d90f115a101aa5f73bc79eb63b8de843cf6c0e4b910c0f08fa0ec0e970c708d25801b58824832cb873c4c23922113fc6e9467e5300150b75230ff7c35575653043fa5c2469470c81306a1ad94b22ab8a3d8859e387f5474630a525ff3d8bfc5d065396be34091e5462ceb73a067d7753f656b2a4110635a900288e389d60db244159a56f2257aabcb1e06a3a2ae10d5c64caf1394272a1675a91daf2293b6bf7e6240d19e225375886923abc101d66ce617c27359f1c9e10378cbc0c46e8422cfdcbb9dea61008d50949afb1cbda6afd4b57332368fdd9430e078f23650dcf95671bed3bd98468a6f21170b24538cab4ea642d9a9930fa87871b1da7d94647e407fdb8e4b51d11bedbfa43b373bd17dccfa6eab1592ac4f825cc2d48e78f4b76f02a25ea276da2fd33319a8dcfced62cbda322973139f5e27ddabd9d4a3d1e49054d417e34449f0bc057d787958858cec31cd450e43a5bc6b9cd33a199b022369a85b81a1866b0915994fd30f52016d769a20339a8b1f20f1df0f6ebd1f7bf6fe1fdb964c3977bea8a9752da879746f2fe992803512b586971a7d9a6c5b27a0dfb04b3054c70e18919d12095f14b9d04a28ce83e6eb16cb4c58efac939f5ae2a4822144ccda9b145332bf9eb388550d8fdd85016a564b4825f295f8eebde247e5e209ca6f3a385b05835a964be8aea9c346c7e5963134c0576f00776f349611e834c1ed0514e638edf46c563ea752ef4c238dfe2fdeac6d5ba89c621c1211359d4d430a43d9142b171857c2a413a50a8947440a97e9d147705ae0cb25d0cc2fb0498fa40842226b171ff8274d25f24c4387fe6ca7d360abd821cda0196db6fd4194e9127a6b2fff36e29b2b69a1685121dc6fdd9cdc36bf139789b9fd82aec8b48868ae0a631c4a008fb8f1125327f4767155cf8958eb4d68ea15fe1d826d48267320c0f2407a1b3410b6f5e616a6451b529142fb6c4a49ac1bdeb805929d2c0ab92f5fb3e7155f24834dcc2b4b1977060403c9c3dd64f3622657155fb02499c9a7a601cc9bc335fcce56e66372a8ec2b4d8215d0277132f4b74b5f2a6f9f38eb4df01d0f757901187e7d2e9fc1e98f1240c2aa61a7059796b79f8c1a9b299f905a537c1520968226dfdbdb674b6f24959fb248d1b2edc6a9e4d3d1867f5133e6f8f8cf4170d3deaf579e6df24f41c1d38a40d934b8ac65902a092a1e05b6190b8fa47c510a6207ea9c9a049edb0fcccef2ecbda165780de7ce3ee81facb13c6b28ab580a33f4ca86919f31653c5e0c0a3e0ccfbf4a3a2da737aba1ee9236ad8aed7f718ebd045104ad1cb5f46603a116cb17ca7b998c05f96ca1fbb5d0ad3dacf3e2b131c6e7e8290fd3a0e938121aea43f0ee8a3f6876ee51766ff57419ffdc33a54dee2230ff3af1f0d2b5518eb6f0ab9ae55327f33423d23735dba706292e749370977e60a9f00ebeb0baf334a1378237dea62a76cafd70bdb011f2065ab2c788b16e9c2d0c05c6a52fa4fdbfb95e9db8c056d428370fc2610b02d40baddbbfa08e6950b69300f03508d41819fdcef9e551090e9288c0664a70740281b6b7256f6a1be84db8aec0cd01cd7ed2095ba4eb7c76b5868397cc41a94d134c98d410d2e489d9da51cb7469f8641305b540121f5e16ab7ba32f24ee6f3133d17bac33a970db43e25f52616c96a661c7a6ce8186b15b6c696907f894bbbbef9209a3fa0f891ed5b55ce5f63665963b43ba7eed425590a1510eaec6fcf3472f58f7436aacac41d1d723c61043a718e5c7082d3c92d84e835dae2089d1a136206a36b5a525afe1e5c46b1e2f901cf455a7bbbf5b925ff9f05ece85b5420c0cd3a0e32610386e71d656da9cbfb6d5adba7796ffd70686bb8cfdac42856d304cbe880537b0098d9cade1b0b8814c73715b925b34c172d845e94c0973e53e787e0438ab629656a7691f9cffc58d4ba582d91cd25bbefce82e26d1f705931a810674c4e10307d7db387e27d46727658a9570396158798d4b7b4d4b63934d01c843ef193bfcec70e1a534b9516c16b01a16d7378390b9b92ae468c86be25a49b45cc410b827f412bd155c137a498315d777712b8146572ef2e0cc18df6cf36774344af0808d8c28804e2fea5c5b18c9fa9107bf157ca0a496758c9c851007590775a7f6e780514b4d013bfded5ea5ac7198f8bb584068f23dfb5d4a826490cc0f95478106cdf95844ea3a868c8a4bfd95ac3572b656b3b86369438b7dee426b6805f2700f80a186f1d2a277dcfa3688cee0cffac974ecdc6e2a722a7db76c2f67d18d7cc99299a1abca4c194946d17ca6841d02df8b92b13a373538f558e994aa9dbdb1bef948271b80aa8559da699c32fc5b75e73cbab84c111fa7ab27015a48156e0ec3323262a6ed4e52c768452a9113590d9036e29d0ad1bfd3a3ca11cdad140588325b151609a3c7e061d172c7aada05d49dab5196345c764ef6f21966d707c74bd3d9fe96f52a13e226d0c7d242ca31b22ff237b01603a81830a1173aef6f0a1f503a4b633a88dcc6d0da9a7a992fef31711db34ff70dc79027fe35af4384d704d18880ea5930c35eed1c66cfb52d39a7755ad4eab61ebcf8d9a48291f7e67fef25996ffae3dad22b899ff2b7703417c40f0f2195cbaaaa7386811ab5f1db29fe7d2a79754043ecd829a3caa944e903432adda382c856178c7a7baf1a60f5a67fbb5fc7ebbaa2daf85b8fcc31cff097421896d6dcd3aebc32d6ae0b78e361abecb8eecfd642fb52e9038493b5ad19fdb62f44e1ba1ad90545c41abe34159debbf8de74b8d68452e3376099c8e9f640602123727b157285157efa2f76d15c5b5976e89b3f36e496c1aac366548cc9b3efc5d4a13d0db9bc548de03b2054bfc053082159307f097bc27dc173caaca1b1e54d6c55a878958d64efcc4c15f2b7a433a7fa7da3d8d97065ca7b200318b0340eff435930703d818dd3c767bce5a57862000fb1e3d02bcb88c847a4be9648ec4665f12170b9d52906ca63dc1977f147247c03fedc953611269372fd2af46929fffcd3d0230fbc6885e1c41c326fb27f476fa790766e95ee6359b35575dddc8a3f902032a9995e557f339ebbaa833a7245262bca9d416e55c9a9a4007520d30beef7a4d0a1808edad7adc4d0526defef6815dbc8e43e1eb1223d74844c66cbb61e2a496f16f797ae694ff3f75d099ba435f70666054cc26bde279d2a97efa5c6710ea7c5617a676ecf96aca38444fafe0219d7ac4a436668eccabb22b548df397b83099ca8034ca1dc899936917c4e245bcd644d5c737ecf96764cc367ca96ad6193280d7f10230fbd989b0a96daf542193b75e8e90af71c779efd283b36a2a257bb24315c0083dff87437c21f4f8dc022f017fe7e370753fcfbb7c2602a942f4e838801b27aa8085c43d22643199522b3d4649f3733b41bdb18d35b04967c1dd4c9d0579d29101e608dd59aac6113b8b6d31488fe9b76666b6acd8e3784cc1a7782dc619f99f95c0037ac31ad70d03447ed656a7fd57f57a0c718c25311faee862a5e0768761d6f84af6203831f8fdd46cbfbba8a2c53c2edd756b1008885b75842904cab2515685bda15f24ae709dd858dc631f8f910d1a4397db1a36670c7a7dee70130328059fe4c13d804349138e1e8d4207b04f8ead94ffbf944ef25fdde2feabf68a19d8ac323d4bb2f104ac1b4add5bdaa7a60324de49ed2617ccaa8a73f99f5fef4f59f2c0e32ca1de5b1c8a6ae5aa4f6049f2d1ddb3744ba1cf22b54e03213bc3c32b4f7e705359c3e392d93745bc97d02dba09899a78ea6a92ab6a987045d0f499eb3a9c5209db48940ea472ee578d485e09d0cea0f933114cf80675affe8201e3edf10671c82b25cb3e025a17760b598820beaa8a759f2bb7faae1a27b9621464c248f9a42046f8cb5580d787ce5c1412f340a39c985d85ee5da5b8ead3e21ff0b473ba85ac97b600241ac137f9045500f4dc248e32816d0314585520b7362f9cbe3f9573ff76ee88186e36f057172e3ee6b07030bb1a001b6c0130b9e63b70b34fec3d956017e2f1208a5fefefad3841740176ed93a3438c6c3cac41c0b15ab97873af8a374279fb5e6b87d886a9613df6a19a1d807c350b09e7c114483bf19976252747e657cf54b59a778ebdab45495a61acd4459874e52eef07cd5760f6530eae5f6b5bfb0f703da3f78b88dfe302d9598ea41b3a360621c3fe01fcdc06a84e275fd8d2c3995eb750d334b59d496423c2c7bf04b8276982e072701dd1318f08c86ebacadd329a2d5eff9d7b0f86e06d5b598ad70dd75d4f34b2c775776957a4c84b42f2e3487dd711c4264032cd0bf1ad90ac284b0b97c69bb554b7237ae5f8619ae29beaaf579f6a2999bab4a42e363f5d4553e8b4f1d7e3195b456704370ed25b3563f7ca6eec4381acedf64bd95f312eb2896aa4a37e3a0b5373749af802aa98e46347f015b9d5d50ad0608301c3f34604b57fdf1414d21d9d0a6d3f4eeb2a20c72fb0e367a9b8f1eec4c3dadff8a06b1d63c0cd04ce5954463a2001061af94cfceb4152652308b663e9813134bc00fb241127d7cfb718aa4a64ccbc3400d81ed5a1e562755b5ae632df4a5841c3bd5857ae82ef0261d833c8e57b1b9911059857872dddb6b564e46ccd936fd5eae617438c4ac8c6e50692de21db7623bec201dca85eb2348bf6c0df8a9da9df545217b038bfb9669e895c684913ba00354342964bcab4099ae447916bbe68dee67deb5f32be60be7673e0691deca333dd6c27174fd527901ff33953ac5548af2e05a33ba3cdb964db575cf8e3debfb690a46feff4ea63fbeddbf99d009e39b9d55cbba56918782d46d205c0bfc39845862f52506d628476a949ee900359f54265de006116d59328cce30c5eec77e42f06ab0ccb22a54e0191019585c46ba4180d430e8d6800bfde284dfbd973a03704ef7a9bd54c0631b7d1818900337cf7b0837f6bd87da9ca348f6ee95dbf6308bddaacd1e83ffd2ce1e391be7a580473315a9b1f8da17f5e6b3a5fa6ec9bfe364f8375950fb399559fe64d190158b90bbc3e10173d20e5e391cc59d71437a90a915b3bd5fca1f6f90bad32d4bb6f6585363f8e52c0946b5dc70f8061171e39bda7b70964b61843a881eff3edbd26f9e47074b8e03716f58f825fce34e7e03b1d77862bb8e20159698f99f84643ae945cb807719c1bae79de969cd74afea53450a83ef971648e10fa7e25298db5deeef5c018693d847ac995270ab666bcf9656fd7490d620f271274d0194c912c02e7ab5f530def22f8b470d090aa69a7fa41c2a1e4908ab7c4cf29432c845e795b4d3a695ce6233de644793a1209c3ad3908f532f5ef5330441f341dd00e49706268ddfd77419113beb1f2b98d66ed1aba55bbad323ed4c51f57bc424fe3d30dc3bfd5ecf4678cdb23a9bc1de8523b4cacd95f12c808886ef6828e1f6885de5cb2f9a2bef29e52bcd1e990fdbaf4dac2a3a0c46efeb52eb01eeb58dcc60058bfc6ffcb98310dbff89a7b9988be7ea35f2776a14b96ec73cdf7de8758bf07b64c9feaf5d09c95679e570d821ca4859067e9bb2638db207b95ff35e7ea2977c361314c64f6614e2ac95ca36fa299c5e81ef32b0c3817ca633d33354c9c6ec21c429b03d870c9fd749db064e1e3d98c975f170cf5688091ddb2f980f522a29eb0d773c8ffae1d875158d8acf373a3093bf067ff10d12863711b8aed6f7cabeaf651e8f418275fffa8b317d691279099b24394199873463c8cb60d4bc6eca6a45cb11e1e220b1d4cff9310c6d2934929dcbebd023e7ae32dc3cdc661a22c46c48ce271333ff45e53e28961ba802b0c2a1c7d122669f5f62a3d7e29df9a2e1d54a5bad8b811e55f03e2853ee875dbb6d47420e81c79ff101ab5dd7537578697b63902bbb2ab6e641b72d2b4b3cbad608e362f0b1804cd7d9a694d29b2e47c51066b68e76629dbc5323225066f096366fe39b59b44b8602581820542d2acd55df8ca681434005cb355f5854d8ee4297a328a493a9c672bef644f3eed039fe223c73afb01b1cd7d7a704dee445014e82a6047e5f053f402e4de2ccb94bd11c7f1f0f241afcd15c133b6dee899d6f6b3f08536aa9991f266c631f648a7a4d04a8abc12d023a2daabc73032c68e2a2ea28200c05bd8e8e2f7385cedbffe90a3a6e23450a365e0fc2470943ed7a2ba202480951d6fa83707acf8fa6c4bf94dd33e2a628c9f41f2b9def17346a255c4045f299f667c6ce4e2fbdf68b186a18b28a9ee0cd43e8256616f053308d3e2d5fb0207946445525619bd043c3aedaab4b296704df1360d49fcf1750956965f0318f640e10748a77aa4d157a54609765c662fbb671f970a7d544d4d3afc03268b82d7ad5fae201a4ecbea9d2258ba7e01bea826e1761de5fc92a16bb977cb9e4ef3b54ccc7e780c159ceca11c9f81943dc024fe0ba286127f18bf4bbac38f32618ca59f3139b940cab1396477b599ebc00d8217e4b4ed6ed03efb3c625fafd12ad9a9cfaf6e8bcedb1183504fdaf1bc34220a12cfc667e5f2ae62df080846f462274f313e22af2c72206ec8e616cd2b0e9ebc85895cd2b8db7adabce212aa8137ac7700f53a576a2df9540621317f26b572ee908f96767683afacf86c42fc489c46a67b756f5e17e923b60159c9ac000b10cd282092926cfe52cb5a11f9c6cb7b64e696dcd7fd35343f1837664bb7108d15341fe84f3ddb2722c75259d5cedd661237b096ce3c2dcfef4a978f074fe6256efcb5c6a11b9acddad994e12e45021112edb8a7b92fc3e5c2963cd3b2445004f95a09a994444cb9e4a97dadf07d2e4bfd7edffa339ae27a0aaa7434d79b20feb3ba3ed7b6e744446e7c3615bd7b6594308702df722ab8b5ee416ad9bbf0c27c6114519c718d57aa9e1f3264c07c80a93e08975738f29acc76c4c21fc0320998892ace4087ce4f538f0b9b554943896262895c02789d251c8a3123975cc6992d14b460dad6ccef346b3a30a6a78220c75999222fad4a7a51a688d7d82eabf9d730260e2b308a06ae7dff59c3670c89e0f30c17ba30082396e253c562ef3aede6678cadc427116f2fbe2bdb8757abfc50ce6489b59f4134ea37260fa27db511952c0e0f625db78620ed6deda4de518c40758a577f7f17bdbe14a90939cb1809c6fab9be907e4cede8055e396ac759c21f75390374473d963437dc459bce71d7a42adab6650968c11c1846d86854c60d0268f59eb8c6e6224ca69e6a4c5a3c2b8bd5f3add6b99251d29b67a6c49c3e2806cd31a84aea378e179f0f533b6ba309733bd2a94c24b933739f8588569f0ce4e1e527473a932210132da3b1c08b408c4280cfd89dea9698f79b56c1c110b46eaddf87504b5db7f24a4c2570da9b46ce3abda2f33b82299ce1b236d80628bf9b764a09c9f52e3e89ae76de047f54da945661b3d246d9928dd92f0178583b7dc656d91f2a8d4ee8a396f34161aa6c56ee7c8e9ad617d7790792db4090795a01183644930a40135dec12707b80972ab384822c443c2ade7b8f95d3624bacc423b226218f6a49fae81d54f8f4e64ea532cefeb37a7fa3f49d8d5cfb42269708b65b7d8b7e325dacba1254d2b45ac3e733c2103a44763efd8513391bfefaf6fead34ab5cf36e6c57c930ab287ce5d6bf995c41b9c2343bc562e70bb8c9621b89a693a8e902af828a5f699928b5147fa3a716637c878c034b3ed38a8ec7781cee6f165ad21f294db22a33c5cf5fd59b145e1223dda2113878a9c706d31890e6f054d08665d059a8619abfa62b56d443dfb6df62812e2295e1814c508da8d25cc81020a7decae34f290f7a144e83f40e7054cb5d9eb76a6e9e17952ab60b8f8330906e854da430c815f400b711f1b57a35cb4d9b2940c65027197c4c370353e20eeceb049d91f0812ea5d109fba89a72a6d3359ca4d1ff1edba05fa6071308652e0811ddf5be3d879f4b90763ec88654e8b3c9b444d8cc5f72823e87e31e7c8d2f85335d718b519bb8bea59bf11b805f2e7997ff3b002ac8503997b009bd03b2619e728fa9e06364f646558945c527cb57f7639b99948a383dcb78df1efab2c34fc58acded3edd7b4b331810b39f1d8012f11b2f8622532565d79b24c0ce9522b0343db70dc342bd8de5df3c8e0d406b19d7bba4fc2e4a3fa6616a36ad82afec0af29399de3ec152e180b1088e53be740d26011f173e820f72732863b948d7f3c6238002627414f20c64038c8210bd8e6b9254e605cae46c72927b835792c3d90baf388451d4355f01f1a0eaa003c2042d716bf76794fd26a6f683d1b0b0e8f9757c258bd585b45ed10c56dfc12e26c970616d668e16a32922f21791e5755a65921825de4b096a8d8ab329939c1de7e58e2b839d874ccacfd1d56e6b85dc349871779decaafffb331d5138110633e110b71456f7caac46b18405cd4822b9f4e47f8eb916481e2dc00ff6411479c04d636ed0312f623ed6a83311f988b72d3092991523ed7072ba49fd98f7434e8eb1243b616d352d1a22ac81f5d7a140929b968737b999c1c1d4462dc308191a4a413fed8ac6287f5f460e81ba19d46bdc8e3216e004363fce6a46402d2d9c21a5a5bf2c00050d70f6bd279c9542442cc856ea7a4b0ee4dbd696893c9634039c0873a9456a6f5633871e12a17634c00ba8b78e9040f870eea8e9fb74d0d0f89ec34fd26260b24af0393dcdb913513fb0f63089b8b66e49ad14ae925702a10772824a3f324a006d29c12fba67947e6b6908fedcfd561df962b0aac3003862199a899e98300cb57f8111f70c7665d6c67f97b9dab7301af4abd66b7ad14001ab8b56b2b33407d1b474841c0925f7a339c8df0734484000cf82898e55ea1fa4999de2a8e6780dac3ec79dd47cbe5b03c878ac36a079697eac5ef59269b085e98d5edc2693649ede93975903fe9bd10defc84450e6bf6b78497e2d6e374ca96629a3b567875221c9044804b4400043df7767dcd900fbcdee28f4f5f6f714a7e8cb0aa73dcbe8be5016461390ce418f819359195372dd7ddacbbda3579d2b8298bb64ad018b1162cca400adcbce4cf8528c8be0c1d23680bfb0fb217abd51ff83e0257579ceb41331c9732b02dc216eaac566b5bb51e8b5a69f9eb34970e668de3dbbc7c932a2840f6528e9747ba645ebfa629f09d81d500f59ff0c2ac24bc8f1f954cfb91977cc2a60b352d763328cdfd0476e82a5e34817c93701f7937a4706363aa08db75622a647a3f1e1e664578e843b923257b9699a099092f93be774433fc6d696c9e70c40c94f2e277622afbbb9a82c694395686c54580d2027b6e1f5126a5259e7f3902c00ec185c864895aca399d8a53f9dbf35ea247f440744bd10e182399ac2015b09b62c18e0749bf017931abbda47cb87fd58e2f891165aa29b63aef15c5569cdfd8986f19a021b0239b19b9b5a78bf6b1f3b5cd5d2326810eb9cb476ee6f7e30ee460119d3762714f6125bf415907950dc4c7f33e9315e6115fcba2051b59f313ce3f5c03bc6df432ad2525561ebf03db7647228a7616c72d7f964a9ad66438ecd9084655e7ff4cde5995df52ffc82c189663e40e13db438f76b786d9dde75a7bf401d29e013c54b9baf62b467a8bf3182c3e41f137af32da7db9aaf19eae99e7565c9809978e2a1c204c5f04a227d598e14c334edc827f359582e7e559a534334e483252a5da37d2fa3f284f0a4767ff04419aa7f3a94495618fce69cd4fc8db929c23709d8a5b4d758dc678a4ec1355105ff6a7960270c2f8250e3e7cd7c50fe7017085f2c62f11b64740d33a2069ded1e4a568895a2bfbff652dc4d9f45270311b536245cf92e5a03776d80cb607f21be1bbda2940781ca5a1747170324882a04a8312c5c132aaa212d2b52c4a408843256abdc5ab26c5c389a3c330d9eb18f8bb55d68bec5dc04e2f008a52d4a325631d8c7df372f66e9c93d41487e19c18715fed28bbcdf1fea85a1cc3b46f4d28b82bb088d65628c588034cf9db8f0d9c33eb3cf45653fe3f9799bedcebf8ac848235e84816406a1155dfc43087adbf230ed51dfc464b5ef4078d21dbbc7fd78b123c23d30fca22db366044532598eb1b2acb7955b2ec60a4257c89ad6ff35dfafa3f65f393063757d47575e6b783b442e854425040f96356695051480c1defa9094a63a273ec3cacc67f182d02c80cbb209b1f031e07b14ddcb370f2991976e8c4fe5dfd90113f4877eaabd245276b41be9ff5befb6a601d9bd64f4883db41f905812b24d87ef3b6d7edfebcb8e4156c50fd3b9fe11c15d129b9c45a526300f4f54a53cdffc34f63a62084e2aaa043a51b5d5cf9d4b1ad0885bc48e9114ecdb9e5d459508091e1d0a4ab7ce9a09cc734c4c100244c59e29ea592a732434e5877fb8008b4907d3601a8263e7dea6ce64c4cf6d9fdf31ac600ef9031cfd704d11f4fb3d14eb69fdb79337117223f2b053a79eb7670978ba8f46c86d712a588695218dd42330e59add1659b769cd8ba3a1b8e48572ee082d243a59bfd09025ea866b5fea258f40572d4aece14b3f48caf333ec99e694ab1b80fbfe37bb22c7093499752fc24fb126b2092a9b3fe1d0c21fe76aba3206db6c26a06ec027ffa620f512d8aa39f3d33d0a0a95d23d595a97c693372f81ba67c55fb8a4cbaae4383f0502da2868cd080125b3da02b98d3596eecb94e4e5107023854e29805ac6d3f3d82a811aeb137ec5832df60cfd55659664b6fc561975c8af4379e4e9272b185ff315313328204c0e534fc5cc56aae3e213abf54282e95317acaa658336d732a6826480ec92cea6faa5ea74cadcad0c02bdf4550fba2b964707d85b5b6b2841f3f2b89e0ec85815be464b630794524ae759ab12f1dd51d46b8de38451f4667a09ef9b13cbf783baa350891e983aaba77ed6244e1e6e2173dd08fe756ae000dc97fe10b1dbab48712e05edd2975b75a51af43bf482f94ef7e6b402f6d8759bf5248bb86f1640561538583d556fddd64939647869a3cbd488b4a53b8c9be30ec7d4520b5671574c86fb3b063dc45876bb1dd412de6f52a6dd60b14f4147af5e956bfe6dfa3c5404079c3785a86fc71d2d5496edea8cae653f30a9cf95b1c793692605e22c3e133d2976477f41c50845ade6640eb93ad1c92ecb30bdc2b413393259eec880c97c287db6fa4ab59ad86826d1b0bdb148a846c1f5adeb9ecbfa6a5d663ab9ed62ea1756dba19801b176b575ebe7e4d061112884677fac4638f6c510ecee18a8b4d8509bde8714668233bfd9cc9ce06fac91297d2ab6b99802139a6a6c5ee2c4942984d1231258b3df2d153eda396244562b569eabfce5e1b4458616ead101754dacd0d2858cbde4f2be3d1dba726c15372a9837d7788760ec48734fa3e0650e8727376edea9449b100714e63893749396ff97859f186ebad5d1655f32abda83bb51aa87efbe70d21b69ae20d3b65b6cff71d00df430c158026498af11befcae316220bd4664d9ad4714ba1739988d36a2a19adcf41533c64621f8b65e9e6ba6c4e7f6d26928450b4519845d256f6d72f8b645b943db199b308593111d0b00af8eb706a4516a4beee1bf67328db967506716b4aa2f5b7dc52cb40e4a25659dca9ca3d8279f60052f142fb3bede37f09a86a53aeadff0c63219b04257b498dd06cb21f7318d178be6c592c435f61db3fcbfb8bf002b48d4920289103ba1eae734ee0f55c55c16d59bab4e6a3877cdcfc43ac62d223a8571baacfddcc27918721da9589038ff4f56e39166f78235bf2f086429551c565a7f32733461d031267f29993b66eb17a24f95dae402552d549f6ec217316cd96172f1c395d5182185d2c4af82ad423a519c705d1b8150b11f51209ff38e3780a9b9e30449c0156cdbc96c0b349cb2014af69c2ee9ec7a15c0e6be74c85fa2a4c8f6decdac5f7106db568571c9d73f669fb22a82abb7c351cdda1694724162d0a7ed6bfeb3a02fddf4e3b3196c67d2f7fa22ec80aa4848b52dcdacf3d27cf8121d4d1e85974d5758e0316ce27c09b00e977860","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
