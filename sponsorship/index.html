<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"612ada5e01dadeb3262410a57398b55f80bfdd46f9a51c139c8cd13356579e721f3a9443e80e8d071c3ba0e26380962c9bc9d3b323020518c7ad82ccc8b38709c1e6aa89ee489b5992ce7336a80c1499cd7e04cb93b2f5a40f209a6ca4b734790b0486cb4301e355d66df30c891de7108186a3ccce588032d9b3f22ad8d26cf9b2259acfe4f32aae743fcbec96daa7acab3a8e8d2ec67d4eb7f9cf91059008d581c0ecd8cea004046ced1226b6394418b478cb7c3198173fdc13c6e98be13eabba7942b3efc559a0543169f80b5999911d1250dc98c7d8d79d31685feec2610a177b3950b794c1d0b02a886992995f6d539b719e1845264cd37e51b256dc281bf1d5d2efd709495fcd83e02d0901dce881b77a1614c3da445c2602fe24160ad5c61836287a93e60bbe243b9322fe9fe69c927063fbb20c03e6d81b5f09b1ce8fe6afc608b0b5bf14954185b5289102dd07f97fd9bec25f3354b2e64b295ce2633ae13f6d6cdc4908767fefdaa2f7a84becb9992ad6931c5fd363454aa004b9ae04f5fdc1d2c46d8b0e8da81b4555871d940179a030c646cf92ccf6490a1339e2b2b5902f7cc54adf950b5bbfeedb80c75e81e67caef5d5cb44a903acff0456c82bc9c15ee05e3f989e0227583021643daca45378add9699b5691ec317d7b609e84ac87fb21c348c1052743c01d949c699c7b0ba06ff57c42549dbaa29c5f9d2a885129e05f9a239ac1dbb6da2a060fbdbab362d0da7b3b3829a8739694a499154fef74657b8e13106c7fbf32af0cd5edb768bc27a813bd665c07b8c1d3c8eef98702a5178edbd2eef09489c1dc080f241c10e5b65e02d8479dbb4b3f7bd80dbf1b06ac9924aaf5ce4bc411975d908ef5659eeabb72881d314ba7d4c345fc1543cde0bf5433200ca4777e4127a1abf84f8f2d8b4897f60808687b6cc2cf5a03b62120cbdd4288897ef30a0ce74766bde5fc39f5acd854a23fd9a0e4ba506a254fa1808af9ec653d30457eee06c3512e17e685d87be31f65b1792b472d768862532431b20ee0bc9d3ae4f853c6f8511ff351c406c0855c41167458a96261bc1611e6bbb33e5f7ab6908599cd9972a1ac7fce0153144c36db821e76af6eea499f12afa34fe7ae785c5016c0f295c617a566def5dfe091d1a4d0b6d3ffa473f15f03c777af064c2a0ad4a89b93cfe21cb245399264a281d0d9b9888b427793ac6d22f7edc1fba6a19945a407b6e393e33201f038fd8f6c3b3c745f0e4c177a2ccc80ee921d7e50bec07f3d16a40ea5822335e7e2f2bb0ade7c07a935817f2e24ded97ee830706e2fd318b8546c3efe5e8cc15840b85c5800297b2053da2d9d6b10939bdef717517b4ec3a00984dc62b18b57ada713e98c8a116d2f7693322027a6bd69a3b0441c8cdc047c2bd8d1e700a59db9ab2564ca66b0aef2fe6a8bd7b5de0ee0b8d24bbf8d9ce294b86ee306ffbfba657a8a229ef18d53dc3647cfed8459633ab3b0a92a5944025fc4b1682b583bd20644ad90254c82ae33d6d5036149f306dc7c50b5d8933cc90813b53a1e5ab9f11cf8b87008a1d002d9575a487e7737468e3315c48b9e4b413b7b694aa2332b31d71dff520794f7618216c0346fef6611fa5dbb54d3522b33bdb723462d6471db3c2bf178acdc321da0ff196a5fb613e7eb851ec91f94d353a01aaca3c99b37022d39df472da44e2511022ce2ca0aa916c4e06e51b1c43edd4729c9ee94348a4c75f5f5418fa96b6ca6a4c41aa64e0e55ec00b96b03ce2801a32f9eebdea0c1f69e29abd5a6f3082e8728861473987ec3cca6ff76ddcdce0c9cef1bbc83e2902af5eb39e14ee859c7ef41c619ed81a06f2467343b84f31b6e7be6718da703f6fa424403cab2b32ecdb15db782810e76560639b5afcfc3100ebc09d700706d345b1a71b9780e399b06ccf1306710bbb95fefd01cc51654df90fe4c96dd230dad41ea1d57a2158e384583f27eccf98d5ae39e8461ccf2eff8c20c5b4c633b7bc962e8cc68b577d19b2fca420fb9be16c82d52c394e9a0b91d7e9180dfe14044984d153f0c7bcada7165b9ca3f91efda38765d18c26ae5a10a0fb17cb438d3375f8a5be7baec0fd0a657650dbaf4d4f2264f2e47e55d0a2e791571e267fccab339d9d905d1d3c12ff8c6f79c7f37c9c7557b51584957da9ecce918c6eb9d97c6db3495916bd8e8b338dabd7cad160cf7c45d9509fa44fc80e6f100f704ccecf4a0d872eeaecd149cd942e3261b57e60098ac8d726733611f409499be49579809fb12296b320001cc6a1caf2bb0df2dddf68389d9f76a79009aa5b5f412ab289bf067046835f44672c9540c410ebd989eb9336e123c202eb8ef7d7ad1e56e5529716b0d98c006b6db982c62e9eb684c7cbdf5f274cabe248ec107dcce5a5d9dba8901ec667c5b1262b3f9893f974941c0c95a143fa6f097b0b331c1fd7d3c015d79b44fa5823b85566f2a645ddd6d8159e0f94306490ebc550aafa7225733e38085ce8a4d9a6cdae9f19eba75b4d045911f6695f393da0ff74fcea717fc9a533235ebf8e57a045f5315b3ba603ec0e0936f10f2054d9d1a425eac91598052ccce2fd748fd5ac44694bb8ed58edd2276c490997fb64e8f65e57252b4547132feca37fd1c9fc262425a6f6f135fb0e0d632b046d8018a7fa72d07f506dce75317ab3873cb213401a15f23e60b3ef4b01579a7fe26c81fa66c6615b4c83b68207c9cdb1351b061449caaf4670cffeb222d66d6730713fe05243f1dac62b60f0a51c27d0623065202f6c2e5b62207a4927e154dffc424c0ef8ccaeaba439a5accaf182bdca3a32678350b393b0a1f80d47a297614cfd9bef1b16b4e464ca2e8bfbe244fba121b3616b01b028e41fa77b8f71eababb06be110f58b54c7669cd040cb8e6638f8b83bee80a6106981173405a2cb59db3fed5a9df987f271969d9c4c890db7ec91e8ccaa9d16cfcfd16bbfc43eb481610ab302b3aceaab218158998efc3fa52b00859b13ce6482c8962da0a38756587f39facca2e3cc303c06f25e119986857a75e8cfb668a3e8c1cdec335d293d42a4d43071b694771573652570be2e44e69a09d1967596775743c52f84053eb5936128cd2315e013b8d705f0d007eed3ea422293ad4156f3870ad789ae728337e78899f1dcfdcfebcacf233016c9688456e77311cdaeda36241f86d1006aab5113531a1082ede8b5379ea20fe4d76f87eb144078e56fbf2f0545b1f074ea9146d4959f957c190c8f5050779621f41bbec94c41be4d0dc04ebee4b58021dcdbd9852a75c192e784aecd4d7ca0d101913fb403dcbf236452e9731d6526c3497e5c0cd903c5363f59b0871d98ee870e67e9cf05f603a5be1566c702b71883927441a82b27770b7e852225e225faa68634b138290bde68e4b8d8fda7093d175c1abf069f77e7b4de6c492e6e83a7a9f2eaad82efdbaacd44e454082fc013c3d6d51baf1f3504607c3536d3901005b7315fb224e3be56225422bf27a8f6ff4cc210d89accafd3178419a5775a546075a8141912a85b72d8b3edb87b2876fe9e2130a48590f606698f9cdca9026cb9fb0c5545498536b8fab75bc2b86763334668643a4626f55597862dcfb02d362d83538d8c5d37ef95ac763b8200a2f39693ea6ec8799c19a61cafcb9a083b510873ace47ed6d5edcd33f739ed1752e2042b41d943ca0928e194d51501d057f35a052acacff021560fd9a5c8079f8f00f36f6b061249ef9304179f52cfb41b39b3a751c3b2930aa3934938bfc1f4788d89c8bcb8e6dc394f57265673d3e4c4854cedee2223522937485c28104928841c6c544a278dc94a6a2ad963eaf431afef8e1341cb0453b6d6bc70be91c4535a9ed050280fe7bef260ba8fd457dee8daa75e110e770038beaa291207f1510eab09e7178cb9e14f2ee0d7cc5e0c807a67314de2a2090cc3ae40013e354ea85ff1a8eda455c1f343c720805318653096af85290ccd27b7f0a4470a2063ce3229f0ad82384485b9d90ae9d58ba2a3af1356cd4d0d468d8802096ec6da81e9318ee438e03d1779320c79530b8d3905f5d491d1bb59a34681c1bd8af91768014451c9de774114b83cb6603bf620447e9b3f2131da45ecc51deed17eb0cc5fc9b46133807cb3e3232ef0c3cd60943f45f48b3712f54edf9c1d4c07b69e79527b414a3b26772e15a27d3e37017472f30c13a70421ae98a3b2a45870893e499b2b7cfa32d2b0ded5c8660dd1ada4934f141393bb64dd667685dc9fcbc12dbfc90b52f1e521a97161ddff249097a50b12674ee7c5a3177c0f1b471893ab451339176e18e1c2928c2950982b723fbe771c775fb14ad32f9f2688682c1e2b0e7a70c5f6618a6cf6e272e9f2c3b37939bc82e32d99f06d8039dd1f1360ebe1c31636f64cbd12801cdeb46da5477285e668198b337ec2849e9975868c37af22d19db43b5b377d998dc07bcd48db5b1f6aff580a9341e6d8176e225755d8dc05390af10f756ad267aa1d2d9915998cc6d70cb9067d759783b32c00106e60d20f6fbdb345495fb5befe07af7f7989a16ff3636f74c1617a55d55889d9ac3a10538c2660cb4cf5d896f36c7e3657ea55f34077a5f95e89d8e19b10f365913c90278538c2a1d218a351e3a114e2aab6e0e63c390972d10c01dc5bdf8e1147b75caadaf2d2ab2531d154450abf52bad407b6cc2e844d9b9e68768f7fc4186789c90a9a0c99fc43ac27145942a2c2d55500a410e23049469bfd41fb2e1ed3d89f604d5b601ffeeab8a12bbaa5f5081e7840362e5055ad5a0890692dd9993dbc460356d9f80e5a2c9827de22bd29c533902aa73da4dd1313436660581580071964ad1449959db80681b6ad526f1b13cfa5aa6bf2d633976a08b21716ade0511e66b562683451a242932a43b33c36fc4bbecfeb51eed1bc84e1491827826b35ab1dd33ca6fc2ae126d2e401f09ecaee050d2c626536a1547966ca4004ce18f6a82bdb21fa1785c02ab75989500179bc209eb83dd20a3ddc9e3debfe6de4a16a16936ed05b2c72c4d8ce4fb902bc6b5cb5b327ce82d0614b9a24d44d6691b96b1e5a64d7c1baa6b1e1f075c290ce0f5d8458ba04a7b23165c03d12feb6945129d298c350eb5d343d9fd00920360a4abca3681c2bb03390c688dff9df0d982bb57b3c34cf5f19fbd0e30ebfe8a694e04dbca0f835b6c90674ea9e056cf1ccf840e9dfec1ffc434687a451a04a248e70e8869d233a8745e3e031e6eae33268f2ceb77af7766116e1a8802bd140300d7c5c1c3a640190be6f301eafd3f92cbdca4ac6084da504de8f0159de386fe021bb99dadd863b11fec505098f560fd8393b1842d7da5ce261fb3d738021fea34aba611a36315749acbc8e461202f2b120c5db9dd725d8009094f2222361bf3a330de18a5bd789025199c629cff12bae5334ca8d8daf2b23f161be618ef12e4d2851a644a85ce9233a57651d5565279d991b946fea78e1f0508caac33a9d83f8ae9ad463168511013886c82ba9ca06919a520aab185fad2cf5160deaacdb107cd0a16344f869a88f35cc9f9b1180a892c5b4ce85a73c209ae667c3384d126a434afcd667b092365348e05d89d4eb16f8264204777ee3a8ef43bbdd44087cd068d680ca1b93dacdb44b84322b827a0b0ece6fc3b0e2e52e42494d670ea17b6446b554e49951e79326ac75ef7569661b865e54d2ca22357d9a5e57882263013654117dbe791e601fbb0830d5f89051ceb727945ac44138bc9ffa55e1978811a42462315c201dc068188cc9d5d6fe2be96e64b03848d21554fdee49cc99dbb09d40a2db28dc15144db470d2eb1ff86fcdc9c7b672f655e213391525f6c2e6480d81c827545617ce1d130d1d4127e296774551713f2d06dbed80279e99d9df91a4cb10930f71e4ac6fdae8d469cd968b9761f47c895bb19f00eaff61f3340109872aae2cca7956641e7982d813e0568397b1170e382e9b0e9db6a7484bddebefbde718b7820b6f9cf23ffe72caf3e654adab1fee12b98e282a4ee0e3725d5e0e8177b25663d6057016bc542f491ead13b45f89db0f30b68df09a4537ab7d317012100c4ce2396bb50e483839ba065e9df03a739aa9caaf10e4e5d26b4cf7d2f7419d09b612eeb87556306ffc2864404497aa63dfd0e65bd5aacbf5ac6d3c9298d06ed36faf6f5366b62d99792814a5ee2ea9def27fd8b95224bee0b15109dd996525b8fe5e3506f4145d9c3dfb81b5e8c5a932183f06451eefdf2a62a277bb616f7fee2514d13056428d0450acdddf34f9cb9716998207e9cdde358daf60d8ca32edf02c5640669f89afe20a8e2f00769fcfe9ff8bb471c2dd4434ff54025d0403d5cefec4a8b21e73ffb8b778d522e688f7b44108709d6ba494b3d8908e9363e5ad4d79732d2f27bdcc532774dbb58bfad49df91d5a52dcbdf68c29e801214e087042939c39467e8d844a3bf6a90d53ec8dbba85544d1c254a7d4f7add3fb8914d4854590ad9980b11b1b2ca7d3a9f11a47ee546e4df76025d6b38e95c90dbc2eb650071316e9ac49371d7282b7df85ea7e89ebc249382e80bc58da408972b00bdcacdcb14c1139d53c021844bbff326d63cc8d8dbe09c9fdc335e023523ed89bad780a23a6af94a1221a8889f908890ebf812beaccbc63167b5fc50db881c196069f7f2031ed97841922c65f3d5e89d60055cded758161f8f72a93c96b19447b01cc0c174267088751fe834e5040bff9a42e1ee0072aca2a257b4cb23ff11ca6af8bba0b5b6b1ee33f5dd0bbc1c37b7caa28db69a3973d2694d8e35c40338948e1fe1e54ce618caed3d16113c888828d0703b25f7bf267412a081c57cd63d2492fc993e38356f7a0851751f4dd860080952dcaa721acced92f9f82b45b4f7928c137d91dfbe4bf39763c4d639a9d4df3d15ddb7510a87501bb7ca100786d8a011050260ffa31e5960493e664cb81481ce2fe6a0653f3e401cbf1748832bc98ebc42d558bdb5440289cc22770460477818964850683e069a892de4e1c89264ee4dcc6bb48cc6e65e36ee153e16c6ba2be2f466d7036def096774184701769be7f0ced2102eb1795a45039240ac3e0b043b533263e63c26e76ca9737fa26395900ebdfc35ae334383259170e5470e5ac1bee95bd4c9bab162317ef4652e8511fc3c6a4a5fbdbfd22310edf251de13a1f445e1e7d6b145a47709875c3094e00348fdf579e354fcdc6ac5b100f039ed130a4529f0ecd943350cb62e6c8c1ea5f263f2e8c1f36acdd182ec5c129cdbda81f935d598c36fa4121e702bb1ae422f770cf5ed7918497195adee86dfc782bae6752b8d87d373910a95bd4f03f8ab8138b9cfaa497e662b9e0ac8461b988aec251291eeb20019dc2d9d0a6eead8039938a42ea67e41d56f55b7c439b7639e4cf9816531ab90f9d68a9fe3696d287ed1dccb4727dbac96d6bcf934987fcc05ee7f92384128aa3494ee3d817574857e1f7a75e260575cacb635d701ea805c106ede2f8c2836c02ef6d74d859fb11e1a81b3eb3a494162fd3cd0ae855ba2c1d7181757508c602bcffc60256b27f26a28686f18100a79aa27d21909e208aae918339e63e9c657b36086d5b6a2ca1817acb0d84d3c75372ecd32c4e768d06171c2ffb87476d4d467d1f3d332ac3dc131470a6067cd0e08981ab92201eac1901b04f07c150cd3ad00f87ddffdaeb257459756c8d940d215bb75971597e561100b2dbb0020bca2eaee8e94b04a25d98d9562cef4e9851a0342453c0c54b09c67cd93d1c4f77002c5f83392d104faa1ccf6f34e25996eb4212a1f2578e8d281ba429e4ce43f3715d58706ae2ce1316baee7ce3c9759a813b2baaea38683fcf457837f7054811f73ee9fe69b7c6e7ccd661d2fab034301e6624294876e081ad730856e43541ad403fe564069d91ae2d14633c3c6bde5ca1d807b0221a5c3f6990c3e140b757628b073e3bd903b425ed1ae44329d9297e940bec2917dc0791c2a6305cdc9f55ed85004fb157b9b132476d4d2ba0ba5f4682b3d51289ef0fd49a9bc233fffb5c9f9c958760e0e5de4e048cd287a466f5d1bd1793450f46967806a1c95a8572a93cb6cb844dce916e035aeb92a2cced4ed17f63bb4f688c9c876a39197294f50048be10f6e5f242f928d11a7df43367db334387fca45f2df5c91aefb74c2c2494edf7a21ecf0c2093b57419a4fd96cef648463fa48a261e9ffc3d15fbd676150c38f32413023da45b94e1b8a6d744c31c15bc55c313707b94e0066e3d54387765355c4c2c0150c040b824f13a3ecdb3dc4ff69115ee0023439ec904e5ff4ca9d7db103a71edcc921bd148851459c58a59c75c20f3081dd178fa17a824b14f8fbd86e29e0d2a6f75002f8c1b27d13e369805bd0ebcb8d4cb9fb5ed88da55109725df33709f05e2b02a203b0d2641b837cb3163b21818d1f7de6f7898af77ac12cac2bd41b48369cf7bafd2db75a02152ce0f22fb43f6a373e285f1aca803e091eb941a7b919f68c702f653d92390cc40d4b51e9ebf58a6583d7483778e437a0761cf6f9c7799ff8575fa23310697a93a89704c5e6db370eacc7d71f277e749f169148367394958c119d278be456bc345085d80ccac30da46e09d2e3828996792c23feab239a5e4e353c5aab2c731958fbeab3cc52113b5ef5688b9122d0a1f271540dfa13d9fe8a1255d9b54f64a50e5e0b6e207d4b0546de4ca10ae1e8a93d17f22fe1a8eca2446d129f42b1b0ce03b3926f40ce346d7cd5a304d33521c07adeb32bd0850dbe7b4a6cef1baa6471dd21522f9ae429672bae2f8f6f06e25164bdb2b94a892a4fa457fe933800b07b4d3df467187ff2cb1bcac2d9b67b38a42fdce48699f5abf4b57a9ea04c744352ed2150d1d8bcf6bf0ea10a9fa70c587c2e6f7bcf478ec3bc2efbaf8dfd11686828d0e3bcaf989fc620f053d6b78f47421275d4c5180cbadf5351f42b1ccf5a3dd5e1ed0f29b5b0ec0ed697763f26e85d1be412bf316f6d963f22240aae90e6a581f396e7df26246410ed18aa3c5b1ca23242ac8f13cefc9419cc5687a1c5ed5ee9bc5923854bb04390835f538da522b78c78cb088a1ebfb9b6849dab39a358c87b1b6fe0def3566f97752fd7d2a23c0912aa13ab88824a906936f9e17c8c9a6d6824ba14ea63bd892f06e8dab4c04e03ca7c464bcb34f510619499e62fc0e307bc7aa59517bb0f6f75f167b696f3ffa4f67544bb5e72c4b2f5d45da75f336d00910ce1b143057a2fcd389149519a20b233f4feb1e19ea670302347c1a547102d1db85a4445ee390a846be7c5c3d210473fe7a725965e96d897a8c4ae62ff0609d867a0b2d4bfb30dd862e6b64499d24c4e16dbcaa669b10bf7e594becb72d46658d55c8bb8d961b3e9c9a07bb915f57b74bf79453d828b2e4be4ef315fd0e4233502ba6d8c2795d4474e503e4ecb79cca6b2ae6448041f7b777ab37a3f1dff0cdcdeda6c08bd77ce3219258f86658205367b2ba50f766c0c8ab6e7f137df9409be37ea9d66e0ca37c1b87884556f6b6a3d636c852cff4c22e9f0a9942b34195d32ddea84bd457c11bfa3840392bb0764a72d7e86789b1de52d641c9e4404ab56c0bac493a46b2f0d0e2ab4370afa116acadb5f3823a1e28dccb23ace7700525ed1d055caaad5298dc9c4c07e557c4b9df01b30543707eae914ecc7d1a0b4ce39485f0bcf8277179956e0139fb816b259fe5b3ddb0039ee9f1c6978af3008da842132a118952cba63680230c9e7a7a0024e07b6b0b1052a2852062e31fa776564c8fc49293b5e30434879bc8213ac361e8223c7dc595568fe0e6d43ed8a584b22f1ac2122f0040f7601b382f75c58311a2eab6bc85a0cd36d023fe24528117c05c7871b9f37f8194196517b53326c71369237b8c59be8c9df8b79acd7ee63c4d724c70a483b892260573af67a028056b1836544c0bb1ebbcbdb95581d34869fbc68658445527f159d2dd694d265e541f555ac14daf15df8110141b9f517cee21cb1327ec1578dc8ab58db1782ad30f9ee75694e3925a2ea414b86e3ff5d7233bb1b3591f2ab7818df5d851da4834123bacda5409e2b2a300cf8a0a7e492c0e757001f5edaf1c32faf3b0328d94976a09a88e9f400b147045161e02e518906281df34cafd2665c460b9c6543259fb970f484d6ac7b1ff667606668cae27241e395dcd88dee74cf401533b897d43d54b404d2b74b37f6a902eaff69f5ade380ced9b7c262fdefb7cb7381740bc651099fd9f98558fa45248f494cd90644d5074ae29e0915e9c60bceb99ce6bd767e0e41143ba2da3d4d07b163ef1b1303f57c77e1f3644494c2f72307971beae8a1dc9246d6e227a351fcb9eddb16557fcabd44521a802b4517c14571e28e6e45942183241edae7de1dc65262afed08c6dea81f5551cb09c7460ff8d6fa804a4e8ca686997878db0242566da98f5fff3ed476892500ccc36ad1c6e67bdf4e4ec2e1a6bc0fbb74e74fa9260840634ccd0ef24177ed7ca35dbf318a2056a6161df454225e392b3306402f2e198191ef5572364b10d9c25bf4acd0581d530af65d02a13b9e2b0f3904735236ad8d549f387c00d5c90b8d1c522b61f01716dda4f664b8dd7a4075620d91b868707e96a7919767a42f211c53e408a243a67874405092a2d462ccfdabcf27aa762facfc897f1b2e1ec8eaa5859ba7a573b9b71bdf82ae4a3f8f41f420bdaaa7753f43b58dd1cb95e9a8bfb0c1bf9e46b91f102ec7d5bf96240157c5add731bd62e2d46b74d28e18a7f50c87f5664d035e877e5103a1fb9484511db7ffe510d5df1948f11ab534b29ba8980343ff8a2c7e30ddf917e751a9f8fc14ea9e9258a2f6ffeadd58bb28eb9eb9049941c9a830a73ac46a94b88eb77735ffe9b50b9b2dfb3d3a4b1bc65b6f88d63b41c3120a10f6b4126bd37842c1efc8102752b35ce404ba4fa73dba9d28859413bfe7b2c1a4473ca4b4996868b0a378010c4c8f9272f3b30e4ccf8b73affe2ba67481158f852d8a18a533576756fa2bed7450f5c5f60be30277f2a73663a33e12becfaa1c946244908df1d944d5cf028445a0bb86568a50e9485c0b323777338b08f106f2d31474a53b6f7fa50bb8aeb7f9794ad2f3d27753b35a6b0eb4a6c484a5a71fe0fb83af64bbe376f2859c6000095355b4cd9324d5e7539d409820b411f8b66911201e4d946333a54349c25bbf14a696040a9c00c15426a4942a907bbeb0857f2d2f57d682f37a47a74a504ce776a7e88ab3c3ecee0b05460da1975c7ef6f77c8caf51a9f8492017feaa0e461a095803a860398f7c8e8a8a45ea864350a233d8a66762ea03aa1ec2c571f8915bef0c3a6ceb130e205ec9e20620882112585c55d7b0f31d605b1bac077a3fb02f8884b6a106956ad127cd6d30b30a6a5bf1ddfae37d84e833c2f2bffb2d511d5e147b8bdacb0ab37bd183c464f3d41682ba42d02a5fff3b316bbd88bb500c6da5c5243e46124b74de0885ca8b507aadd0a4094ebd42497d766cc39596bbd3d81aa41e970969f261f01a5ba44aaa5746fcd8dc5dab6f555447d047f4ca7312536061b25ccea72bf42f5a5fba165ee429b4f7c70ca0f163c6694ea09de1611976d560465bf921ab9ac7e775580e92cf2b2afbe60bbe16d6db100149d4faf4cb495db384e4a8b6c3a6c2767c80998cf88202cdc5edeb04147a294b0a72d23a81fbdc0c5434132222d20a0a9e09c0cff8161ac54bd43a3b3037c148ad80b628bb173617afd6c3907014c78fb98e47997b5d4c36a967588262b07c26ce03cb7d3a37de70544dd35f73962bf1d711a555ae263014bd0719469b7c42e6d16405e93e4702fef02124e773b01328644352c6202929a2931ee74eff381ee3386ea8c4d4fb1e20c92c83345ccb07dd89898fd34adbd784bd6da2010565556105264d2b51f8849efb48179aa88f00b9d73cd1c0831e53b72a04ff15a39f9929b62fb4f5d71e684ee4e23759aa287a8ef772cbb2df5e322a63445b0c58269d5d31ac86023ce7f7cd138ecedd5772ac67238e2d8a329f0f9a7f21f7520e8628271b9ca456db0ed4f96b838057ee7aa35dc76d6df45f507b1a3c074f3242c2c0ae6143aed5e5c28268b4f08e93c553251a0f51c47af835e2c6407d5ade9ea8d7143bcf9427f142ef974e7949d6dc0f39ca42a1833a3c79170871d0725b062301900c210c813786af902921d2e8f01708b7a13c362cc57a4e64efe0ef30a58a2ade640f4280e30828345e679c2d0dff1e7edf39486131f08ea69c072af338efcd64a942c38ed36d1336fee2159647cfd938646b84bba70aac42c5370f261f5ab234b8b1ecc67c6e3d8dafa292252d5dde59b32af331a1b13bd9e54352f49d644fb90a98619c78a8b36276894c88e5d3e2810d68a9f2d4acf18f72016e2bc69d4bc47684863e4a807e0521f1b5f8eff53f4a00661d52c288c0e565f88964d8fb6277f7b17be5b7c65b1c109df720897bb2e917906454de853659dfd7c26d99bc3e185ae8b5ea4b383d2864c6ded4a11b933372f515586e988fa9fea5ec193fda5c9420eb542a27c8f14c7aeb3507d5e3f103d10f3596796320b7d8d9fea87c067700fe8d74fbd6e613a67e5359d65df79565c0767f2c5f69f0e5612f0621e0a55dcf397469c25ae3d6f926de6f5d16cb8b860eb0358af4fe5901f5185571981ad6940368728b4336a8f4075d74125b9829feef3bf86e257fcd951160c1b152e8481ad27aae985386584c6741cdf8348d041aeecf2987187673749f18f4429655b0a72d0fcb1a5c66198b82f7fe7c2597ee96288d4dd83c9db80f60deaec8932638408c1546014b2f5f5b2dde8ab4a55e3253b2adeb3c9ddaeb337b47f360f9289ee69ee8192db8d3941c2449fc64f40b0bc0482e50e8adf711a79a92ca4d822566b36a70e41c6ea2f106bd4d4dad0f5e5083ec9c09d6507efd3c36a819bc3c192cfb5c3d8ea3ab113a863f6f513bf0f63b1249855a87661fe71e24b4219a287aeadc46a7d1ae8002ff098f67904b1202cb2a7066bafea578dc9d2ac6ba139e9497597214f9719d3c6c4a3b8bbce1b3883cfebb86bc2f421e36a640e1e168f721d095278cfed61841b59645b5dcb4daf91a89a8439aee86d7b51d43c75fe2ff57dadbaf33b403a83d20f043cf99b492684f28e6d2ef95807d9f4376064886792e2bbfe1a384ab666702bbe10715df335c5b9bd8e802dda6421ef4f2995b3bf439b40acc358e8cdc9a0877117ebf99d6cd683e761d15feb48cffad0595104ced876ec0b43bef4d20892aac16a5ead4985608b39e4a42716a2718d87a43b3b393aebecab1f9a66a9928f6ff0ba1fb4f459fbf51c70437e8e84115b71948be9177caf637af63c3aad1d8b827b9d8d46d6d6cc08a50a3eff3bfd7169f0b42b0c9b1cdbaf18438039d5d9862fab23ee76e8d87bcc997ba04431a5d30df92f3786b737d360829798995dbaad851336fcb35f91e3414b23633052c7aa6cef7956d2e37c5ac800b406f7e05b8d1161ea241987a3b18c2822d371aecbdb0f9c1b649306434f133007ae28c9dffda246686b620648ff5bab01c4000043d38ff532cfde64888d029b3930ed2a7f5a7c9f5afa8c6c89df068a51767337bd8bc34c386cadc4c483f98d8d8124ce62843bb1253e711adeb1d3289b5fe26615b25874fe98070a5a4bbf33fbfa8ff3cdc8ecfe63103b32b85581fa2d7608871ac0ff3cc94fcc9a061a5bd77c8d5bc3e3db03cdffeb267dfa46ac19f5aeee5a88f91729fde361b2c09f2ebbbae9d8cddfc951f3088ae417b5f2f85217602279737bd39dc3e08786da10778a994e96308290fc80eff581ba23f9022f3f066f0b633530ba0a30987f627d1df9ea39eea3da829511ac5d2839bf64a673e5aa9b422cad2a1644d2fd91650f532a65f34a2cadf3c6d5f20d7eda4dcf8154852607499785f65027943306ec8656280cce15095445b0ac4ad5776285720d60a77d826c7e16138de0870a351a137dc52e4dfe162e1cf13b74ecb8dbd905fe2c70df72cb86b77737143cb9de9e3e5ea6c4034eb79cd1427d9f43239c25ba5a288c29af8ff0dcf7914c2507b77abee23dcfece46d91c11f31e0ea7a1bca14d96934db01f3f042a73ab8f4f75ec3cc01f89b15ae0d507492bdb73336413be1b9994393eb92aad969c306acebf066070d916a6538d112ab66aced5ae28cdf6d09202b58bf29f6b4231e71e6a4fdea2c4973bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
