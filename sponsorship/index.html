<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c3ffbd76650407083ec909ae767a70f7a75f52659abfdee400dd44587e10d5ae08e76ba54082a33b9e6241683d3c5734735e8d9c60a7597b438e14f61054bd490d8da853a2533c54f2700dda4ca99f975749d7c0cd7411849973ce04895a9b3bc13418e2cacdbbd34a576047c8af020076c95ef092d413343750413986d9a7099fd4a73e73f718512f36a21369ec313da1e242c5acb1a73bbaf1c05c21c1511f57e7fcbbeceb5ee83770d67202a388f60bda10e1deb6d27487426d2e06e4b68d08f60fa181f5d0efd7cc25be7ff48b2d4e7f65e54eefd709add2bb624e42d3327d0780feeaed0b15e9f1e705ddd7c1b5f5b33b7418bfb575d5e2a9b5a469294ed33004003333183d687475cacf5229e9564dcd2b6c4624d6212501e70380456a1a818a6e363fc32fbb80c180894e537dc09a7839331ad7162914a8b85206571b6bfdf49a9c7899521bcaf4a44cf8061a809bba8ab9a54a4a0baffe25b804645d40f8e5a88dd732a9d7b9739cb5e9d539871ceaf580d98640f762117acade9d1ff0334b28fad4fd723b00c426a1a4859d28d50dfc304ee1f07303d18adc50dfb4ba27e21ace2ad7a6fc1bdef21fca276eea9d7682e73e469c1cb69feaf7579b18181e72791126a50234cc1b547481d688312699e890bdba0846938b44cce186094b55f8cc955814eb2b21b80aa18965156887fefbdee50d22b3b5d1399a74aadf52a9208d17e2107b34077ad561cf52c6cc2a573fba59bb1824c758fd163f799e887db127f285ec368a369f54aa1f12be2535278a0541f4434a2a06b76d1c939ee6665bc9f9410f03422ca23c4bee0eb3f0e596b47305e042eb40f78a7823ad3f25a4d496426b0781eef559e7b93150a3f8564b0997d4b1fa5ec79f7b0a4d80c3ab9ff077cffeb5e087fb3e553fc847750c95e76960f9537825762ab234ce7796872fa34a4d75a169877c5ad3af52978b8f5c9db8b14495fb9a9f1c085d645c79e03696b9f426085c3e7247685afe8ef2407f126c44eef51bd88de0019f772b773741cb0b59998619ae67cefb1d5f20f9f9f6971b9aade59aa9066946b8c34a5cbc4260950e1f8f10999c55fb56ad54b7dc62563bb3844f0bf2dfd7b0798b758455bdeffb613ef2d8370735872f0bf1875696ceaa940049c8aacb04ec6ce0af346985857fea29e5ef6f0798d6c2c4eb9bc1c2529ac3ce0d20cdce0458cf0a7e0a1a8c389b825e90079b26aa441f281fb167215c1a9edf71a3d95f7dd6a1446d096fb3a2b388eadb14083ddc9795d990470ab2daeeded2b272e5ec1b67a01768d8702002039a249312041aa5614a1daeb0a4e43c1df9bcbe9513401d307b86a2e73a4fcf2fbc099aff40b38f2d4ec8025fc94a41879b278e6d5dd268866f5d260f3b41b462561829470e0a0d4b95929038c952de1398a4259fe15edaea6b65a23decd691e31e87953919772fca3e295d2791387ec22d2850f35b08f69f6b22ab8576bfb8bf0f3781ff97d99c84ff20b5105077496df90730bb946239fc6a72427d2545308c99096b5171e6816bd670a6c7705a47870b6cc6d2382f4f53fded7ddff10493a8397caa28a4f34ad74c946006ab5c3aaee989794b89f89155410fdfa23ef883f21322a77c04b1b5376c77f5c37b34d24f71d476393d90711a00f086b10be8d81ad37f88214ed982b94a36f522d118ca5edb4c84edfb8e595e3862300dbfd809fea510e0fc76b611a19d14aad583097ab40f42932cbcbc146b9e349f835f71e67e11a0ef00f9d18fb6ff0f6bb83683e444af3cc2da2418e15b7614b7caacf542abdc296c64a79fd643a8bd67696354f882ea154d41d614daa98a5cae0f5dafc4cf8ec54241c1b3f0f20aaf6b5c48c15497dfcbced1d2492c5da9ae116a3f9e99a8fc2d0e4fb5108ec8f04b582e262b61b391c1eeecd81ad43c42e93e2e02f32dc179acbdbfe92890bdb518ea65212512c022639fb98f1d55850c218c87fbc51efe6975bd25316aea36efa84a2714a8c11510a62f7391fb48e904d828a32f0247668dae0bd02f804b313299449767c2ff875400abaf2226b1c099a48e2d2c4627a0638389b8104e76abddc93885bedf84d3b4aff534b77e47432e8fc75104372df4b01b42416f39da1ca6e6779a8486f19f5471d1abe936549beb4f73eb591914e4f5538222984da14c8edf264c6e6d731529ffe360248afe73ab99f9f9a9c75173e8e824ed71a7bd5543dc666be7b7dbd4066a61a7b8d1ee9727a5da414bc2215600c97020cd112aa473e71bbe4332d2e9f52fea6d54fe79c950551b342a3a7146d0a0aeff5fad2aee76e1eab0b4a9dfde9986d870c1541e620c132d91623aa4c1a41a37fc01cb89ea9438ab380bfe9cc98cc06af9a96ff2a5cfdc93add931ee302332d6218215065a8978dd2f601c0d21c25a4529817f0dd427ca1cc640e14a379fb79e2bfcf84daa9fbe300a13f9b96c85d610953d6a8345376b1f995dbc7de1efc4ce72752aafe7fc079b1521df40bbdbd2bc2a5d415dcd86e2bcdad65d51857c0549fdbe052d4aa45afff78aa56eabaf126753ad9bc7c48b93aa69458a58f476339ab2440f6bbd9d571d60d56a44e6c5df6797a68112da441982c52943aea910309c3fbaf6895d5446c0083ec34ce0953cce7998607f03b345dc72eb7a882721bc2bc94350aca8e72847089f8d015bf8b5322bb955629f6e4063855ac858f27d060a01d3a0123369eda8d45e25f3fd92b6100f28bbba9b8cb2d21e43f1720ecd2304a119b5694beb9aeeac9de11a9ca8887ecb84414d797c093dbd0be3d2f631efb5b0dd2f1c9d0b521ca3b3169c41ce85fb5d3d458ae77dd6d62295445fd8022814c7a290670cb5be9a350cd493442e78fa377f4ca2530201a19bdf071d37be199f9b871811c005a20e8e081ec67c6fca9e6f67d43630f6846c944034043426239e1d8ef08cbe66217ebc9871e76ab8aa515b0f385c48ce3acc790e039afb601b3f784cb12ce694e80428f882a6a68fcc2b43dc07fc3c11be58dc6dcaaa167f795b39af7aa1287b79f8c63697194669ec6a90a2b2e32715d70e57e4e1a2f5cc858ca0f1cb3fd4ffb99167f325f99df4a67cb6343f02dd645dd88e95d2b6c7139ca99d1da871f5b9f53f49fe8ad42d1f27f68a5b89122d8b6b8f45cd26c9277088d3ae7c890ad4aeade796448c77696cc5b26153d136cab7566b8d02461fe1bc6f12c45a80b91640322f95d4656c160523cc901676224e6e7d5c347176d8ede6b4687250787fc761f8fa5d1ce39490e9e6f0cdaa28628704aa771f970abe1f84b6650775d145dbab574be2c1340b8d721c13426c1235851aaf1bfa2e4f0f86b4191c2f2aa8231b99a4a3ca9470e2ba03d348f2c760445c347ae72b6dbdb7f8a2e7f03e05ee06ac9e233f75d4ac937f74f30454431201ea688e86048492a619584cb7282ed811fd3e47406ff4cb4d55890af4e6d57789af1d27b23265333a55029e1cd6607494aea57a18efa72e167fc7e59be96a58d774a3de3c23346f12080eec8bf9795285c6a3e581930dc1c2bfd03c7ad8a52eccb9d973c6d301bb8589ce40adcf86bde7e605614d6469c6501e80425d79ee39047a9c3aafe175f0c1cbef75f31ec2abab4f4af64b9d36d05d16bd0ce075e98001d5fc9c15cb2a35bc7efdd98b5e1eae95c2bb081190a704a60edf8c2f215bb3f833076448d5af28a5107ab17d2d36157c69135c7c58296b0c0f3119420f758aaec168a23a77c319a58ec2bdcbd6044e9eac82dd81cc86b07536329d6684c6e562582ac7845984c591c9410c007b626be81cf52364bc9d96991e6141626b5895aca416b458cba2b76507bc54dce634514e6c194cb6d21e85d30cd4d0cb2d42e847c2e6904803d60da1cf397927928d2bdc2992699bcd913d04f8fb67531139accec10b6ebe45de644f096fcb200213f73d19f4048d9fee0de3a5e6e649b6f029c1779a731b150f082269c80b568e1c05cf1a7ac6a01000d54baba5d970620f8d3b5691aaa371f3088106b14d33a176e328cee20ea60981f255ca817d3252fe5f4b301a8d672053ad3a076c3f4dafefb4053f1c90a9e01e9ab7ad0b7ae5d2035b0763ad8fa0fe192e1cc90f71a50d4da5926424f0e15a1b0aeff164bd00c5cd00af0f68d99e0cb00b6a22a181f1e5ef78d689e20a265c39c8f86da033a63f7ab742a80ff87bb52fbe5597af568e0f3ebef79c253c132f21a41e4d9aabfc5584c105d41cc276afbde78b62170a67a132bdf40d431dc0fe0099278a947d2f7bfc2360d75a367b8e9da07424c72df5f872969695ae0fbc80da7e5aff020bec69b92d2e4bceb098e066d3bebd8006b514c035ed77ada4bc5ed53f4f158aba098302a4ee5efd5de8337cd85934d8970d4e86eaa59cec36fed8abb47fdb5fb46af76463a5db8d97386d363dfbec360e881a647fabd3385c8503d2ae9f89e04c220cc022e05faec603b6a35a0ee2b003f11e4cb2d191348347bfd09bba0fe913f3a88cfe510ef623d8c11c834d94539dfdf9da39b53bbf0ed51f5fee74dec8f72dc33459fbb40746c3ba0a03b116e3db4036baa2716dce9b76fe084e84623a5babdd0cd8b6734dd1f966aa692599367d78d98cb2819084a159a269fd7dd6a39af09debc1a688752ea2aa8e177657783f8fba8232ef77064ee7ae555e0b4d7e32eb914f3bf406c2126d1ffed0ae3761d469e788bb1f82772f97a8c5402de8c5d8c37ac00d341fe7aacf1ade0050af8580191c6ba5c0eea380695dba06d454a27b820d0accb0fb5dc6adc04413973c4e7164ba6d56f017932dd3631124b17acc8f8dda2d9851435fbadf8e9e700a9254d6bc38644b3682c5ac777d2967de64305422ad80aed81823d0218cb6af7fc7fe893abd32b2537200ece51a931ffb0f0be81f6add21097b406b58f1519e67a7a39496607dacd2702da566a780f7d201fb31304a20ec74550a10fb4e97868ebeb1786db3c0c5f462bb7a727f20fa08f5cb1449688ca7e5cfcfc33a375f9f3480af1055925d9ef17077a654e57a5575ae5448750d70d0d978279b48efc5d654dce0b17ba64b6aea0e4991fc31517803306b62e0e4c6c8f1b3a3debecc7d865c2159179d5d7312c1a3ba3761dc835374c71d2f9af57a8d8483a07b8bdf5d3a627c4e00ed08515a8129f6657677a3f05c95437854138fe1d9718a9bb7d7a10d8ceaef540ff06c4513db67da8288af823308e5897307b1ea87d5c045cd32a8f622b92b1afe191ec802559a7b9b67f99d9734941a85facf6d67b90a63761836ba83d5c0a37811380801a991c9ad2b372e1d62fe6e2327fe1d589b6e097657514bb92eb6c65c0af819e18a26ce1cf80a28c90f557fc4b7870de55525941b903513f59748c3bd2cbe1ad3fbcc9ec8b5ee21ee12c934e00dc4096d3b822bfe51ad1bf1d656aad7b2ee4014b977990034848d384ac0c880a7ee1b56331ae2b32b56e89e40f1f2daf000aaee5357f8cc4f85f84076ea1186b04b044c29a9a975bce4b3d12fa989775ce50121b54ed59af0ce5fa04c0e5b61b2996ce69ecdd6e5862921f05a3c1381912412b0732b6da368e22ec8c2fd33faa83ee6fdb9f3517c36a120f9140413d369be4524b66b390af4f43f343a0bc904108b3b4dbeb6dee61ea7aa66d1c6c830c1858733b8754a4069cfb5c9e81fbf6fd193812bc9d01ce76987fd502f2b6494c06062cc3cc83acce461ab6dafa17e33eb81717b9c0399871882a6979bd18c983aba2a8a2afb5ed0c730a219a17072a895f82e8f1a92443ee213122be94f948bc5c9b3d8585d5ea1d5120aa786c00334876278d8031c45aa663d599b88f3561505a8e230542fd9bdb0e12251924985a3e3e4a80c2b4c4e4f557e21ddd6f763ba436af8f843f605cd2c85e9ad3b25a949e7f711e32af97659b607dd9437113948c5031c102b3335bf564975354340179c1d0d9b7f88c543cdd518e37c57e7a0c347370b0625d952f12c480b3141bedc6118ad249bbb8c86c9a92c72d4d366dfd97d2b13ef53c1c5d2e89df38cf482a7a8e443555008d8ebfbb8d6d5d2017a9160970c3178e86d6243b9edee2155c0f0593d133185779ab5452fb3b0c12da3ba7c4b8133bcda62db33e19d53a84ac4197ac6dcbf7537ea564b2b70843a924ebd6be0ab9ea1bf2365dfe48f160a83ffff012ec6ef5af6c1397abe5eaa608ff5ffa859dca18d9173756cc39a7ecbdfc1f1385e0a7900360f537df51431cb7c2731864c72041d03332ac53046302bad7367f63f5fd13cd226af8edb95c3fefa1876e79ebbbfd683a358164fe095e6cf4516fb1c0e6b9c48e04b21eb943db625d01886a6cb5d1989b8228f513201febc2ec88b187559cd2c9d6adccfea613920ca9f7cb479ff0f6a7caa491870de45fc845e9142da23f9e358c3748d490f95057d46c265e46d6def58f70bccbd75b90f9ee7bfc864810dfb127c6b0f4c49a9cb5313bbb940416e32921fe4ac57a7de2ed095c96555ceaa8210c566aac89f0876d2061f08a1e0ee7e14bdc3cb0876b0d177df23141195057f0df840a28b17f58a398d75d781c3845fbd222fdd2fc7d8f704366e91244ee107cc3d58bd33c6bb6582c6788c7eceb8d0ca57cfb4bc0200350e75aaac63f8628ce2dd953897f9f06ca18c3b7273d1f626d2034d87a953cfb5d3ce58e5d604a1ef218a4b5387b02e45ccd8fd095f1281674f0b071aa169ed554a5525b50319fdb2f68f54765f84124956de89a253b85627f8ab206aee64e6fee8fc0f6318f838b14215e8163a30d9aac4fc13e7f2e8cc9927f7d9b710583793078f1976ba229c761518290a43b08ea25340d9a726803dd0af9ef1b39162314b36a579e8856bf20022f7f73d9f224a60a018f22926f1593045056bce5778994295811b3d6940df833af886f8f95cbb56366e886e9d0127331ae59d9af7bcaa6ee3699df97008f991a38ba68a8f90634e2008fa319d5d11b1d0d0a3bd0bdb4c92549628cd3169c74dc6cbfdec3ae6e368ea3110c6356adc0a8722635eae4a1cb8886cc378c71118d8d273e98686d3ad651dc4902391287cea13048ce1ca19ee724d66cf4eae137e7524b04e026e1ae525c8f178d89beb8f4c74edfe91059f3b5a4d6ace050b6de3661a0cd9ad9c2c24517b74492729e388662eca20e45c03432a8b89bb6f403ebef2e3785f3573f7978e45f3da2abf558dac4a78981907eb42b45f21725c8da74337c44bda097431923d27c4e455acf8ed24ce37531c1e2ffe56350b938513ccac257576eaba39e0e9c2257c50292831a042799025a852302ccfa1d6fdf30fdd015b6722a238179b0e645e2a1755c3ce1db7f4afa5b4e4fc11ae6b4ad92437a8cf0eb263ac844ec466b10e56be6f1bbcd0a79621ac6bac1e332540b568bea79b585556931a704430f7e26c7b722f3cafb887de08a5441d2975be91fd56ecdc00e9728c1afe5954c05a686e7dc2a718aa124f859f0a6be4b3bec7406c81baaa296713f3485de75d3bfc02b440e686de8c16829d36e6489652e2a3898114323f93b8a49aeba55b8080abf3f20fefd95d78ff8c416b27ac3b20b740e1b10519fbc4576ef1910e60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
