<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff4eb144c14dec248589dcd6cf500134c823a2a39e616945967b448159772b5dcfa1b20f1591b1aeb8f3b63058840a74dad2da2424e68cddd473d5684ec6b4e530acfdcfa48e6e46fbf82c15ce4ba427fc1c8ce4d40e12ed941e49191e02e9aa3d228ce9b7d760d430bb7891d2881042aa09dab86d2e1bba7ed129d8f43d4a3f463afed5ce6b0ddfe1387c906971d69d082d7dc03f2ec200606550cad69eb92ed1dfbc652f7e86414975bb050d6cfb7581fd35c0272af7fcd359c9d6b5db0a09f443cce27c2801e8744da78feb2815cfdac17e7047bbfad6ca1c136072f2c2ecdc18d960d321045728caa84d01549cbae2e2522bdcecf2031d455e22d84d830903cf06e53b10a4bba58e0767251e50a711fd48fe4ccb0ce1b9f61f8c6a65ac60676630aa23a6b4a1416ad8c9fe1e11bf07da4d24887da95f460bf742d0804da62c0016dcdbc30c130f03a17df8308a4e1a130c8a82817b4bf8ef255936e240a1d1c234bb4881d1db3323d9f74b5438336b5d8fa8520af8ec824c142d3958c6d26be4c904988b5ef6710edcf822c1972def8c8b449724e3787d2c853d8ee246180a0dbb1b08a1878dc3d08043741547fbe145e706881e19327863ab5cb6cf643fb6b4a8a33797cc1c4ec62a3e35dc6f71ad2a1be3ad0271ca8d1228a4546a671063a3d7208be10b095db76d7353a0b6d65f6d5a7df6c7c965c6104731a45555df643430d905eef2be10515a2e6811b8efc2e02f7fbeb7ff43e5dddd7be474ea5f579c0434b27940c682713d89a171d58b155801f9e32563774ae9adf5d0e5a0a1ca9fc2baae59adb66fcb9b77a3d7676ec330cfdbdc0292bccf4a02c12b651c08de0fdc9b65f059f6726ce58f72af7116e40e8e1de5d5066000b5784c0c00e99bd4b48bf53bc96551e6b1dac725f594f69726071979d63e2295b8166e05d6761ff94c7b38928c08123ccd316a79caccf239e0005f3416a1c408dd25552a62dec0f25a692e60f7c1e24fe99244ff747a64244405d21a391874236a2d84146c9e9efe5110acba9238dbbd5fae321486b53357652a06b864ffe56ca2310d155c472454a7389773dfc7b077918e1f2cae123565795c41a4b4e7857d8b0d36bb264da7a3f52f0d93c24e939ea0cac860974b67ddce153966eb859ffbb3aa39c2ebadf7a500d3475b4beb68b5f7e05f0ccd6246b1a0edb64f8ef48d27003c76bc7ce23ece6d95ca2b20d18f8d159491b675c2c27e719f576df4fce6cb922c185c7154eef0eb41c4dc08183b9147f4b69235213f045fa43a19f6fa58f2bad8362daf8a9ea35543c3a4e79788211363a1fdbb755ee98394ca156948fe1807450d3bc9cb3126463ad26879a0a7b66d9c52539c111eeacdf84bac7c52178685c58b0b1dcf56d2ad0ed3f5eb7d557e36fabd1c5d8325ff4c9e7836af2d0d2934a1b04f62f34265adb0f3356335788a484046343bfa7e6e58ab40488c2b85e780a8cde2b4efcb77a2bc16bd9cc48065002ef8d1ed143010fc2e297b9f670a93c0d6373efbee4198a6ba9e7a74e62ef40d6b5e987abd9643ed6d6a4ba8a3bdc2a0e13b7ea52c71ffe07e89ed2c6ad77487624630185641f6c29137fbbb981ef3c8fe7d355cb973026f723834fe03fd665696584cf35c6105af7ae1771439358e9980297f075eecacf2bb861b729612ea6371d2d78ef5bc24d407699ef147a3e9663a53499a9b7b8ca4fb09effe7da0b55e7dd117df2e74217c6d1d023a269c3e9bf04b2ca8da37e4e97f280124719aedc4be5ccb3bdde28882c6953865e5f872be4e7c2c0442481f5932d068f18bac686ce839a957dcd31db24cf78d9bf216df086d2676b4a4cffbab54f5584a18028961853e98c9616ed9c9e4fd515081abc1fd31a63685bcb22ea6260587a980f7de5da63bcf38712d0f343655195c8682194756a85f14d88fbd8ee1199b5733f037371f8c9cabda366e5bfe1e2d038b7b333f8bff4a3f6cc98893e7943f3c3391d9b672979c07701b6a08cbc389e0a97e131c94c2aa63b425faecbc228a5c3cee4228eaab838c6c4f8f6f040337a0ba470541867f75720d83064d2ebed2a8b9787dbb4d94500dcd0c373523395c4687dfaaeaf3bf94d15dd6e1a7d6e2cb17551788d515f09df207cffcdbdabbc1ad4ee75077d546db4a15925061b0d9bf01fbb21850da9cdf3b722ca60cbe00a984df311d52f0be2eb09364e9955490e32114d44b3e4c0baf02a01973e58a7a7477aa92e2d37fb326aadb195214611d44953abfebc5dcbc3ab032ea0d218770c24bdacea5a2b5a3d28351a9c4b943974b1958a13e06c6cc434b8a221ec641287a9c685430feaa0af46927a655d2b47e09fca7b790e20ecfc1532bb8f67b47f123fb92cc6031deab256c92186e1eea11617e63d695af44a079b3529a248664ed23a3e79ec43f157fa13cc2575af8ed0533948b0f8b69369a0c06eacdbfc45ca93ee8c6023975e97c8a44b9c16925ccda70f4c59e49e9fd5e70b219cca775ec873b0120ee2859745ec284c318207ac090bac70ee1d7c2f104cadfa55b9d52f8400bb3f7f7758cec74d35f093ee122ec23a0b8a5db41ec54372d8f0b4c4cb3f10a45780f2f81bf0e4034c3b27820c0d2a4d4cf56c5f1a7b7647e511c81114550cfb02018b7fcfca70d3fcbea95516d1f5f828c39abdcdb1af92e4e17a1320e1909c515654eb667b1d34afa5e4c4a6f6d5b56ebf8146d84b10f9aff327c422b82186505ca1da0b28a5ce9901c852c567c8570b8a2ca67df209d3527aeb29503c430b584a7588c1e7c361bd519471c2a8913f1613192220a55f929c7b65588a5c50d1e1ca0e2c24035c16b7cae54929ea00ff3125be614fef1af009c1788f4818f86024c5178c9f9fb4df1416fbe3f90c5efc3bd9e2521f4ffd4ccd08a6aba94b75edc3cee70751c8df47ada6cc7a5b60a45698b56140e26b353e2d0eb41fbbb6479e7343787bcb3ebe80c60255fc0b3eed20d4e8a88ca3c2131c4acc859dc7dbe7a477dac233a3970a7567a69fc7827dd6f0b90bec26498264a5bf6ca5ada48c41dbf1e969c192a8c711871610645ed3fd97e42bc0f261d858a445f39716632e1346ebda4c53d7085891d6729d33412fa9e8bdcc69bdede1bbea72fd6d3c9ac8d8395ed9902d945841f789d67aaa4a8f03c3d96c477498da3e5d4868e9c37f410d5d2bf251b0dbaebdf578a855d8a900471b4f9f6cffd4ec9f876b98cf64fd7a9b6814ffd2c8a49d943d6c60e79231a5b0522b3cbec1939cec518502f7b557968d58c4310a77b7e5991b794ee21874fea61cdc24709bbb792f7a1d4d67f832afbc072d725f05a1af6d1a0751ae0d9025487cc5d15feb2f2122e4103985fb7e5bcd207ae0c68bd8530600398eaeb5e49e5197c58b6c8da5d3f2521b44e616e58ad30ed9c4edf100d215f7f7a03446e17e7b08c842753cf96326d3fe6bcb7e8ec35e5dde135405bd12e6406b707b8521f8e7709ce13e635d6da3f2408ed07fcbadab12944e8785377daf34a550533de1a6988bb0ce0f673fc9bfc137bbdfbcd2a6f0f170072bb4f85a388ab3cd463ea0e9f09e91e1572deb860521786f675450f7e5b01bbd6e17447518aa00b516856641a5bb24203ecb3a4fa88003fad5ddfd83e91b416e6dbab26839412556cda2c6ac7ff9f08e630202aba66f705c5d246b5a580e48f437ce205d0de1ba24e761d36fa9d796c2d3e92942de6eb3b51df9a04eb3f825a6c658a34ac397daa2d56e40e1eddcada3967133eff3b7705a949b560c5388592ed60e280ba865109650133a2bc4a7c7885535ff8ff83058bd8f30f26982a9cc4740ddbbffc4880ee4972733331d29a97c739710056df37361bdae1317a98bb08296ad453c03bd83a925eb0f6b98a7d9dc559fbd0dd4feaf2f518f6487da12d262c0d963c4ebbb5f9a99c0c0ff3ff1277b6f912277e949a3167fa670dd8ff8236a82c8ac49b63b670919b2822e1ce66838896b706783cd59e93986638ebe89ab4f7488c6959ac99b2351e103e25e1fe4f22dcd8d7f402ccc065959b8d85bb7ab6ed5535b1ffca10682de9359a11bcfddf359283f53afa0189b067f956ca5cb340fef643cd967fb843d69621c8418fab7453db2137f0476112f85fb919338d3deea3139950efe5d53e9e0a931b91d1a4e04fc43d1a8c4272997705b1113d428fced700ebda8f9618443914b3d53b007c07644e7aedef36b354a1c41fad5ea2dc9bd22d841a25b1c828046369f072485351b91ac73621e6a1913a2b20960f8f894e1a2a12c852b898b27d8b1dc62e2158e53901ea4cf7cd1fbb150aa3f9e95165a84fdbb4a86334f78b094c1ac8ec1c1cc2e5de4c73962e830069bd0b621aecf121a49219e0646279469179328f12e89f892e9101a5aa44dd4076feb064730f23be559ba3a53ec3572fbeb30c724865b7e99143a3b312b18f7e425930878485dacf14bd08e88cf3e225015610bdcf183ac2338eb98a7bb3b4ee3e235777aee220e391ea4fc90091bac47453e3cabdfbad42273e4160c31046bf02b508be88475ddd57c4c91ecbf3d6cb8b1c9383004a527c8a76942e42c2b150efc2bc3e775a21e4ebc56fb1cc0b14e203f76c7afa1d6f65ad148c9f79b00f33c8f8fc5cea8426af7b6df83a59cf98d9249d7087d683157bf61f6ca9c08872677c07eb27bd7e10ac367e70c8853906b3b7705bdb8029c593c0a00fb848defa5041c06ae3952d4e7de1d31de127ef7fa7c585d6fa2742dca9b2729b94caded801b29fb391e7b83519929b7dee25d8869f011d4dc4b2c017e12d57f8efcc72b39a60af9f6cbd49f2f6708d114e2e24a0bccdeb53bb11d106a0d6dfbac599dbd3ca49708d0fc5602290f78803037acb6387db7ecf9ef378b257d697ac541da18444bf5511001770ca22a58f60acd538defad0a53fddf784f9f00cd2e986d7fddba9c8e9b57b40999ab2fba3b5697a712f96008054e501cd615e34a7f6c4cafed13ef470f34e3b7ecb81e3044714bd54cabab08cbbd1b05f40201457d879b14cf24636659b6aef966d73422c61f5fe576a594025205b6b9eb8be6bc4003f239f3e2439e5f464f6c467e445659ae94b9f82e3bcd5635cc16a1e9bd1af174a4bc684ad6dc57b7dc0d964d7ed466b1e39a5ca9b84e6eb0c2dd11bc28bf871cbca6b0c7e87b334d891f9b9624e265b91b72275b468a0b523481e21755a513f31bd9f7ce50c85cbec3bd8cb2b0c273a8eb40e32c0c1d3d44a737311763b125c78028f196a7bccaa7ff1ca21307038010f9c2361b08b7ffc39026c62ea1dc639c8686bf49c529513be585b2e885cb6b0c81137c92794d5ceecea88b684a0797802887799a8e2a74b8aeea8f74de1cac8000502395845d8cd6f770fe942681278bf76bb4df78388da15f9c2d26f655f6857d19aee263a273383ce03c74a539fc7defed8599161b74ee1c1e8709f872a0ff37d31dce032ce3875743818684e2054aac2f02684607f77c75e321885920fd7c0bfe8f1b72258960890e2f83493e314a01fbd06794ac6c4b633e3fb7a22470acf22c74bbc0bf595406a0c071f63c88df5ca2b00b45838f92a189094f25be52d32f098d5b294762dae1e697932619655f69b7175580e3d4a807a39ba38bd5166433fb56d1f40ebd1d8912a2b29b318394da3de691f30f69b10c22aef48db2a5ed9fdd1c7289e2bebbef7d64983368819a538fb4a034896c865c3dc1225b2810671a81a42466e8ec45ebb2f17546c85670bcda121e8be6d03979780f94928853bf3ed393a7e74c1582a2f49a663bf36f25756fe828c7f34f9f1cc3927f13e1bcfd5848d21ce60bc427aa63d9fac6bd3836027aa6d029fa201d86a4a4b4cc5caf14b34d1c9ef6d56027d471066bca8672d4dfb89072a053012adb86888733c5a7e2e430c75809b924e47d5a09193eb34c73e5a22fae6361647073949dd9e3f53dd88c3c24a280764a782e98be263b56b84a43c0765a94e39cd895c8f179528b1d0f6cace7ed6a495da53ca59716dc11c0695c97305c81ff8e9e4116de4d3a0299ccc062f9cf07541cc5d3c4747940edc141951b67fd28c842f90e06a4e8dbc2f3868f393d4a6adda8c97b8e70a3ed2d63e4ca5193e1ac029a5912712f7a977126cc2950408edcc664cf8be4433b14daa8ac26447abf2beb66909d730a73ddb5c2c908533dd2999ad2b1cc795232dbdacb3dc4fe9ae396f6679be867963a02b0ac171be49a63edbf44a66d50366cc2824b36505bc8fde5e16f605c000821fe92a85c2586460f2f8c4ea1fdc0f3d64107da962988a8248e31b3ae7c8fb9ba436090920992ad1c62dedfe76189f55623d6d7905bd500f1fbf6d3c9271e88de742c0ad2cbd4b3a7449ac6f9830718cd54f53c04aa467ae76e29bd260a85a76de4f4c8c958b3f4e3af170e46ef32a1d1871d98c3d25cd03337f82e369db13d8b27bdb25ef937be3d5b8cca537e92da00bf6f7de459a547abbe64bd3dc959a0a0f0d4172173dc1c9a013d171e2f19e890d240b0d918382e2164a9d564589800d972ab1fcc5df3fdd29056323bc49f339c8387034e8562843c03f0e73d7f78780443f78777d416eb0462a6f146330d28ae6617080486e72f50cec3bba21e2795c9ded394ee00504ffa526f9379147f9334f1e414ce62634b51d6b76d395b0447d974451ffd112a08590e32a8279768d82bfc4a3cf454f41763c75ef5788c73a5d1699a6540ae4ac16870e9757f6d0e51cc23746e327e358c6d0ed385a715bb7748067a7ba003d715288f1c1e24c813fc59efeec72bbb4f3eb8f59f5baa1d5d6326390497688dc1783031f04b6f38447e177acf454b0b6a868a620e15be296ae833500e46d9fa03db7305dbbe990e11ab00108ac684252d9dd3d525bc4b1c2796f1874dafc6bf0a38d4dad85fc142ca13e4a4c7ef74d447dc1b2aeaa6665c3a964751172cdfd14a1346d06919e98fb469bd733bfd29c40aff1ec025fd5a529e7679d52ae685595b3b708d7bebcd2c1410d4e4d765d50e9ea1f3b00ab96cefe09bdcae59526d73c557205ceef8a85640c444b60856ead88ae7e85af72a880b89bd8b8f663a6ea6bfb2db82502cbfffefed30ff11298d52a66ccb3a32f4230d1ccad189a172073969e2effb2362491e442e48b436c115581ef9bd1bb7a9bfb74f7942b7d2d553a8eebd46f4ddd0b922749a6334759bde9733e4bb517e930d72184a4983beb5335c2dfc75f4c0363ecacb612ee92bbe387222e3de7e2e1e88424c81453e94c22feaaf0354f05822eae98c4e8579120df1be32f8d8117750119397ecd51181fcfe5273ccffa722104cbe0de6ece1da0d3db833da0b02871b171769b5a540ed3d1440876f6102bf77ac6029bc19293aa3a13004aa46c0a8c50836183f1e6cd36dfe228469db4c4cb4f84cec993949c153877db872f850234d4a84dbf2b85eb02525c5ceb5e80bce36c3d6f0565e49bb74b54457467df34c4858a3bb4bfa5a3613ac10d2950b3ca182b43484bc0fc07379a543c357cafe39ddc4cf8cf115659ae975003e2125372c592de61d1774e3337fc52e67d2491eed02959f7fc47d47540170646739257dc20c5fd1bd90929d883b940a6bce41e4c5e5a7aa6804f499feeb280ecab781ef9cef33a1deaa108ac8858a0e0071ef3fbbd3c1a8275fa4ab20b5654f4efa6cccb4ce1f968cb8639ce203f90091a8cc7349b53377f785abe90be09a225166b312be76210ca9e0f0e6ebaf27a3911fe5cafe49a6db9aabdfbc6c87751857a609e31e60f8b762473f61fe0b461619542e128cc9ebf0253fc3cabeea26b850ab1a4ac7b873ff4a01624791237782ca17fd962338d7c9bfb948acbd8a5badd993fdcd0541431e953600e0552b358acc244e69b5471468e8b7a780e53d9733329ffecbcb898759a891345b1bf9b8dac35130da775000f5f9761fc7a39c1154092f9f4fe9a0341451c785464d4a2a7b3d1ba03afbc6e582eee7fddbb76e644a2a8a8393e3d252d28a090d084a9240d8ee0a0406bc199264db6a9808abb35f61eb360687d50aedfe33fdaafe99ffe63ac5fe496ffa6d2739141fe8532a81c13617469828dcf413f519cda484490b42fa4ea99e3e8281713fcdb0f3cc1a6b17236556ababe5b6bfcd0c3cfe5df540e66f8ddd1e20669030f51a5f7553a66c965b6aaa6418257d95acc6f47f51a0e5f9b9cb9612ba9c24f8bb0bef6edb1dd14b27db7450662b667de117615f04f07ad65a47556c11dcb37595af22e454eaa476a1b38ff0055a30f291b9b380a0cc80e84190d359d641ad2d47e759c49b50c71c71e68c97ab6749e6283620486925132c392848673c9911498f225bc6bd30d0c4ee42d18a58beb9ba2a3632fcb1f5214f282c7da330ec7b49ff4c2625321eb4bf9ba814c17affec8bcf16b12750420fe1e6379b880142abf788c602ead32b3b2d226418976d92fbc14a810feee8f296c131d891c96d90aa1caf73188491c7789382410ef534050e160c42b83a3b389dfdd6c1bb37f0126e47d309c2ba94a1eb7baf9632ea2485a17cad3e515896a4f8f8c98ae06ac3d43178edc15e5274ef522a31fc4b331e5c18732dd80d26d778733eff3aad231e70d756a9ff191c1b7bc6bd44ae4b19d1634f90d01241446bab97cc4b78f2a4567de102101cb2db68c7a1f1be4e97e34703f045bedc049283911d16c772c3aa24ebc9a643a7295e6faefc7f77c2d99ae335dff77057b315cbee4100c4516dbc5458e9d103a167f6d62a8d1b3e45f676ab6766ef1658010c2e4bc41fd91b7976c706bf520b37be3df4dd6ccd383c25376da5c70ba6646d25f79ce5ba0ccd428a805b8be535144968a5729977dced473855d530afe51c1bd2d69075f3e9aed6e3bc6adc7385b0498deae187101bfebdb538aaae8b5b45fe85a6623147757b794e196b59641ee98f8d8ab2d68dcf4c3652a599e493a144c4995de2df9c07015b861b15907eadefa2889ddf11f5a9df37e57c628f9da6acd3c37865767fcc4b8f6260ad3e26ee34bd53af76bec2bf02419a8d088690ab7c793f72f00958d25ed6d4916c3cfafce355141793aadb8bd602dd0a71e043553a13a9f20764bba7078e1dc46cbcb598db3dfe7d93aecd2d37973014f5061cad4fb8e830df348ac4a94ac079d561ef6c737fdf10d15182939075e329b3f30429e2dc2e3802191a77b871d6f5b78005c8c0e755ae8584fbc0e183372873806dcd559ace9b252c87aeab0c48360ebeb15653f85e9317f2b2d76f4b7f17a3b40ed06b559b4b2bc8c198f6b0bac11b9d998537f4d1f44fdc8224dc72cfc8aac835c6a2893726c0b237fc449aff23d6c8a3d81330318b37c47d2ce0ff503732ae3736cac1155e662dba50d7c075be333635a03ff110b07a38cc1c80ff8aee10933fd8e1ad6fecaa631d0cacc42274ba6b2aeaf7bd344db25d5666d48d6a2a8f0b809d9ea298a9b2d6758ce719d7d4ae5b3303e259a328941489de56cf73f3391b64b643131935cca80938a2e3546c3b376da5fbc477038ae96bc952d0a046d619a51e8221a2e8588fdeb89b583ab0d84df038ab82c023b6c36f25aab7a14c7660d2d70a5205c9f0a75c6ac8be8d290090de2d92cda93697bb0d3b70db4d11a98d15c8f23f074a728800f23d02cea9db2c2833b0ecb287ff4a9ce4f7395f30c3eed598bad7433458519670203df0f6075523555d644a28fcac7bf3e51448eae3df05af986d1f2cc8f23f748f6c002b04cd272c79ef544c35094e81c46f3d8d0d90f6745fa8622c87f05a8c3dddb198f09f08fbdb393b355ba60e4b488509ea8de88aa5bc330a975d41630164b4a753c2c20def73c8a787b7b7b2b218f2dbee0beec42a57ae035a7fa8c98dbba5b90861729a75f22e8ae1ea355b9b4ec488db1a21a01b6f47058578c9ff4277e28a7db235ffd56a5974a12a3479292b181ad550f0747efbde3849e66bb233eaa4da2a14e8f246ab60a0b3c52318ca8cccdcb67e9e136af1a4baf2e90513b8a238337e5765d0b79e8d993bd1908c7630a7f97c79c61c7b497a091584c9a310b022beba40be776a7124528287d4e5c1c25f450390ec50cf8b2a0ceb708499b0a06cbc7bba1437bebacdade8434127de68e7705edb6b50aa630d87a11a8131c16bac27c21ab0bae9a49c2c2b632a956f00a95a45cc7d46b9165ce7206a0b3bca8949a7c9f042623d4b85c847efefeada1398b6fa62cbdccf2b6bc235633c8a9d951bf32a46e09b8bfb5b6e9186ce902bd60a9beee169409573cff987bce1ec43f4d292b9c2c1a85dcd0a8f2d1e71424f24cfd905b66d3d31c34f92892fa99cd780ad457d6b01e80a7b4c7645c88e65cb95e52b4024aac8a632c323eb41f7d8e87a9a9d8f2e999ba7a18b173cc5b2e153ca97fa12f1d4e7b779527ba74c142707d21a52e7858d8c31c521bc63df14d181ca5a18cbea0fe939b2ce44347dd0ba5ea88558718bf646b2165f1b4da5f3008e87ccda518c81224e94cf6d6efa9498279e1215f3ae05b68d154a808ee509f69f719bd8a2efcd46b5449dc27c33608e24e783b6d9b5dc0f22f3a788f51f0796f2540f82dd3258d548ed04a06d7b9eac8ce8dd45d963a1e9bde26e7d9e3cf2a1093a64b55847d15a9fb792d887d67e468c73796dedff58bce826c7b64d388343b06d0f192c5938ede960042f82e18989e8e219d7446918f07a115cf451e497dfa215e6930fc7dd002e59ff7220e9de01105f07797a4a6e9a1ef06e7e03f24a7a51c843a4cb209e1bf0bc5e6f13ce09ef93482b0d6f57d130cfa2ab0c0a21f425c779298e43baea0a5e585abe33f2184ca2c16c7f9955a76c5dbff0e739aa7d547411e3bf49d818bdf00836035fe0b382e8f5c4cc88ae12d64c21774232d2cc304eeec2feaeb50c9c3992b216db90bcae795fbfa7812b6cdbec9ae865dc0915cac2b1000fe615d60d06a53c5ce6d9ea23ea193d6390ef8adb48307dad78f6c9bf41f68ddc02cc0a8f2ac0a9dcc7f6abe79bea560b68e1495c2d2ac84193d7b6f559b87f771eb164ef5988917add5f7ec8c895ed4e665c35479f91f71d3db2e235737016232b35419c89d93d5fae2f445777e60b94bcc51b8dc5b6b5fcdccc21458e4384165cd027af61aff1a703d97a28331ea8de920b671f71be3db0037b5d9febd5e2c1183b68780e9a97bcff323edfc0a87aa81e477e0065f33993a764b0fe90df849877f5385357e678931f196a06763b97b9a66cf7daac66bd23e02c7590f104d512d8339b193930289f3d0be87c9ad14e3d47ec6bf01dfb76dabd60e9109383c43474aee9337e76224bfefaf5b7f2734665a1d27d5e66a3b5e663a356eb605d40b0911c8f27d7a040a7002dbfebad31856260726e34719b1d21c5fbec58ce31631fde67d2d07023c8dbe94f73754291245bf938be68addef4a284e48aaaceb957c465a70571ebd16fed7de80cfbe936e5c3e76e07af719fe67353cdab738b0ba94e8a2cd2c324da1397d35d0873466e32acc8e1a14f480001dfcd8635e716abd56c264750c0681c9331acb4ed9d04c34413b89143544ba598d3fd5183f8484c089101e01f1d918791fa9b78ad82167086168fd1d4e726caa81b744f807df5e58d3eca4065f33f3f6b49f20bb50b9ab53693ead161ab0b58bb521cbca6396d29e0fa11ce0a2d9a35f566f91f751ea2152baa6ff0dbc26c06a8ca3b7a3d9e8beb751348ff18f28f4436a946fb0ca1b334f04c43256a903c3bd0ffa8ec60fbb24c194dc931247af009d99903e5189f6905275b7238e554556e29b71d059f46c31861471930b5c073122038498f6ea47ae20255016ccb708c983806702fee047df9a1cb0c539100db5493899c25ac3a67d55dffb6b4bcb22582d203f4edb1c89144061adf894137ad678809df8eef51d216c4318e667e5653fbd93ae6d044a8bbea6bb85330b46ea92a6120dc7a24f49ffe3a1071d71a1ecbe6777e7ada49a1ce2e05d507aa9c9c54fec948ba7a19f5296b6e4dfd4aba75d73efb05b8d5a2d620705542023ea953ce2ce54230e4bef382b64044ed0b6125a7c0a26a1a8ca7503a7e087e36a0b30c3c6bc0d9598c9c0ec6fe9c4a2ac5211a41a41e2aba753284d399a4a2ca49b409a6d1d6ffa35bce6a157398a1beb2d6b80e5cb56f6e733597635479b058c9d70319763615e817c13791a19f805eb25c780a3891c5c9574ff58525f3f4afdb6ffebe5a805d2bef59514c131bad9a47bd481986eddf2c40ac5a4a5ae657ad5e00a8b35de03e80feca71e0bff32c27becd5ec9a62d96e1aacd9c9f53c2cc22535eef4966720574ba62e392a4387d50d50972641d68067c30c99c124ab55a62d76bb59c30bdf26c0107a75b676bcf58caaed1935074f368b0fffe881bd6d7a64639f5ec7bc4dbbe8f4c4e4656eb93e03f46bdc30bb3d07ae85a4e10b350145912631d06ce24a5dd45393c9c8eb0ad4b429d0c6c249da18366425bfbaaf5e161a78f84012d3805a137bbe83184d0eeb17bf57126bac9c65a3b3006902b05b8fb1251c2de3f963dcbb3817f0c101fba8ec77635d2a53a8af797d9a1a51f6825420de1bfa5da9af53894e563e87d62c97e2dd3cd1a78e68f7b5c2b19e4b1342a11467c1aee864421444684111da0dbf5acf3a05d61cdb5c8d8525e6fc761ee5575200686f970d34e5a587c8056b20a342f9000b047dc1fd368a73b27268db331787016968b98ca80e13a9daa45cc34f2c3c0f066cdb9eee0ea3fb1bb362eb3db5d7f5af77eaa4916655c1f5553eabad7a96c387641f8e350f79754e1935a3f252000a5ca043331d62824f04e5ae6180faeb9e0f796a1e17f3af2c555348a24894b617eef7c6bd82b700d3e20747ead668074ac25f8899c24f2e4ddf186f0ad03082896d7436a9f2793cc3cf514899b25133a9dcb53f5564e99e4a69c4b8d1da94e404af81fe9d947827fd1b17fade42da369bfaca13ff8cece6434dc83b71460102d1e968341724c9b0e788f4ee00437dd182317010ee13023e55ed510264295a340645ba9a0ea083a71ce5e7530fecdff1d94cb6ee23c729d41d5c7eb287a7891dba74b9893d347a1f8c6171fba82447a50950a0e4447c08b5a8aae43e966aa2721cf190a9d1b0897b6efc314173c83e10c1f42e22fd148ceba065ba019b5ce527fe35f4bf5aa69622152d146463bbf8c361d9e430e0fe39119766e40c51872ccd57975d4b1ed9bb598d75e0b482bc04a52441efd2567cfc80e59b985963a532e4c29674b232cfcc887367ad1f3dc175cf9eeb6f33a6c551d5f8322e2aa68ccfefa4924f95b866c508024cc7d808a4a3c74e2c6a291f5cb8b4870299cff9c80d9cf7dd9c21bc151fc6b0693fe02cc894de89cbdd0d0a8d93e726179588b77192f5a0e57d0357f69d20af9816425236c90910f4e4b97310216ade2001e348782d2f2e5ae10a03b87eba944b535793647fb5eab80015f321464685327ae2b542c11c189d563542af9d1f38af2c50b753ca97a0c4a89def495b8c5ac027cc1974a7d8a29299ba176ac011afe953153918497df98fe0f07571ef4b503e4e6af9ccf109cacfb0a1c2eb4bcf56e94ea395bde2d18b6236e95313e8b38f0f49c00b964e1cad078dfc75d2f04078d60a1026b27432786995c9d88c8c46f6e4fb7c00fcfe5c1967c5334dcdff7efdffb0960c1814167b632766beb6ac83f93dcd05d18353cdaea33482cf1828364ee941e8390b48325226af79e441c7048a6f8529e3e614175ffec66975aa2ed3a4a32cee356e8fa3c38165ffebc4a22163ae099136ec0876d3a24c56b2b3b2a166b16e4f0f8a163e80bc3b525b71e70dc2160d2203bbf95a906e865381d612ea94024de76e699644738bad6e3caddd23c69d737d45194df02b59ed32789a57afc9817d30695a934f193dfc9cd7bacee0ad534d1101ce64eb34b9fb6843bdb25ef9c1964d03f7e28da06acf933a8e8fa5867a426026d3f7038e6c5ec452e3b114b0c38842bdd7e09037277b85fef2f1c09aca0f1f92eac2d24e0953ba5bd3327f8ff175e6e6110d135070586adecee75e8727e31f92bb37c9c83636d4360e5ae0063ad7c4a5ff5ad76fe7b39b961c0a803f2f25a428a19391c299849e680878c8690a66dcdaf37a91c6f7a31ad51a8300b9d3c1941ed7d485d3509a5f0c0acb3cd9b7954e4a50e6f428332424d4844da3ec2a464a1045b8e32741077089233f47973b0d53deb0e1ca5cbc48959a983f57df6a7be99e1969544b0ef1486762c27b1b8434f2d4b77cebf93cf8952e49543ac908667a8e9aa3084376e7cae42c071729966c87a3e805ab2d141881bf60c2785619ebb3d8e3c7cb14c92a305c6c47569aac7722d717fb4d3ad257d7c17d27754a4f6f6ead7906134810f209f4d03bff99ce8678a0f6c1bde1918a7412c0dd42456e3b46c506e06b43ccc1dd225335033380ee7f9702a73197ee2fcaaeb12647c9040f9014a8da89d849d178d27069fa5cbe10b29cd4714e22fced23abfc4e39f261464488a0c5aca670391c79778fba17cd2d211a78c54303f6705e43b9bcd87f7e5ce94ba4403e10bcd52d9cab9af248a752e411771fd9629ee74b689b6da8a8d0e810b652fd311038324b761b1f857cc8972417c842415d2b7fb3562305536b4aa7e84b827dd0fe2abcd6d8bf639b98c790c4df5fb194e6e7d38316195bdae90bb2fbd7442ebb4d9c40a563f40d776b558d2ef9b195619b5013e720e522e0643ba379391d84c8219a738132c8e104dd6745c3e5a3145de7478daaee0659e5d5ced3e277d5c728ed9ccfb3e797d9befa3d217c3048aa85397c684834927800a7e53dd7cf68ded8ed5cda5672334756973d571a5259b9612d34e21d15199b5a4fb4dc7041f6e7139cc3c9951da4711e19dae8c3005941bcd90a73dd837cb9a47c06669d278f0e88473882e06554784c11071b6d10e6a6368875fc263f71b31b760225efd98d519e014cf2294a11d685e1a6e49b061ea140a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
